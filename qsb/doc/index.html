<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8" />
        <title>Symfonia</title>
        <link rel="stylesheet" href="css/main.css" />
        <script src="js/jquery.js"></script>
        <script src="js/search.js"></script>
    </head>
    <body>
        <div id="modules">
            <div id="searchContainer">
                <h1>Symfonia</h1>
                <p>Willkommen in der Dokumentation von Symfonia!</p>
                <p>
                    Die Dokumentation soll Dir beim Erstellen von neuen Maps zur Seite stehen. Damit du nicht von all den Modulen erschlagen wirst, 
                    wurde diese Startseite vorangestellt. Gib eindach einen Suchbegriff ein. Alle passenden Bundles von Symfonia werden anschließend 
                    in einer Liste angezeigt. Wähle das passende Bundle durch klicken aus.
                </p>
                <hr/>
                <form id="searchForm">
                    <input type="text" id="pattern" />
                    <input type="button" name="search" id="search" value="Suchen" />
                    <input type="button" name="reset" id="reset" value="Zurücksetzen" />
                    <input type="submit" style="display: none" />
                </form>
            <div>
            <div id="searchResultsContainer">
                <h3>Index</h3>
                <div id="modulesContainer">
                    <div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/core.lua.html">
            <div class='doclink'>
                <div>Core</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia Core                                                         # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Hier werden wichtige Basisfunktionen bereitgestellt. Diese Funktionen sind</p><p>-- auch in der Minimalkonfiguration der QSB vorhanden und essentiell für alle</p><p>-- anderen Bundles.</p><p>-- @set sort=true</p><p>-- AddOn Versionsnummer</p><p>-- @local</p><p>    g_GameExtraNo = Framework.GetGameExtraNo();</p><p>    g_GameExtraNo = MapEditor.GetGameExtraNo();</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Initialisiert alle verfügbaren Bundles und führt ihre Install-Methode aus.</p><p>-- Bundles werden immer getrennt im globalen und im lokalen Skript gestartet.</p><p>-- Diese Funktion muss zwingend im globalen und lokalen Skript ausgeführt</p><p>-- werden, bevor die QSB verwendet werden kann.</p><p>-- @within Anwenderfunktionen</p><p>function API.Install()</p><p>    Core:InitalizeBundles();</p><p>-- Tables --------------------------------------------------------------------</p><p>-- Kopiert eine komplette Table und gibt die Kopie zurück. Tables können</p><p>-- nicht durch Zuweisungen kopiert werden. Verwende diese Funktion. Wenn ein</p><p>-- Ziel angegeben wird, ist die zurückgegebene Table eine Vereinigung der 2</p><p>-- angegebenen Tables.</p><p>-- Die Funktion arbeitet rekursiv.</p><p>-- </p><p>-- @param[type=table] _Source Quelltabelle</p><p>-- @param[type=table] _Dest   (optional) Zieltabelle</p><p>-- @return[type=table] Kopie der Tabelle</p><p>-- @within Anwenderfunktionen</p><p>-- @usage Table = {1, 2, 3, {a = true}}</p><p>-- Copy = API.InstanceTable(Table)</p><p>function API.InstanceTable(_Source, _Dest)</p><p>    _Dest = _Dest or {};</p><p>    assert(type(_Source) == "table")</p><p>    assert(type(_Dest) == "table")</p><p>    for k, v in pairs(_Source) do</p><p>        if type(v) == "table" then</p><p>            _Dest[k] = _Dest[k] or {};</p><p>            for kk, vv in pairs(API.InstanceTable(v)) do</p><p>                _Dest[k][kk] = _Dest[k][kk] or vv;</p><p>            end</p><p>        else</p><p>            _Dest[k] = _Dest[k] or v;</p><p>        end</p><p>    end</p><p>    return _Dest;</p><p>-- Sucht in einer eindimensionalen Table nach einem Wert. Das erste Auftreten</p><p>-- des Suchwerts wird als Erfolg gewertet.</p><p>-- Es können praktisch alle Lua-Werte gesucht werden, obwohl dies nur für</p><p>-- Strings und Numbers wirklich sinnvoll ist.</p><p>-- </p><p>-- @param             _Data Gesuchter Eintrag (multible Datentypen)</p><p>-- @param[type=table] _Table Tabelle, die durchquert wird</p><p>-- @return[type=booelan] Wert gefunden</p><p>-- @within Anwenderfunktionen</p><p>-- @usage Table = {1, 2, 3, {a = true}}</p><p>-- local Found = API.TraverseTable(3, Table)</p><p>function API.TraverseTable(_Data, _Table)</p><p>    for k,v in pairs(_Table) do</p><p>        if v == _Data then</p><p>            return true;</p><p>        end</p><p>    end</p><p>    return false;</p><p>-- Schreibt ein genaues Abbild der Table ins Log. Funktionen, Threads und</p><p>-- Metatables werden als Adresse geschrieben.</p><p>-- @param[type=table]  _Table Tabelle, die gedumpt wird</p><p>-- @param[type=string] _Name Optionaler Name im Log</p><p>-- @within Anwenderfunktionen</p><p>-- @local</p><p>-- @usage Table = {1, 2, 3, {a = true}}</p><p>-- API.DumpTable(Table)</p><p>function API.DumpTable(_Table, _Name)</p><p>    local Start = "{";</p><p>    if _Name then</p><p>        Start = _Name.. " = \n" ..Start;</p><p>    end</p><p>    Framework.WriteToLog(Start);</p><p>    for k, v in pairs(_Table) do</p><p>        if type(v) == "table" then</p><p>            Framework.WriteToLog("[" ..k.. "] = ");</p><p>            API.DumpTable(v);</p><p>        elseif type(v) == "string" then</p><p>            Framework.WriteToLog("[" ..k.. "] = \"" ..v.. "\"");</p><p>        else</p><p>            Framework.WriteToLog("[" ..k.. "] = " ..tostring(v));</p><p>        end</p><p>    end</p><p>    Framework.WriteToLog("}");</p><p>-- Konvertiert alle Strings, Booleans und Numbers einer Tabelle in</p><p>-- einen String. Die Funktion ist rekursiv, d.h. es werden auch alle</p><p>-- Untertabellen mit konvertiert. Alles was kein Number, Boolean oder</p><p>-- String ist, wird als Adresse geschrieben.</p><p>-- @param[type=table] _Table Table zum konvertieren</p><p>-- @return[type=string] Converted table</p><p>-- @within Anwenderfunktionen</p><p>-- @local</p><p>function API.ConvertTableToString(_Table)</p><p>    assert(type(_Table) == "table");</p><p>    local TableString = "{";</p><p>    for k, v in pairs(_Table) do</p><p>        local key;</p><p>        if (tonumber(k)) then</p><p>            key = ""..k;</p><p>        else</p><p>            key = "\""..k.."\"";</p><p>        end</p><p>        if type(v) == "table" then</p><p>            TableString = TableString .. "[" .. key .. "] = " .. API.ConvertTableToString(v) .. ", ";</p><p>        elseif type(v) == "number" then</p><p>            TableString = TableString .. "[" .. key .. "] = " .. v .. ", ";</p><p>        elseif type(v) == "string" then</p><p>            TableString = TableString .. "[" .. key .. "] = \"" .. v .. "\", ";</p><p>        elseif type(v) == "boolean" or type(v) == "nil" then</p><p>            TableString = TableString .. "[" .. key .. "] = " .. tostring(v) .. ", ";</p><p>        else</p><p>            TableString = TableString .. "[" .. key .. "] = \"" .. tostring(v) .. "\", ";</p><p>        end</p><p>    end</p><p>    TableString = TableString .. "}";</p><p>    return TableString</p><p>-- Quests ----------------------------------------------------------------------</p><p>-- Gibt die ID des Quests mit dem angegebenen Namen zurück. Existiert der</p><p>-- Quest nicht, wird nil zurückgegeben.</p><p>-- </p><p>-- @param[type=string] _Name Name des Quest</p><p>-- @return[type=number] ID des Quest</p><p>-- @within Anwenderfunktionen</p><p>function API.GetQuestID(_Name)</p><p>    if type(_Name) == "number" then</p><p>        return _Name;</p><p>    end</p><p>    for k, v in pairs(Quests) do</p><p>        if v and k  0 then</p><p>            if v.Identifier == _Name then</p><p>                return k;</p><p>            end</p><p>        end</p><p>    end</p><p>-- Prüft, ob zu der angegebenen ID ein Quest existiert. Wird ein Questname</p><p>-- angegeben wird dessen Quest-ID ermittelt und geprüft.</p><p>-- </p><p>-- @param[type=number] _QuestID ID oder Name des Quest</p><p>-- @return[type=boolean] Quest existiert</p><p>-- @within Anwenderfunktionen</p><p>function API.IsValidateQuest(_QuestID)</p><p>    return Quests[_QuestID] ~= nil or Quests[API.GetQuestID(_QuestID)] ~= nil;</p><p>-- Lässt eine Liste von Quests fehlschlagen.</p><p>-- Der Status wird auf Over und das Resultat auf Failure gesetzt.</p><p>-- </p><p>-- @param[type=string] ... Liste mit Quests</p><p>-- @within Anwenderfunktionen</p><p>-- @local</p><p>function API.FailAllQuests(...)</p><p>    for i=1, #arg, 1 do</p><p>        API.FailQuest(arg[i]);</p><p>    end</p><p>-- Lässt den Quest fehlschlagen.</p><p>-- Der Status wird auf Over und das Resultat auf Failure gesetzt.</p><p>-- </p><p>-- @param[type=string]  _QuestName Name des Quest</p><p>-- @param[type=boolean] _Verbose   Meldung nicht anzeigen</p><p>-- @within Anwenderfunktionen</p><p>function API.FailQuest(_QuestName, _Verbose)</p><p>    local Quest = Quests[GetQuestID(_QuestName)];</p><p>    if Quest then</p><p>        if not _Verbose then</p><p>            API.Note("fail quest " .._QuestName);</p><p>        end</p><p>        Quest:RemoveQuestMarkers();</p><p>        Quest:Fail();</p><p>    end</p><p>-- Startet eine Liste von Quests neu.</p><p>-- </p><p>-- @param[type=string] ... Liste mit Quests</p><p>-- @within Anwenderfunktionen</p><p>-- @local</p><p>function API.RestartAllQuests(...)</p><p>    for i=1, #arg, 1 do</p><p>        API.RestartQuest(arg[i]);</p><p>    end</p><p>-- Startet den Quest neu.</p><p>-- Der Quest muss beendet sein um ihn wieder neu zu starten. Wird ein Quest</p><p>-- neu gestartet, müssen auch alle Trigger wieder neu ausgelöst werden, außer</p><p>-- der Quest wird manuell getriggert.</p><p>-- Alle Änderungen an Standardbehavior müssen hier berücksichtigt werden. Wird</p><p>-- ein Standardbehavior in einem Bundle verändern, muss auch diese Funktion</p><p>-- angepasst oder überschrieben werden.</p><p>-- </p><p>-- @param[type=string]  _QuestName Name des Quest</p><p>-- @param[type=boolean] _Verbose   Meldung nicht anzeigen</p><p>-- @within Anwenderfunktionen</p><p>function API.RestartQuest(_QuestName, _Verbose)</p><p>    local QuestID = GetQuestID(_QuestName);</p><p>    local Quest = Quests[QuestID];</p><p>    if Quest then</p><p>        if not _Verbose then</p><p>            API.Note("restart quest " .._QuestName);</p><p>        end</p><p>        if Quest.Objectives then</p><p>            local questObjectives = Quest.Objectives;</p><p>            for i = 1, questObjectives[0] do</p><p>                local objective = questObjectives[i];</p><p>                objective.Completed = nil</p><p>                local objectiveType = objective.Type;</p><p>                if objectiveType == Objective.Deliver then</p><p>                    local data = objective.Data;</p><p>                    data[3] = nil;</p><p>                    data[4] = nil;</p><p>                    data[5] = nil;</p><p>                elseif g_GameExtraNo and g_GameExtraNo = 1 and objectiveType == Objective.Refill then</p><p>                    objective.Data[2] = nil;</p><p>                elseif objectiveType == Objective.Protect or objectiveType == Objective.Object then</p><p>                    local data = objective.Data;</p><p>                    for j=1, data[0], 1 do</p><p>                        data[-j] = nil;</p><p>                    end</p><p>                elseif objectiveType == Objective.DestroyEntities and objective.Data[1] == 2 and objective.DestroyTypeAmount then</p><p>                    objective.Data[3] = objective.DestroyTypeAmount;</p><p>                elseif objectiveType == Objective.DestroyEntities and objective.Data[1] == 3 then</p><p>                    objective.Data[4] = nil;</p><p>                elseif objectiveType == Objective.Distance then</p><p>                    if objective.Data[1] == -65565 then</p><p>                        objective.Data[4].NpcInstance = nil;</p><p>                    end</p><p>                elseif objectiveType == Objective.Custom2 and objective.Data[1].Reset then</p><p>                    objective.Data[1]:Reset(Quest, i);</p><p>                end</p><p>            end</p><p>        end</p><p>        local function resetCustom(_type, _customType)</p><p>            local Quest = Quest;</p><p>            local behaviors = Quest[_type];</p><p>            if behaviors then</p><p>                for i = 1, behaviors[0] do</p><p>                    local behavior = behaviors[i];</p><p>                    if behavior.Type == _customType then</p><p>                        local behaviorDef = behavior.Data[1];</p><p>                        if behaviorDef and behaviorDef.Reset then</p><p>                            behaviorDef:Reset(Quest, i);</p><p>                        end</p><p>                    end</p><p>                end</p><p>            end</p><p>        end</p><p>        resetCustom("Triggers", Triggers.Custom2);</p><p>        resetCustom("Rewards", Reward.Custom);</p><p>        resetCustom("Reprisals", Reprisal.Custom);</p><p>        Quest.Result = nil;</p><p>        local OldQuestState = Quest.State;</p><p>        Quest.State = QuestState.NotTriggered;</p><p>        Logic.ExecuteInLuaLocalState("LocalScriptCallback_OnQuestStatusChanged("..Quest.Index..")");</p><p>        if OldQuestState == QuestState.Over then</p><p>            Trigger.RequestTrigger(Events.LOGIC_EVENT_EVERY_SECOND, "", QuestTemplate.Loop, 1, 0, { Quest.QueueID });</p><p>        end</p><p>        return QuestID, Quest;</p><p>    end</p><p>-- Startet eine Liste von Quests.</p><p>-- </p><p>-- @param[type=string] ... Liste mit Quests</p><p>-- @within Anwenderfunktionen</p><p>-- @local</p><p>function API.StartAllQuests(...)</p><p>    for i=1, #arg, 1 do</p><p>        API.StartQuest(arg[i]);</p><p>    end</p><p>-- Startet den Quest sofort, sofern er existiert.</p><p>-- Dabei ist es unerheblich, ob die Bedingungen zum Start erfüllt sind.</p><p>-- </p><p>-- @param[type=string]  _QuestName Name des Quest</p><p>-- @param[type=boolean] _Verbose   Meldung nicht anzeigen</p><p>-- @within Anwenderfunktionen</p><p>function API.StartQuest(_QuestName, _Verbose)</p><p>    local Quest = Quests[GetQuestID(_QuestName)];</p><p>    if Quest then</p><p>        if not _Verbose then</p><p>            API.Note("start quest " .._QuestName);</p><p>        end</p><p>        Quest:SetMsgKeyOverride();</p><p>        Quest:SetIconOverride();</p><p>        Quest:Trigger();</p><p>    end</p><p>-- Unterbricht eine Liste von Quests.</p><p>-- </p><p>-- @param[type=string] ... Liste mit Quests</p><p>-- @within Anwenderfunktionen</p><p>-- @local</p><p>function API.StopAllQuests(...)</p><p>    for i=1, #arg, 1 do</p><p>        API.StopQuest(arg[i]);</p><p>    end</p><p>-- Unterbricht den Quest.</p><p>-- Der Status wird auf Over und das Resultat auf Interrupt gesetzt. Sind Marker</p><p>-- gesetzt, werden diese entfernt.</p><p>-- </p><p>-- @param[type=string]  _QuestName Name des Quest</p><p>-- @param[type=boolean] _Verbose   Meldung nicht anzeigen</p><p>-- @within Anwenderfunktionen</p><p>function API.StopQuest(_QuestName, _Verbose)</p><p>    local Quest = Quests[GetQuestID(_QuestName)];</p><p>    if Quest then</p><p>        if not _Verbose then</p><p>            API.Note("interrupt quest " .._QuestName);</p><p>        end</p><p>        Quest:RemoveQuestMarkers();</p><p>        Quest:Interrupt(-1);</p><p>    end</p><p>-- Gewinnt eine Liste von Quests.</p><p>-- Der Status wird auf Over und das Resultat auf Success gesetzt.</p><p>-- </p><p>-- @param[type=string] ... Liste mit Quests</p><p>-- @within Anwenderfunktionen</p><p>-- @local</p><p>function API.WinAllQuests(...)</p><p>    for i=1, #arg, 1 do</p><p>        API.WinQuest(arg[i]);</p><p>    end</p><p>-- Gewinnt den Quest.</p><p>-- Der Status wird auf Over und das Resultat auf Success gesetzt.</p><p>-- </p><p>-- @param[type=string]  _QuestName Name des Quest</p><p>-- @param[type=boolean] _Verbose   Meldung nicht anzeigen</p><p>-- @within Anwenderfunktionen</p><p>function API.WinQuest(_QuestName, _Verbose)</p><p>    local Quest = Quests[GetQuestID(_QuestName)];</p><p>    if Quest then</p><p>        if not _Verbose then</p><p>            API.Note("win quest " .._QuestName);</p><p>        end</p><p>        Quest:RemoveQuestMarkers();</p><p>        Quest:Success();</p><p>    end</p><p>-- Messages --------------------------------------------------------------------</p><p>-- Schreibt eine Nachricht in das Debug Window. Der Text erscheint links am</p><p>-- Bildschirm und ist nicht statisch.</p><p>-- </p><p>-- @param[type=string] _Message Anzeigetext</p><p>-- @within Anwenderfunktionen</p><p>-- @local</p><p>function API.Note(_Message)</p><p>    _Message = API.EnsureMessage(_Message);</p><p>    local MessageFunc = Logic.DEBUG_AddNote;</p><p>    if GUI then</p><p>        MessageFunc = GUI.AddNote;</p><p>    end</p><p>    MessageFunc(_Message);</p><p>-- Schreibt eine Nachricht in das Debug Window. Der Text erscheint links am</p><p>-- Bildschirm und verbleibt dauerhaft am Bildschirm.</p><p>-- </p><p>-- @param[type=string] _Message Anzeigetext</p><p>-- @within Anwenderfunktionen</p><p>function API.StaticNote(_Message)</p><p>    _Message = API.EnsureMessage(_Message);</p><p>    if not GUI then</p><p>        Logic.ExecuteInLuaLocalState('GUI.AddStaticNote("' .._Message.. '")');</p><p>        return;</p><p>    end</p><p>    GUI.AddStaticNote(_Message);</p><p>-- Löscht alle Nachrichten im Debug Window.</p><p>-- @within Anwenderfunktionen</p><p>function API.ClearNotes()</p><p>    if not GUI then</p><p>        Logic.ExecuteInLuaLocalState('GUI.ClearNotes()');</p><p>        return;</p><p>    end</p><p>    GUI.ClearNotes();</p><p>-- Schreibt eine Nachricht in das Nachrichtenfenster unten in der Mitte.</p><p>-- </p><p>-- @param[type=string] _Message Anzeigetext</p><p>-- @within Anwenderfunktionen</p><p>function API.Message(_Message)</p><p>    _Message = API.EnsureMessage(_Message);</p><p>    if not GUI then</p><p>        Logic.ExecuteInLuaLocalState('Message("' .._Message.. '")');</p><p>        return;</p><p>    end</p><p>    Message(_Message);</p><p>-- Ermittelt automatisch den Nachrichtentext, falls eine lokalisierte Table</p><p>-- übergeben wird.</p><p>-- @param[type=string] _Message Anzeigetext</p><p>-- @return[type=string] Message</p><p>-- @within Anwenderfunktionen</p><p>-- @local</p><p>function API.EnsureMessage(_Message)</p><p>    local Language = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>    if type(_Message) == "table" then</p><p>        _Message = _Message[Language];</p><p>    end</p><p>    return tostring(_Message);</p><p>-- Schreibt einen FATAL auf den Bildschirm und ins Log.</p><p>-- </p><p>-- </p><p>-- </p><p>-- @param[type=string] _Message Anzeigetext</p><p>-- @within Anwenderfunktionen</p><p>-- @local</p><p>function API.Fatal(_Message)</p><p>    API.StaticNote("FATAL: " .._Message)</p><p>    Framework.WriteToLog("FATAL: " .._Message);</p><p>-- Schreibt eine WARNING auf den Bildschirm und ins Log.</p><p>-- </p><p>-- @param[type=string] _Message Anzeigetext</p><p>-- @within Anwenderfunktionen</p><p>-- @local</p><p>function API.Warn(_Message)</p><p>    API.StaticNote("WARNING: " .._Message)</p><p>    Framework.WriteToLog("WARNING: " .._Message);</p><p>-- Entities --------------------------------------------------------------------</p><p>-- Sendet einen Handelskarren zu dem Spieler. Startet der Karren von einem</p><p>-- Gebäude, wird immer die Position des Eingangs genommen.</p><p>-- </p><p>-- @param _position                        Position (Skriptname oder Positionstable)</p><p>-- @param[type=number] _player             Zielspieler</p><p>-- @param[type=number] _good               Warentyp</p><p>-- @param[type=number] _amount             Warenmenge</p><p>-- @param[type=number] _cartOverlay        (optional) Overlay für Goldkarren</p><p>-- @param[type=boolean] _ignoreReservation (optional) Marktplatzreservation ignorieren</p><p>-- @return[type=number] Entity-ID des erzeugten Wagens</p><p>-- @within Anwenderfunktionen</p><p>-- @usage -- API-Call</p><p>-- API.SendCart(Logic.GetStoreHouse(1), 2, Goods.G_Grain, 45)</p><p>-- -- Legacy-Call mit ID-Speicherung</p><p>-- local ID = SendCart("Position_1", 5, Goods.G_Wool, 5)</p><p>function API.SendCart(_position, _player, _good, _amount, _cartOverlay, _ignoreReservation)</p><p>    local eID = GetID(_position);</p><p>    if not IsExisting(eID) then</p><p>        return;</p><p>    end</p><p>    local ID;</p><p>    local x,y,z = Logic.EntityGetPos(eID);</p><p>    local resCat = Logic.GetGoodCategoryForGoodType(_good);</p><p>    local orientation = 0;</p><p>    if Logic.IsBuilding(eID) == 1 then</p><p>        x,y = Logic.GetBuildingApproachPosition(eID);</p><p>        orientation = Logic.GetEntityOrientation(eID)-90;</p><p>    end</p><p>    if resCat == GoodCategories.GC_Resource then</p><p>        ID = Logic.CreateEntityOnUnblockedLand(Entities.U_ResourceMerchant, x, y,orientation,_player)</p><p>    elseif _good == Goods.G_Medicine then</p><p>        ID = Logic.CreateEntityOnUnblockedLand(Entities.U_Medicus, x, y,orientation,_player)</p><p>    elseif _good == Goods.G_Gold or _good == Goods.G_None or _good == Goods.G_Information then</p><p>        if _cartOverlay then</p><p>            ID = Logic.CreateEntityOnUnblockedLand(_cartOverlay, x, y,orientation,_player)</p><p>        else</p><p>            ID = Logic.CreateEntityOnUnblockedLand(Entities.U_GoldCart, x, y,orientation,_player)</p><p>        end</p><p>    else</p><p>        ID = Logic.CreateEntityOnUnblockedLand(Entities.U_Marketer, x, y,orientation,_player)</p><p>    end</p><p>    Logic.HireMerchant( ID, _player, _good, _amount, _player, _ignoreReservation)</p><p>    return ID</p><p>-- Ersetzt ein Entity mit einem neuen eines anderen Typs. Skriptname,</p><p>-- Rotation, Position und Besitzer werden übernommen.</p><p>-- : Die Entity-ID ändert sich und beim Ersetzen von</p><p>-- Spezialgebäuden kann eine Niederlage erfolgen.</p><p>-- </p><p>-- @param _Entity      Entity (Skriptname oder ID)</p><p>-- @param[type=number] _Type     Neuer Typ</p><p>-- @param[type=number] _NewOwner (optional) Neuer Besitzer</p><p>-- @return[type=number] Entity-ID des Entity</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.ReplaceEntity("Stein", Entities.XD_ScriptEntity)</p><p>function API.ReplaceEntity(_Entity, _Type, _NewOwner)</p><p>    local eID = GetID(_Entity);</p><p>    if eID == 0 then</p><p>        return;</p><p>    end</p><p>    local pos = GetPosition(eID);</p><p>    local player = _NewOwner or Logic.EntityGetPlayer(eID);</p><p>    local orientation = Logic.GetEntityOrientation(eID);</p><p>    local name = Logic.GetEntityName(eID);</p><p>    DestroyEntity(eID);</p><p>    if Logic.IsEntityTypeInCategory(_Type, EntityCategories.Soldier) == 1 then</p><p>        return CreateBattalion(player, _Type, pos.X, pos.Y, 1, name, orientation);</p><p>    else</p><p>        return CreateEntity(player, _Type, pos, name, orientation);</p><p>    end</p><p>-- Rotiert ein Entity, sodass es zum Ziel schaut.</p><p>-- </p><p>-- @param _entity         Entity (Skriptname oder ID)</p><p>-- @param _entityToLookAt Ziel (Skriptname oder ID)</p><p>-- @param[type=number]    _offsetEntity Winkel Offset</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.LookAt("Hakim", "Alandra")</p><p>function API.LookAt(_entity, _entityToLookAt, _offsetEntity)</p><p>    local entity = GetEntityId(_entity);</p><p>    local entityTLA = GetEntityId(_entityToLookAt);</p><p>    if not IsExisting(entity) or not IsExisting(entityTLA) then</p><p>        API.Warn("API.LookAt: One entity is invalid or dead!");</p><p>        return;</p><p>    end</p><p>    local eX, eY = Logic.GetEntityPosition(entity);</p><p>    local eTLAX, eTLAY = Logic.GetEntityPosition(entityTLA);</p><p>    local orientation = math.deg( math.atan2( (eTLAY - eY) , (eTLAX - eX) ) );</p><p>    if Logic.IsBuilding(entity) == 1 then</p><p>        orientation = orientation - 90;</p><p>    end</p><p>    _offsetEntity = _offsetEntity or 0;</p><p>    Logic.SetOrientation(entity, orientation + _offsetEntity);</p><p>-- Lässt zwei Entities sich gegenseitig anschauen.</p><p>-- @param _entity         Entity (Skriptname oder ID)</p><p>-- @param _entityToLookAt Ziel (Skriptname oder ID)</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.Confront("Hakim", "Alandra")</p><p>function API.Confront(_entity, _entityToLookAt)</p><p>    API.LookAt(_entity, _entityToLookAt);</p><p>    API.LookAt(_entityToLookAt, _entity);</p><p>-- Bestimmt die Distanz zwischen zwei Punkten. Es können Entity-IDs,</p><p>-- Skriptnamen oder Positionstables angegeben werden.</p><p>-- Wenn die Distanz nicht bestimmt werden kann, wird -1 zurückgegeben.</p><p>-- </p><p>-- @param _pos1 Erste Vergleichsposition (Skriptname, ID oder Positions-Table)</p><p>-- @param _pos2 Zweite Vergleichsposition (Skriptname, ID oder Positions-Table)</p><p>-- @return[type=number] Entfernung zwischen den Punkten</p><p>-- @within Anwenderfunktionen</p><p>-- @usage local Distance = API.GetDistance("HQ1", Logic.GetKnightID(1))</p><p>function API.GetDistance( _pos1, _pos2 )</p><p>    if (type(_pos1) == "string") or (type(_pos1) == "number") then</p><p>        _pos1 = GetPosition(_pos1);</p><p>    end</p><p>    if (type(_pos2) == "string") or (type(_pos2) == "number") then</p><p>        _pos2 = GetPosition(_pos2);</p><p>    end</p><p>    if type(_pos1) ~= "table" or type(_pos2) ~= "table" then</p><p>        return -1;</p><p>    end</p><p>    local xDistance = (_pos1.X - _pos2.X);</p><p>    local yDistance = (_pos1.Y - _pos2.Y);</p><p>    return math.sqrt((xDistance^2) + (yDistance^2));</p><p>-- Prüft, ob eine Positionstabelle eine gültige Position enthält.</p><p>-- Eine Position ist Ungültig, wenn sie sich nicht auf der Welt befindet.</p><p>-- Das ist der Fall bei negativen Werten oder Werten, welche die Größe</p><p>-- der Welt übersteigen.</p><p>-- </p><p>-- @param[type=table] _pos Positionstable {X= x, Y= y}</p><p>-- @return[type=boolean] Position ist valide</p><p>-- @within Anwenderfunktionen</p><p>function API.ValidatePosition(_pos)</p><p>    if type(_pos) == "table" then</p><p>        if (_pos.X ~= nil and type(_pos.X) == "number") and (_pos.Y ~= nil and type(_pos.Y) == "number") then</p><p>            local world = {Logic.WorldGetSize()}</p><p>            if _pos.Z and _pos.Z  0 then</p><p>                return false;</p><p>            end</p><p>            if _pos.X = 0 then</p><p>                return true;</p><p>            end</p><p>        end</p><p>    end</p><p>    return false;</p><p>-- Lokalisiert ein Entity auf der Map. Es können sowohl Skriptnamen als auch</p><p>-- IDs verwendet werden. Wenn das Entity nicht gefunden wird, wird eine</p><p>-- Tabelle mit XYZ = 0 zurückgegeben.</p><p>-- </p><p>-- @param _Entity Entity (Skriptname oder ID)</p><p>-- @return[type=table] Positionstabelle {X= x, Y= y, Z= z}</p><p>-- @within Anwenderfunktionen</p><p>-- @usage local Position = API.LocateEntity("Hans")</p><p>function API.LocateEntity(_Entity)</p><p>    if (type(_Entity) == "table") then</p><p>        return _Entity;</p><p>    end</p><p>    if (not IsExisting(_Entity)) then</p><p>        return {X= 0, Y= 0, Z= 0};</p><p>    end</p><p>    local x, y, z = Logic.EntityGetPos(GetID(_Entity));</p><p>    return {X= x, Y= y, Z= z};</p><p>-- Aktiviert ein interaktives Objekt, sodass es benutzt werden kann.</p><p>-- Der State bestimmt, ob es immer aktiviert werden kann, oder ob der Spieler</p><p>-- einen Helden benutzen muss. Wird der Parameter weggelassen, muss immer ein</p><p>-- Held das Objekt aktivieren.</p><p>-- </p><p>-- @param[type=string] _ScriptName  Skriptname des IO</p><p>-- @param[type=number] _State       Aktivierungszustand</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.ActivateIO("Haus1", 0)</p><p>-- API.ActivateIO("Hut1")</p><p>function API.ActivateIO(_ScriptName, _State)</p><p>    _State = _State or 0;</p><p>    if GUI then</p><p>        GUI.SendScriptCommand('API.ActivateIO("' .._ScriptName.. '", ' .._State..')');</p><p>        return;</p><p>    end</p><p>    if not IsExisting(_ScriptName) then</p><p>        return</p><p>    end</p><p>    Logic.InteractiveObjectSetAvailability(GetID(_ScriptName), true);</p><p>    for i = 1, 8 do</p><p>        Logic.InteractiveObjectSetPlayerState(GetID(_ScriptName), i, _State);</p><p>    end</p><p>-- Deaktiviert ein Interaktives Objekt, sodass es nicht mehr vom Spieler</p><p>-- aktiviert werden kann.</p><p>-- </p><p>-- @param[type=string] _ScriptName Skriptname des IO</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.DeactivateIO("Hut1")</p><p>function API.DeactivateIO(_ScriptName)</p><p>    if GUI then</p><p>        GUI.SendScriptCommand('API.DeactivateIO("' .._ScriptName.. '")');</p><p>        return;</p><p>    end</p><p>    if not IsExisting(_ScriptName) then</p><p>        return;</p><p>    end</p><p>    Logic.InteractiveObjectSetAvailability(GetID(_ScriptName), false);</p><p>    for i = 1, 8 do</p><p>        Logic.InteractiveObjectSetPlayerState(GetID(_ScriptName), i, 2);</p><p>    end</p><p>-- Ermittelt alle Entities in der Kategorie auf dem Territorium und gibt</p><p>-- sie als Liste zurück.</p><p>-- </p><p>-- @param[type=number] _player    PlayerID [0-8] oder -1 für alle</p><p>-- @param[type=number] _category  Kategorie, der die Entities angehören</p><p>-- @param[type=number] _territory Zielterritorium</p><p>-- @within Anwenderfunktionen</p><p>-- @usage local Found = API.GetEntitiesOfCategoryInTerritory(1, EntityCategories.Hero, 5)</p><p>function API.GetEntitiesOfCategoryInTerritory(_player, _category, _territory)</p><p>    local PlayerEntities = {};</p><p>    local Units = {};</p><p>    if (_player == -1) then</p><p>        for i=0,8 do</p><p>            local NumLast = 0;</p><p>            repeat</p><p>                Units = { Logic.GetEntitiesOfCategoryInTerritory(_territory, i, _category, NumLast) };</p><p>                PlayerEntities = Array_Append(PlayerEntities, Units);</p><p>                NumLast = NumLast + #Units;</p><p>            until #Units == 0;</p><p>        end</p><p>    else</p><p>        local NumLast = 0;</p><p>        repeat</p><p>            Units = { Logic.GetEntitiesOfCategoryInTerritory(_territory, _player, _category, NumLast) };</p><p>            PlayerEntities = Array_Append(PlayerEntities, Units);</p><p>            NumLast = NumLast + #Units;</p><p>        until #Units == 0;</p><p>    end</p><p>    return PlayerEntities;</p><p>-- Gibt dem Entity einen eindeutigen Skriptnamen und gibt ihn zurück.</p><p>-- Hat das Entity einen Namen, bleibt dieser unverändert und wird</p><p>-- zurückgegeben.</p><p>-- @param[type=number] _EntityID Entity ID</p><p>-- @return[type=string] Skriptname</p><p>-- @within Anwenderfunktionen</p><p>function API.EnsureScriptName(_EntityID)</p><p>    if type(_EntityID) == "string" then</p><p>        return _EntityID;</p><p>    else</p><p>        assert(type(_EntityID) == "number");</p><p>        local name = Logic.GetEntityName(_EntityID);</p><p>        if (type(name) ~= "string" or name == "" ) then</p><p>            QSB.GiveEntityNameCounter = (QSB.GiveEntityNameCounter or 0)+ 1;</p><p>            name = "EnsureScriptName_Name_"..QSB.GiveEntityNameCounter;</p><p>            Logic.SetEntityName(_EntityID, name);</p><p>        end</p><p>        return name;</p><p>    end</p><p>-- Overwrite -------------------------------------------------------------------</p><p>-- Schickt einen Skriptbefehl an die jeweils andere Skriptumgebung.</p><p>-- Wird diese Funktion als dem globalen Skript aufgerufen, sendet sie den</p><p>-- Befehl an das lokale Skript. Wird diese Funktion im lokalen Skript genutzt,</p><p>-- wird der Befehl an das globale Skript geschickt.</p><p>-- @param[type=string]  _Command Lua-Befehl als String</p><p>-- @param[type=boolean] _Flag FIXME Optional für GUI.SendScriptCommand benötigt. </p><p>--                      Was macht das Flag?</p><p>-- @within Anwenderfunktionen</p><p>-- @local</p><p>function API.Bridge(_Command, _Flag)</p><p>    if not GUI then</p><p>        Logic.ExecuteInLuaLocalState(_Command)</p><p>    else</p><p>        GUI.SendScriptCommand(_Command, _Flag)</p><p>    end</p><p>-- Wandelt underschiedliche Darstellungen einer Boolean in eine echte um.</p><p>-- Jeder String, der mit j, t, y oder + beginnt, wird als true interpretiert.</p><p>-- Alles andere als false.</p><p>-- Ist die Eingabe bereits ein Boolean wird es direkt zurückgegeben.</p><p>-- </p><p>-- @param _Value Wahrheitswert</p><p>-- @return[type=boolean] Wahrheitswert</p><p>-- @within Anwenderfunktionen</p><p>-- @local</p><p>-- @usage local Bool = API.ToBoolean("+")  -- Bool = true</p><p>-- local Bool = API.ToBoolean("no") -- Bool = false</p><p>function API.ToBoolean(_Value)</p><p>    return Core:ToBoolean(_Value);</p><p>-- Fügt eine Beschreibung zu einem selbst gewählten Hotkey hinzu.</p><p>-- Ist der Hotkey bereits vorhanden, wird -1 zurückgegeben.</p><p>-- @param[type=string] _Key         Tastenkombination</p><p>-- @param[type=string] _Description Beschreibung des Hotkey</p><p>-- @return[type=number] Index oder Fehlercode</p><p>-- @within Anwenderfunktionen</p><p>function API.AddHotKey(_Key, _Description)</p><p>    if not GUI then</p><p>        API.Fatal("API.AddHotKey: Can not be used from the global script!");</p><p>        return;</p><p>    end</p><p>    g_KeyBindingsOptions.Descriptions = nil;</p><p>    table.insert(Core.Data.HotkeyDescriptions, {_Key, _Description});</p><p>    return #Core.Data.HotkeyDescriptions;</p><p>-- Entfernt eine Beschreibung eines selbst gewählten Hotkeys.</p><p>-- @param[type=number] _Index Index in Table</p><p>-- @within Anwenderfunktionen</p><p>function API.RemoveHotKey(_Index)</p><p>    if not GUI then</p><p>        API.Fatal("API.RemoveHotKey: Can not be used from the global script!");</p><p>        return;</p><p>    end</p><p>    if type(_Index) ~= "number" or _Index  #Core.Data.HotkeyDescriptions then</p><p>        API.Fatal("API.RemoveHotKey: No candidate found or Index is nil!");</p><p>        return;</p><p>    end</p><p>    Core.Data.HotkeyDescriptions[_Index] = nil;</p><p>-- Simple Job Overhaul ---------------------------------------------------------</p><p>-- Registriert eine Funktion, die nach dem laden ausgeführt wird.</p><p>-- : AddOnSaveGameLoadedAction</p><p>-- @param[type=function] _Function Funktion, die ausgeführt werden soll</p><p>-- @within Anwenderfunktionen</p><p>-- @usage SaveGame = function()</p><p>--     API.Note("foo")</p><p>-- end</p><p>-- API.AddSaveGameAction(SaveGame)</p><p>function API.AddSaveGameAction(_Function)</p><p>    if GUI then</p><p>        API.Fatal("API.AddSaveGameAction: Can not be used from the local script!");</p><p>        return;</p><p>    end</p><p>    return Core:AppendFunction("Mission_OnSaveGameLoaded", _Function)</p><p>-- Fügt eine Funktion als Job hinzu, die einmal pro Sekunde ausgeführt</p><p>-- wird. Die Argumente werden an die Funktion übergeben.</p><p>-- : StartSimpleJobEx</p><p>-- @param[type=number] _Function Funktion, die ausgeführt wird</p><p>-- @param              ...       Liste von Argumenten</p><p>-- @return[type=number] Job ID</p><p>-- @within Anwenderfunktionen</p><p>function API.StartJob(_Function, ...)</p><p>    Core.Data.Events.JobIDCounter = Core.Data.Events.JobIDCounter +1;</p><p>    local JobID = Core.Data.Events.JobIDCounter;</p><p>    Core.Data.Events.EverySecond[JobID] = {</p><p>        Function  = _Function,</p><p>        Arguments = API.InstanceTable(arg);</p><p>    };</p><p>    return JobID;</p><p>-- Fügt eine Funktion als Job hinzu, die zehn Mal pro Sekunde ausgeführt</p><p>-- wird. Die Argumente werden an die Funktion übergeben.</p><p>-- : StartSimpleHiResJobEx</p><p>-- @param[type=number] _Function Funktion, die ausgeführt wird</p><p>-- @param              ...       Liste von Argumenten</p><p>-- @return[type=number] Job ID</p><p>-- @within Anwenderfunktionen</p><p>function API.StartHiResJob(_Function, ...)</p><p>    Core.Data.Events.JobIDCounter = Core.Data.Events.JobIDCounter +1;</p><p>    local JobID = Core.Data.Events.JobIDCounter;</p><p>    Core.Data.Events.EveryTurn[JobID] = {</p><p>        Function  = _Function,</p><p>        Arguments = API.InstanceTable(arg);</p><p>    };</p><p>    return JobID;</p><p>-- Prüft ob ein Job mit der ID existiert.</p><p>-- : JobIsRunningEx</p><p>-- @param[type=number] _JobID ID des Jobs</p><p>-- @within Anwenderfunktionen</p><p>function API.JobIsRunning(_JobID)</p><p>    if Core.Data.Events.EveryTurn[_JobID] then</p><p>        return true;</p><p>    end</p><p>    if Core.Data.Events.EverySecond[_JobID] then</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- Bendet einen QSB-Job.</p><p>-- : EndJobEx</p><p>-- @param[type=number] _JobID ID des Jobs</p><p>-- @within Anwenderfunktionen</p><p>function API.EndJob(_JobID)</p><p>    if Core.Data.Events.EveryTurn[_JobID] then</p><p>        Core.Data.Events.EveryTurn[_JobID] = nil;</p><p>    end</p><p>    if Core.Data.Events.EverySecond[_JobID] then</p><p>        Core.Data.Events.EverySecond[_JobID] = nil;</p><p>    end</p><p>-- Echtzeit --------------------------------------------------------------------</p><p>-- Gibt die real vergangene Zeit seit dem Spielstart in Sekunden zurück.</p><p>-- @return[type=number] Vergangene reale Zeit</p><p>-- @within Anwenderfunktionen</p><p>function API.RealTimeGetSecondsPassedSinceGameStart()</p><p>    return QSB.RealTime_SecondsSinceGameStart;</p><p>-- Wartet die angebene Zeit in realen Sekunden und führt anschließend das</p><p>-- Callback aus.</p><p>-- Hinweis: Einmal gestartet, kann wait nicht beendet werden.</p><p>-- @param[type=number] _Waittime Wartezeit in realen Sekunden</p><p>-- @param[type=function] _Action Callback-Funktion</p><p>-- @param ... Liste der Argumente</p><p>-- @return[type=number] Vergangene reale Zeit</p><p>-- @within Anwenderfunktionen</p><p>function API.RealTimeWait(_Waittime, _Action, ...)</p><p>    StartSimpleJobEx( function(_StartTime, _Delay, _Callback, _Arguments)</p><p>        if (QSB.RealTime_SecondsSinceGameStart = _StartTime + _Delay) then</p><p>            if #_Arguments  0 then</p><p>                _Callback(unpack(_Arguments));</p><p>            else</p><p>                _Callback();</p><p>            end</p><p>            return true;</p><p>        end</p><p>    end, QSB.RealTime_SecondsSinceGameStart, _Waittime, _Action, {...});</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Data = {</p><p>        Events = {</p><p>            EverySecond = {},</p><p>            EveryTurn = {},</p><p>            JobIDCounter = 0,</p><p>        },</p><p>        Overwrite = {</p><p>            StackedFunctions = {},</p><p>            AppendedFunctions = {},</p><p>            Fields = {},</p><p>        },</p><p>        HotkeyDescriptions = {},</p><p>        BundleInitializerList = {},</p><p>        InitalizedBundles = {},</p><p>    }</p><p>-- Initialisiert alle verfügbaren Bundles und führt ihre Install-Methode aus.</p><p>-- Bundles werden immer getrennt im globalen und im lokalen Skript gestartet.</p><p>-- @within Internal</p><p>-- @local</p><p>    if not GUI then</p><p>        self:SetupGobal_HackCreateQuest();</p><p>        self:SetupGlobal_HackQuestSystem();</p><p>        </p><p>        StartSimpleJob("CoreEventJob_OnEveryRealTimeSecond");</p><p>        Trigger.RequestTrigger(Event.LOGIC_EVENT_ENTITY_DESTROYED, "", "CoreEventJob_OnEntityDestroyed", 1);</p><p>        Trigger.RequestTrigger(Event.LOGIC_EVENT_ENTITY_HURT_ENTITY, "", "CoreEventJob_OnEntityHurtEntity", 1);</p><p>        StartSimpleHiResJob("CoreEventJob_OnEveryTurn");</p><p>        StartSimpleJob("CoreEventJob_OnEverySecond");</p><p>    else</p><p>        self:SetupLocal_HackRegisterHotkey();</p><p>        StartSimpleJob("CoreEventJob_OnEveryRealTimeSecond");</p><p>        Trigger.RequestTrigger(Event.LOGIC_EVENT_ENTITY_DESTROYED, "", "CoreEventJob_OnEntityDestroyed", 1);</p><p>        Trigger.RequestTrigger(Event.LOGIC_EVENT_ENTITY_HURT_ENTITY, "", "CoreEventJob_OnEntityHurtEntity", 1);</p><p>        StartSimpleHiResJob("CoreEventJob_OnEveryTurn");</p><p>        StartSimpleJob("CoreEventJob_OnEverySecond");</p><p>    end</p><p>    for k,v in pairs(self.Data.BundleInitializerList) do</p><p>        local Bundle = _G[v];</p><p>        if not GUI then</p><p>            if Bundle.Global ~= nil and Bundle.Global.Install ~= nil then</p><p>                Bundle.Global:Install();</p><p>                Bundle.Local = nil;</p><p>            end</p><p>        else</p><p>            if Bundle.Local ~= nil and Bundle.Local.Install ~= nil then</p><p>                Bundle.Local:Install();</p><p>                Bundle.Global = nil;</p><p>            end</p><p>        end</p><p>        self.Data.InitalizedBundles[v] = true;</p><p>        collectgarbage();</p><p>    end</p><p>-- Überschreibt CreateQuest für die Anbindung an Symfonia.</p><p>-- @within Internal</p><p>-- @local</p><p>    CreateQuest = function(_QuestName, _QuestGiver, _QuestReceiver, _QuestHidden, _QuestTime, _QuestDescription, _QuestStartMsg, _QuestSuccessMsg, _QuestFailureMsg)</p><p>        local Triggers = {};</p><p>        local Goals = {};</p><p>        local Reward = {};</p><p>        local Reprisal = {};</p><p>        local NumberOfBehavior = Logic.Quest_GetQuestNumberOfBehaviors(_QuestName);</p><p>        for i=0, NumberOfBehavior-1, 1 do</p><p>            -- Behavior ermitteln</p><p>            local BehaviorName = Logic.Quest_GetQuestBehaviorName(_QuestName, i);</p><p>            local BehaviorTemplate = GetBehaviorTemplateByName(BehaviorName);</p><p>            assert( BehaviorTemplate, "No template for name: " .. BehaviorName .. " - using an invalid QuestSystemBehavior.lua?!");</p><p>            local NewBehavior = {};</p><p>            Table_Copy(NewBehavior, BehaviorTemplate);</p><p>            local Parameter = Logic.Quest_GetQuestBehaviorParameter(_QuestName, i);</p><p>            for j=1,#Parameter do</p><p>                NewBehavior:AddParameter(j-1, Parameter[j]);</p><p>            end</p><p>            -- Füge als Goal hinzu</p><p>            if (NewBehavior.GetGoalTable ~= nil) then</p><p>                Goals[#Goals + 1] = NewBehavior:GetGoalTable();</p><p>                Goals[#Goals].Context = NewBehavior;</p><p>                Goals[#Goals].FuncOverrideIcon = NewBehavior.GetIcon;</p><p>                Goals[#Goals].FuncOverrideMsgKey = NewBehavior.GetMsgKey;</p><p>            end</p><p>            -- Füge als Trigger hinzu</p><p>            if (NewBehavior.GetTriggerTable ~= nil) then</p><p>                Triggers[#Triggers + 1] = NewBehavior:GetTriggerTable();</p><p>            end</p><p>            -- Füge als Reprisal hinzu</p><p>            if (NewBehavior.GetReprisalTable ~= nil) then</p><p>                Reprisal[#Reprisal + 1] = NewBehavior:GetReprisalTable();</p><p>            end</p><p>            -- Füge als Reward hinzu</p><p>            if (NewBehavior.GetRewardTable ~= nil) then</p><p>                Reward[#Reward + 1] = NewBehavior:GetRewardTable();</p><p>            end</p><p>        end</p><p>        -- Prüfe Mindestkonfiguration des Quest</p><p>        if (#Triggers == 0) or (#Goals == 0) then</p><p>            return;</p><p>        end</p><p>        -- Erzeuge den Quest</p><p>        if Core:CheckQuestName(_QuestName) then</p><p>            local QuestID = QuestTemplate:New(</p><p>                _QuestName,</p><p>                _QuestGiver or 1,</p><p>                _QuestReceiver or 1,</p><p>                Goals,</p><p>                Triggers,</p><p>                tonumber(_QuestTime) or 0,</p><p>                Reward,</p><p>                Reprisal,</p><p>                nil, nil,</p><p>                (not _QuestHidden or ( _QuestStartMsg and _QuestStartMsg ~= "") ),</p><p>                (not _QuestHidden or ( _QuestSuccessMsg and _QuestSuccessMsg ~= "") or ( _QuestFailureMsg and _QuestFailureMsg ~= "") ),</p><p>                _QuestDescription,</p><p>                _QuestStartMsg,</p><p>                _QuestSuccessMsg,</p><p>                _QuestFailureMsg</p><p>            );</p><p>            g_QuestNameToID[_QuestName] = QuestID;</p><p>        else</p><p>            fatal("Quest '"..tostring(questName).."': invalid questname! Contains forbidden characters!");</p><p>        end</p><p>    end</p><p>-- Implementiert die vordefinierten Texte für Custom Behavior und den Aufruf</p><p>-- der :Interrupt Methode.</p><p>-- @within Internal</p><p>-- @local</p><p>    QuestTemplate.Trigger_Orig_QSB_Core = QuestTemplate.Trigger</p><p>    QuestTemplate.Trigger = function(_quest)</p><p>        QuestTemplate.Trigger_Orig_QSB_Core(_quest);</p><p>        for i=1,_quest.Objectives[0] do</p><p>            if _quest.Objectives[i].Type == Objective.Custom2 and _quest.Objectives[i].Data[1].SetDescriptionOverwrite then</p><p>                local Desc = _quest.Objectives[i].Data[1]:SetDescriptionOverwrite(_quest);</p><p>                Core:ChangeCustomQuestCaptionText(Desc, _quest);</p><p>                break;</p><p>            end</p><p>        end</p><p>    end</p><p>    QuestTemplate.Interrupt_Orig_QSB_Core = QuestTemplate.Interrupt;</p><p>    QuestTemplate.Interrupt = function(_quest)</p><p>        QuestTemplate.Interrupt_Orig_QSB_Core(_quest);</p><p>        for i=1, _quest.Objectives[0] do</p><p>            if _quest.Objectives[i].Type == Objective.Custom2 and _quest.Objectives[i].Data[1].Interrupt then</p><p>                _quest.Objectives[i].Data[1]:Interrupt(_quest, i);</p><p>            end</p><p>        end</p><p>        for i=1, _quest.Triggers[0] do</p><p>            if _quest.Triggers[i].Type == Triggers.Custom2 and _quest.Triggers[i].Data[1].Interrupt then</p><p>                _quest.Triggers[i].Data[1]:Interrupt(_quest, i);</p><p>            end</p><p>        end</p><p>    end</p><p>-- Überschreibt das Hotkey-Register, sodass eigene Hotkeys mit im Menü</p><p>-- angezeigt werden können.</p><p>-- @within Internal</p><p>-- @local</p><p>    function g_KeyBindingsOptions:OnShow()</p><p>        local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>        if Game ~= nil then</p><p>            XGUIEng.ShowWidget("/InGame/KeyBindingsMain/Backdrop", 1);</p><p>        else</p><p>            XGUIEng.ShowWidget("/InGame/KeyBindingsMain/Backdrop", 0);</p><p>        end</p><p>        if g_KeyBindingsOptions.Descriptions == nil then</p><p>            g_KeyBindingsOptions.Descriptions = {};</p><p>            DescRegister("MenuInGame");</p><p>            DescRegister("MenuDiplomacy");</p><p>            DescRegister("MenuProduction");</p><p>            DescRegister("MenuPromotion");</p><p>            DescRegister("MenuWeather");</p><p>            DescRegister("ToggleOutstockInformations");</p><p>            DescRegister("JumpMarketplace");</p><p>            DescRegister("JumpMinimapEvent");</p><p>            DescRegister("BuildingUpgrade");</p><p>            DescRegister("BuildLastPlaced");</p><p>            DescRegister("BuildStreet");</p><p>            DescRegister("BuildTrail");</p><p>            DescRegister("KnockDown");</p><p>            DescRegister("MilitaryAttack");</p><p>            DescRegister("MilitaryStandGround");</p><p>            DescRegister("MilitaryGroupAdd");</p><p>            DescRegister("MilitaryGroupSelect");</p><p>            DescRegister("MilitaryGroupStore");</p><p>            DescRegister("MilitaryToggleUnits");</p><p>            DescRegister("UnitSelect");</p><p>            DescRegister("UnitSelectToggle");</p><p>            DescRegister("UnitSelectSameType");</p><p>            DescRegister("StartChat");</p><p>            DescRegister("StopChat");</p><p>            DescRegister("QuickSave");</p><p>            DescRegister("QuickLoad");</p><p>            DescRegister("TogglePause");</p><p>            DescRegister("RotateBuilding");</p><p>            DescRegister("ExitGame");</p><p>            DescRegister("Screenshot");</p><p>            DescRegister("ResetCamera");</p><p>            DescRegister("CameraMove");</p><p>            DescRegister("CameraMoveMouse");</p><p>            DescRegister("CameraZoom");</p><p>            DescRegister("CameraZoomMouse");</p><p>            DescRegister("CameraRotate");</p><p>            for k,v in pairs(Core.Data.HotkeyDescriptions) do</p><p>                if v then</p><p>                    v[1] = (type(v[1]) == "table" and v[1][lang]) or v[1];</p><p>                    v[2] = (type(v[2]) == "table" and v[2][lang]) or v[2];</p><p>                    table.insert(g_KeyBindingsOptions.Descriptions, 1, v);</p><p>                end</p><p>            end</p><p>        end</p><p>        XGUIEng.ListBoxPopAll(g_KeyBindingsOptions.Widget.ShortcutList);</p><p>        XGUIEng.ListBoxPopAll(g_KeyBindingsOptions.Widget.ActionList);</p><p>        for Index, Desc in ipairs(g_KeyBindingsOptions.Descriptions) do</p><p>            XGUIEng.ListBoxPushItem(g_KeyBindingsOptions.Widget.ShortcutList, Desc[1]);</p><p>            XGUIEng.ListBoxPushItem(g_KeyBindingsOptions.Widget.ActionList,   Desc[2]);</p><p>        end</p><p>    end</p><p>-- Prüft, ob das Bundle bereits initalisiert ist.</p><p>-- @param[type=string] _Bundle Name des Moduls</p><p>-- @return[type=boolean] Bundle initalisiert</p><p>-- @within Internal</p><p>-- @local</p><p>    return self.Data.InitalizedBundles[Bundle] == true;</p><p>-- Registiert ein Bundle, sodass es initialisiert wird.</p><p>-- @param[type=string] _Bundle Name des Moduls</p><p>-- @within Internal</p><p>-- @local</p><p>    local text = string.format("Error while initialize bundle 's': does not exist!", tostring(_Bundle));</p><p>    assert(_G[_Bundle] ~= nil, text);</p><p>    table.insert(self.Data.BundleInitializerList, _Bundle);</p><p>-- Registiert ein AddOn als Bundle, sodass es initialisiert wird.</p><p>-- Diese Funktion macht prinziplell das Gleiche wie Core:RegisterBundle und</p><p>-- existiert nur zur Übersichtlichkeit.</p><p>-- @param[type=string] _AddOn Name des Moduls</p><p>-- @within Internal</p><p>-- @local</p><p>    local text = string.format("Error while initialize addon 's': does not exist!", tostring(_AddOn));</p><p>    assert(_G[_AddOn] ~= nil, text);</p><p>    table.insert(self.Data.BundleInitializerList, _AddOn);</p><p>-- Bereitet ein Behavior für den Einsatz im Assistenten und im Skript vor.</p><p>-- Erzeugt zudem den Konstruktor.</p><p>-- @param[type=table] _Behavior Behavior-Objekt</p><p>-- @within Internal</p><p>-- @local</p><p>    if GUI then</p><p>        return;</p><p>    end</p><p>    if _Behavior.RequiresExtraNo and _Behavior.RequiresExtraNo  g_GameExtraNo then</p><p>        return;</p><p>    end</p><p>    if not _G["b_" .. _Behavior.Name] then</p><p>        fatal("AddQuestBehavior: can not find ".. _Behavior.Name .."!");</p><p>    else</p><p>        if not _G["b_" .. _Behavior.Name].new then</p><p>            _G["b_" .. _Behavior.Name].new = function(self, ...)</p><p>                local behavior = API.InstanceTable(self);</p><p>                behavior.i47ya_6aghw_frxil = {};</p><p>                for i= 1, #arg, 1 do</p><p>                    if self.Parameter and self.Parameter[i] ~= nil then</p><p>                        behavior:AddParameter(i-1, arg[i]);</p><p>                    else</p><p>                        table.insert(behavior.i47ya_6aghw_frxil, arg[i]);</p><p>                    end</p><p>                end</p><p>                return behavior;</p><p>            end</p><p>        end</p><p>        for i= 1, #g_QuestBehaviorTypes, 1 do</p><p>            if g_QuestBehaviorTypes[i].Name == _Behavior.Name then</p><p>                return;</p><p>            end</p><p>        end</p><p>        table.insert(g_QuestBehaviorTypes, _Behavior);</p><p>    end</p><p>-- Prüft, ob der Questname formal korrekt ist. Questnamen dürfen i.d.R. nur</p><p>-- die Zeichen A-Z, a-7, 0-9, - und _ enthalten.</p><p>-- @param[type=string] _Name Name des Quest</p><p>-- @return[type=boolean] Questname ist fehlerfrei</p><p>-- @within Internal</p><p>-- @local</p><p>    return string.find(_Name, "^[A-Za-z0-9_]+$") ~= nil;</p><p>-- Ändert den Text des Beschreibungsfensters eines Quests. Die Beschreibung</p><p>-- wird erst dann aktualisiert, wenn der Quest ausgeblendet wird.</p><p>-- @param[type=string] _Text Neuer Text</p><p>-- @param[type=table] _Quest Quest Table</p><p>-- @within Internal</p><p>-- @local</p><p>    _Quest.QuestDescription = _Text;</p><p>    Logic.ExecuteInLuaLocalState([[</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomLeft/Message/QuestObjectives/Custom/BGDeco",0)</p><p>        local identifier = "]].._Quest.Identifier..[["</p><p>        for i=1, Quests[0] do</p><p>            if Quests[i].Identifier == identifier then</p><p>                local text = Quests[i].QuestDescription</p><p>                XGUIEng.SetText("/InGame/Root/Normal/AlignBottomLeft/Message/QuestObjectives/Custom/Text", "]].._Text..[[")</p><p>                break</p><p>            end</p><p>        end</p><p>    ]]);</p><p>-- Erweitert eine Funktion um eine andere Funktion.</p><p>-- Jede hinzugefügte Funktion wird vor der Originalfunktion ausgeführt. Es</p><p>-- ist möglich, eine neue Funktion an einem bestimmten Index einzufügen. Diese</p><p>-- Funktion ist nicht gedacht, um sie direkt auszuführen. Für jede Funktion</p><p>-- im Spiel sollte eine API-Funktion erstellt werden.</p><p>-- Wichtig: Die gestapelten Funktionen, die vor der Originalfunktion</p><p>-- ausgeführt werden, müssen etwas zurückgeben, um die Funktion an</p><p>-- gegebener Stelle zu verlassen.</p><p>-- @param[type=string]   _FunctionName Name der erweiterten Funktion</p><p>-- @param[type=function] _StackFunction Neuer Funktionsinhalt</p><p>-- @param[type=number]   _Index Reihenfolgeindex</p><p>-- @within Internal</p><p>-- @local</p><p>    if not self.Data.Overwrite.StackedFunctions[_FunctionName] then</p><p>        self.Data.Overwrite.StackedFunctions[_FunctionName] = {</p><p>            Original = self:GetFunctionInString(_FunctionName),</p><p>            Attachments = {}</p><p>        };</p><p>        local batch = function(...)</p><p>            local ReturnValue;</p><p>            for i= 1, #self.Data.Overwrite.StackedFunctions[_FunctionName].Attachments, 1 do</p><p>                local Function = self.Data.Overwrite.StackedFunctions[_FunctionName].Attachments[i];</p><p>                ReturnValue = {Function(unpack(arg))};</p><p>                if #ReturnValue  0 then</p><p>                    return unpack(ReturnValue);</p><p>                end</p><p>            end</p><p>            ReturnValue = {self.Data.Overwrite.StackedFunctions[_FunctionName].Original(unpack(arg))};</p><p>            return unpack(ReturnValue);</p><p>        end</p><p>        self:ReplaceFunction(_FunctionName, batch);</p><p>    end</p><p>    _Index = _Index or #self.Data.Overwrite.StackedFunctions[_FunctionName].Attachments+1;</p><p>    table.insert(self.Data.Overwrite.StackedFunctions[_FunctionName].Attachments, _Index, _StackFunction);</p><p>-- Erweitert eine Funktion um eine andere Funktion.</p><p>-- Jede hinzugefügte Funktion wird nach der Originalfunktion ausgeführt. Es</p><p>-- ist möglich eine neue Funktion an einem bestimmten Index einzufügen. Diese</p><p>-- Funktion ist nicht gedacht, um sie direkt auszuführen. Für jede Funktion</p><p>-- im Spiel sollte eine API-Funktion erstellt werden.</p><p>-- @param[type=string]   _FunctionName Name der erweiterten Funktion</p><p>-- @param[type=function] _AppendFunction Neuer Funktionsinhalt</p><p>-- @param[type=number]   _Index Reihenfolgeindex</p><p>-- @within Internal</p><p>-- @local</p><p>    if not self.Data.Overwrite.AppendedFunctions[_FunctionName] then</p><p>        self.Data.Overwrite.AppendedFunctions[_FunctionName] = {</p><p>            Original = self:GetFunctionInString(_FunctionName),</p><p>            Attachments = {}</p><p>        };</p><p>        local batch = function(...)</p><p>            local ReturnValue = self.Data.Overwrite.AppendedFunctions[_FunctionName].Original(unpack(arg));</p><p>            for i= 1, #self.Data.Overwrite.AppendedFunctions[_FunctionName].Attachments, 1 do</p><p>                local Function = self.Data.Overwrite.AppendedFunctions[_FunctionName].Attachments[i];</p><p>                ReturnValue = {Function(unpack(arg))};</p><p>            end</p><p>            return unpack(ReturnValue);</p><p>        end</p><p>        self:ReplaceFunction(_FunctionName, batch);</p><p>    end</p><p>    _Index = _Index or #self.Data.Overwrite.AppendedFunctions[_FunctionName].Attachments+1;</p><p>    table.insert(self.Data.Overwrite.AppendedFunctions[_FunctionName].Attachments, _Index, _AppendFunction);</p><p>-- Überschreibt eine Funktion mit einer anderen.</p><p>-- Funktionen in einer Tabelle werden überschrieben, indem jede Ebene des</p><p>-- Tables mit einem Punkt angetrennt wird.</p><p>-- @param[type=string]   _FunctionName Name der erweiterten Funktion</p><p>-- @param[type=function] _AppendFunction Neuer Funktionsinhalt</p><p>-- @local</p><p>-- @within Internal</p><p>-- @usage A = {foo = function() API.Note("bar") end}</p><p>-- B = function() API.Note("muh") end</p><p>-- Core:ReplaceFunction("A.foo", B)</p><p>-- -- A.foo() == B() = "muh"</p><p>    assert(type(_FunctionName) == "string");</p><p>    local ref = _G;</p><p>    local s, e = _FunctionName:find(".");</p><p>    while (s ~= nil) do</p><p>        local SubName = _FunctionName:sub(1, e-1);</p><p>        SubName = (tonumber(SubName) ~= nil and tonumber(SubName)) or SubName;</p><p>        ref = ref[SubName];</p><p>        _FunctionName = _FunctionName:sub(e+1);</p><p>        s, e = _FunctionName:find(".");</p><p>    end</p><p>    local SubName = (tonumber(_FunctionName) ~= nil and tonumber(_FunctionName)) or _FunctionName;</p><p>    ref[SubName] = _Function;</p><p>-- Sucht eine Funktion mit dem angegebenen Namen.</p><p>-- Ist die Funktionen innerhalb einer Table, so sind alle Ebenen bis zum</p><p>-- Funktionsnamen mit anzugeben, abgetrennt durch einen Punkt.</p><p>-- @param[type=string] _FunctionName Name der erweiterten Funktion</p><p>-- @return[type=function] Referenz auf die Funktion</p><p>-- @within Internal</p><p>-- @local</p><p>    assert(type(_FunctionName) == "string");</p><p>    local ref = _G;</p><p>    local s, e = _FunctionName:find(".");</p><p>    while (s ~= nil) do</p><p>        local SubName = _FunctionName:sub(1, e-1);</p><p>        SubName = (tonumber(SubName) ~= nil and tonumber(SubName)) or SubName;</p><p>        ref = ref[SubName];</p><p>        _FunctionName = _FunctionName:sub(e+1);</p><p>        s, e = _FunctionName:find(".");</p><p>    end</p><p>    local SubName = (tonumber(_FunctionName) ~= nil and tonumber(_FunctionName)) or _FunctionName;</p><p>    return ref[SubName];</p><p>-- Wandelt underschiedliche Darstellungen einer Boolean in eine echte um.</p><p>-- Jeder String, der mit j, t, y oder + beginnt, wird als true interpretiert.</p><p>-- Alles andere als false.</p><p>-- Ist die Eingabe bereits ein Boolean wird es direkt zurückgegeben.</p><p>-- @param[type=string] _Input Boolean-Darstellung</p><p>-- @return[type=boolean] Konvertierte Boolean</p><p>-- @within Internal</p><p>-- @local</p><p>    if type(_Input) == "boolean" then</p><p>        return _Input;</p><p>    end</p><p>    if string.find(string.lower(tostring(_Input)), "^[tjy\\+].*$") then</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- Jobs ------------------------------------------------------------------------</p><p>-- Dieser Job ermittelt automatisch, ob eine Sekunde reale Zeit vergangen ist</p><p>-- und zählt eine Variable hoch, die die gesamt verstrichene reale Zeit hält.</p><p>    if not QSB.RealTime_LastTimeStamp then</p><p>        QSB.RealTime_LastTimeStamp = math.floor(Framework.TimeGetTime());</p><p>    end</p><p>    local CurrentTimeStamp = math.floor(Framework.TimeGetTime());</p><p>    -- Eine Sekunde ist vergangen</p><p>    if QSB.RealTime_LastTimeStamp ~= CurrentTimeStamp then</p><p>        QSB.RealTime_LastTimeStamp = CurrentTimeStamp;</p><p>        QSB.RealTime_SecondsSinceGameStart = QSB.RealTime_SecondsSinceGameStart +1;</p><p>    end</p><p>-- Dieser Job führt alle registrierten Events aus, die einmal pro Sekunde</p><p>-- gestartet werden sollen.</p><p>    for k, v in pairs(Core.Data.Events.EverySecond) do</p><p>        if v and v.Function(unpack(v.Arguments)) then</p><p>            Core.Data.Events.EverySecond[k] = nil;</p><p>        end</p><p>    end</p><p>-- Dieser Job führt alle registrierten Events aus, die zehn Mal pro Sekunde</p><p>-- gestartet werden sollen.</p><p>    for k, v in pairs(Core.Data.Events.EveryTurn) do</p><p>        if v and v.Function(unpack(v.Arguments)) then</p><p>            Core.Data.Events.EveryTurn[k] = nil;</p><p>        end</p><p>    end</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundlebriefingsystem.lua.html">
            <div class='doclink'>
                <div>BundleBriefingSystem</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia BundleBriefingSystem                                         # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ermöglicht es Briefing zu verwenden.</p><p>-- Briefings dienen zur Darstellung von Dialogen oder zur näheren Erleuterung</p><p>-- der aktuellen Spielsituation. Mit Multiple Choice können dem Spieler mehrere</p><p>-- Auswahlmöglichkeiten gegeben werden, multiple Handlungsstränge gestartet</p><p>-- oder Menüstrukturen abgebildet werden. Mittels Sprüngen und Leerseiten</p><p>-- kann innerhalb des Multiple Choice Briefings navigiert werden.</p><p>-- Das wichtigste auf einen Blick:</p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet ein Briefing.</p><p>-- Für ein Briefing könn verschiedene spezielle Einstellungen vorgenommen</p><p>-- werden. Jede dieser Einstellungen wird mit true aktiviert.</p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- : StartBriefing</p><p>-- @param[type=table] _Briefing Briefing Definition</p><p>-- @return[type=number] ID des Briefing</p><p>-- @within Anwenderfunktionen</p><p>function API.StartBriefing(_Briefing)</p><p>    if GUI then</p><p>        warn("API.StartBriefing: Cannot start briefing from local script!");</p><p>        return -1;</p><p>    end</p><p>    return BundleBriefingSystem.Global:StartBriefing(_Briefing);</p><p>-- Prüft, ob ein Briefing abgeschlossen wurde.</p><p>-- : IsBriefingFinished</p><p>-- @param[type=table] _Briefing Briefing Definition</p><p>-- @return[type=boolean] Briefing ist beendet</p><p>-- @within Anwenderfunktionen</p><p>function API.IsBriefingFinished(_BriefingID)</p><p>    if GUI then</p><p>        warn("API.IsBriefingFinished: Cannot check briefing state from local script!");</p><p>        return false;</p><p>    end</p><p>    return BundleBriefingSystem.Global.Data.FinishedBriefings[_BriefingID] == true;</p><p>-- Prüft, ob ein Briefing abgeschlossen wurde.</p><p>-- : IsBriefingActive</p><p>-- @param[type=table] _Briefing Briefing Definition</p><p>-- @return[type=boolean] Briefing ist beendet</p><p>-- @within Anwenderfunktionen</p><p>function API.IsBriefingActive(_BriefingID)</p><p>    if GUI then</p><p>        return BundleBriefingSystem.Local.Data.BriefingActive == true;</p><p>    end</p><p>    return BundleBriefingSystem.Global.Data.BriefingActive == true;</p><p>-- Steuert, ob Quest Timer während Briefings pausiert sind oder weiterzählen.</p><p>-- : PauseQuestsDuringBriefings</p><p>-- @param[type=briefing] _Flag Briefing Definition</p><p>-- @within Anwenderfunktionen</p><p>function API.BriefingPauseQuests(_Flag)</p><p>    BundleBriefingSystem.Global.Data.PauseQuests = _Flag == true;</p><p>-- Erzeugt die Funktionen zum erzeugen von Seiten in einem Briefing und bindet</p><p>-- sie an das Briefing. Diese Funktion muss vor dem Start eines Briefing</p><p>-- aufgerufen werden.</p><p>-- : AddPages</p><p>-- @param[type=table] _Briefing Briefing Definition</p><p>-- @return[type=function] </p><p>-- @return[type=function] </p><p>-- @within Anwenderfunktionen</p><p>-- @usage local AP, ASP = API.AddPages(Briefing);</p><p>function API.AddPages(_Briefing)</p><p>    if GUI then</p><p>        fatal("API.AddPages: Cannot be used from local script!");</p><p>        return;</p><p>    end</p><p>    _Briefing.GetPage = function(self, _NameOrID)</p><p>        local ID = BundleBriefingSystem.Global:GetPageIDByName(_NameOrID);</p><p>        return BundleBriefingSystem.Global.Data.CurrentBriefing[ID];</p><p>    end</p><p>    local AP = function(_Page)</p><p>        if type(_Page) == "table" then</p><p>            -- Sprache anpassen</p><p>            local Language = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>            if type(_Page.Title) == "table" then</p><p>                _Page.Title = _Page.Title[Language];</p><p>            end</p><p>            if type(_Page.Text) == "table" then</p><p>                _Page.Text = _Page.Text[Language];</p><p>            end</p><p>            -- Lookat mappen</p><p>            if type(_Page.LookAt) == "string" or type(_Page.LookAt) == "number" then</p><p>                _Page.LookAt = {_Page.LookAt, 0}</p><p>            end</p><p>            -- Position mappen</p><p>            if type(_Page.Position) == "string" or type(_Page.Position) == "number" then</p><p>                _Page.Position = {_Page.Position, 0}</p><p>            end</p><p>            -- Dialogkamera</p><p>            if _Page.DialogCamera == true then</p><p>                _Page.Angle = _Page.Angle or BundleBriefingSystem.Global.Data.DLGCAMERA_ANGLEDEFAULT;</p><p>                _Page.Zoom = _Page.Zoom or BundleBriefingSystem.Global.Data.DLGCAMERA_ZOOMDEFAULT;</p><p>                _Page.FOV = _Page.FOV or BundleBriefingSystem.Global.Data.DLGCAMERA_FOVDEFAULT;</p><p>                _Page.Rotation = _Page.Rotation or BundleBriefingSystem.Global.Data.DLGCAMERA_ROTATIONDEFAULT;</p><p>            else</p><p>                _Page.Angle = _Page.Angle or BundleBriefingSystem.Global.Data.CAMERA_ANGLEDEFAULT;</p><p>                _Page.Zoom = _Page.Zoom or BundleBriefingSystem.Global.Data.CAMERA_ZOOMDEFAULT;</p><p>                _Page.FOV = _Page.FOV or BundleBriefingSystem.Global.Data.CAMERA_FOVDEFAULT;</p><p>                _Page.Rotation = _Page.Rotation or BundleBriefingSystem.Global.Data.CAMERA_ROTATIONDEFAULT;</p><p>            end</p><p>            -- FlyTo Animation für MC entfernen</p><p>            if _Page.FlyTo and _Page.MC then</p><p>                _Page.FlyTo = nil;</p><p>            end</p><p>            -- Anzeigezeit setzen</p><p>            if not _Page.Duration then</p><p>                if _Page.FlyTo then</p><p>                    _Page.Duration = _Page.FlyTo.Duration;</p><p>                else</p><p>                    _Briefing.SkippingAllowed = true;</p><p>                    _Page.Duration = -1;</p><p>                end</p><p>            end</p><p>            -- Multiple Choice</p><p>            if _Page.MC then</p><p>                _Page.Text = "";</p><p>                _Page.text = "";</p><p>                _Page.NoSkipping = true;</p><p>                _Page.Duration = -1;</p><p>            end</p><p>            _Page.GetSelectedAnswer = function(self)</p><p>                if not self.MC or not self.MC.Selected then</p><p>                    return 0;</p><p>                end</p><p>                return self.MC.Selected;</p><p>            end</p><p>            table.insert(_Briefing, _Page);</p><p>        else</p><p>            table.insert(_Briefing, (_Page ~= nil and _Page) or -1);</p><p>        end</p><p>        return _Page;</p><p>    end</p><p>    local ASP = function(...)</p><p>        local Name;</p><p>        if #arg  5 then</p><p>            PageName = table.remove(arg, 1);</p><p>        end</p><p>        return AP {</p><p>            Name         = PageName,</p><p>            Title        = arg[2],</p><p>            Text         = arg[3],</p><p>            Position     = arg[1],</p><p>            DialogCamera = arg[4] == true,</p><p>            Action       = arg[5]</p><p>        }</p><p>    end</p><p>    return AP, ASP;</p><p>-- Erstellt eine Seite für ein Dialog-Briefing.</p><p>-- : Diese Funktion wird von</p><p>--  erzeugt und an</p><p>-- das Briefing gebunden.</p><p>-- Eine einfache Seite lässt sich unter Nutzung von DialogCamera erstellen.</p><p>-- Dadurch wird entweder Nahsicht oder Fernsicht verwendet. Werte für Angle,</p><p>-- Rotation oder Zoom werden automatisch gesetzt, wenn sie fehlen.</p><p>-- AP {</p><p>--    Title        = "Titel",</p><p>--    Text         = "Das ist der Text der Seite.",</p><p>--    Position     = "HQ2",</p><p>--    DialogCamera = false,</p><p>--    Angle        = 30</p><p>-- Es gilt zu beachten, dass Seiten ohne Duration solange angezeigt werden,</p><p>-- bis der Benutzer die Seite per Button-Klick verlässt.</p><p>-- Es kann eine einfache Bewegung erzeugt werden. Hierzu wird FlyTo benutzt.</p><p>-- AP {</p><p>--    ...</p><p>--    FlyTo        = {</p><p>--        Position = {"hero", 250},</p><p>--        Zoom     = 2200,</p><p>--        Rotation = Logic.GetEntityOrientation(GetID("hero"))+90,</p><p>--        Angle    = 12,</p><p>--        Duration = 15,</p><p>--    }</p><p>-- Die Dauer der Animation (FlyTo.Duration) wird automatisch zur Dauer der</p><p>-- Seite, wenn nicht gesetzt oder geringer als die Dauer der Animation ist.</p><p>-- Jede Seite kann eine Grafik am linken Rand anzeigen. Diese Grafik wird</p><p>-- als Portrait betrachtet.</p><p>-- </p><p>-- Jede Seite kann ebenso eine bildschirmfüllende Grafik anzeigen. Diese Grafik</p><p>-- heißt Splashscreen.</p><p>-- </p><p>-- AP unterstützt ebenso die Angabe von XYZ-Koordinaten. Positionen können auch</p><p>-- als Vektoren angegeben werden. Dann hat die Kamera eine Position und eine</p><p>-- Blickrichtung.</p><p>-- Position = {X= 12000.0, Y= 36000.0, Z= 6000.0},</p><p>-- In einem Dialog kann der Spieler auch zur Auswahl einer Option gebeten</p><p>-- werden. Dies wird als Multiple Choice bezeichnet. Schreibe die Optionen</p><p>-- in eine Subtable MC.</p><p>-- AP {</p><p>--    ...</p><p>--    MC = {</p><p>--        {"Antwort 1", 5},</p><p>--        {"Antwort 2", "SomePageName"},</p><p>--    },</p><p>-- Nachdem der Spieler eine Antwort gewählt hat, wird er auf die Seite mit</p><p>-- der angegebenen ID oder dem Namen geleitet. Um das Briefing zu beenden,</p><p>-- nachdem ein Pfad beendet ist, wird eine leere AP-Seite genutzt. Auf diese</p><p>-- Weise weiß das Briefing, das es an dieser Stelle zuende ist.</p><p>-- </p><p>-- Soll stattdessen zu einer anderen Seite gesprungen werden, kann bei AP die</p><p>-- ID der Seite angeben werden, zu der gesprungen werden soll.</p><p>-- </p><p>-- Pages können auch einen Namen erhalten. Der Name kann anstelle der ID für</p><p>-- Sprünge und Multiple Choice genutzt werden.</p><p>-- </p><p>-- Um später zu einem beliebigen Zeitpunkt die gewählte Antwort einer Seite zu</p><p>-- erfahren, muss der Name der Seite oder die ID genutzt werden.</p><p>-- Briefing.Finished(_Data)</p><p>-- Die zurückgegebene Zahl ist die Position der Antwort, angefangen von oben.</p><p>-- Wird 0 zurückgegeben, wurde noch nicht geantwortet.</p><p>-- Wenn man zurückblättern erlaubt, aber nicht will, dass die Entscheidung</p><p>-- erneut getroffen werden kann, kann man dies mit NoRethink unterbinden.</p><p>-- AP {</p><p>--    ...</p><p>--    NoRethink = true,</p><p>-- Auf diese Weise hat der Spieler die Möglichkeit die Texte nach der letzten</p><p>-- Entscheidung noch einmal zu lesen, ohne dass er seine Meinung ändert.</p><p>-- @param[type=table] _Page Spezifikation der Seite</p><p>-- @return[type=table] Refernez auf die angelegte Seite</p><p>-- @within Briefing</p><p>    API.Fatal("AP: Please use the function provides by AddPages!");</p><p>-- Erstellt eine Seite in vereinfachter Syntax. Es wird davon</p><p>-- Ausgegangen, dass das Entity ein Siedler ist. Die Kamera</p><p>-- schaut den Siedler an.</p><p>-- : Diese Funktion wird von</p><p>--  erzeugt und an</p><p>-- das Briefing gebunden.</p><p>-- @param[type=string]  _entity       Zielentity</p><p>-- @param[type=string]  _title	      Titel der Seite</p><p>-- @param[type=string]  _text         Text der Seite</p><p>-- @param[type=boolean] _dialogCamera Nahsicht an/aus</p><p>-- @param[type=function] _action      Callback-Funktion</p><p>-- @return[type=table] Referenz auf die Seite</p><p>-- @within Briefing</p><p>-- @usage ASP("hans", "Hänschen-Klein", "Ich gehe in die weitel Welt hinein.", true);</p><p>    fatal("ASP: Please use the function provided by AddPages!");</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {</p><p>        Data = {</p><p>            CAMERA_ANGLEDEFAULT = 43,</p><p>            CAMERA_ROTATIONDEFAULT = -45,</p><p>            CAMERA_ZOOMDEFAULT = 6250,</p><p>            CAMERA_FOVDEFAULT = 42,</p><p>            DLGCAMERA_ANGLEDEFAULT = 29,</p><p>            DLGCAMERA_ROTATIONDEFAULT = -45,</p><p>            DLGCAMERA_ZOOMDEFAULT = 3400,</p><p>            DLGCAMERA_FOVDEFAULT = 25,</p><p>            FinishedBriefings = {},</p><p>            CurrentBriefing = {},</p><p>            CurrentPage = {},</p><p>            BriefingQueue = {},</p><p>            BriefingID = 0,</p><p>            DisplayIngameCutscene = false,</p><p>            BriefingActive = false,</p><p>            PauseQuests = true,</p><p>        }</p><p>    },</p><p>    Local = {</p><p>        Data = {</p><p>            CurrentBriefing = {},</p><p>            CurrentPage = {},</p><p>            DisplayIngameCutscene = false,</p><p>            BriefingActive = false,</p><p>            LastSkipButtonPressed = 0,</p><p>        },</p><p>    },</p><p>    Text = {</p><p>        NextButton = {de = "Weiter",  en = "Forward"},</p><p>        PrevButton = {de = "Zurück",  en = "Previous"},</p><p>        EndButton  = {de = "Beenden", en = "Close"},</p><p>    },</p><p>-- Global Script ------------------------------------------------------------ --</p><p>-- Startet das Bundle im globalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    StartSimpleHiResJobEx(self.BriefingExecutionController);</p><p>    StartSimpleJobEx(self.BriefingQuestPausedController);</p><p>-- Konvertiert eine Briefing-Table des alten Formats in das neue. Diese</p><p>-- Funktion ist auf Zeit im Skript und wird später wieder entfernt.</p><p>-- @param[type=table] _Briefing Briefing Definition</p><p>-- @return[type=number] ID des Briefing</p><p>-- @within Internal</p><p>-- @local</p><p>    _Briefing.DisableGlobalInvulnerability = _Briefing.disableGlobalInvulnerability or _Briefing.DisableGlobalInvulnerability;</p><p>    _Briefing.HideBorderPins = _Briefing.hideBorderPins or _Briefing.HideBorderPins;</p><p>    _Briefing.ShowSky = _Briefing.showSky or _Briefing.ShowSky;</p><p>    _Briefing.RestoreGameSpeed = _Briefing.restoreGameSpeed or _Briefing.RestoreGameSpeed;</p><p>    _Briefing.RestoreCamera = _Briefing.restoreCamera or _Briefing.RestoreCamera;</p><p>    _Briefing.SkippingAllowed = (_Briefing.skipPerPage or _Briefing.skipAll) or _Briefing.SkippingAllowed;</p><p>    _Briefing.ReturnForbidden = _Briefing.returnForbidden or _Briefing.ReturnForbidden;</p><p>    _Briefing.Finished = _Briefing.finished or _Briefing.Finished;</p><p>    _Briefing.Starting = _Briefing.starting or _Briefing.Starting;</p><p>    </p><p>    for k, v in pairs(_Briefing) do</p><p>        if type(v) == "table" then</p><p>            -- Normale Optionen</p><p>            _Briefing[k].Title = v.title or _Briefing[k].Title;</p><p>            _Briefing[k].Text = v.text or _Briefing[k].Text;</p><p>            _Briefing[k].Position = (v.position and {v.position, 0}) or _Briefing[k].Position;</p><p>            _Briefing[k].Angle = v.angle or _Briefing[k].Angle;</p><p>            _Briefing[k].Rotation = v.rotation or _Briefing[k].Rotation;</p><p>            _Briefing[k].Zoom = v.zoom or _Briefing[k].Zoom;</p><p>            _Briefing[k].Action = v.action or _Briefing[k].Action;</p><p>            _Briefing[k].FadeIn = v.fadeIn or _Briefing[k].FadeIn;</p><p>            _Briefing[k].FadeOut = v.fadeOut or _Briefing[k].FadeOut;</p><p>            _Briefing[k].FaderAlpha = v.faderAlpha or _Briefing[k].FaderAlpha;</p><p>            _Briefing[k].DialogCamera = v.dialogCamera or _Briefing[k].DialogCamera;</p><p>            _Briefing[k].Portrait = v.portrait or _Briefing[k].Portrait;</p><p>            _Briefing[k].NoRethink = v.noRethink or _Briefing[k].NoRethink;</p><p>            _Briefing[k].NoHistory = v.noHistory or _Briefing[k].NoHistory;</p><p>            -- Splashscreen</p><p>            if v.splashscreen then</p><p>                v.Splashscreen = v.splashscreen;</p><p>                if type(v.Splashscreen) == "table" then</p><p>                    v.Splashscreen = v.Splashscreen.image;</p><p>                end</p><p>            end</p><p>            -- Multiple Choice</p><p>            if v.mc then</p><p>                _Briefing[k].Title = v.mc.title;</p><p>                _Briefing[k].Text = v.mc.title;</p><p>                _Briefing[k].MC = v.mc.answers;</p><p>            end</p><p>        end</p><p>    end</p><p>    return _Briefing;</p><p>-- Startet ein Briefing.</p><p>-- @param[type=table] _Briefing Briefing Definition</p><p>-- @return[type=number] ID des Briefing</p><p>-- @within Internal</p><p>-- @local</p><p>    _Briefing = self:ConvertBriefingTable(_Briefing);</p><p>    </p><p>    if not self.Data.LoadScreenHidden or self:IsBriefingActive() then</p><p>        table.insert(self.Data.BriefingQueue, _Briefing);</p><p>        if not self.Data.BriefingQueueJobID then</p><p>            self.Data.BriefingQueueJobID = StartSimpleHiResJobEx(self.BriefingQueueController);</p><p>        end</p><p>        return;</p><p>    end</p><p>    self.Data.BriefingID = self.Data.BriefingID +1;</p><p>    self.Data.CurrentBriefing = _Briefing;</p><p>    self.Data.CurrentBriefing.Page = 1;</p><p>    self.Data.CurrentBriefing.PageHistory = {};</p><p>    self.Data.CurrentBriefing.ID = self.Data.BriefingID;</p><p>    if self.Data.CurrentBriefing.DisableGlobalInvulnerability ~= false then</p><p>        Logic.SetGlobalInvulnerability(1);</p><p>    end</p><p>    local Briefing = API.ConvertTableToString(self.Data.CurrentBriefing);</p><p>    API.Bridge("BundleBriefingSystem.Local:StartBriefing(" ..Briefing.. ")");</p><p>    </p><p>    self.Data.BriefingActive = true;</p><p>    if self.Data.CurrentBriefing.Starting then</p><p>        self.Data.CurrentBriefing:Starting();</p><p>    end</p><p>    self:PageStarted();</p><p>    return self.Data.BriefingID;</p><p>-- Beendet ein Briefing.</p><p>-- @within Internal</p><p>-- @local</p><p>    Logic.SetGlobalInvulnerability(0);</p><p>    API.Bridge("BundleBriefingSystem.Local:FinishBriefing()");</p><p>    if self.Data.CurrentBriefing.Finished then</p><p>        self.Data.CurrentBriefing:Finished();</p><p>    end</p><p>    self.Data.FinishedBriefings[self.Data.CurrentBriefing.ID] = true;</p><p>    self.Data.CurrentBriefing = {};</p><p>    self.Data.CurrentPage = {};</p><p>    self.Data.BriefingActive = false;</p><p>-- Gibt die Page-ID zum angegebenen Page-Namen zurück.</p><p>-- Wenn keine Seite gefunden wird, die den angegebenen Namen hat, wird 0</p><p>-- zurückgegeben. Wenn eine Page-ID angegeben wird, wird diese zurückgegeben.</p><p>-- @param[type=string] _PageName Name der Seite</p><p>-- @return[type=number] ID der Seite</p><p>-- @within Internal</p><p>-- @local</p><p>    if self.Data.CurrentBriefing then</p><p>        if type(_PageName) == "number" then</p><p>            return _PageName;</p><p>        end</p><p>        for i= 1, #self.Data.CurrentBriefing, 1 do</p><p>            local Page = self.Data.CurrentBriefing[i];</p><p>            if Page and type(Page) == "table" and Page.Name == _PageName then</p><p>                return i;</p><p>            end</p><p>        end</p><p>    end</p><p>    return 0;</p><p>-- Startet die aktuelle Briefing-Seite.</p><p>-- @within Internal</p><p>-- @local</p><p>    local PageID = self.Data.CurrentBriefing.Page;</p><p>    if PageID then</p><p>        if type(self.Data.CurrentBriefing[PageID]) == "table" then</p><p>            if type(self.Data.CurrentBriefing[PageID]) == "table" then</p><p>                if self.Data.CurrentBriefing[PageID].Action then</p><p>                    self.Data.CurrentBriefing[PageID]:Action();</p><p>                end</p><p>                self.Data.CurrentPage = self.Data.CurrentBriefing[PageID];</p><p>                self.Data.CurrentPage.Started = Logic.GetTime();</p><p>                API.Bridge("BundleBriefingSystem.Local:PageStarted()");</p><p>            end</p><p>        elseif type(self.Data.CurrentBriefing[PageID]) == "string" then</p><p>            PageID = self:GetPageIDByName(self.Data.CurrentBriefing[PageID]);</p><p>            if PageID  0 then</p><p>                self.Data.CurrentBriefing.Page = PageID;</p><p>                API.Bridge("BundleBriefingSystem.Local.Data.CurrentBriefing.Page = " ..PageID);</p><p>                self:PageStarted();</p><p>            else</p><p>                self:FinishBriefing();</p><p>            end</p><p>        elseif type(self.Data.CurrentBriefing[PageID]) == "number" and self.Data.CurrentBriefing[PageID]  0 then</p><p>            self.Data.CurrentBriefing.Page = self.Data.CurrentBriefing[PageID];</p><p>            API.Bridge("BundleBriefingSystem.Local.Data.CurrentBriefing.Page = " ..self.Data.CurrentBriefing.Page);</p><p>            self:PageStarted();</p><p>        else</p><p>            self:FinishBriefing();</p><p>        end</p><p>    end</p><p>-- Beendet die aktuelle Briefing-Seite</p><p>-- @within Internal</p><p>-- @local</p><p>    local PageID = self.Data.CurrentBriefing.Page;</p><p>    API.Bridge("BundleBriefingSystem.Local:PageFinished()");</p><p>    self.Data.CurrentBriefing.Page = (self.Data.CurrentBriefing.Page or 0) +1;</p><p>    local PageID = self.Data.CurrentBriefing.Page;</p><p>    if not self.Data.CurrentBriefing[PageID] or PageID  #self.Data.CurrentBriefing then</p><p>        BundleBriefingSystem.Global:FinishBriefing();</p><p>    else</p><p>        BundleBriefingSystem.Global:PageStarted();</p><p>    end</p><p>-- Prüft, ob ein Briefing aktiv ist.</p><p>-- @param[type=boolean] Briefing ist aktiv</p><p>-- @within Internal</p><p>-- @local</p><p>    return self.Data.BriefingActive == true;</p><p>-- Reagiert auf die Auswahl einer Option einer Multiple-Choice-Page.</p><p>-- @within Internal</p><p>-- @local</p><p>    if self.Data.CurrentPage.MC then</p><p>        local PageID = self.Data.CurrentBriefing.Page;</p><p>        self.Data.CurrentBriefing[PageID].MC.Selected = _Selected;</p><p>        local JumpData = self.Data.CurrentPage.MC[_Selected];</p><p>        if type(JumpData[2]) == "function" then</p><p>            self.Data.CurrentBriefing.Page = self:GetPageIDByName(JumpData[2](self.Data.CurrentPage, JumpData))-1;</p><p>        else</p><p>            self.Data.CurrentBriefing.Page = self:GetPageIDByName(JumpData[2])-1;</p><p>        end</p><p>        API.Bridge("BundleBriefingSystem.Local.Data.CurrentBriefing.Page = " ..self.Data.CurrentBriefing.Page);</p><p>        self:PageFinished();</p><p>    end</p><p>-- Steuert das automatische weiter blättern und Sprünge zwischen Pages.</p><p>-- @within Internal</p><p>-- @local</p><p>    if not BundleBriefingSystem.Global.Data.DisplayIngameCutscene then</p><p>        if BundleBriefingSystem.Global:IsBriefingActive() then</p><p>            if BundleBriefingSystem.Global.Data.CurrentPage == nil then</p><p>                BundleBriefingSystem.Global:FinishBriefing();</p><p>            elseif type(BundleBriefingSystem.Global.Data.CurrentPage) == "table" then</p><p>                if BundleBriefingSystem.Global.Data.CurrentPage then</p><p>                    local Duration = (BundleBriefingSystem.Global.Data.CurrentPage.Duration or 0);</p><p>                    if Duration  -1 then</p><p>                        if Logic.GetTime()  BundleBriefingSystem.Global.Data.CurrentPage.Started + Duration then</p><p>                            local PageID = BundleBriefingSystem.Global.Data.CurrentBriefing.Page;</p><p>                            if not BundleBriefingSystem.Global.Data.CurrentPage.NoHistory then</p><p>                                API.Bridge("table.insert(BundleBriefingSystem.Local.Data.CurrentBriefing.PageHistory, " ..PageID.. ")");</p><p>                            end</p><p>                            BundleBriefingSystem.Global:PageFinished();</p><p>                        end</p><p>                    end</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>-- Verhindert, dass während Briefings Quest-Timer weiter laufen.</p><p>-- @within Internal</p><p>-- @local</p><p>    if BundleBriefingSystem.Global.Data.BriefingActive and BundleBriefingSystem.Global.Data.PauseQuests then</p><p>        for i= 1, #Quests, 1 do</p><p>            if Quests[i].State == QuestState.Active then</p><p>                Quests[i].StartTime = Quests[i].StartTime +1;</p><p>            end</p><p>        end</p><p>    end</p><p>-- Steuert die Briefing-Warteschlange.</p><p>-- @within Internal</p><p>-- @local</p><p>    if #BundleBriefingSystem.Global.Data.BriefingQueue == 0 then</p><p>        BundleBriefingSystem.Global.Data.BriefingQueueJobID = nil;</p><p>        return true;</p><p>    end</p><p>    </p><p>    if BundleBriefingSystem.Global.Data.LoadScreenHidden and not BundleBriefingSystem.Global:IsBriefingActive() then</p><p>        local Next = table.remove(BundleBriefingSystem.Global.Data.BriefingQueue, 1);</p><p>        BundleBriefingSystem.Global:StartBriefing(Next);</p><p>    end</p><p>-- Local Script ------------------------------------------------------------- --</p><p>-- Startet das Bundle im globalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    if not InitializeFader then</p><p>        Script.Load("script/mainmenu/fader.lua");</p><p>    end</p><p>    self:OverrideThroneRoomFunctions();</p><p>    StartSimpleHiResJobEx(self.WaitForLoadScreenHidden);</p><p>-- Startet ein Briefing.</p><p>-- @param[type=table] _Briefing Briefing Definition</p><p>-- @within Internal</p><p>-- @local</p><p>    self.Data.SelectedEntities = {GUI.GetSelectedEntities()};</p><p>    self.Data.CurrentBriefing.Page = 1;</p><p>    self.Data.CurrentBriefing = _Briefing;</p><p>    if self.Data.CurrentBriefing.HideBorderPins then</p><p>        Display.SetRenderBorderPins(0);</p><p>    end</p><p>    if self.Data.CurrentBriefing.ShowSky then</p><p>        Display.SetRenderSky(1);</p><p>    end</p><p>    if Game.GameTimeGetFactor() ~= 0 then</p><p>        if self.Data.CurrentBriefing.RestoreGameSpeed and not self.Data.GameSpeedBackup then</p><p>            self.Data.GameSpeedBackup = Game.GameTimeGetFactor();</p><p>        end</p><p>        Game.GameTimeSetFactor(GUI.GetPlayerID(), 1);</p><p>    end</p><p>    if self.Data.CurrentBriefing.RestoreCamera and not self.Data.CameraBackup then</p><p>        self.Data.CameraBackup = {Camera.RTS_GetLookAtPosition()};</p><p>    end</p><p>    if not self.Data.CinematicActive then</p><p>        self:ActivateCinematicMode();</p><p>    end</p><p>    self.Data.BriefingActive = true;</p><p>-- Beendet ein Briefing.</p><p>-- @within Internal</p><p>-- @local</p><p>    if self.Data.CurrentBriefing.CameraBackup then </p><p>        Camera.RTS_SetLookAtPosition(unpack(self.Data.CurrentBriefing.CameraBackup));</p><p>        self.Data.CurrentBriefing.CameraBackup = nil;</p><p>    end</p><p>    for k, v in pairs(self.Data.SelectedEntities) do</p><p>        GUI.SelectEntity(v);</p><p>    end</p><p>    Display.SetRenderBorderPins(1);</p><p>    Display.SetRenderSky(0);</p><p>    local GameSpeed = (self.Data.GameSpeedBackup or 1);</p><p>    Game.GameTimeSetFactor(GUI.GetPlayerID(), GameSpeed);</p><p>    self.Data.GameSpeedBackup = nil;</p><p>    self:DeactivateCinematicMode();</p><p>    self.Data.BriefingActive = false;</p><p>-- Zeigt die aktuele Seite an.</p><p>-- @within Internal</p><p>-- @local</p><p>    local PageID = self.Data.CurrentBriefing.Page;</p><p>    self.Data.CurrentPage = self.Data.CurrentBriefing[PageID];</p><p>    if type(self.Data.CurrentPage) == "table" then</p><p>        self.Data.CurrentPage.Started = Logic.GetTime();</p><p>        -- Zurück und Weiter</p><p>        local BackFlag = 1;</p><p>        local SkipFlag = 1;</p><p>        if not self.Data.CurrentBriefing.SkippingAllowed or self.Data.CurrentPage.NoSkipping then</p><p>            if self.Data.CurrentPage.MC and not self.Data.CurrentPage.NoHistory then</p><p>                table.insert(self.Data.CurrentBriefing.PageHistory, PageID);</p><p>            end</p><p>            SkipFlag = 0;</p><p>            BackFlag = 0;</p><p>        end</p><p>        local LastPageID = self.Data.CurrentBriefing.PageHistory[#self.Data.CurrentBriefing.PageHistory];</p><p>        local LastPage = self.Data.CurrentBriefing[LastPageID];</p><p>        local NoRethinkMC = (type(LastPage) == "table" and LastPage.NoRethink and 0) or 1;</p><p>        if PageID == 1 or NoRethinkMC == 0 or self.Data.CurrentBriefing.ReturnForbidden == true then</p><p>            BackFlag = 0;</p><p>        end</p><p>        XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/Skip", SkipFlag);</p><p>        XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/StartButton", BackFlag);</p><p>        -- Rotation an Rotation des Ziels anpassen</p><p>        if self.Data.CurrentPage.DialogCamera and IsExisting(self.Data.CurrentPage.Position[1]) then</p><p>            self.Data.CurrentPage.Rotation = Logic.GetEntityOrientation(GetID(self.Data.CurrentPage.Position[1])) + 90;</p><p>        end</p><p>        -- Titel setzen</p><p>        local TitleWidget = "/InGame/ThroneRoom/Main/DialogTopChooseKnight/ChooseYourKnight";</p><p>        XGUIEng.SetText(TitleWidget, "");</p><p>        if self.Data.CurrentPage.Title then</p><p>            local Title = self.Data.CurrentPage.Title;</p><p>            if Title:sub(1, 1) ~= "{" then</p><p>                Title = "{@color:255,250,0,255}{center}" ..Title;</p><p>            end</p><p>            XGUIEng.SetText(TitleWidget, Title);</p><p>        end</p><p>        -- Text setzen</p><p>        local TextWidget = "/InGame/ThroneRoom/Main/MissionBriefing/Text";</p><p>        XGUIEng.SetText(TextWidget, "");</p><p>        if self.Data.CurrentPage.Text then</p><p>            local Text = self.Data.CurrentPage.Text;</p><p>            if Text:sub(1, 1) ~= "{" then</p><p>                Text = "{center}" ..Text;</p><p>            end</p><p>            XGUIEng.SetText(TextWidget, Text);</p><p>        end</p><p>        -- Fader</p><p>        self:SetFader();</p><p>        -- Portrait</p><p>        self:SetPortrait();</p><p>        -- Splashscreen</p><p>        self:SetSplashscreen();</p><p>        -- Multiple Choice</p><p>        self:SetOptionsDialog();</p><p>    end</p><p>-- Beendet die aktuelle Seite.</p><p>-- @within Internal</p><p>-- @local</p><p>    -- TODO: Warum ist PageHistory hier u.U. nil?</p><p>    -- self.Data.CurrentBriefing.PageHistory = self.Data.CurrentBriefing.PageHistory or {};</p><p>    self.Data.CurrentBriefing.Page = (self.Data.CurrentBriefing.Page or 0) +1;</p><p>    EndJobEx(self.Data.CurrentBriefing.FaderJob);</p><p>-- Prüft, ob ein Briefing aktiv ist.</p><p>-- @param[type=boolean] Briefing ist aktiv</p><p>-- @within Internal</p><p>-- @local</p><p>    return self.Data.BriefingActive == true;</p><p>-- Reagiert auf die Auswahl einer Option einer Multiple-Choice-Page.</p><p>-- @within Internal</p><p>-- @local</p><p>    local Widget = "/InGame/SoundOptionsMain/RightContainer/SoundProviderComboBoxContainer";</p><p>    local Position = self.Data.OriginalBoxPosition;</p><p>    XGUIEng.SetWidgetScreenPosition(Widget, Position[1], Position[2]);</p><p>    XGUIEng.ShowWidget(Widget, 0);</p><p>    XGUIEng.PopPage();</p><p>    if self.Data.CurrentPage.MC then</p><p>        local Selected = XGUIEng.ListBoxGetSelectedIndex(Widget .. "/ListBox")+1;</p><p>        API.Bridge("BundleBriefingSystem.Global:OnMCConfirmed(" ..Selected.. ")");</p><p>    end</p><p>-- Steuert die Kamera während des Throneroom Mode.</p><p>-- @within Internal</p><p>-- @local</p><p>    if self.Data.DisplayIngameCutscene then</p><p>        if AddOnCutsceneSystem then</p><p>            AddOnCutsceneSystem.Local:ThroneRoomCameraControl();</p><p>        end</p><p>    else</p><p>        if type(self.Data.CurrentPage) == "table" then</p><p>            -- Kamera</p><p>            local PX, PY, PZ = self:GetPagePosition();</p><p>            local LX, LY, LZ = self:GetPageLookAt();</p><p>            local PageFOV = self.Data.CurrentPage.FOV or 42.0;</p><p>            </p><p>            if PX and not LX then</p><p>                LX, LY, LZ, PX, PY, PZ = self:GetCameraProperties();</p><p>            end</p><p>            Camera.ThroneRoom_SetPosition(PX, PY, PZ);</p><p>            Camera.ThroneRoom_SetLookAt(LX, LY, LZ);</p><p>            Camera.ThroneRoom_SetFOV(PageFOV);</p><p>            -- Multiple Choice</p><p>            if self.Data.MCSelectionIsShown then</p><p>                local Widget = "/InGame/SoundOptionsMain/RightContainer/SoundProviderComboBoxContainer";</p><p>                if XGUIEng.IsWidgetShown(Widget) == 0 then</p><p>                    self.Data.MCSelectionIsShown = false;</p><p>                    self:LocalOnMCConfirmed();</p><p>                end</p><p>            end</p><p>            -- Button Texte</p><p>            local Language = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>            XGUIEng.SetText("/InGame/ThroneRoom/Main/StartButton", "{center}" ..BundleBriefingSystem.Text.PrevButton[Language]);</p><p>            local SkipText = BundleBriefingSystem.Text.NextButton[Language];</p><p>            local PageID = self.Data.CurrentBriefing.Page;</p><p>            if PageID == #self.Data.CurrentBriefing or self.Data.CurrentBriefing[PageID+1] == -1 then</p><p>                SkipText = BundleBriefingSystem.Text.EndButton[Language];</p><p>            end</p><p>            XGUIEng.SetText("/InGame/ThroneRoom/Main/Skip", "{center}" ..SkipText);</p><p>        end</p><p>    end</p><p>-- Gibt die Blickrichtung der Kamera und die Position der Kamera für den</p><p>-- Kompatibelitätsmodus zurück.</p><p>-- @return[type=number] LookAt X</p><p>-- @return[type=number] LookAt Y</p><p>-- @return[type=number] LookAt Z</p><p>-- @return[type=number] Position X</p><p>-- @return[type=number] Position Y</p><p>-- @return[type=number] Position Z</p><p>-- @within Internal</p><p>-- @local</p><p>    local CurrPage = self.Data.CurrentPage;</p><p>    local FlyTo = self.Data.CurrentPage.FlyTo;</p><p>    local startTime = CurrPage.Started;</p><p>    local flyTime = CurrPage.FlyTime;</p><p>    local startPosition = (FlyTo and FlyTo.Position) or CurrPage.Position;</p><p>    local endPosition = CurrPage.Position;</p><p>    local startRotation = (FlyTo and FlyTo.Rotation) or CurrPage.Rotation;</p><p>    local endRotation = CurrPage.Rotation;</p><p>    local startZoomAngle = (FlyTo and FlyTo.Angle) or CurrPage.Angle;</p><p>    local endZoomAngle = CurrPage.Angle;</p><p>    local startZoomDistance = (FlyTo and FlyTo.Zoom) or CurrPage.Zoom;</p><p>    local endZoomDistance = CurrPage.Zoom;</p><p>    local startFOV = ((FlyTo and FlyTo.FOV) or CurrPage.FOV) or 42.0;</p><p>    local endFOV = (CurrPage.FOV) or 42.0;</p><p>    local factor = self:GetLERP();</p><p>    </p><p>    local lPLX, lPLY, lPLZ = BundleBriefingSystem.Local:ConvertPosition(startPosition);</p><p>    local cPLX, cPLY, cPLZ = BundleBriefingSystem.Local:ConvertPosition(endPosition);</p><p>    local lookAtX = lPLX + (cPLX - lPLX) * factor;</p><p>    local lookAtY = lPLY + (cPLY - lPLY) * factor;</p><p>    local lookAtZ = lPLZ + (cPLZ - lPLZ) * factor;</p><p>    local zoomDistance = startZoomDistance + (endZoomDistance - startZoomDistance) * factor;</p><p>    local zoomAngle = startZoomAngle + (endZoomAngle - startZoomAngle) * factor;</p><p>    local rotation = startRotation + (endRotation - startRotation) * factor;</p><p>    local line = zoomDistance * math.cos(math.rad(zoomAngle));</p><p>    local positionX = lookAtX + math.cos(math.rad(rotation - 90)) * line;</p><p>    local positionY = lookAtY + math.sin(math.rad(rotation - 90)) * line;</p><p>    local positionZ = lookAtZ + (zoomDistance) * math.sin(math.rad(zoomAngle));</p><p>    return lookAtX, lookAtY, lookAtZ, positionX, positionY, positionZ;</p><p>-- Gibt die interpolierte Kameraposition zurück.</p><p>-- @return[type=number] X</p><p>-- @return[type=number] Y</p><p>-- @return[type=number] Z</p><p>-- @within Internal</p><p>-- @local</p><p>    local Position = self.Data.CurrentPage.Position;</p><p>    local x, y, z = self:ConvertPosition(Position);</p><p>    local FlyTo = self.Data.CurrentPage.FlyTo;</p><p>    if FlyTo then</p><p>        local lX, lY, lZ = self:ConvertPosition(FlyTo.Position);</p><p>        if lX then</p><p>            x = x + (lX - x) * self:GetLERP();</p><p>            y = y + (lY - y) * self:GetLERP();</p><p>            z = z + (lZ - z) * self:GetLERP();</p><p>        end</p><p>    end</p><p>    return x, y, z;</p><p>-- Gibt die interpolierte Blickrichtung der Kamera zurück.</p><p>-- @return[type=number] X</p><p>-- @return[type=number] Y</p><p>-- @return[type=number] Z</p><p>-- @within Internal</p><p>-- @local</p><p>    local LookAt = self.Data.CurrentPage.LookAt;</p><p>    local x, y, z = self:ConvertPosition(LookAt);</p><p>    local FlyTo = self.Data.CurrentPage.FlyTo;</p><p>    if FlyTo and x then</p><p>        local lX, lY, lZ = self:ConvertPosition(FlyTo.LookAt);</p><p>        if lX then</p><p>            x = x + (lX - x) * self:GetLERP();</p><p>            y = y + (lY - y) * self:GetLERP();</p><p>            z = z + (lZ - z) * self:GetLERP();</p><p>        end</p><p>    end</p><p>    return x, y, z;</p><p>-- Konvertiert die angegebenen Koordinaten zu XYZ.</p><p>-- @return[type=number] X</p><p>-- @return[type=number] Y</p><p>-- @return[type=number] Z</p><p>-- @within Internal</p><p>-- @local</p><p>    local x, y, z;</p><p>    if _Table and _Table.X then</p><p>        x = _Table.X; y = _Table.Y; z = _Table.Z;</p><p>    elseif _Table and not _Table.X then</p><p>        x, y, z = Logic.EntityGetPos(GetID(_Table[1]));</p><p>        z = z + (_Table[2] or 0);</p><p>    end</p><p>    return x, y, z;</p><p>-- Gibt den linearen Interpolationsfaktor zurück.</p><p>-- @param[type=number] LERP</p><p>-- @within Internal</p><p>-- @local</p><p>    local Current = Logic.GetTime();</p><p>    local Started = self.Data.CurrentPage.Started;</p><p>    local FlyTime;</p><p>    if self.Data.CurrentPage.FlyTo then</p><p>        FlyTime = self.Data.CurrentPage.FlyTo.Duration;</p><p>    end</p><p>    local Factor = 1.0;</p><p>    if FlyTime then</p><p>        if Started + FlyTime  Current then</p><p>            Factor = (Current - Started) / FlyTime;</p><p>            if Factor  1 then</p><p>                Factor = 1.0;</p><p>            end</p><p>        end</p><p>    end</p><p>    return Factor;</p><p>-- Reagiert auf einen beliebigen Linksklick im Throneroom.</p><p>-- @within Internal</p><p>-- @local</p><p>    if self.Data.DisplayIngameCutscene then</p><p>        if AddOnCutsceneSystem then</p><p>            AddOnCutsceneSystem.Local:ThroneRoomLeftClick();</p><p>        end</p><p>    else</p><p>        -- Klick auf Entity</p><p>        local EntityID = GUI.GetMouseOverEntity();</p><p>        API.Bridge([[</p><p>            local CurrentPage = BundleBriefingSystem.Global.CurrentPage;</p><p>            if CurrentPage and CurrentPage.LeftClickOnEntity then</p><p>                BundleBriefingSystem.Global.CurrentPage:LeftClickOnEntity(]] ..tostring(EntityID).. [[)</p><p>            end</p><p>        ]]);</p><p>        -- Klick in die Spielwelt</p><p>        local x,y = GUI.Debug_GetMapPositionUnderMouse();</p><p>        API.Bridge([[</p><p>            local CurrentPage = BundleBriefingSystem.Global.CurrentPage;</p><p>            if CurrentPage and CurrentPage.LeftClickOnPosition then</p><p>                BundleBriefingSystem.Global.CurrentPage:LeftClickOnPosition(]] ..tostring(x).. [[, ]] ..tostring(y).. [[)</p><p>            end</p><p>        ]]);</p><p>        -- Klick auf den Bildschirm</p><p>        local x,y = GUI.GetMousePosition();</p><p>        API.Bridge([[</p><p>            local CurrentPage = BundleBriefingSystem.Global.CurrentPage;</p><p>            if CurrentPage and CurrentPage.LeftClickOnScreen then</p><p>                BundleBriefingSystem.Global.CurrentPage:LeftClickOnScreen(]] ..tostring(x).. [[, ]] ..tostring(y).. [[)</p><p>            end</p><p>        ]]);</p><p>    end</p><p>-- Reagiert auf Klick auf den Skip-Button während des Throneroom Mode.</p><p>-- Wenn eine Cutscene aktiv ist, wird die überschriebene Methode aus dem</p><p>-- Addon benutzt.</p><p>-- @within Internal</p><p>-- @local</p><p>    if self.Data.DisplayIngameCutscene then</p><p>        if AddOnCutsceneSystem then</p><p>            AddOnCutsceneSystem.Local:NextButtonPressed();</p><p>        end</p><p>    else</p><p>        if (self.Data.LastSkipButtonPressed + 500)  Logic.GetTimeMs() then</p><p>            self.Data.LastSkipButtonPressed = Logic.GetTimeMs();</p><p>            if not self.Data.CurrentPage.NoHistory then</p><p>                table.insert(self.Data.CurrentBriefing.PageHistory, self.Data.CurrentBriefing.Page);</p><p>            end</p><p>            if self.Data.CurrentPage.OnForward then</p><p>                API.Bridge("BundleBriefingSystem.Global.CurrentPage:OnForward()");</p><p>            end</p><p>            API.Bridge("BundleBriefingSystem.Global:PageFinished()");</p><p>        end</p><p>    end</p><p>-- Reagiert auch Klick auf den Back-Button während des Throneroom Mode.</p><p>-- @within Internal</p><p>-- @local</p><p>    if not self.Data.DisplayIngameCutscene then</p><p>        if (self.Data.LastSkipButtonPressed + 500)  Logic.GetTimeMs() then</p><p>            self.Data.LastSkipButtonPressed = Logic.GetTimeMs();</p><p>            local LastPageID = table.remove(BundleBriefingSystem.Local.Data.CurrentBriefing.PageHistory);</p><p>            if not LastPageID then</p><p>                return;</p><p>            end</p><p>            local LastPage = BundleBriefingSystem.Local.Data.CurrentBriefing[LastPageID];</p><p>            if type(LastPage) == "number" then</p><p>                LastPageID = table.remove(BundleBriefingSystem.Local.Data.CurrentBriefing.PageHistory);</p><p>                LastPage = BundleBriefingSystem.Local.Data.CurrentBriefing[LastPageID];</p><p>            end</p><p>            if not LastPageID or LastPageID  1 or not LastPage then</p><p>                return;</p><p>            end</p><p>            if self.Data.CurrentPage.OnReturn then</p><p>                API.Bridge("BundleBriefingSystem.Global.CurrentPage:OnReturn()");</p><p>            end</p><p>            BundleBriefingSystem.Local.Data.CurrentBriefing.Page = LastPageID -1;</p><p>            API.Bridge([[</p><p>                BundleBriefingSystem.Global.Data.CurrentBriefing.Page = ]] ..(LastPageID -1).. [[</p><p>                BundleBriefingSystem.Global:PageFinished()</p><p>            ]]);</p><p>        end</p><p>    end</p><p>-- Setzt den Stil der Briefing-Bars.</p><p>-- @param[type=boolean] _Transparend Transparente Bars benutzen</p><p>-- @within Internal</p><p>-- @local</p><p>    local Alpha = (_Transparend and 100) or 255;</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoomBars", 1);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2", 1);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_Dodge", 1);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2_Dodge", 1);</p><p>    XGUIEng.SetMaterialAlpha("/InGame/ThroneRoomBars/BarBottom", 1, Alpha);</p><p>    XGUIEng.SetMaterialAlpha("/InGame/ThroneRoomBars/BarTop", 1, Alpha);</p><p>    XGUIEng.SetMaterialAlpha("/InGame/ThroneRoomBars_2/BarBottom", 1, Alpha);</p><p>    XGUIEng.SetMaterialAlpha("/InGame/ThroneRoomBars_2/BarTop", 1, Alpha);</p><p>-- Setzt die Fader-Optionen der aktuellen Seite.</p><p>-- @within Internal</p><p>-- @local</p><p>    -- Alpha der Fader-Maske</p><p>    g_Fade.To = 0;</p><p>    SetFaderAlpha(self.Data.CurrentPage.FaderAlpha or 0);</p><p>    -- Fadein starten</p><p>    local PageFadeIn = self.Data.CurrentPage.FadeIn;</p><p>    if PageFadeIn then</p><p>        FadeIn(PageFadeIn);</p><p>    end</p><p>    -- Fadeout starten</p><p>    local PageFadeOut = self.Data.CurrentPage.FadeOut;</p><p>    if PageFadeOut then</p><p>        self.Data.CurrentBriefing.FaderJob = StartSimpleHiResJobEx(function(_Time, _FadeOut)</p><p>            if Logic.GetTimeMs()  _Time - (_FadeOut * 1000) then</p><p>                FadeOut(_FadeOut);</p><p>                return true;</p><p>            end</p><p>        end, Logic.GetTimeMs() + ((self.Data.CurrentPage.Duration or 0) * 1000), PageFadeOut);</p><p>    end</p><p>-- Aktiviert den Auswahldialog einer Multiple-Choice-Seite.</p><p>-- @within Internal</p><p>-- @local</p><p>    if self.Data.CurrentPage.MC then</p><p>        local Screen = {GUI.GetScreenSize()};</p><p>        local Widget = "/InGame/SoundOptionsMain/RightContainer/SoundProviderComboBoxContainer";</p><p>        self.Data.OriginalBoxPosition = {</p><p>            XGUIEng.GetWidgetScreenPosition(Widget)</p><p>        };</p><p>        local listbox = XGUIEng.GetWidgetID(Widget .. "/ListBox");</p><p>        XGUIEng.ListBoxPopAll(listbox);</p><p>        for i=1, #self.Data.CurrentPage.MC, 1 do</p><p>            XGUIEng.ListBoxPushItem(listbox, self.Data.CurrentPage.MC[i][1]);</p><p>        end</p><p>        XGUIEng.ListBoxSetSelectedIndex(listbox, 0);</p><p>        local wSize = {XGUIEng.GetWidgetScreenSize(Widget)};</p><p>        local xFactor = (Screen[1]/1920);</p><p>        local xFix = math.ceil((Screen[1]/2) - (wSize[1] /2));</p><p>        local yFix = math.ceil(Screen[2] - (wSize[2]-20));</p><p>        XGUIEng.SetWidgetScreenPosition(Widget, xFix, yFix);</p><p>        XGUIEng.PushPage(Widget, false);</p><p>        XGUIEng.ShowWidget(Widget, 1);</p><p>        self.Data.MCSelectionIsShown = true;</p><p>    end</p><p>-- Setzt das Portrait der aktuellen Seite.</p><p>-- @within Internal</p><p>-- @local</p><p>    if self.Data.CurrentPage.Portrait then</p><p>        XGUIEng.SetMaterialAlpha("/InGame/ThroneRoom/KnightInfo/KnightBG", 1, 255);</p><p>        XGUIEng.SetMaterialTexture("/InGame/ThroneRoom/KnightInfo/KnightBG", 1, self.Data.CurrentPage.Portrait);</p><p>        XGUIEng.SetWidgetPositionAndSize("/InGame/ThroneRoom/KnightInfo/KnightBG", 0, 6000, 400, 600);</p><p>        XGUIEng.SetMaterialUV("/InGame/ThroneRoom/KnightInfo/KnightBG", 1, 0, 0, 1, 1);</p><p>    else</p><p>        XGUIEng.SetMaterialAlpha("/InGame/ThroneRoom/KnightInfo/KnightBG", 1, 0);</p><p>    end</p><p>-- Setzt den Splashscreen der aktuellen Seite.</p><p>-- @within Internal</p><p>-- @local</p><p>    local BG = "/InGame/ThroneRoomBars_2/BarTop";</p><p>    local BB = "/InGame/ThroneRoomBars_2/BarBottom";</p><p>    if self.Data.CurrentPage.Splashscreen == nil then</p><p>        XGUIEng.SetMaterialTexture(BG, 1, "");</p><p>        XGUIEng.SetMaterialTexture(BB, 1, "");</p><p>        XGUIEng.SetMaterialColor(BG, 1, 0, 0, 0, 255);</p><p>        XGUIEng.SetMaterialColor(BB, 1, 0, 0, 0, 255);</p><p>        if self.Data.CurrentBriefing.BriefingBarSizeBackup then</p><p>            local Position = self.Data.CurrentBriefing.BriefingBarSizeBackup;</p><p>            XGUIEng.SetWidgetSize(BG, Position[1], Position[2]);</p><p>            self.Data.CurrentBriefing.BriefingBarSizeBackup = nil;</p><p>        end</p><p>        self:SetBarStyle(false);</p><p>        return;</p><p>    end</p><p>    if self.Data.CurrentPage.Splashscreen then</p><p>        local size   = {GUI.GetScreenSize()};</p><p>        local is4To3 = math.floor((size[1]/size[2]) * 100) == 133;</p><p>        local is5To4 = math.floor((size[1]/size[2]) * 100) == 125;</p><p>        local u0, v0, u1, v1 = 0, 0, 1, 1;</p><p>        if is4To3 or is5To4 then</p><p>            u0 = u0 + (u0 * 0.125); u1 = u1 - (u1 * 0.125);</p><p>        end</p><p>        XGUIEng.SetMaterialColor(BG, 1, 255, 255, 255, 255);</p><p>        XGUIEng.SetMaterialTexture(BG, 1, self.Data.CurrentPage.Splashscreen);</p><p>        XGUIEng.SetMaterialUV(BG, 1, u0, v0, u1, v1);</p><p>    end</p><p>    if not self.Data.CurrentBriefing.BriefingBarSizeBackup then</p><p>        local x, y = XGUIEng.GetWidgetSize(BG);</p><p>        self.Data.CurrentBriefing.BriefingBarSizeBackup = {x, y};</p><p>    end</p><p>    local BarX    = self.Data.CurrentBriefing.BriefingBarSizeBackup[1];</p><p>    local _, BarY = XGUIEng.GetWidgetSize("/InGame/ThroneRoomBars");</p><p>    XGUIEng.SetWidgetSize(BG, BarX, BarY);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoomBars", 0);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2", 1);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_Dodge", 0);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2_Dodge", 0);</p><p>    XGUIEng.ShowWidget(BG, 1);</p><p>-- Aktiviert den Cinematic Mode.</p><p>-- @within Internal</p><p>-- @local</p><p>    self.Data.CinematicActive = true;</p><p>    </p><p>    local LoadScreenVisible = XGUIEng.IsWidgetShownEx("/LoadScreen/LoadScreen") == 1;</p><p>    if LoadScreenVisible then</p><p>        XGUIEng.PopPage();</p><p>    end</p><p>    XGUIEng.ShowWidget("/InGame/Root/3dOnScreenDisplay", 0);</p><p>    XGUIEng.ShowWidget("/InGame/Root/Normal", 0);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom", 1);</p><p>    XGUIEng.PushPage("/InGame/ThroneRoomBars", false);</p><p>    XGUIEng.PushPage("/InGame/ThroneRoomBars_2", false);</p><p>    XGUIEng.PushPage("/InGame/ThroneRoom/Main", false);</p><p>    XGUIEng.PushPage("/InGame/ThroneRoomBars_Dodge", false);</p><p>    XGUIEng.PushPage("/InGame/ThroneRoomBars_2_Dodge", false);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/Skip", 1);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/StartButton", 1);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogTopChooseKnight", 1);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogTopChooseKnight/Frame", 0);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogTopChooseKnight/DialogBG", 0);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogTopChooseKnight/FrameEdges", 0);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogBottomRight3pcs", 0);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/KnightInfoButton", 0);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/BackButton", 0);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/Briefing", 0);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/TitleContainer", 0);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/MissionBriefing/Text", 1);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/MissionBriefing/Title", 1);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/MissionBriefing/Objectives", 1);</p><p>    XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Text", " ");</p><p>    XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Title", " ");</p><p>    XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Objectives", " ");</p><p>    local x,y = XGUIEng.GetWidgetScreenPosition("/InGame/ThroneRoom/Main/DialogTopChooseKnight/ChooseYourKnight");</p><p>    XGUIEng.SetWidgetScreenPosition("/InGame/ThroneRoom/Main/DialogTopChooseKnight/ChooseYourKnight", x, 65);</p><p>    local x,y = XGUIEng.GetWidgetScreenPosition("/InGame/ThroneRoom/Main/Skip");</p><p>    XGUIEng.SetWidgetScreenPosition("/InGame/ThroneRoom/Main/StartButton", 20, y);</p><p>    XGUIEng.SetWidgetPositionAndSize("/InGame/ThroneRoom/KnightInfo/Objectives", 2, 0, 2000, 20);</p><p>    XGUIEng.PushPage("/InGame/ThroneRoom/KnightInfo", false);</p><p>    XGUIEng.ShowAllSubWidgets("/InGame/ThroneRoom/KnightInfo", 0);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom/KnightInfo/Text", 1);</p><p>    XGUIEng.SetText("/InGame/ThroneRoom/KnightInfo/Text", " ");</p><p>    XGUIEng.SetWidgetPositionAndSize("/InGame/ThroneRoom/KnightInfo/Text", 200, 300, 1000, 10);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom/KnightInfo/LeftFrame", 1);</p><p>    XGUIEng.ShowAllSubWidgets("/InGame/ThroneRoom/KnightInfo/LeftFrame", 0);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom/KnightInfo/KnightBG", 1);</p><p>    XGUIEng.SetWidgetPositionAndSize("/InGame/ThroneRoom/KnightInfo/KnightBG", 0, 0, 400, 600);</p><p>    XGUIEng.SetMaterialAlpha("/InGame/ThroneRoom/KnightInfo/KnightBG", 0, 0);</p><p>    BundleBriefingSystem.Local:SetBarStyle(false);</p><p>    GUI.ClearSelection();</p><p>    GUI.ForbidContextSensitiveCommandsInSelectionState();</p><p>    GUI.ActivateCutSceneState();</p><p>    GUI.SetFeedbackSoundOutputState(0);</p><p>    GUI.EnableBattleSignals(false);</p><p>    Input.CutsceneMode();</p><p>    Display.SetRenderFogOfWar(0);</p><p>    Display.SetUserOptionOcclusionEffect(0);</p><p>    Camera.SwitchCameraBehaviour(5);</p><p>    InitializeFader();</p><p>    g_Fade.To = 0;</p><p>    SetFaderAlpha(0);</p><p>    if LoadScreenVisible then</p><p>        XGUIEng.PushPage("/LoadScreen/LoadScreen", false);</p><p>    end</p><p>-- Deaktiviert den Cinematic Mode.</p><p>-- @within Internal</p><p>-- @local</p><p>    self.Data.CinematicActive = false;</p><p>    g_Fade.To = 0;</p><p>    SetFaderAlpha(0);</p><p>    XGUIEng.PopPage();</p><p>    Camera.SwitchCameraBehaviour(0);</p><p>    Display.UseStandardSettings();</p><p>    Input.GameMode();</p><p>    GUI.EnableBattleSignals(true);</p><p>    GUI.SetFeedbackSoundOutputState(1);</p><p>    GUI.ActivateSelectionState();</p><p>    GUI.PermitContextSensitiveCommandsInSelectionState();</p><p>    Display.SetRenderFogOfWar(1);</p><p>    if Options.GetIntValue("Display", "Occlusion", 0)  0 then</p><p>        Display.SetUserOptionOcclusionEffect(1);</p><p>    end</p><p>    XGUIEng.PopPage();</p><p>    XGUIEng.PopPage();</p><p>    XGUIEng.PopPage();</p><p>    XGUIEng.PopPage();</p><p>    XGUIEng.PopPage();</p><p>    XGUIEng.PopPage();</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom", 0);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoomBars", 0);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2", 0);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_Dodge", 0);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2_Dodge", 0);</p><p>    XGUIEng.ShowWidget("/InGame/Root/Normal", 1);</p><p>    XGUIEng.ShowWidget("/InGame/Root/3dOnScreenDisplay", 1);</p><p>-- Überschreibt die Throneroom-Funktionen.</p><p>-- Überschriebene Funktionen:</p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- @within Internal</p><p>-- @local</p><p>    ThroneRoomCameraControl = function()</p><p>        if BundleBriefingSystem then</p><p>            if BundleBriefingSystem.Local.Data.DisplayIngameCutscene then</p><p>                if AddOnCutsceneSystem then</p><p>                    AddOnCutsceneSystem.Local:ThroneRoomCameraControl();</p><p>                end</p><p>            else</p><p>                BundleBriefingSystem.Local:ThroneRoomCameraControl();</p><p>            end</p><p>        end</p><p>    end</p><p>    ThroneRoomLeftClick = function()</p><p>        if BundleBriefingSystem then</p><p>            if BundleBriefingSystem.Local.Data.DisplayIngameCutscene then</p><p>                if AddOnCutsceneSystem then</p><p>                    AddOnCutsceneSystem.Local:ThroneRoomLeftClick();</p><p>                end</p><p>            else</p><p>                BundleBriefingSystem.Local:ThroneRoomLeftClick();</p><p>            end</p><p>        end</p><p>    end</p><p>    OnSkipButtonPressed = function()</p><p>        if BundleBriefingSystem then</p><p>            if BundleBriefingSystem.Local.Data.DisplayIngameCutscene then</p><p>                if AddOnCutsceneSystem then</p><p>                    AddOnCutsceneSystem.Local:NextButtonPressed();</p><p>                end</p><p>            else</p><p>                BundleBriefingSystem.Local:NextButtonPressed();</p><p>            end</p><p>        end</p><p>    end</p><p>    OnStartButtonPressed = function()</p><p>        if BundleBriefingSystem then</p><p>            BundleBriefingSystem.Local:PrevButtonPressed();</p><p>        end</p><p>    end</p><p>    OnBackButtonPressed = function()</p><p>        if BundleBriefingSystem then</p><p>            BundleBriefingSystem.Local:PrevButtonPressed();</p><p>        end</p><p>    end</p><p>    BundleBriefingSystem.Local.GameCallback_Escape = GameCallback_Escape;</p><p>    GameCallback_Escape = function()</p><p>        if not BundleBriefingSystem.Local:IsBriefingActive() then</p><p>            BundleBriefingSystem.Local.GameCallback_Escape();</p><p>        end</p><p>    end</p><p>-- Speichert, wenn der Ladebildschirm geschlossen wird.</p><p>-- @within Internal</p><p>-- @local</p><p>    if XGUIEng.IsWidgetShownEx("/LoadScreen/LoadScreen") == 0 then</p><p>        GUI.SendScriptCommand("BundleBriefingSystem.Global.Data.LoadScreenHidden = true");</p><p>        return true;</p><p>    end</p><p>-- Behavior ----------------------------------------------------------------- --</p><p>-- Ruft die Lua-Funktion mit dem angegebenen Namen auf und spielt das Briefing</p><p>-- in ihr ab. Die Funktion muss eine Briefing-ID zurückgeben.</p><p>-- Das Brieifng wird an den Quest gebunden und kann mit Trigger_Briefing</p><p>-- überwacht werden. Es kann pro Quest nur ein Niederlage-Briefing </p><p>-- gebunden werden!</p><p>-- @param[type=string] _Briefing Funktionsname als String</p><p>-- @within Reprisal</p><p>    return b_Reprisal_Briefing:new(...);</p><p>Reprisal_Briefing</p><p>    Name = "Reprisal_Briefing",</p><p>    Description = {</p><p>        en = "Reward: Calls a function that creates a briefing and saves the returned briefing ID into the quest.",</p><p>        de = "Lohn: Ruft eine Funktion auf, die ein Briefing erzeugt und die zurueckgegebene ID in der Quest speichert.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Default, en = "Briefing function", de = "Funktion mit Briefing" },</p><p>    },</p><p>    return { Reprisal.Custom,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.Function = _Parameter;</p><p>    end</p><p>    local BriefingID = _G[self.Function](self, _Quest);</p><p>    local QuestID = GetQuestID(_Quest.Identifier);</p><p>    Quests[QuestID].zl97d_ukfs5_0dpm0 = BriefingID;</p><p>    if not type(_G[self.Function]) == "function" then</p><p>        fatal(_Quest.Identifier..": "..self.Name..": '"..self.Function.."' was not found!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>    local QuestID = GetQuestID(_Quest.Identifier);</p><p>    Quests[QuestID].zl97d_ukfs5_0dpm0 = nil;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ruft die Lua-Funktion mit dem angegebenen Namen auf und spielt das Briefing</p><p>-- in ihr ab. Die Funktion muss eine Briefing-ID zurückgeben.</p><p>-- Das Brieifng wird an den Quest gebunden und kann mit Trigger_Briefing</p><p>-- überwacht werden. Es kann pro Quest nur ein Erfolgs-Briefing gebunden werden!</p><p>-- @param[type=string] _Briefing Funktionsname als String</p><p>-- @within Reward</p><p>    return b_Reward_Briefing:new(...);</p><p>Reward_Briefing = API.InstanceTable(b_Reprisal_Briefi</p><p>Reward_Briefing.Name = "Reward_Briefi</p><p>Reward_Briefing.Description.en = "Reward: Calls a function that creates a briefing and saves the returned briefing ID into the ques</p><p>Reward_Briefing.Description.de = "Lohn: Ruft eine Funktion auf, die ein Briefing erzeugt und die zurueckgegebene ID in der Quest speicher</p><p>Reward_Briefing.GetReprisalTable = </p><p>Reward_Briefing.GetRewardTable = function(self, _Qu</p><p>    return { Reward.Custom,{self, self.CustomFunction} }</p><p>Reward_Briefing.CustomFunction = function(self, _Qu</p><p>    local BriefingID = _G[self.Function](self, _Quest);</p><p>    local QuestID = GetQuestID(_Quest.Identifier);</p><p>    Quests[QuestID].w5kur_xig0q_d9k7e = BriefingID;</p><p>Reward_Briefing.Reset = function(self, _Qu</p><p>    local QuestID = GetQuestID(_Quest.Identifier);</p><p>    Quests[QuestID].w5kur_xig0q_d9k7e = nil;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet einen Quest, nachdem das Briefing eines Quests gestartet und</p><p>-- durchlaufen wurde.</p><p>-- Der Trigger wird sowohl Erfolgs- als auch Niederlage-Briefings prüfen.</p><p>-- Über den Typ-Parameter kann auf eine spezielle Art eingeschränt werden.</p><p>-- @param[type=string] _QuestName Name des Quest</p><p>-- @param[type=number] _Waittime (optional) Wartezeit in Sekunden</p><p>-- @within Trigger</p><p>    return b_Trigger_Briefing:new(...);</p><p>Trigger_Briefing</p><p>    Name = "Trigger_Briefing",</p><p>    Description = {</p><p>        en = "Trigger: After a briefing of the given quest has finished, this quest will be started. Additionally you can choose the type of briefing this trigger shall react to.",</p><p>        de = "Ausloeser: Wenn ein Briefing des angegebenen Quest beendet ist, wird dieser Quest gestartet. Optional kann gewählt werden, auf welchen Typ von Briefing reagiert werden soll.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.QuestName, en = "Quest name",    de = "Questname" },</p><p>        { ParameterType.Custom,    en = "Briefing type", de = "Briefing-Typ" },</p><p>        { ParameterType.Number,    en = "Wait time",     de = "Wartezeit" },</p><p>    },</p><p>    return { Triggers.Custom2,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.Quest = _Parameter;</p><p>    elseif (_Index == 1) then</p><p>        _Paramater = _Parameter or "All";</p><p>        self.BriefingType = _Parameter;</p><p>    elseif (_Index == 2) then</p><p>        _Parameter = _Parameter or 0;</p><p>        self.WaitTime = _Parameter * 1;</p><p>    end</p><p>    if _Index == 1 then</p><p>        return {"All", "Success", "Failure"};</p><p>    end</p><p>    if self.BriefingType == "All" then</p><p>        return IsBriefingFinished(Quests[_QuestID].zl97d_ukfs5_0dpm0) or IsBriefingFinished(Quests[_QuestID].w5kur_xig0q_d9k7e);</p><p>    elseif self.BriefingType == "Failure" then</p><p>        return IsBriefingFinished(Quests[_QuestID].zl97d_ukfs5_0dpm0);</p><p>    elseif self.BriefingType == "Success" then</p><p>        return IsBriefingFinished(Quests[_QuestID].w5kur_xig0q_d9k7e);</p><p>    end</p><p>    return false;</p><p>    local QuestID = GetQuestID(self.Quest);</p><p>    if self:IsConditionFulfilled(QuestID) then</p><p>        if self.WaitTime and self.WaitTime  0 then</p><p>            self.WaitTimeTimer = self.WaitTimeTimer or Logic.GetTime();</p><p>            if Logic.GetTime() = self.WaitTimeTimer + self.WaitTime then</p><p>                return true;</p><p>            end</p><p>        else</p><p>            return true;</p><p>        end</p><p>    end</p><p>    return false;</p><p>    local QuestID = GetQuestID(self.Quest);</p><p>    Quests[QuestID].w5kur_xig0q_d9k7e = nil;</p><p>    Quests[QuestID].zl97d_ukfs5_0dpm0 = nil;</p><p>    self.WaitTimeTimer = nil</p><p>    local QuestID = GetQuestID(self.Quest);</p><p>    Quests[QuestID].w5kur_xig0q_d9k7e = nil;</p><p>    Quests[QuestID].zl97d_ukfs5_0dpm0 = nil;</p><p>    self.WaitTimeTimer = nil</p><p>    if self.WaitTime and self.WaitTime  0 then</p><p>        dbg(__quest_.Identifier.." "..self.Name..": waittime is below 0!");</p><p>        return true;</p><p>    elseif not IsValidQuest(self.Quest) then</p><p>        fatal(_Quest.Identifier.." "..self.Name..": '"..self.Quest.."' is not a valid quest!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundlebuildingbuttons.lua.html">
            <div class='doclink'>
                <div>BundleBuildingButtons</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia BundleBuildingButtons                                        # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Dieses Bundle erweitert das Gebäudemenü für verschiedene Gebäude um weitere</p><p>-- Funktionen. Es ist bspw. möglich ungenutzte Schalter frei zu programmieren.</p><p>-- Bekannte Funktionen sind natürlich auch wieder mit dabei.</p><p>-- Das wichtigste auf einen Blick:</p><p>-- </p><p>-- Viehzucht: Hernzüchten von Kühen und Schafen in Gattern</p><p>-- ,</p><p>-- ,</p><p>-- </p><p>-- ,</p><p>-- ,</p><p>-- </p><p>-- </p><p>-- Single Stop: Anhalten der Produktion von einzelnen Gebäuden</p><p>-- ,</p><p>-- </p><p>-- </p><p>-- Downgrade: Rückbau von Stadt- und Rohstoffgebäuden</p><p>-- ,</p><p>-- </p><p>-- </p><p>-- </p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Aktiviert oder deaktiviert die Single Stop Buttons. Single Stop ermöglicht</p><p>-- das Anhalten eines einzelnen Betriebes, anstelle des Anhaltens aller</p><p>-- Betriebe des gleichen Typs.</p><p>-- Im Gegensatz zur Viehzucht und zum Rückbau, welche feste eigeständige</p><p>-- Buttons sind, handelt es sich hierbei um einen Custom Button. Single</p><p>-- Stop belegt Index 1.</p><p>-- @param[type=boolean] _Flag Single Stop nutzen</p><p>-- @within Anwenderfunktionen</p><p>-- @see API.AddCustomBuildingButton</p><p>function API.UseSingleStop(_Flag)</p><p>    if not GUI then</p><p>        API.Bridge("API.UseSingleStop(" ..tostring(_Flag).. ")");</p><p>        return;</p><p>    end</p><p>    if _Flag then</p><p>        BundleBuildingButtons.Local:AddOptionalButton(</p><p>            2,</p><p>            BundleBuildingButtons.Local.ButtonDefaultSingleStop_Action,</p><p>            BundleBuildingButtons.Local.ButtonDefaultSingleStop_Tooltip,</p><p>            BundleBuildingButtons.Local.ButtonDefaultSingleStop_Update</p><p>        );</p><p>    else</p><p>        BundleBuildingButtons.Local:DeleteOptionalButton(2);</p><p>    end</p><p>-- Aktiviere oder deaktiviere Rückbau bei Stadt- und Rohstoffgebäuden. Die</p><p>-- Rückbaufunktion erlaubt es dem Spieler bei Stadt- und Rohstoffgebäude</p><p>-- der Stufe 2 und 3 jeweils eine Stufe zu zerstören. Der überflüssige</p><p>-- Arbeiter wird entlassen.</p><p>-- @param[type=boolean] _Flag Downgrade nutzen</p><p>-- @within Anwenderfunktionen</p><p>function API.UseDowngrade(_Flag)</p><p>    if not GUI then</p><p>        API.Bridge("API.UseDowngrade(" ..tostring(_Flag).. ")");</p><p>        return;</p><p>    end</p><p>    BundleBuildingButtons.Local.Data.Downgrade = _Flag == true;</p><p>-- Erlaube oder verbiete dem Spieler Schafe zu züchten.</p><p>-- </p><p>-- @param[type=boolean] _flag Schafzucht aktiv/inaktiv</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- -- Schafsaufzucht ist erlaubt</p><p>-- API.UseBreedSheeps(true);</p><p>function API.UseBreedSheeps(_flag)</p><p>    if not GUI then</p><p>        API.Bridge("API.UseBreedSheeps(" ..tostring(_flag).. ")");</p><p>        return;</p><p>    end</p><p>    BundleBuildingButtons.Local.Data.BreedSheeps = _flag == true;</p><p>    if _flag == true then</p><p>        local Price = MerchantSystem.BasePricesOrigBundleBuildingButtons[Goods.G_Sheep]</p><p>        MerchantSystem.BasePrices[Goods.G_Sheep] = Price;</p><p>        API.Bridge("MerchantSystem.BasePrices[Goods.G_Sheep] = " ..Price);</p><p>    else</p><p>        local Price = BundleBuildingButtons.Local.Data.SheepMoneyCost;</p><p>        MerchantSystem.BasePrices[Goods.G_Sheep] = Price;</p><p>        API.Bridge("MerchantSystem.BasePrices[Goods.G_Sheep] = " ..Price);</p><p>    end</p><p>-- Erlaube oder verbiete dem Spieler Kühe zu züchten.</p><p>-- </p><p>-- @param[type=boolean] _flag Kuhzucht aktiv/inaktiv</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- -- Es können keine Kühe gezüchtet werden</p><p>-- API.UseBreedCattle(false);</p><p>function API.UseBreedCattle(_flag)</p><p>    if not GUI then</p><p>        API.Bridge("API.UseBreedCattle(" ..tostring(_flag).. ")");</p><p>        return;</p><p>    end</p><p>    BundleBuildingButtons.Local.Data.BreedCattle = _flag == true;</p><p>    if _flag == true then</p><p>        local Price = MerchantSystem.BasePricesOrigBundleBuildingButtons[Goods.G_Cow];</p><p>        MerchantSystem.BasePrices[Goods.G_Cow] = Price;</p><p>        API.Bridge("MerchantSystem.BasePrices[Goods.G_Cow] = " ..Price);</p><p>    else</p><p>        local Price = BundleBuildingButtons.Local.Data.CattleMoneyCost;</p><p>        MerchantSystem.BasePrices[Goods.G_Cow] = Price;</p><p>        API.Bridge("MerchantSystem.BasePrices[Goods.G_Cow] = " ..Price);</p><p>    end</p><p>-- Setzt die Menge an Getreide, das zur Zucht eines Tieres benötigt wird.</p><p>-- </p><p>-- @param[type=number] _Amount Getreidekosten</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- -- Wucherpreise zum Züchten!</p><p>-- API.SetSheepGrainCost(50);</p><p>function API.SetSheepGrainCost(_Amount)</p><p>    if not GUI then</p><p>        API.Bridge("API.SetSheepGrainCost(" .._Amount.. ")");</p><p>        return;</p><p>    end</p><p>    BundleBuildingButtons.Local.Data.SheepCosts = _Amount;</p><p>-- Setzt die Menge an Getreide, das zur Zucht eines Tieres benötigt wird.</p><p>-- </p><p>-- @param[type=number] _Amount Getreidekosten</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- -- Wucherpreise zum Züchten!</p><p>-- API.SetCattleGrainCost(50);</p><p>function API.SetCattleGrainCost(_Amount)</p><p>    if not GUI then</p><p>        API.Bridge("API.SetCattleGrainCost(" .._Amount.. ")");</p><p>        return;</p><p>    end</p><p>    BundleBuildingButtons.Local.Data.CattleCosts = _Amount;</p><p>-- Setzt die zur Zucht benötigte Menge an Tieren in einem Gatter.</p><p>-- </p><p>-- @param[type=number] _Amount Benötigte Menge</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- -- Es wird ein volles Gatter zur Zucht benötigt:</p><p>-- API.SetSheepNeeded(5);</p><p>function API.SetSheepNeeded(_Amount)</p><p>    if not GUI then</p><p>        API.Bridge("API.SetSheepNeeded(" .._Amount.. ")");</p><p>        return;</p><p>    end</p><p>    if type(_Amount) ~= "number" or _Amount  5 then</p><p>        API.Fatal("API.SetSheepNeeded: Needed amount is invalid!");</p><p>    end</p><p>    BundleBuildingButtons.Local.Data.SheepNeeded = _Amount;</p><p>-- Setzt die zur Zucht benötigte Menge an Tieren in einem Gatter.</p><p>-- </p><p>-- @param[type=number] _Amount Benötigte Menge</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- -- Es werden keine Kühe zur Zucht benötigt:</p><p>-- API.SetCattleNeeded(0);</p><p>function API.SetCattleNeeded(_Amount)</p><p>    if not GUI then</p><p>        API.Bridge("API.SetCattleNeeded(" .._Amount.. ")");</p><p>        return;</p><p>    end</p><p>    if type(_Amount) ~= "number" or _Amount  5 then</p><p>        API.Fatal("API.SetCattleNeeded: Needed amount is invalid!");</p><p>    end</p><p>    BundleBuildingButtons.Local.Data.CattleNeeded = _Amount;</p><p>-- Fügt einen optionalen Gebäudeschalter hinzu. Der Index bestimmt, welcher</p><p>-- der beiden möglichen Buttons verwendet wird.</p><p>-- Mit dieser Funktion können zwei ungenutzte Buttons im Gebäudemenu mit einer</p><p>-- Funktionalität versehen werden. Es obliegt dem Mapper für welche Gebäude</p><p>-- der Button angezeigt wird und welche Funktion er hat. Es ist nicht möglich</p><p>-- Kosten im Tooltip anzuzeigen.</p><p>-- Jeder Button kann immer nur mit einer Aktion versehen werden. Soll die</p><p>-- Aktion für verschiedene Gebäudetypen unterschiedlich sein, muss in der</p><p>-- Aktion eine Fallunterscheidung durchgeführt werden.</p><p>-- Ein optionaler Button benötigt immer drei Funktionen:</p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- Alle drei Funktionen erhalten die ID des Buttons und die ID des Gebäudes,</p><p>-- das gerade selektiert ist.</p><p>-- </p><p>-- @param[type=number]   _Index Index des Buttons</p><p>-- @param[type=function] _Action Aktion des Buttons</p><p>-- @param[type=function] _Tooltip Tooltip Control</p><p>-- @param[type=function] _Update Button Update</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- -- Aktion</p><p>-- function ExampleButtonAction(_WidgetID, _BuildingID)</p><p>--     GUI.AddNote("Hier passiert etwas!");</p><p>-- end</p><p>-- -- Tooltip</p><p>-- function ExampleButtonTooltip(_WidgetID, _BuildingID)</p><p>--     UserSetTextNormal("Beschreibung", "Das ist die Beschreibung!");</p><p>-- end</p><p>-- -- Update</p><p>-- function ExampleButtonUpdate(_WidgetID, _BuildingID)</p><p>--     SetIcon(_WidgetID, {1, 1});</p><p>-- end</p><p>-- -- Beispiel für einen einfachen Button, der immer angezeigt wird, das Bild</p><p>-- -- eines Apfels trägt und eine Nachricht anzeigt.</p><p>-- API.AddCustomBuildingButton(1, ExampleButtonAction, ExampleButtonTooltip, ExampleButtonUpdate);</p><p>function API.AddCustomBuildingButton(_Index, _Action, _Tooltip, _Update)</p><p>    if not GUI then</p><p>        API.Fatal("API.AddCustomBuildingButton: Can not be used from global script!");</p><p>        return;</p><p>    end</p><p>    if (type(_Index) ~= "number" or (_Index  2)) then</p><p>        API.Fatal("API.AddCustomBuildingButton: Index must be 1 or 2!");</p><p>        return;</p><p>    end</p><p>    if (type(_Action) ~= "function" or type(_Tooltip) ~= "function" or type(_Update) ~= "function") then</p><p>        API.Fatal("API.AddCustomBuildingButton: Action, tooltip and update must be functions!");</p><p>        return;</p><p>    end</p><p>    return BundleBuildingButtons.Local:AddOptionalButton(</p><p>        _Index, _Action, _Tooltip, _Update</p><p>    );</p><p>-- Entfernt den optionalen Gebäudeschalter mit dem angegebenen Index.</p><p>-- </p><p>-- @param[type=number] _Index Index des Buttons</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- -- Entfernt die Konfiguration für Button 1</p><p>-- API.RemoveCustomBuildingButton(1);</p><p>function API.RemoveCustomBuildingButton(_Index)</p><p>    if not GUI then</p><p>        API.Bridge("API.RemoveCustomBuildingButton("..tostring(_Index)..")");</p><p>        return;</p><p>    end</p><p>    if (type(_Index) ~= "number" or (_Index  2)) then</p><p>        API.Fatal("API.RemoveCustomBuildingButton: Index must be 1 or 2!");</p><p>        return;</p><p>    end</p><p>    return BundleBuildingButtons.Local:DeleteOptionalButton(_Index);</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {</p><p>        Data = {}</p><p>    },</p><p>    Local = {</p><p>        Data = {</p><p>            OptionalButton1 = {</p><p>                UseButton = false,</p><p>            },</p><p>            OptionalButton2 = {</p><p>                UseButton = false,</p><p>            },</p><p>            StoppedBuildings = {},</p><p>            Downgrade = true,</p><p>            BreedCattle = true,</p><p>            CattleCosts = 10,</p><p>            CattleNeeded = 3,</p><p>            CattleKnightTitle = 0,</p><p>            CattleMoneyCost = 300,</p><p>            BreedSheeps = true,</p><p>            SheepCosts = 10,</p><p>            SheepNeeded = 3,</p><p>            SheepKnightTitle = 0,</p><p>            SheepMoneyCost = 300,</p><p>        },</p><p>        Description = {</p><p>            Downgrade = {</p><p>                Title = {</p><p>                    de = "Rückbau",</p><p>                    en = "Downgrade",</p><p>                },</p><p>                Text = {</p><p>                    de = "- Reißt eine Stufe des Geb?udes ein {cr}- Der überschüssige Arbeiter wird entlassen",</p><p>                    en = "- Destroy one level of this building {cr}- The surplus worker will be dismissed",</p><p>                },</p><p>                Disabled = {</p><p>                    de = "Kann nicht zurückgebaut werden!",</p><p>                    en = "Can not be downgraded yet!",</p><p>                },</p><p>            },</p><p>            BuyCattle = {</p><p>                Title = {</p><p>                    de = "Nutztier kaufen",</p><p>                    en = "Buy Farm animal",</p><p>                },</p><p>                Text = {</p><p>                    de = "- Kauft ein Nutztier {cr}- Nutztiere produzieren Rohstoffe",</p><p>                    en = "- Buy a farm animal {cr}- Farm animals produce resources",</p><p>                },</p><p>                Disabled = {</p><p>                    de = "Kauf ist nicht möglich!",</p><p>                    en = "Buy not possible!",</p><p>                },</p><p>            },</p><p>            SingleStop = {</p><p>                Title = {</p><p>                    de = "Arbeit anhalten/aufnehmen",</p><p>                    en = "Start/Stop Work",</p><p>                },</p><p>                Text = {</p><p>                    de = "- Startet oder stoppe die Arbeit in diesem Betrieb",</p><p>                    en = "- Continue or stop work for this building",</p><p>                },</p><p>            },</p><p>        },</p><p>    },</p><p>-- Global Script ---------------------------------------------------------------</p><p>-- Initalisiert das Bundle im globalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>-- Local Script ----------------------------------------------------------------</p><p>-- Initalisiert das Bundle im lokalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    MerchantSystem.BasePricesOrigBundleBuildingButtons                = {};</p><p>    MerchantSystem.BasePricesOrigBundleBuildingButtons[Goods.G_Sheep] = MerchantSystem.BasePrices[Goods.G_Sheep];</p><p>    MerchantSystem.BasePricesOrigBundleBuildingButtons[Goods.G_Cow]   = MerchantSystem.BasePrices[Goods.G_Cow];</p><p>    MerchantSystem.BasePrices[Goods.G_Sheep] = BundleBuildingButtons.Local.Data.SheepMoneyCost;</p><p>    MerchantSystem.BasePrices[Goods.G_Cow]   = BundleBuildingButtons.Local.Data.CattleMoneyCost;</p><p>    self:OverwriteHouseMenuButtons();</p><p>    self:OverwriteBuySiegeEngine();</p><p>    self:OverwriteToggleTrap();</p><p>    self:OverwriteGateOpenClose();</p><p>    self:OverwriteAutoToggle();</p><p>    Core:AppendFunction("GameCallback_GUI_SelectionChanged", self.OnSelectionChanged);</p><p>-- Diese Funktion erzeugt ein Nutztier und entfernt das Getreide vom Spieler.</p><p>-- @within Internal</p><p>-- @local</p><p>    Sound.FXPlay2DSound("ui\\menu_click");</p><p>    local eType = Logic.GetEntityType(_eID);</p><p>    if eType == Entities.B_CattlePasture then</p><p>        local Cost = BundleBuildingButtons.Local.Data.CattleCosts * (-1);</p><p>        GUI.SendScriptCommand([[</p><p>            local PlayerID = Logic.EntityGetPlayer(]].._eID..[[)</p><p>            local x, y = Logic.GetBuildingApproachPosition(]].._eID..[[)</p><p>            Logic.CreateEntity(Entities.A_X_Cow01, x, y, 0, PlayerID)</p><p>            AddGood(Goods.G_Grain, ]] ..Cost.. [[, PlayerID)</p><p>        ]]);</p><p>    elseif eType == Entities.B_SheepPasture then</p><p>        local Cost = BundleBuildingButtons.Local.Data.SheepCosts * (-1);</p><p>        GUI.SendScriptCommand([[</p><p>            local PlayerID = Logic.EntityGetPlayer(]].._eID..[[)</p><p>            local x, y = Logic.GetBuildingApproachPosition(]].._eID..[[)</p><p>            Logic.CreateEntity(Entities.A_X_Sheep01, x, y, 0, PlayerID)</p><p>            AddGood(Goods.G_Grain, ]] ..Cost.. [[, PlayerID)</p><p>        ]]);</p><p>    end</p><p>-- Das aktuell selektierte Gebäude wird um eine Stufe zurückgebaut.</p><p>-- Ein Gebäude der Stufe 1 wird zerstört. Aktuell ist dies aber inaktiv.</p><p>-- @within Internal</p><p>-- @local</p><p>    Sound.FXPlay2DSound("ui\\menu_click");</p><p>    local Selected = GUI.GetSelectedEntity();</p><p>    GUI.DeselectEntity(Selected);</p><p>    if Logic.GetUpgradeLevel(Selected)  0 then</p><p>        local AmountToHurt = math.ceil(Logic.GetEntityMaxHealth(Selected) / 2);</p><p>        if Logic.GetEntityHealth(Selected) = AmountToHurt then</p><p>            GUI.SendScriptCommand([[Logic.HurtEntity(]] ..Selected.. [[, ]] ..AmountToHurt.. [[)]]);</p><p>        end</p><p>    else</p><p>        local AmountToHurt = Logic.GetEntityMaxHealth(Selected);</p><p>        GUI.SendScriptCommand([[Logic.HurtEntity(]] ..Selected.. [[, ]] ..AmountToHurt.. [[)]]);</p><p>    end</p><p>-- Fügt einen Button dem Hausmenü hinzu. Es können nur 2 Buttons</p><p>-- hinzugefügt werden. Buttons brauchen immer eine Action-, eine</p><p>-- Tooltip- und eine Update-Funktion.</p><p>-- @param[type=number]   _idx              Indexposition des Button (1 oder 2)</p><p>-- @param[type=function] _actionFunction   Action-Funktion (String in Global)</p><p>-- @param[type=function] _tooltipFunction  Tooltip-Funktion (String in Global)</p><p>-- @param[type=function] _updateFunction   Update-Funktion (String in Global)</p><p>-- @within Internal</p><p>-- @local</p><p>-- @see API.AddCustomBuildingButton</p><p>    assert(_idx == 1 or _idx == 2);</p><p>    local wID = {</p><p>        XGUIEng.GetWidgetID("/InGame/Root/Normal/BuildingButtons/GateAutoToggle"),</p><p>        XGUIEng.GetWidgetID("/InGame/Root/Normal/BuildingButtons/GateOpenClose"),</p><p>    };</p><p>    BundleBuildingButtons.Local.Data["OptionalButton".._idx].WidgetID = wID[_idx];</p><p>    BundleBuildingButtons.Local.Data["OptionalButton".._idx].UseButton = true;</p><p>    BundleBuildingButtons.Local.Data["OptionalButton".._idx].ActionFunction = _actionFunction;</p><p>    BundleBuildingButtons.Local.Data["OptionalButton".._idx].TooltipFunction = _tooltipFunction;</p><p>    BundleBuildingButtons.Local.Data["OptionalButton".._idx].UpdateFunction = _updateFunction;</p><p>-- Entfernt den Zusatz-Button auf dem Index.</p><p>-- @param[type=number] _idx Indexposition des Button (1 oder 2)</p><p>-- @within Internal</p><p>-- @local</p><p>    assert(_idx == 1 or _idx == 2);</p><p>    local wID = {</p><p>        XGUIEng.GetWidgetID("/InGame/Root/Normal/BuildingButtons/GateAutoToggle"),</p><p>        XGUIEng.GetWidgetID("/InGame/Root/Normal/BuildingButtons/GateOpenClose"),</p><p>    };</p><p>    BundleBuildingButtons.Local.Data["OptionalButton".._idx].WidgetID = wID[_idx];</p><p>    BundleBuildingButtons.Local.Data["OptionalButton".._idx].UseButton = false;</p><p>    BundleBuildingButtons.Local.Data["OptionalButton".._idx].ActionFunction = nil;</p><p>    BundleBuildingButtons.Local.Data["OptionalButton".._idx].TooltipFunction = nil;</p><p>    BundleBuildingButtons.Local.Data["OptionalButton".._idx].UpdateFunction = nil;</p><p>-- Überschreibt die GUI-Funktionen des inaktiven Schalters für automatisches</p><p>-- Umschalten von Torsperren.</p><p>-- Diese Funktion implementiert den optionalen Schalter #1.</p><p>-- @within Internal</p><p>-- @local</p><p>    GUI_BuildingButtons.GateAutoToggleClicked = function()</p><p>        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();</p><p>        local EntityID = GUI.GetSelectedEntity();</p><p>        if not BundleBuildingButtons.Local.Data.OptionalButton1.ActionFunction then</p><p>            return;</p><p>        end</p><p>        BundleBuildingButtons.Local.Data.OptionalButton1.ActionFunction(CurrentWidgetID, EntityID);</p><p>    end</p><p>    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</p><p>    GUI_BuildingButtons.GateAutoToggleMouseOver = function()</p><p>        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();</p><p>        local EntityID = GUI.GetSelectedEntity();</p><p>        if not BundleBuildingButtons.Local.Data.OptionalButton1.TooltipFunction then</p><p>            return;</p><p>        end</p><p>        BundleBuildingButtons.Local.Data.OptionalButton1.TooltipFunction(CurrentWidgetID, EntityID);</p><p>    end</p><p>    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</p><p>    GUI_BuildingButtons.GateAutoToggleUpdate = function()</p><p>        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();</p><p>        local EntityID = GUI.GetSelectedEntity();</p><p>        local MaxHealth = Logic.GetEntityMaxHealth(EntityID);</p><p>        local Health = Logic.GetEntityHealth(EntityID);</p><p>        SetIcon(CurrentWidgetID, {8,16});</p><p>        if EntityID == nil</p><p>        or Logic.IsBuilding(EntityID) == 0</p><p>        or not BundleBuildingButtons.Local.Data.OptionalButton1.UpdateFunction</p><p>        or not BundleBuildingButtons.Local.Data.OptionalButton1.UseButton</p><p>        or Logic.IsConstructionComplete(EntityID) == 0 then</p><p>            XGUIEng.ShowWidget(CurrentWidgetID, 0);</p><p>            return;</p><p>        end</p><p>        if Logic.BuildingDoWorkersStrike(EntityID) == true</p><p>        or Logic.IsBuildingBeingUpgraded(EntityID) == true</p><p>        or Logic.IsBuildingBeingKnockedDown(EntityID) == true</p><p>        or Logic.IsBurning(EntityID) == true</p><p>        or MaxHealth-Health  0 then</p><p>            XGUIEng.ShowWidget(CurrentWidgetID, 0);</p><p>            return;</p><p>        end</p><p>        BundleBuildingButtons.Local.Data.OptionalButton1.UpdateFunction(CurrentWidgetID, EntityID);</p><p>    end</p><p>-- Überschreibt den inaktiven Button zum öffnen/schließen von Toren.</p><p>-- Diese Funktion implementiert den optionalen Schalter #2.</p><p>-- @within Internal</p><p>-- @local</p><p>    GUI_BuildingButtons.GateOpenCloseClicked = function()</p><p>        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();</p><p>        local EntityID = GUI.GetSelectedEntity();</p><p>        if not BundleBuildingButtons.Local.Data.OptionalButton2.ActionFunction then</p><p>            return;</p><p>        end</p><p>        BundleBuildingButtons.Local.Data.OptionalButton2.ActionFunction(CurrentWidgetID, EntityID);</p><p>    end</p><p>    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</p><p>    GUI_BuildingButtons.GateOpenCloseMouseOver = function()</p><p>        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();</p><p>        local EntityID = GUI.GetSelectedEntity();</p><p>        if not BundleBuildingButtons.Local.Data.OptionalButton2.TooltipFunction then</p><p>            return;</p><p>        end</p><p>        BundleBuildingButtons.Local.Data.OptionalButton2.TooltipFunction(CurrentWidgetID, EntityID);</p><p>    end</p><p>    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</p><p>    GUI_BuildingButtons.GateOpenCloseUpdate = function()</p><p>        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();</p><p>        local EntityID = GUI.GetSelectedEntity();</p><p>        local MaxHealth = Logic.GetEntityMaxHealth(EntityID);</p><p>        local Health = Logic.GetEntityHealth(EntityID);</p><p>        SetIcon(CurrentWidgetID, {8,16});</p><p>        if EntityID == nil</p><p>        or Logic.IsBuilding(EntityID) == 0</p><p>        or not BundleBuildingButtons.Local.Data.OptionalButton2.UpdateFunction</p><p>        or not BundleBuildingButtons.Local.Data.OptionalButton2.UseButton</p><p>        or Logic.IsConstructionComplete(EntityID) == 0</p><p>        or Logic.IsBuilding(EntityID) == 0 then</p><p>            XGUIEng.ShowWidget(CurrentWidgetID, 0);</p><p>            return;</p><p>        end</p><p>        if Logic.BuildingDoWorkersStrike(EntityID) == true</p><p>        or Logic.IsBuildingBeingUpgraded(EntityID) == true</p><p>        or Logic.IsBuildingBeingKnockedDown(EntityID) == true</p><p>        or Logic.IsBurning(EntityID) == true</p><p>        or MaxHealth-Health  0 then</p><p>            XGUIEng.ShowWidget(CurrentWidgetID, 0);</p><p>            return;</p><p>        end</p><p>        BundleBuildingButtons.Local.Data.OptionalButton2.UpdateFunction(CurrentWidgetID, EntityID);</p><p>    end</p><p>-- Überschreibt den inaktiven Button zum umschalten der Torhausfallen.</p><p>-- Diese Funktion implementiert den Rückbau.</p><p>-- @within Internal</p><p>-- @local</p><p>    GUI_BuildingButtons.TrapToggleClicked = function()</p><p>        BundleBuildingButtons.Local:DowngradeBuilding();</p><p>    end</p><p>    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</p><p>    GUI_BuildingButtons.TrapToggleMouseOver = function()</p><p>        local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>        BundleBuildingButtons.Local:TextNormal(</p><p>            BundleBuildingButtons.Local.Description.Downgrade.Title[lang],</p><p>            BundleBuildingButtons.Local.Description.Downgrade.Text[lang],</p><p>            BundleBuildingButtons.Local.Description.Downgrade.Disabled[lang]</p><p>        );</p><p>    end</p><p>    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</p><p>    GUI_BuildingButtons.TrapToggleUpdate = function()</p><p>        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();</p><p>        local EntityID = GUI.GetSelectedEntity();</p><p>        local eName = Logic.GetEntityName(EntityID);</p><p>        local eType = Logic.GetEntityType(EntityID);</p><p>        local tID = GetTerritoryUnderEntity(EntityID);</p><p>        local MaxHealth = Logic.GetEntityMaxHealth(EntityID);</p><p>        local Health = Logic.GetEntityHealth(EntityID);</p><p>        local Level = Logic.GetUpgradeLevel(EntityID);</p><p>        local x,y = XGUIEng.GetWidgetLocalPosition("/InGame/Root/Normal/BuildingButtons/Upgrade");</p><p>        SetIcon(CurrentWidgetID, {3,15});</p><p>        XGUIEng.SetWidgetLocalPosition(CurrentWidgetID, x+64, y);</p><p>        if EntityID == nil or Logic.IsBuilding(EntityID) == 0 then</p><p>            XGUIEng.ShowWidget(CurrentWidgetID, 0);</p><p>            return;</p><p>        end</p><p>        -- Protection - Submodul</p><p>        if BundleDestructionControl then</p><p>            -- Prüfe auf Namen</p><p>            if Inside(eName, BundleDestructionControl.Local.Data.Entities) then</p><p>                XGUIEng.ShowWidget(CurrentWidgetID, 0);</p><p>                return;</p><p>            end</p><p>            -- Prüfe auf Typen</p><p>            if Inside(eType, BundleDestructionControl.Local.Data.EntityTypes) then</p><p>                XGUIEng.ShowWidget(CurrentWidgetID, 0);</p><p>                return;</p><p>            end</p><p>            -- Prüfe auf Territorien</p><p>            if Inside(tID, BundleDestructionControl.Local.Data.OnTerritory) then</p><p>                XGUIEng.ShowWidget(CurrentWidgetID, 0);</p><p>                return;</p><p>            end</p><p>            -- Prüfe auf Category</p><p>            for k,v in pairs(BundleDestructionControl.Local.Data.EntityCategories) do</p><p>                if Logic.IsEntityInCategory(_BuildingID, v) == 1 then</p><p>                    XGUIEng.ShowWidget(CurrentWidgetID, 0);</p><p>                    return;</p><p>                end</p><p>            end</p><p>        end</p><p>        if Logic.IsConstructionComplete(EntityID) == 0</p><p>        or (Logic.IsEntityInCategory(EntityID, EntityCategories.OuterRimBuilding) == 0</p><p>        and Logic.IsEntityInCategory(EntityID, EntityCategories.CityBuilding) == 0)</p><p>        or not BundleBuildingButtons.Local.Data.Downgrade</p><p>        or Level == 0 then</p><p>            XGUIEng.ShowWidget(CurrentWidgetID, 0);</p><p>            return;</p><p>        end</p><p>        if Logic.BuildingDoWorkersStrike(EntityID) == true</p><p>        or Logic.IsBuildingBeingUpgraded(EntityID) == true</p><p>        or Logic.IsBuildingBeingKnockedDown(EntityID) == true</p><p>        or Logic.IsBurning(EntityID) == true</p><p>        or MaxHealth-Health  0 then</p><p>            XGUIEng.DisableButton(CurrentWidgetID, 1);</p><p>        else</p><p>            XGUIEng.DisableButton(CurrentWidgetID, 0);</p><p>        end</p><p>    end</p><p>-- Diese Funktion überschreibt die Belagerungswaffenwerkstattsteuerung. Dabei</p><p>-- wird die Nutztierzucht implementiert.</p><p>-- @within Internal</p><p>-- @local</p><p>    GUI_BuildingButtons.BuySiegeEngineCartMouseOver = function(_EntityType,_TechnologyType)</p><p>        local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();</p><p>        local BarrackID = GUI.GetSelectedEntity();</p><p>        local BuildingEntityType = Logic.GetEntityType(BarrackID);</p><p>        if  BuildingEntityType ~= Entities.B_SiegeEngineWorkshop</p><p>        and BuildingEntityType ~= Entities.B_CattlePasture</p><p>        and BuildingEntityType ~= Entities.B_SheepPasture then</p><p>            return;</p><p>        end</p><p>        local Costs = {Logic.GetUnitCost(BarrackID, _EntityType)}</p><p>        if BuildingEntityType == Entities.B_CattlePasture then</p><p>            BundleBuildingButtons.Local:TextCosts(</p><p>                BundleBuildingButtons.Local.Description.BuyCattle.Title[lang],</p><p>                BundleBuildingButtons.Local.Description.BuyCattle.Text[lang],</p><p>                BundleBuildingButtons.Local.Description.BuyCattle.Disabled[lang],</p><p>                {Goods.G_Grain, BundleBuildingButtons.Local.Data.CattleCosts},</p><p>                false</p><p>            );</p><p>        elseif BuildingEntityType == Entities.B_SheepPasture then</p><p>            BundleBuildingButtons.Local:TextCosts(</p><p>                BundleBuildingButtons.Local.Description.BuyCattle.Title[lang],</p><p>                BundleBuildingButtons.Local.Description.BuyCattle.Text[lang],</p><p>                BundleBuildingButtons.Local.Description.BuyCattle.Disabled[lang],</p><p>                {Goods.G_Grain, BundleBuildingButtons.Local.Data.SheepCosts},</p><p>                false</p><p>            );</p><p>        else</p><p>            GUI_Tooltip.TooltipBuy(Costs,nil,nil,_TechnologyType);</p><p>        end</p><p>    end</p><p>    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</p><p>    GUI_BuildingButtons.BuySiegeEngineCartClicked_OrigTHEA_Buildings = GUI_BuildingButtons.BuySiegeEngineCartClicked</p><p>    GUI_BuildingButtons.BuySiegeEngineCartClicked = function(_EntityType)</p><p>        local BarrackID = GUI.GetSelectedEntity()</p><p>        local PlayerID = GUI.GetPlayerID()</p><p>        local eType = Logic.GetEntityType(BarrackID)</p><p>        if eType == Entities.B_CattlePasture or eType == Entities.B_SheepPasture then</p><p>            BundleBuildingButtons.Local:BuyAnimal(BarrackID);</p><p>        else</p><p>            GUI_BuildingButtons.BuySiegeEngineCartClicked_OrigTHEA_Buildings(_EntityType)</p><p>        end</p><p>    end</p><p>    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</p><p>    GUI_BuildingButtons.BuySiegeEngineCartUpdate = function(_Technology)</p><p>        local PlayerID = GUI.GetPlayerID();</p><p>        local KnightTitle = Logic.GetKnightTitle(PlayerID);</p><p>        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();</p><p>        local EntityID = GUI.GetSelectedEntity();</p><p>        local EntityType = Logic.GetEntityType(EntityID);</p><p>        local grain = GetPlayerResources(Goods.G_Grain,PlayerID);</p><p>        local pos = GetPosition(EntityID);</p><p>        if EntityType == Entities.B_SiegeEngineWorkshop then</p><p>            XGUIEng.ShowWidget(CurrentWidgetID,1);</p><p>            if _Technology == Technologies.R_BatteringRam then</p><p>                SetIcon(CurrentWidgetID, {9,5});</p><p>            elseif _Technology == Technologies.R_SiegeTower then</p><p>                SetIcon(CurrentWidgetID, {9,6});</p><p>            elseif _Technology == Technologies.R_Catapult then</p><p>                SetIcon(CurrentWidgetID, {9,4});</p><p>            end</p><p>        elseif EntityType == Entities.B_CattlePasture then</p><p>            local CattlePasture = GetPlayerEntities(PlayerID,Entities.B_CattlePasture);</p><p>            local cows          = {Logic.GetPlayerEntitiesInArea(PlayerID,Entities.A_X_Cow01,pos.X,pos.Y,800,16)};</p><p>            local curAnimal     = Logic.GetNumberOfPlayerEntitiesInCategory(PlayerID,EntityCategories.CattlePasture);</p><p>            local maxAnimal     = #CattlePasture*5;</p><p>            SetIcon(CurrentWidgetID, {3,16})</p><p>            if _Technology == Technologies.R_Catapult and BundleBuildingButtons.Local.Data.BreedCattle then</p><p>                XGUIEng.ShowWidget("/InGame/Root/Normal/BuildingButtons",1);</p><p>                XGUIEng.ShowWidget("/InGame/Root/Normal/BuildingButtons/BuyCatapultCart",1);</p><p>                if curAnimal = maxAnimal then</p><p>                    XGUIEng.DisableButton(CurrentWidgetID, 1);</p><p>                elseif grain  BundleBuildingButtons.Local.Data.CattleCosts then</p><p>                    XGUIEng.DisableButton(CurrentWidgetID, 1);</p><p>                elseif KnightTitle  BundleBuildingButtons.Local.Data.CattleKnightTitle then</p><p>                    XGUIEng.DisableButton(CurrentWidgetID, 1);</p><p>                elseif cows[1]  BundleBuildingButtons.Local.Data.CattleNeeded then</p><p>                    XGUIEng.DisableButton(CurrentWidgetID, 1);</p><p>                else</p><p>                    XGUIEng.DisableButton(CurrentWidgetID, 0);</p><p>                end</p><p>            else</p><p>                XGUIEng.ShowWidget(CurrentWidgetID,0);</p><p>            end</p><p>        elseif EntityType == Entities.B_SheepPasture then</p><p>            local SheepPasture     = GetPlayerEntities(PlayerID,Entities.B_SheepPasture);</p><p>            local sheeps        = {Logic.GetPlayerEntitiesInArea(PlayerID,Entities.A_X_Sheep01,pos.X,pos.Y,800,16)};</p><p>            table.remove(sheeps, 1);</p><p>            local sheeps2        = {Logic.GetPlayerEntitiesInArea(PlayerID,Entities.A_X_Sheep02,pos.X,pos.Y,800,16)};</p><p>            table.remove(sheeps2, 1);</p><p>            local curAnimal     = Logic.GetNumberOfPlayerEntitiesInCategory(PlayerID,EntityCategories.SheepPasture);</p><p>            local maxAnimal     = #SheepPasture*5;</p><p>            sheeps = Array_Append(sheeps,sheeps2)</p><p>            SetIcon(CurrentWidgetID, {4,1})</p><p>            if _Technology == Technologies.R_Catapult and BundleBuildingButtons.Local.Data.BreedSheeps then</p><p>                XGUIEng.ShowWidget("/InGame/Root/Normal/BuildingButtons",1);</p><p>                XGUIEng.ShowWidget("/InGame/Root/Normal/BuildingButtons/BuyCatapultCart",1);</p><p>                if curAnimal = maxAnimal then</p><p>                    XGUIEng.DisableButton(CurrentWidgetID, 1);</p><p>                elseif grain  BundleBuildingButtons.Local.Data.SheepCosts then</p><p>                    XGUIEng.DisableButton(CurrentWidgetID, 1);</p><p>                elseif #sheeps  BundleBuildingButtons.Local.Data.SheepKnightTitle then</p><p>                    XGUIEng.DisableButton(CurrentWidgetID, 1);</p><p>                elseif #sheeps  BundleBuildingButtons.Local.Data.SheepNeeded then</p><p>                    XGUIEng.DisableButton(CurrentWidgetID, 1);</p><p>                else</p><p>                    XGUIEng.DisableButton(CurrentWidgetID, 0);</p><p>                end</p><p>            else</p><p>                XGUIEng.ShowWidget(CurrentWidgetID,0);</p><p>            end</p><p>        else</p><p>            XGUIEng.ShowWidget(CurrentWidgetID,0);</p><p>            return;</p><p>        end</p><p>        if Logic.IsConstructionComplete(GUI.GetSelectedEntity()) == 0 then</p><p>            XGUIEng.ShowWidget(CurrentWidgetID,0);</p><p>            return;</p><p>        end</p><p>        if EntityType ~= Entities.B_SheepPasture and EntityType ~= Entities.B_CattlePasture then</p><p>            local TechnologyState = Logic.TechnologyGetState(PlayerID, _Technology);</p><p>            if EnableRights == nil or EnableRights == false then</p><p>                XGUIEng.DisableButton(CurrentWidgetID,0);</p><p>                return</p><p>            end</p><p>            if TechnologyState == TechnologyStates.Researched then</p><p>                XGUIEng.DisableButton(CurrentWidgetID,0);</p><p>            else</p><p>                XGUIEng.DisableButton(CurrentWidgetID,1);</p><p>            end</p><p>        end</p><p>    end</p><p>-- Diese Funktion überschreibt das House Menu, sodass Single stop fehlerfrei</p><p>-- funktioniert.</p><p>-- @within Internal</p><p>-- @local</p><p>    HouseMenuStopProductionClicked_Orig_SingleStop = HouseMenuStopProductionClicked;</p><p>    HouseMenuStopProductionClicked = function()</p><p>        HouseMenuStopProductionClicked_Orig_SingleStop();</p><p>        local WidgetName = HouseMenu.Widget.CurrentBuilding;</p><p>        local EntityType = Entities[WidgetName];</p><p>        local PlayerID = GUI.GetPlayerID();</p><p>        local Buildings = GetPlayerEntities(PlayerID, EntityType);</p><p>        for i=1, #Buildings, 1 do</p><p>            if BundleBuildingButtons.Local.Data.StoppedBuildings[Buildings[i]] ~= HouseMenu.StopProductionBool then</p><p>                BundleBuildingButtons.Local.Data.StoppedBuildings[Buildings[i]] = HouseMenu.StopProductionBool;</p><p>                GUI.SetStoppedState(Buildings[i], HouseMenu.StopProductionBool);</p><p>            end</p><p>        end</p><p>    end</p><p>-- Ändert die Textur eines Icons im House Menu.</p><p>-- @param[type=string] _Widget Icon Widget</p><p>-- @param[type=table]  _Icon   Icon Textur</p><p>-- @within BundleBuildingButtons</p><p>-- @local</p><p>    if type(_Icon) == "table" then</p><p>        if type(_Icon[3]) == "string" then</p><p>            local ButtonState = 1;</p><p>            if XGUIEng.IsButton(_Widget) == 1 then</p><p>                ButtonState = 7;</p><p>            end</p><p>            local u0, u1, v0, v1;</p><p>            u0 = (_Coordinates[1] - 1) * 64;</p><p>            v0 = (_Coordinates[2] - 1) * 64;</p><p>            u1 = (_Coordinates[1]) * 64;</p><p>            v1 = (_Coordinates[2]) * 64;</p><p>            XGUIEng.SetMaterialAlpha(_Widget, ButtonState, 255);</p><p>            XGUIEng.SetMaterialTexture(_Widget, ButtonState, _Icon[3].. "big.png");</p><p>            XGUIEng.SetMaterialUV(_Widget, ButtonState, u0, v0, u1, v1);</p><p>        else</p><p>            SetIcon(_Widget, _Icon);</p><p>        end</p><p>    else</p><p>        local screenSize = {GUI.GetScreenSize()};</p><p>        local Scale = 330;</p><p>        if screenSize[2] = 800 then</p><p>            Scale = 260;</p><p>        end</p><p>        if screenSize[2] = 1000 then</p><p>            Scale = 210;</p><p>        end</p><p>        XGUIEng.SetMaterialAlpha(_Widget, 1, 255);</p><p>        XGUIEng.SetMaterialTexture(_Widget, 1, _file);</p><p>        XGUIEng.SetMaterialUV(_Widget, 1, 0, 0, Scale, Scale);</p><p>    end</p><p>-- Setzt einen für den Tooltip des aktuellen Widget einen neuen Text.</p><p>-- @param[type=string] _Title        Titel des Tooltip</p><p>-- @param[type=string] _Text         Text des Tooltip</p><p>-- @param[type=string] _DisabledText (optional) Textzusatz wenn inaktiv</p><p>-- @within BundleBuildingButtons</p><p>-- @local</p><p>    local TooltipContainerPath = "/InGame/Root/Normal/TooltipNormal";</p><p>    local TooltipContainer = XGUIEng.GetWidgetID(TooltipContainerPath);</p><p>    local TooltipNameWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Name");</p><p>    local TooltipDescriptionWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Text");</p><p>    local TooltipBGWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/BG");</p><p>    local TooltipFadeInContainer = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn");</p><p>    local PositionWidget = XGUIEng.GetCurrentWidgetID();</p><p>    GUI_Tooltip.ResizeBG(TooltipBGWidget, TooltipDescriptionWidget);</p><p>    local TooltipContainerSizeWidgets = {TooltipBGWidget};</p><p>    GUI_Tooltip.SetPosition(TooltipContainer, TooltipContainerSizeWidgets, PositionWidget);</p><p>    GUI_Tooltip.FadeInTooltip(TooltipFadeInContainer);</p><p>    _DisabledText = _DisabledText or "";</p><p>    local disabled = ""</p><p>    if XGUIEng.IsButtonDisabled(PositionWidget) == 1 and _DisabledText ~= "" and _Text ~= "" then</p><p>        disabled = disabled .. "{cr}{@color:255,32,32,255}" .. _DisabledText</p><p>    end</p><p>    XGUIEng.SetText(TooltipNameWidget, "{center}" .. _Title);</p><p>    XGUIEng.SetText(TooltipDescriptionWidget, _Text .. disabled);</p><p>    local Height = XGUIEng.GetTextHeight(TooltipDescriptionWidget, true);</p><p>    local W, H = XGUIEng.GetWidgetSize(TooltipDescriptionWidget);</p><p>    XGUIEng.SetWidgetSize(TooltipDescriptionWidget, W, Height);</p><p>-- Setzt den Kostentooltip des aktuellen Widgets.</p><p>-- @param[type=string]  _Title        Titel des Tooltip</p><p>-- @param[type=string]  _Text         Text des Tooltip</p><p>-- @param[type=string]  _DisabledText (optional) Textzusatz wenn inaktiv</p><p>-- @param[type=number]  _Costs        Kostentabelle</p><p>-- @param[type=boolean] _InSettlement Kosten in Siedlung suchen</p><p>-- @within Internal</p><p>-- @local</p><p>    local TooltipContainerPath = "/InGame/Root/Normal/TooltipBuy"</p><p>    local TooltipContainer = XGUIEng.GetWidgetID(TooltipContainerPath)</p><p>    local TooltipNameWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Name")</p><p>    local TooltipDescriptionWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Text")</p><p>    local TooltipBGWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/BG")</p><p>    local TooltipFadeInContainer = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn")</p><p>    local TooltipCostsContainer = XGUIEng.GetWidgetID(TooltipContainerPath .. "/Costs")</p><p>    local PositionWidget = XGUIEng.GetCurrentWidgetID()</p><p>    GUI_Tooltip.ResizeBG(TooltipBGWidget, TooltipDescriptionWidget)</p><p>    GUI_Tooltip.SetCosts(TooltipCostsContainer, _Costs, _InSettlement)</p><p>    local TooltipContainerSizeWidgets = {TooltipContainer, TooltipCostsContainer, TooltipBGWidget}</p><p>    GUI_Tooltip.SetPosition(TooltipContainer, TooltipContainerSizeWidgets, PositionWidget, nil, true)</p><p>    GUI_Tooltip.OrderTooltip(TooltipContainerSizeWidgets, TooltipFadeInContainer, TooltipCostsContainer, PositionWidget, TooltipBGWidget)</p><p>    GUI_Tooltip.FadeInTooltip(TooltipFadeInContainer)</p><p>    _DisabledText = _DisabledText or "";</p><p>    local disabled = ""</p><p>    if XGUIEng.IsButtonDisabled(PositionWidget) == 1 and _DisabledText ~= "" and _Text ~= "" then</p><p>        disabled = disabled .. "{cr}{@color:255,32,32,255}" .. _DisabledText</p><p>    end</p><p>    XGUIEng.SetText(TooltipNameWidget, "{center}" .. _Title)</p><p>    XGUIEng.SetText(TooltipDescriptionWidget, _Text .. disabled)</p><p>    local Height = XGUIEng.GetTextHeight(TooltipDescriptionWidget, true)</p><p>    local W, H = XGUIEng.GetWidgetSize(TooltipDescriptionWidget)</p><p>    XGUIEng.SetWidgetSize(TooltipDescriptionWidget, W, Height)</p><p>-- Diese Funktion ist die Action von Single Stop.</p><p>-- @within Internal</p><p>-- @local</p><p>    local StoppedState = BundleBuildingButtons.Local.Data.StoppedBuildings[EntityID] == true;</p><p>    GUI.SetStoppedState(EntityID, not StoppedState);</p><p>    BundleBuildingButtons.Local.Data.StoppedBuildings[EntityID] = not StoppedState;</p><p>-- Diese Funktion steuert den Tooltip von Single Stop.</p><p>-- @within Internal</p><p>-- @local</p><p>    local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>    BundleBuildingButtons.Local:TextNormal(</p><p>        BundleBuildingButtons.Local.Description.SingleStop.Title[lang],</p><p>        BundleBuildingButtons.Local.Description.SingleStop.Text[lang]</p><p>    );</p><p>-- Diese Funktion ist der Update Job von Single Stop.</p><p>-- @within Internal</p><p>-- @local</p><p>    local IsOuterRimBuilding = Logic.IsEntityInCategory(_EntityID, EntityCategories.OuterRimBuilding) == 1;</p><p>    local IsCityBuilding = Logic.IsEntityInCategory(_EntityID, EntityCategories.CityBuilding) == 1;</p><p>    if IsOuterRimBuilding == false and IsCityBuilding == false then</p><p>        XGUIEng.ShowWidget(_WidgetID, 0);</p><p>    end</p><p>    if BundleBuildingButtons.Local.Data.StoppedBuildings[_EntityID] == true then</p><p>        SetIcon(_WidgetID, {4, 12});</p><p>    else</p><p>        SetIcon(_WidgetID, {4, 13});</p><p>    end</p><p>-- Diese Funktion wird aufgerufen, sobald sich die Selektion ändert.</p><p>-- Hier werden die ausgeblendeten ungenutzten Gebäudeschalter eingeblendet.</p><p>-- @param[type=number] _Source Quelle der Änderung</p><p>-- @within Internal</p><p>-- @local</p><p>    local eID = GUI.GetSelectedEntity();</p><p>    local eType = Logic.GetEntityType(eID);</p><p>    XGUIEng.ShowWidget("/InGame/Root/Normal/BuildingButtons/GateAutoToggle",1);</p><p>    XGUIEng.ShowWidget("/InGame/Root/Normal/BuildingButtons/GateOpenClose",1);</p><p>    XGUIEng.ShowWidget("/InGame/Root/Normal/BuildingButtons/TrapToggle",1);</p><p>-- -------------------------------------------------------------------------- --</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundleclassicbehaviors.lua.html">
            <div class='doclink'>
                <div>BundleClassicBehaviors</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia BundleClassicBehaviors                                       # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Dieses Bundle enthält alle Behavior, die aus der QSB 3.9 PlusB bekannt sind.</p><p>-- Die Behavior sind weitesgehend unverändert und es dürfte keine Probleme mit</p><p>-- Inkompatibelität geben, wenn die QSB ausgetauscht wird.</p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Gibt das im Quest gespeicherte Resultat von Goal_InputDialog als Text zurück.</p><p>-- : Es wird nur die letzte Eingabe zurückgegeben.</p><p>-- @param[type=string] _QuestName Name des Quest</p><p>-- @return[type=string] Eingabe des Spielers</p><p>-- @within Anwenderfunktionen</p><p>function API.GetInputStringFromQuest(_QuestName)</p><p>    if GUI then</p><p>        API.Fatal("API.GetInputStringFromQuest: Quests can not be checked from local script!");</p><p>        return;</p><p>    end</p><p>    local Quest = Quests[GetQuestID(_QuestName)];</p><p>    if not Quest then</p><p>        API.Fatal("API.GetInputStringFromQuest: Quest '" ..tostring(_QuestName).. "' not found!");</p><p>        return;</p><p>    end</p><p>    return BundleClassicBehaviors.Global:GetInputFromQuest(_QuestName);</p><p>-- Gibt das im Quest gespeicherte Resultat von Goal_InputDialog Als Zahl zurück.</p><p>-- : Es wird nur die letzte Eingabe zurückgegeben.</p><p>-- @param[type=string] _QuestName Name des Quest</p><p>-- @return[type=number] Eingabe des Spielers</p><p>-- @within Anwenderfunktionen</p><p>function API.GetInputNumberFromQuest(_QuestName)</p><p>    return tonumber(API.GetInputStringFromQuest(_QuestName));</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Goals                                                                      --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ein Interaktives Objekt muss benutzt werden.</p><p>-- @param _ScriptName Skriptname des interaktiven Objektes</p><p>-- @within Goal</p><p>    return b_Goal_ActivateObject:new(...);</p><p>Goal_ActivateObject</p><p>    Name = "Goal_ActivateObject",</p><p>    Description = {</p><p>        en = "Goal: Activate an interactive object",</p><p>        de = "Ziel: Aktiviere ein interaktives Objekt",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Object name", de = "Skriptname" },</p><p>    },</p><p>    return {Objective.Object, { self.ScriptName } }</p><p>   if _Index == 0 then</p><p>        self.ScriptName = _Parameter</p><p>   end</p><p>    return "Quest_Object_Activate"</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Einem Spieler müssen Rohstoffe oder Waren gesendet werden.</p><p>-- In der Regel wird zum Auftraggeber gesendet. Es ist aber möglich auch zu</p><p>-- einem anderen Zielspieler schicken zu lassen. Wird ein Wagen gefangen</p><p>-- genommen, dann muss erneut geschickt werden. Optional kann dem Spieler</p><p>-- auch erlaubt werden, den Karren zurückzuerobern.</p><p>-- @param _GoodType      Typ der Ware</p><p>-- @param _GoodAmount    Menga der Ware</p><p>-- @param _OtherTarget   Anderes Ziel als Auftraggeber</p><p>-- @param _IgnoreCapture Wagen kann zurückerobert werden</p><p>-- @within Goal</p><p>    return b_Goal_Deliver:new(...)</p><p>Goal_Deliver</p><p>    Name = "Goal_Deliver",</p><p>    Description = {</p><p>        en = "Goal: Deliver goods to quest giver or to another player.",</p><p>        de = "Ziel: Liefere Waren zum Auftraggeber oder zu einem anderen Spieler.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Custom, en = "Type of good", de = "Ressourcentyp" },</p><p>        { ParameterType.Number, en = "Amount of good", de = "Ressourcenmenge" },</p><p>        { ParameterType.Custom, en = "To different player", de = "Anderer Empfänger" },</p><p>        { ParameterType.Custom, en = "Ignore capture", de = "Abfangen ignorieren" },</p><p>    },</p><p>    local GoodType = Logic.GetGoodTypeID(self.GoodTypeName)</p><p>    return { Objective.Deliver, GoodType, self.GoodAmount, self.OverrideTarget, self.IgnoreCapture }</p><p>    if (_Index == 0) then</p><p>        self.GoodTypeName = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.GoodAmount = _Parameter * 1</p><p>    elseif (_Index == 2) then</p><p>        self.OverrideTarget = tonumber(_Parameter)</p><p>    elseif (_Index == 3) then</p><p>        self.IgnoreCapture = AcceptAlternativeBoolean(_Parameter)</p><p>    end</p><p>    local Data = {}</p><p>    if _Index == 0 then</p><p>        for k, v in pairs( Goods ) do</p><p>            if string.find( k, "^G_" ) then</p><p>                table.insert( Data, k )</p><p>            end</p><p>        end</p><p>        table.sort( Data )</p><p>    elseif _Index == 2 then</p><p>        table.insert( Data, "-" )</p><p>        for i = 1, 8 do</p><p>            table.insert( Data, i )</p><p>        end</p><p>    elseif _Index == 3 then</p><p>        table.insert( Data, "true" )</p><p>        table.insert( Data, "false" )</p><p>    else</p><p>        assert( false )</p><p>    end</p><p>    return Data</p><p>    local GoodType = Logic.GetGoodTypeID(self.GoodTypeName)</p><p>    local GC = Logic.GetGoodCategoryForGoodType( GoodType )</p><p>    local tMapping = {</p><p>        [GoodCategories.GC_Clothes] = "Quest_Deliver_GC_Clothes",</p><p>        [GoodCategories.GC_Entertainment] = "Quest_Deliver_GC_Entertainment",</p><p>        [GoodCategories.GC_Food] = "Quest_Deliver_GC_Food",</p><p>        [GoodCategories.GC_Gold] = "Quest_Deliver_GC_Gold",</p><p>        [GoodCategories.GC_Hygiene] = "Quest_Deliver_GC_Hygiene",</p><p>        [GoodCategories.GC_Medicine] = "Quest_Deliver_GC_Medicine",</p><p>        [GoodCategories.GC_Water] = "Quest_Deliver_GC_Water",</p><p>        [GoodCategories.GC_Weapon] = "Quest_Deliver_GC_Weapon",</p><p>        [GoodCategories.GC_Resource] = "Quest_Deliver_Resources",</p><p>    }</p><p>    if GC then</p><p>        local Key = tMapping[GC]</p><p>        if Key then</p><p>            return Key</p><p>        end</p><p>    end</p><p>    return "Quest_Deliver_Goods"</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Es muss ein bestimmter Diplomatiestatus zu einer anderen Patei erreicht</p><p>-- werden. Der Status kann eine Verbesserung oder eine Verschlechterung zum</p><p>-- aktuellen Status sein.</p><p>-- @param _PlayerID Partei, die Entdeckt werden muss</p><p>-- @param _State    Diplomatiestatus</p><p>-- @within Goal</p><p>    return b_Goal_Diplomacy:new(...);</p><p>Goal_Diplomacy</p><p>    Name = "Goal_Diplomacy",</p><p>    Description = {</p><p>        en = "Goal: A diplomatic state must b reached. Can be lower than current state or higher.",</p><p>        de = "Ziel: Die Beziehungen zu einem Spieler müssen entweder verbessert oder verschlechtert werden.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.PlayerID, en = "Party", de = "Partei" },</p><p>        { ParameterType.Custom,   en = "Diplomacy state", de = "Diplomatische Beziehung" },</p><p>        { ParameterType.Custom,   en = "Relation", de = "Relation" },</p><p>    },</p><p>    DiploNameMap = {</p><p>        [DiplomacyStates.Allied]             = {de = "Verbündeter",    en = "Allied"},</p><p>        [DiplomacyStates.TradeContact]       = {de = "Handelspartner", en = "Trade Contact"},</p><p>        [DiplomacyStates.EstablishedContact] = {de = "Bekannt",        en = "Established Contact"},</p><p>        [DiplomacyStates.Undecided]          = {de = "Unbekannt",      en = "Undecided"},</p><p>        [DiplomacyStates.Enemy]              = {de = "Feind",          en = "Enemy"},</p><p>    },</p><p>    TextPattern = {</p><p>        de = "DIPLOMATIESTATUS ERREICHEN {cr}{cr}Status: s{cr}Zur Partei: s",</p><p>        en = "DIPLOMATIC STATE {cr}{cr}State: s{cr}To player: s",</p><p>    },</p><p>    return { Objective.Custom2, {self, self.CustomFunction}};</p><p>    local PlayerName = GetPlayerName(self.PlayerID) or "";</p><p>    local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>    local Text = string.format(self.TextPattern[lang], self.DiploNameMap[self.DiplState][lang], PlayerName);</p><p>    Core:ChangeCustomQuestCaptionText(Text, _Quest);</p><p>    self:ChangeCaption(_Quest);</p><p>    if self.BeSmallerThan then</p><p>        if GetDiplomacyState(_Quest.ReceivingPlayer, self.PlayerID)  self.DiplState then</p><p>            return true;</p><p>        end</p><p>    else</p><p>        if GetDiplomacyState(_Quest.ReceivingPlayer, self.PlayerID) = self.DiplState then</p><p>            return true;</p><p>        end</p><p>    end</p><p>    if (_Index == 0) then</p><p>        self.PlayerID = _Parameter * 1</p><p>    elseif (_Index == 1) then</p><p>        self.DiplState = DiplomacyStates[_Parameter];</p><p>    elseif (_Index == 2) then</p><p>        self.BeSmallerThan = _Parameter == "";</p><p>    end</p><p>    return {6, 3};</p><p>    if _Index == 1 then</p><p>        return {"Allied", "TradeContact", "EstablishedContact", "Undecided", "Enemy"};</p><p>    elseif _Index == 2 then</p><p>        return {"=", ""};</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Das Heimatterritorium des Spielers muss entdeckt werden.</p><p>-- Das Heimatterritorium ist immer das, wo sich Burg oder Lagerhaus der</p><p>-- zu entdeckenden Partei befinden.</p><p>-- @param _PlayerID ID der zu entdeckenden Partei</p><p>-- @within Goal</p><p>    return b_Goal_DiscoverPlayer:new(...);</p><p>Goal_DiscoverPlayer</p><p>    Name = "Goal_DiscoverPlayer",</p><p>    Description = {</p><p>        en = "Goal: Discover the home territory of another player.",</p><p>        de = "Ziel: Entdecke das Heimatterritorium eines Spielers.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.PlayerID, en = "Player", de = "Spieler" },</p><p>    },</p><p>    return {Objective.Discover, 2, { self.PlayerID } }</p><p>    if (_Index == 0) then</p><p>        self.PlayerID = _Parameter * 1</p><p>    end</p><p>    local tMapping = {</p><p>        [PlayerCategories.BanditsCamp] = "Quest_Discover",</p><p>        [PlayerCategories.City] = "Quest_Discover_City",</p><p>        [PlayerCategories.Cloister] = "Quest_Discover_Cloister",</p><p>        [PlayerCategories.Harbour] = "Quest_Discover",</p><p>        [PlayerCategories.Village] = "Quest_Discover_Village",</p><p>    }</p><p>    local PlayerCategory = GetPlayerCategoryType(self.PlayerID)</p><p>    if PlayerCategory then</p><p>        local Key = tMapping[PlayerCategory]</p><p>        if Key then</p><p>            return Key</p><p>        end</p><p>    end</p><p>    return "Quest_Discover"</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ein Territorium muss erstmalig vom Auftragnehmer betreten werden.</p><p>-- Wenn ein Spieler zuvor mit seinen Einheiten auf dem Territorium war, ist</p><p>-- es bereits entdeckt und das Ziel sofort erfüllt.</p><p>-- @param _Territory Name oder ID des Territorium</p><p>-- @within Goal</p><p>    return b_Goal_DiscoverTerritory:new(...);</p><p>Goal_DiscoverTerritory</p><p>    Name = "Goal_DiscoverTerritory",</p><p>    Description = {</p><p>        en = "Goal: Discover a territory",</p><p>        de = "Ziel: Entdecke ein Territorium",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.TerritoryName, en = "Territory", de = "Territorium" },</p><p>    },</p><p>    return { Objective.Discover, 1, { self.TerritoryID  } }</p><p>    if (_Index == 0) then</p><p>        self.TerritoryID = tonumber(_Parameter)</p><p>        if not self.TerritoryID then</p><p>            self.TerritoryID = GetTerritoryIDByName(_Parameter)</p><p>        end</p><p>        assert( self.TerritoryID  0 )</p><p>    end</p><p>    return "Quest_Discover_Territory"</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Eine andere Partei muss besiegt werden.</p><p>-- Die Partei gilt als besiegt, wenn ein Hauptgebäude (Burg, Kirche, Lager)</p><p>-- zerstört wurde.</p><p>-- </p><p>--  Bei Banditen ist dieses Behavior wenig sinnvoll, da sie</p><p>-- nicht durch zerstörung ihres Hauptzeltes vernichtet werden. Hier bietet</p><p>-- sich Goal_DestroyAllPlayerUnits an.</p><p>-- @param _PlayerID ID des Spielers</p><p>-- @within Goal</p><p>    return b_Goal_DestroyPlayer:new(...);</p><p>Goal_DestroyPlayer</p><p>    Name = "Goal_DestroyPlayer",</p><p>    Description = {</p><p>        en = "Goal: Destroy a player (destroy a main building)",</p><p>        de = "Ziel: Zerstöre einen Spieler (ein Hauptgebäude muss zerstört werden).",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.PlayerID, en = "Player", de = "Spieler" },</p><p>    },</p><p>    assert( self.PlayerID = 1, "Error in " .. self.Name .. ": GetGoalTable: PlayerID is invalid")</p><p>    return { Objective.DestroyPlayers, self.PlayerID }</p><p>    if (_Index == 0) then</p><p>        self.PlayerID = _Parameter * 1</p><p>    end</p><p>    local tMapping = {</p><p>        [PlayerCategories.BanditsCamp] = "Quest_DestroyPlayers_Bandits",</p><p>        [PlayerCategories.City] = "Quest_DestroyPlayers_City",</p><p>        [PlayerCategories.Cloister] = "Quest_DestroyPlayers_Cloister",</p><p>        [PlayerCategories.Harbour] = "Quest_DestroyEntities_Building",</p><p>        [PlayerCategories.Village] = "Quest_DestroyPlayers_Village",</p><p>    }</p><p>    local PlayerCategory = GetPlayerCategoryType(self.PlayerID)</p><p>    if PlayerCategory then</p><p>        local Key = tMapping[PlayerCategory]</p><p>        if Key then</p><p>            return Key</p><p>        end</p><p>    end</p><p>    return "Quest_DestroyEntities_Building"</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Es sollen Informationen aus der Burg gestohlen werden.</p><p>-- Der Spieler muss einen Dieb entsenden um Informationen aus der Burg zu</p><p>-- stehlen. </p><p>--  Das ist nur bei Feinden möglich!</p><p>-- @param _PlayerID ID der Partei</p><p>-- @within Goal</p><p>    return b_Goal_StealInformation:new(...);</p><p>Goal_StealInformation</p><p>    Name = "Goal_StealInformation",</p><p>    Description = {</p><p>        en = "Goal: Steal information from another players castle",</p><p>        de = "Ziel: Stehle Informationen aus der Burg eines Spielers",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.PlayerID, en = "Player", de = "Spieler" },</p><p>    },</p><p>    local Target = Logic.GetHeadquarters(self.PlayerID)</p><p>    if not Target or Target == 0 then</p><p>        Target = Logic.GetStoreHouse(self.PlayerID)</p><p>    end</p><p>    assert( Target and Target ~= 0 )</p><p>    return {Objective.Steal, 1, { Target } }</p><p>    if (_Index == 0) then</p><p>        self.PlayerID = _Parameter * 1</p><p>    end</p><p>    return "Quest_Steal_Info"</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Alle Einheiten des Spielers müssen zerstört werden.</p><p>-- : Bei normalen Parteien, welche ein Dorf oder eine Stadt</p><p>-- besitzen, ist Goal_DestroyPlayer besser geeignet!</p><p>-- @param _PlayerID ID des Spielers</p><p>-- @within Goal</p><p>    return b_Goal_DestroyAllPlayerUnits:new(...);</p><p>Goal_DestroyAllPlayerUnits</p><p>    Name = "Goal_DestroyAllPlayerUnits",</p><p>    Description = {</p><p>        en = "Goal: Destroy all units owned by player (be careful with script entities)",</p><p>        de = "Ziel: Zerstöre alle Einheiten eines Spielers (vorsicht mit Script-Entities)",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.PlayerID, en = "Player", de = "Spieler" },</p><p>    },</p><p>    return { Objective.DestroyAllPlayerUnits, self.PlayerID }</p><p>    if (_Index == 0) then</p><p>        self.PlayerID = _Parameter * 1</p><p>    end</p><p>    local tMapping = {</p><p>        [PlayerCategories.BanditsCamp] = "Quest_DestroyPlayers_Bandits",</p><p>        [PlayerCategories.City] = "Quest_DestroyPlayers_City",</p><p>        [PlayerCategories.Cloister] = "Quest_DestroyPlayers_Cloister",</p><p>        [PlayerCategories.Harbour] = "Quest_DestroyEntities_Building",</p><p>        [PlayerCategories.Village] = "Quest_DestroyPlayers_Village",</p><p>    }</p><p>    local PlayerCategory = GetPlayerCategoryType(self.PlayerID)</p><p>    if PlayerCategory then</p><p>        local Key = tMapping[PlayerCategory]</p><p>        if Key then</p><p>            return Key</p><p>        end</p><p>    end</p><p>    return "Quest_DestroyEntities"</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ein benanntes Entity muss zerstört werden.</p><p>-- Ein Entity gilt als zerstört, wenn es nicht mehr existiert oder während</p><p>-- der Laufzeit des Quests seine Entity-ID oder den Besitzer verändert.</p><p>-- : Helden können nicht direkt zerstört werden. Bei ihnen</p><p>-- genügt es, wenn sie sich "in die Burg zurückziehen".</p><p>-- @param _ScriptName Skriptname des Ziels</p><p>-- @within Goal</p><p>    return b_Goal_DestroyScriptEntity:new(...);</p><p>Goal_DestroyScriptEntity</p><p>    Name = "Goal_DestroyScriptEntity",</p><p>    Description = {</p><p>        en = "Goal: Destroy an entity",</p><p>        de = "Ziel: Zerstöre eine Entität",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Script name", de = "Skriptname" },</p><p>    },</p><p>    return {Objective.DestroyEntities, 1, { self.ScriptName } }</p><p>    if (_Index == 0) then</p><p>        self.ScriptName = _Parameter</p><p>    end</p><p>    if Logic.IsEntityAlive(self.ScriptName) then</p><p>        local ID = GetID(self.ScriptName)</p><p>        if ID and ID ~= 0 then</p><p>            ID = Logic.GetEntityType( ID )</p><p>            if ID and ID ~= 0 then</p><p>                if Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableBuilding ) == 1 then</p><p>                    return "Quest_DestroyEntities_Building"</p><p>                elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableAnimal ) == 1 then</p><p>                    return "Quest_DestroyEntities_Predators"</p><p>                elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.Hero ) == 1 then</p><p>                    return "Quest_Destroy_Leader"</p><p>                elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.Military ) == 1</p><p>                    or Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableSettler ) == 1</p><p>                    or Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableMerchant ) == 1  then</p><p>                    return "Quest_DestroyEntities_Unit"</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>    return "Quest_DestroyEntities"</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Eine Menge an Entities eines Typs müssen zerstört werden.</p><p>-- : Wenn Raubtiere zerstört werden sollen, muss Spieler 0</p><p>-- als Besitzer angegeben werden.</p><p>-- @param _EntityType Typ des Entity</p><p>-- @param _Amount     Menge an Entities des Typs</p><p>-- @param _PlayerID   Besitzer des Entity</p><p>-- @within Goal</p><p>    return b_Goal_DestroyType:new(...);</p><p>Goal_DestroyType</p><p>    Name = "Goal_DestroyType",</p><p>    Description = {</p><p>        en = "Goal: Destroy entity types",</p><p>        de = "Ziel: Zerstöre Entitätstypen",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Custom, en = "Type name", de = "Typbezeichnung" },</p><p>        { ParameterType.Number, en = "Amount", de = "Anzahl" },</p><p>        { ParameterType.Custom, en = "Player", de = "Spieler" },</p><p>    },</p><p>    return {Objective.DestroyEntities, 2, Entities[self.EntityName], self.Amount, self.PlayerID }</p><p>    if (_Index == 0) then</p><p>        self.EntityName = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.Amount = _Parameter * 1</p><p>        self.DestroyTypeAmount = self.Amount</p><p>    elseif (_Index == 2) then</p><p>        self.PlayerID = _Parameter * 1</p><p>    end</p><p>    local Data = {}</p><p>    if _Index == 0 then</p><p>        for k, v in pairs( Entities ) do</p><p>            if string.find( k, "^[ABU]_" ) then</p><p>                table.insert( Data, k )</p><p>            end</p><p>        end</p><p>        table.sort( Data )</p><p>    elseif _Index == 2 then</p><p>        for i = 0, 8 do</p><p>            table.insert( Data, i )</p><p>        end</p><p>    else</p><p>        assert( false )</p><p>    end</p><p>    return Data</p><p>    local ID = self.EntityName</p><p>    if Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableBuilding ) == 1 then</p><p>        return "Quest_DestroyEntities_Building"</p><p>    elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableAnimal ) == 1 then</p><p>        return "Quest_DestroyEntities_Predators"</p><p>    elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.Hero ) == 1 then</p><p>        return "Quest_Destroy_Leader"</p><p>    elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.Military ) == 1</p><p>        or Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableSettler ) == 1</p><p>        or Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableMerchant ) == 1  then</p><p>        return "Quest_DestroyEntities_Unit"</p><p>    end</p><p>    return "Quest_DestroyEntities"</p><p>-- -------------------------------------------------------------------------- --</p><p>    GameCallback_EntityKilled_Orig_QSB_Goal_DestroySoldiers = GameCallback_EntityKilled;</p><p>    GameCallback_EntityKilled = function(_AttackedEntityID, _AttackedPlayerID, _AttackingEntityID, _AttackingPlayerID, _AttackedEntityType, _AttackingEntityType)</p><p>        if _AttackedPlayerID ~= 0 and _AttackingPlayerID ~= 0 then</p><p>            QSB.DestroyedSoldiers[_AttackingPlayerID] = QSB.DestroyedSoldiers[_AttackingPlayerID] or {}</p><p>            QSB.DestroyedSoldiers[_AttackingPlayerID][_AttackedPlayerID] = QSB.DestroyedSoldiers[_AttackingPlayerID][_AttackedPlayerID] or 0</p><p>            if Logic.IsEntityTypeInCategory( _AttackedEntityType, EntityCategories.Military ) == 1</p><p>            and Logic.IsEntityInCategory( _AttackedEntityID, EntityCategories.HeavyWeapon) == 0 then</p><p>                QSB.DestroyedSoldiers[_AttackingPlayerID][_AttackedPlayerID] = QSB.DestroyedSoldiers[_AttackingPlayerID][_AttackedPlayerID] +1</p><p>            end</p><p>        end</p><p>        GameCallback_EntityKilled_Orig_QSB_Goal_DestroySoldiers(_AttackedEntityID, _AttackedPlayerID, _AttackingEntityID, _AttackingPlayerID, _AttackedEntityType, _AttackingEntityType)</p><p>    end</p><p>-- Ein beliebiger Spieler muss Soldaten eines anderen Spielers zerstören.</p><p>-- Dieses Behavior kann auch in versteckten Quests bentutzt werden, wenn die</p><p>-- Menge an zerstörten Soldaten durch einen Feind des Spielers gefragt ist.</p><p>-- @param _PlayerA Angreifende Partei</p><p>-- @param _PlayerB Zielpartei</p><p>-- @param _Amount Menga an Soldaten</p><p>-- @within Goal</p><p>    return b_Goal_DestroySoldiers:new(...);</p><p>Goal_DestroySoldiers</p><p>    Name = "Goal_DestroySoldiers",</p><p>    Description = {</p><p>        en = "Goal: Destroy a given amount of enemy soldiers",</p><p>        de = "Ziel: Zerstöre eine Anzahl gegnerischer Soldaten",</p><p>                },</p><p>    Parameter = {</p><p>        {ParameterType.PlayerID, en = "Attacking Player", de = "Angreifer", },</p><p>        {ParameterType.PlayerID, en = "Defending Player", de = "Verteidiger", },</p><p>        {ParameterType.Number, en = "Amount", de = "Anzahl", },</p><p>    },</p><p>    return {Objective.Custom2, {self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.AttackingPlayer = _Parameter * 1</p><p>    elseif (_Index == 1) then</p><p>        self.AttackedPlayer = _Parameter * 1</p><p>    elseif (_Index == 2) then</p><p>        self.KillsNeeded = _Parameter * 1</p><p>    end</p><p>    if not _Quest.QuestDescription or _Quest.QuestDescription == "" then</p><p>        local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en"</p><p>        local caption = (lang == "de" and "SOLDATEN ZERSTÖREN {cr}{cr}von der Partei: ") or</p><p>                         "DESTROY SOLDIERS {cr}{cr}from faction: "</p><p>        local amount  = (lang == "de" and "Anzahl: ") or "Amount: "</p><p>        local party = GetPlayerName(self.AttackedPlayer) or "";</p><p>        local text = "{center}" .. caption .. party .. "{cr}{cr}" .. amount .. " "..self.KillsNeeded;</p><p>        Core:ChangeCustomQuestCaptionText(text, _Quest);</p><p>    end</p><p>    local currentKills = 0;</p><p>    if QSB.DestroyedSoldiers[self.AttackingPlayer] and QSB.DestroyedSoldiers[self.AttackingPlayer][self.AttackedPlayer] then</p><p>        currentKills = QSB.DestroyedSoldiers[self.AttackingPlayer][self.AttackedPlayer]</p><p>    end</p><p>    self.SaveAmount = self.SaveAmount or currentKills</p><p>    return self.KillsNeeded = currentKills - self.SaveAmount or nil</p><p>    if Logic.GetStoreHouse(self.AttackingPlayer) == 0 then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": Player " .. self.AttackinPlayer .. " is dead :-(")</p><p>        return true</p><p>    elseif Logic.GetStoreHouse(self.AttackedPlayer) == 0 then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": Player " .. self.AttackedPlayer .. " is dead :-(")</p><p>        return true</p><p>    elseif self.KillsNeeded  0 then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": Amount negative")</p><p>        return true</p><p>    end</p><p>    return {7,12}</p><p>    self.SaveAmount = nil</p><p>-- Eine Entfernung zwischen zwei Entities muss erreicht werden.</p><p>-- Je nach angegebener Relation muss die Entfernung unter- oder überschritten</p><p>-- werden, um den Quest zu gewinnen.</p><p>-- @param _ScriptName1  Erstes Entity</p><p>-- @param _ScriptName2  Zweites Entity</p><p>-- @param _Relation     Relation</p><p>-- @param _Distance     Entfernung</p><p>-- @within Goal</p><p>    return b_Goal_EntityDistance:new(...);</p><p>Goal_EntityDistance</p><p>    Name = "Goal_EntityDistance",</p><p>    Description = {</p><p>        en = "Goal: Distance between two entities",</p><p>        de = "Ziel: Zwei Entities sollen zueinander eine Entfernung über- oder unterschreiten.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Entity 1", de = "Entity 1" },</p><p>        { ParameterType.ScriptName, en = "Entity 2", de = "Entity 2" },</p><p>        { ParameterType.Custom, en = "Relation", de = "Relation" },</p><p>        { ParameterType.Number, en = "Distance", de = "Entfernung" },</p><p>    },</p><p>    return { Objective.Custom2, {self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.Entity1 = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.Entity2 = _Parameter</p><p>    elseif (_Index == 2) then</p><p>        self.bRelSmallerThan = _Parameter == ""</p><p>    elseif (_Index == 3) then</p><p>        self.Distance = _Parameter * 1</p><p>    end</p><p>    if Logic.IsEntityDestroyed( self.Entity1 ) or Logic.IsEntityDestroyed( self.Entity2 ) then</p><p>        return false</p><p>    end</p><p>    local ID1 = GetID( self.Entity1 )</p><p>    local ID2 = GetID( self.Entity2 )</p><p>    local InRange = Logic.CheckEntitiesDistance( ID1, ID2, self.Distance )</p><p>    if ( self.bRelSmallerThan and InRange ) or ( not self.bRelSmallerThan and not InRange ) then</p><p>        return true</p><p>    end</p><p>    local Data = {}</p><p>    if _Index == 2 then</p><p>        table.insert( Data, "" )</p><p>        table.insert( Data, "" )</p><p>    else</p><p>        assert( false )</p><p>    end</p><p>    return Data</p><p>    if not IsExisting(self.Entity1) or not IsExisting(self.Entity2) then</p><p>        fatal("".._Quest.Identifier.." "..self.Name..": At least 1 of the entities for distance check don't exist!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der Primary Knight des angegebenen Spielers muss sich dem Ziel nähern.</p><p>-- Die Distanz ist auf 2500 festgelegt. Es wird immer ein Marker genutzt.</p><p>-- @param _PlayerID   PlayerID des Helden</p><p>-- @param _ScriptName Skriptname des Ziels</p><p>-- @within Goal</p><p>    return b_Goal_KnightDistance:new(...);</p><p>Goal_KnightDistance</p><p>    Name = "Goal_KnightDistance",</p><p>    Description = {</p><p>        en = "Goal: Bring the knight close to a given entity",</p><p>        de = "Ziel: Bringe den Ritter nah an eine bestimmte Entität",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.PlayerID,     en = "Player", de = "Spieler" },</p><p>        { ParameterType.ScriptName, en = "Target", de = "Ziel" },</p><p>    },</p><p>    return {Objective.Distance, Logic.GetKnightID(self.PlayerID), self.Target, 2500, true}</p><p>    if (_Index == 0) then</p><p>        self.PlayerID = _Parameter * 1</p><p>    elseif (_Index == 1) then</p><p>        self.Target = _Parameter</p><p>    end</p><p>-- Eine bestimmte Anzahl an Einheiten einer Kategorie muss sich auf dem</p><p>-- Territorium befinden.</p><p>-- Es kann entweder gefordert werden, weniger als die angegebene Menge auf</p><p>-- dem Territorium zu haben (z.B. """ 1 für 0) oder mindestens so</p><p>-- viele Entities (z.B. "=" 5 für mindestens 5).</p><p>-- @param _Territory  TerritoryID oder TerritoryName</p><p>-- @param _PlayerID   PlayerID der Einheiten</p><p>-- @param _Category   Kategorie der Einheiten</p><p>-- @param _Relation   Mengenrelation (=)</p><p>-- @param _Amount     Menge an Einheiten</p><p>-- @within Goal</p><p>    return b_Goal_UnitsOnTerritory:new(...);</p><p>Goal_UnitsOnTerritory</p><p>    Name = "Goal_UnitsOnTerritory",</p><p>    Description = {</p><p>        en = "Goal: Place a certain amount of units on a territory",</p><p>        de = "Ziel: Platziere eine bestimmte Anzahl Einheiten auf einem Gebiet",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.TerritoryNameWithUnknown, en = "Territory", de = "Territorium" },</p><p>        { ParameterType.Custom,  en = "Player", de = "Spieler" },</p><p>        { ParameterType.Custom,  en = "Category", de = "Kategorie" },</p><p>        { ParameterType.Custom,  en = "Relation", de = "Relation" },</p><p>        { ParameterType.Number,  en = "Number of units", de = "Anzahl Einheiten" },</p><p>    },</p><p>    return { Objective.Custom2, {self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.TerritoryID = tonumber(_Parameter)</p><p>        if self.TerritoryID == nil then</p><p>            self.TerritoryID = GetTerritoryIDByName(_Parameter)</p><p>        end</p><p>    elseif (_Index == 1) then</p><p>        self.PlayerID = tonumber(_Parameter) * 1</p><p>    elseif (_Index == 2) then</p><p>        self.Category = _Parameter</p><p>    elseif (_Index == 3) then</p><p>        self.bRelSmallerThan = (tostring(_Parameter) == "true" or tostring(_Parameter) == "")</p><p>    elseif (_Index == 4) then</p><p>        self.NumberOfUnits = _Parameter * 1</p><p>    end</p><p>    local Units = GetEntitiesOfCategoryInTerritory(self.PlayerID, EntityCategories[self.Category], self.TerritoryID);</p><p>    if self.bRelSmallerThan == false and #Units = self.NumberOfUnits then</p><p>        return true;</p><p>    elseif self.bRelSmallerThan == true and #Units  self.NumberOfUnits then</p><p>        return true;</p><p>    end</p><p>    local Data = {}</p><p>    if _Index == 1 then</p><p>        table.insert( Data, -1 )</p><p>        for i = 1, 8 do</p><p>            table.insert( Data, i )</p><p>        end</p><p>    elseif _Index == 2 then</p><p>        for k, v in pairs( EntityCategories ) do</p><p>            if not string.find( k, "^G_" ) and k ~= "SheepPasture" then</p><p>                table.insert( Data, k )</p><p>            end</p><p>        end</p><p>        table.sort( Data );</p><p>    elseif _Index == 3 then</p><p>        table.insert( Data, "=" )</p><p>        table.insert( Data, "" )</p><p>    else</p><p>        assert( false )</p><p>    end</p><p>    return Data</p><p>    local territories = {Logic.GetTerritories()}</p><p>    if tonumber(self.TerritoryID) == nil or self.TerritoryID  0 or not Inside(self.TerritoryID,territories) then</p><p>        fatal("".._Quest.Identifier.." "..self.Name..": got an invalid territoryID!");</p><p>        return true;</p><p>    elseif tonumber(self.PlayerID) == nil or self.PlayerID  8 then</p><p>        fatal("".._Quest.Identifier.." "..self.Name..": got an invalid playerID!");</p><p>        return true;</p><p>    elseif not EntityCategories[self.Category] then</p><p>        fatal("".._Quest.Identifier.." "..self.Name..": got an invalid entity category!");</p><p>        return true;</p><p>    elseif tonumber(self.NumberOfUnits) == nil or self.NumberOfUnits  0 then</p><p>        fatal("".._Quest.Identifier.." "..self.Name..": amount is negative or nil!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der angegebene Spieler muss einen Buff aktivieren.</p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- @param _PlayerID Spieler, der den Buff aktivieren muss</p><p>-- @param _Buff     Buff, der aktiviert werden soll</p><p>-- @within Goal</p><p>    return b_Goal_ActivateBuff:new(...);</p><p>Goal_ActivateBuff</p><p>    Name = "Goal_ActivateBuff",</p><p>    Description = {</p><p>        en = "Goal: Activate a buff",</p><p>        de = "Ziel: Aktiviere einen Buff",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.PlayerID, en = "Player", de = "Spieler" },</p><p>        { ParameterType.Custom, en = "Buff", de = "Buff" },</p><p>    },</p><p>    return { Objective.Custom2, {self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.PlayerID = _Parameter * 1</p><p>    elseif (_Index == 1) then</p><p>        self.BuffName = _Parameter</p><p>        self.Buff = Buffs[_Parameter]</p><p>    end</p><p>   if not _Quest.QuestDescription or _Quest.QuestDescription == "" then</p><p>        local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en"</p><p>        local caption = (lang == "de" and "BONUS AKTIVIEREN{cr}{cr}") or "ACTIVATE BUFF{cr}{cr}"</p><p>        local tMapping = {</p><p>            ["Buff_Spice"]                        = {de = "Salz", en = "Salt"},</p><p>            ["Buff_Colour"]                        = {de = "Farben", en = "Color"},</p><p>            ["Buff_Entertainers"]                = {de = "Entertainer", en = "Entertainer"},</p><p>            ["Buff_FoodDiversity"]                = {de = "Vielfältige Nahrung", en = "Food diversity"},</p><p>            ["Buff_ClothesDiversity"]            = {de = "Vielfältige Kleidung", en = "Clothes diversity"},</p><p>            ["Buff_HygieneDiversity"]            = {de = "Vielfältige Reinigung", en = "Hygiene diversity"},</p><p>            ["Buff_EntertainmentDiversity"]        = {de = "Vielfältige Unterhaltung", en = "Entertainment diversity"},</p><p>            ["Buff_Sermon"]                        = {de = "Predigt", en = "Sermon"},</p><p>            ["Buff_Festival"]                    = {de = "Fest", en = "Festival"},</p><p>            ["Buff_ExtraPayment"]                = {de = "Sonderzahlung", en = "Extra payment"},</p><p>            ["Buff_HighTaxes"]                    = {de = "Hohe Steuern", en = "High taxes"},</p><p>            ["Buff_NoPayment"]                    = {de = "Kein Sold", en = "No payment"},</p><p>            ["Buff_NoTaxes"]                    = {de = "Keine Steuern", en = "No taxes"},</p><p>        }</p><p>        if g_GameExtraNo = 1 then</p><p>            tMapping["Buff_Gems"]                = {de = "Edelsteine", en = "Gems"}</p><p>            tMapping["Buff_MusicalInstrument"]  = {de = "Musikinstrumente", en = "Musical instruments"}</p><p>            tMapping["Buff_Olibanum"]            = {de = "Weihrauch", en = "Olibanum"}</p><p>        end</p><p>        local text = "{center}" .. caption .. tMapping[self.BuffName][lang]</p><p>        Core:ChangeCustomQuestCaptionText(text, _Quest)</p><p>    end</p><p>    local Buff = Logic.GetBuff( self.PlayerID, self.Buff )</p><p>    if Buff and Buff ~= 0 then</p><p>        return true</p><p>    end</p><p>    local Data = {}</p><p>    if _Index == 1 then</p><p>        Data = {</p><p>            "Buff_Spice",</p><p>            "Buff_Colour",</p><p>            "Buff_Entertainers",</p><p>            "Buff_FoodDiversity",</p><p>            "Buff_ClothesDiversity",</p><p>            "Buff_HygieneDiversity",</p><p>            "Buff_EntertainmentDiversity",</p><p>            "Buff_Sermon",</p><p>            "Buff_Festival",</p><p>            "Buff_ExtraPayment",</p><p>            "Buff_HighTaxes",</p><p>            "Buff_NoPayment",</p><p>            "Buff_NoTaxes"</p><p>        }</p><p>        if g_GameExtraNo = 1 then</p><p>            table.insert(Data, "Buff_Gems")</p><p>            table.insert(Data, "Buff_MusicalInstrument")</p><p>            table.insert(Data, "Buff_Olibanum")</p><p>        end</p><p>        table.sort( Data )</p><p>    else</p><p>        assert( false )</p><p>    end</p><p>    return Data</p><p>    local tMapping = {</p><p>        [Buffs.Buff_Spice] = "Goods.G_Salt",</p><p>        [Buffs.Buff_Colour] = "Goods.G_Dye",</p><p>        [Buffs.Buff_Entertainers] = "Entities.U_Entertainer_NA_FireEater", --{5, 12},</p><p>        [Buffs.Buff_FoodDiversity] = "Needs.Nutrition", --{1, 1},</p><p>        [Buffs.Buff_ClothesDiversity] = "Needs.Clothes", --{1, 2},</p><p>        [Buffs.Buff_HygieneDiversity] = "Needs.Hygiene", --{16, 1},</p><p>        [Buffs.Buff_EntertainmentDiversity] = "Needs.Entertainment", --{1, 4},</p><p>        [Buffs.Buff_Sermon] = "Technologies.R_Sermon", --{4, 14},</p><p>        [Buffs.Buff_Festival] = "Technologies.R_Festival", --{4, 15},</p><p>        [Buffs.Buff_ExtraPayment]    = {1,8},</p><p>        [Buffs.Buff_HighTaxes] = {1,6},</p><p>        [Buffs.Buff_NoPayment] = {1,8},</p><p>        [Buffs.Buff_NoTaxes]    = {1,6},</p><p>    }</p><p>    if g_GameExtraNo and g_GameExtraNo = 1 then</p><p>        tMapping[Buffs.Buff_Gems] = "Goods.G_Gems"</p><p>        tMapping[Buffs.Buff_MusicalInstrument] = "Goods.G_MusicalInstrument"</p><p>        tMapping[Buffs.Buff_Olibanum] = "Goods.G_Olibanum"</p><p>    end</p><p>    return tMapping[self.Buff]</p><p>    if not self.Buff then</p><p>        fatal("".._Quest.Identifier.." "..self.Name..": buff '" ..self.BuffName.. "' does not exist!");</p><p>        return true;</p><p>    elseif not tonumber(self.PlayerID) or self.PlayerID  8 then</p><p>        fatal("".._Quest.Identifier.." "..self.Name..": got an invalid playerID!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Zwei Punkte auf der Spielwelt müssen mit einer Straße verbunden werden.</p><p>-- @param _Position1 Erster Endpunkt der Straße</p><p>-- @param _Position2 Zweiter Endpunkt der Straße</p><p>-- @param _OnlyRoads Keine Wege akzeptieren</p><p>-- @within Goal</p><p>    return b_Goal_BuildRoad:new(...)</p><p>Goal_BuildRoad</p><p>    Name = "Goal_BuildRoad",</p><p>    Description = {</p><p>        en = "Goal: Connect two points with a street or a road",</p><p>        de = "Ziel: Verbinde zwei Punkte mit einer Strasse oder einem Weg.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Entity 1",     de = "Entity 1" },</p><p>        { ParameterType.ScriptName, en = "Entity 2",     de = "Entity 2" },</p><p>        { ParameterType.Custom,     en = "Only roads",     de = "Nur Strassen" },</p><p>    },</p><p>    -- {BehaviorType, {EntityID1, EntityID2, BeSmalerThan, Length, RoadsOnly}}</p><p>    -- - Length wird nicht mehr benutzt. Sorgte für Promleme im Spiel</p><p>    return { Objective.BuildRoad, { GetID( self.Entity1 ), GetID( self.Entity2 ), false, 0, self.bRoadsOnly } }</p><p>    if (_Index == 0) then</p><p>        self.Entity1 = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.Entity2 = _Parameter</p><p>    elseif (_Index == 2) then</p><p>        self.bRoadsOnly = AcceptAlternativeBoolean(_Parameter)</p><p>    end</p><p>    local Data</p><p>    if _Index == 2 then</p><p>        Data = {"true","false"}</p><p>    end</p><p>    return Data</p><p>    if not IsExisting(self.Entity1) or not IsExisting(self.Entity2) then</p><p>        fatal("".._Quest.Identifier.." "..self.Name..": first or second entity does not exist!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Eine Mauer muss gebaut werden um die Bewegung eines Spielers einzuschränken.</p><p>-- </p><p>-- Einschränken bedeutet, dass sich der angegebene Spieler nicht von Punkt A</p><p>-- nach Punkt B bewegen kann, weil eine Mauer im Weg ist. Die Punkte sind</p><p>-- frei wählbar. In den meisten Fällen reicht es, Marktplätze anzugeben.</p><p>-- Beispiel: Spieler 3 ist der Feind von Spieler 1, aber Bekannt mit Spieler 2.</p><p>-- Wenn er sich nicht mehr zwischen den Marktplätzen von Spieler 1 und 2</p><p>-- bewegen kann, weil eine Mauer dazwischen ist, ist das Ziel erreicht.</p><p>--  Bei Monsun kann dieses Ziel fälschlicher Weise als erfüllt</p><p>-- gewertet werden, wenn der Weg durch Wasser blockiert wird!</p><p>-- @param _PlayerID  PlayerID, die blockiert wird</p><p>-- @param _Position1 Erste Position</p><p>-- @param _Position2 Zweite Position</p><p>-- @within Goal</p><p>    return b_Goal_BuildWall:new(...)</p><p>Goal_BuildWall</p><p>    Name = "Goal_BuildWall",</p><p>    Description = {</p><p>        en = "Goal: Build a wall between 2 positions bo stop the movement of an (hostile) player.",</p><p>        de = "Ziel: Baue eine Mauer zwischen 2 Punkten, die die Bewegung eines (feindlichen) Spielers zwischen den Punkten verhindert.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.PlayerID, en = "Enemy", de = "Feind" },</p><p>        { ParameterType.ScriptName, en = "Entity 1", de = "Entity 1" },</p><p>        { ParameterType.ScriptName, en = "Entity 2", de = "Entity 2" },</p><p>    },</p><p>    return { Objective.Custom2, {self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.PlayerID = _Parameter * 1</p><p>    elseif (_Index == 1) then</p><p>        self.EntityName1 = _Parameter</p><p>    elseif (_Index == 2) then</p><p>        self.EntityName2 = _Parameter</p><p>    end</p><p>    local eID1 = GetID(self.EntityName1)</p><p>    local eID2 = GetID(self.EntityName2)</p><p>    if not IsExisting(eID1) then</p><p>        return false</p><p>    end</p><p>    if not IsExisting(eID2) then</p><p>        return false</p><p>    end</p><p>    local x,y,z = Logic.EntityGetPos(eID1)</p><p>    if Logic.IsBuilding(eID1) == 1 then</p><p>        x,y = Logic.GetBuildingApproachPosition(eID1)</p><p>    end</p><p>    local Sector1 = Logic.GetPlayerSectorAtPosition(self.PlayerID, x, y)</p><p>    local x,y,z = Logic.EntityGetPos(eID2)</p><p>    if Logic.IsBuilding(eID2) == 1 then</p><p>        x,y = Logic.GetBuildingApproachPosition(eID2)</p><p>    end</p><p>    local Sector2 = Logic.GetPlayerSectorAtPosition(self.PlayerID, x, y)</p><p>    if Sector1 ~= Sector2 then</p><p>        return true</p><p>    end</p><p>    return nil</p><p>    return "Quest_Create_Wall"</p><p>    return {3,9}</p><p>    if not IsExisting(self.EntityName1) or not IsExisting(self.EntityName2) then</p><p>        fatal("".._Quest.Identifier.." "..self.Name..": first or second entity does not exist!");</p><p>        return true;</p><p>    elseif not tonumber(self.PlayerID) or self.PlayerID  8 then</p><p>        fatal("".._Quest.Identifier.." "..self.Name..": got an invalid playerID!");</p><p>        return true;</p><p>    end</p><p>    if GetDiplomacyState(_Quest.ReceivingPlayer, self.PlayerID)  -1 and not self.WarningPrinted then</p><p>        warn("".._Quest.Identifier.." "..self.Name..": player d is neighter enemy or unknown to quest receiver!");</p><p>        self.WarningPrinted = true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ein bestimmtes Territorium muss vom Auftragnehmer eingenommen werden.</p><p>-- @param _Territory Territorium-ID oder Territoriumname</p><p>-- @within Goal</p><p>    return b_Goal_Claim:new(...)</p><p>Goal_Claim</p><p>    Name = "Goal_Claim",</p><p>    Description = {</p><p>        en = "Goal: Claim a territory",</p><p>        de = "Ziel: Erobere ein Territorium",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.TerritoryName, en = "Territory", de = "Territorium" },</p><p>    },</p><p>    return { Objective.Claim, 1, self.TerritoryID }</p><p>    if (_Index == 0) then</p><p>        self.TerritoryID = tonumber(_Parameter)</p><p>        if not self.TerritoryID then</p><p>            self.TerritoryID = GetTerritoryIDByName(_Parameter)</p><p>        end</p><p>    end</p><p>    return "Quest_Claim_Territory"</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der Auftragnehmer muss eine Menge an Territorien besitzen.</p><p>-- Das Heimatterritorium des Spielers wird mitgezählt!</p><p>-- @param _Amount Anzahl Territorien</p><p>-- @within Goal</p><p>    return b_Goal_ClaimXTerritories:new(...)</p><p>Goal_ClaimXTerritories</p><p>    Name = "Goal_ClaimXTerritories",</p><p>    Description = {</p><p>        en = "Goal: Claim the given number of territories, all player territories are counted",</p><p>        de = "Ziel: Erobere die angegebene Anzahl Territorien, alle spielereigenen Territorien werden gezählt",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Number, en = "Territories" , de = "Territorien" }</p><p>    },</p><p>    return { Objective.Claim, 2, self.TerritoriesToClaim }</p><p>    if (_Index == 0) then</p><p>        self.TerritoriesToClaim = _Parameter * 1</p><p>    end</p><p>    return "Quest_Claim_Territory"</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der Auftragnehmer muss auf dem Territorium einen Entitytyp erstellen.</p><p>-- Dieses Behavior eignet sich für Aufgaben vom Schlag "Baue X Getreidefarmen</p><p>-- Auf Territorium ".</p><p>-- @param _Type      Typ des Entity</p><p>-- @param _Amount    Menge an Entities</p><p>-- @param _Territory Territorium</p><p>-- @within Goal</p><p>    return b_Goal_Create:new(...);</p><p>Goal_Create</p><p>    Name = "Goal_Create",</p><p>    Description = {</p><p>        en = "Goal: Create Buildings/Units on a specified territory",</p><p>        de = "Ziel: Erstelle Einheiten/Gebäude auf einem bestimmten Territorium.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Entity, en = "Type name", de = "Typbezeichnung" },</p><p>        { ParameterType.Number, en = "Amount", de = "Anzahl" },</p><p>        { ParameterType.TerritoryNameWithUnknown, en = "Territory", de = "Territorium" },</p><p>    },</p><p>    return { Objective.Create, assert( Entities[self.EntityName] ), self.Amount, self.TerritoryID  }</p><p>    if (_Index == 0) then</p><p>        self.EntityName = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.Amount = _Parameter * 1</p><p>    elseif (_Index == 2) then</p><p>        self.TerritoryID = tonumber(_Parameter)</p><p>        if not self.TerritoryID then</p><p>            self.TerritoryID = GetTerritoryIDByName(_Parameter)</p><p>        end</p><p>    end</p><p>    return Logic.IsEntityTypeInCategory( Entities[self.EntityName], EntityCategories.AttackableBuilding ) == 1 and "Quest_Create_Building" or "Quest_Create_Unit"</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der Auftragnehmer muss eine Menge von Rohstoffen produzieren.</p><p>-- @param _Type   Typ des Rohstoffs</p><p>-- @param _Amount Menge an Rohstoffen</p><p>-- @within Goal</p><p>    return b_Goal_Produce:new(...);</p><p>Goal_Produce</p><p>    Name = "Goal_Produce",</p><p>    Description = {</p><p>        en = "Goal: Produce an amount of goods",</p><p>        de = "Ziel: Produziere eine Anzahl einer bestimmten Ware.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.RawGoods, en = "Type of good", de = "Ressourcentyp" },</p><p>        { ParameterType.Number, en = "Amount of good", de = "Anzahl der Ressource" },</p><p>    },</p><p>    local GoodType = Logic.GetGoodTypeID(self.GoodTypeName)</p><p>    return { Objective.Produce, GoodType, self.GoodAmount }</p><p>    if (_Index == 0) then</p><p>        self.GoodTypeName = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.GoodAmount = _Parameter * 1</p><p>    end</p><p>    return "Quest_Produce"</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der Spieler muss eine bestimmte Menge einer Ware erreichen.</p><p>-- @param _Type     Typ der Ware</p><p>-- @param _Amount   Menge an Waren</p><p>-- @param _Relation Mengenrelation</p><p>-- @within Goal</p><p>    return b_Goal_GoodAmount:new(...);</p><p>Goal_GoodAmount</p><p>    Name = "Goal_GoodAmount",</p><p>    Description = {</p><p>        en = "Goal: Obtain an amount of goods - either by trading or producing them",</p><p>        de = "Ziel: Beschaffe eine Anzahl Waren - entweder durch Handel oder durch eigene Produktion.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Custom, en = "Type of good", de = "Warentyp" },</p><p>        { ParameterType.Number, en = "Amount", de = "Anzahl" },</p><p>        { ParameterType.Custom, en = "Relation", de = "Relation" },</p><p>    },</p><p>    local GoodType = Logic.GetGoodTypeID(self.GoodTypeName)</p><p>    return { Objective.Produce, GoodType, self.GoodAmount, self.bRelSmallerThan }</p><p>    if (_Index == 0) then</p><p>        self.GoodTypeName = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.GoodAmount = _Parameter * 1</p><p>    elseif  (_Index == 2) then</p><p>        self.bRelSmallerThan = _Parameter == "" or tostring(_Parameter) == "true"</p><p>    end</p><p>    local Data = {}</p><p>    if _Index == 0 then</p><p>        for k, v in pairs( Goods ) do</p><p>            if string.find( k, "^G_" ) then</p><p>                table.insert( Data, k )</p><p>            end</p><p>        end</p><p>        table.sort( Data )</p><p>    elseif _Index == 2 then</p><p>        table.insert( Data, "=" )</p><p>        table.insert( Data, "" )</p><p>    else</p><p>        assert( false )</p><p>    end</p><p>    return Data</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Die Siedler des Spielers dürfen nicht aufgrund des Bedürfnisses streiken.</p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- @param _PlayerID ID des Spielers</p><p>-- @param _Need     Bedürfnis</p><p>-- @within Goal</p><p>    return b_Goal_SatisfyNeed:new(...);</p><p>Goal_SatisfyNeed</p><p>    Name = "Goal_SatisfyNeed",</p><p>    Description = {</p><p>        en = "Goal: Satisfy a need",</p><p>        de = "Ziel: Erfuelle ein Beduerfnis",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.PlayerID, en = "Player", de = "Spieler" },</p><p>        { ParameterType.Need, en = "Need", de = "Beduerfnis" },</p><p>    },</p><p>    return { Objective.SatisfyNeed, Needs[self.Need], self.PlayerID }</p><p>    if (_Index == 0) then</p><p>        self.PlayerID = _Parameter * 1</p><p>    elseif (_Index == 1) then</p><p>        self.Need = _Parameter</p><p>    end</p><p>    local tMapping = {</p><p>        [Needs.Clothes] = "Quest_SatisfyNeed_Clothes",</p><p>        [Needs.Entertainment] = "Quest_SatisfyNeed_Entertainment",</p><p>        [Needs.Nutrition] = "Quest_SatisfyNeed_Food",</p><p>        [Needs.Hygiene] = "Quest_SatisfyNeed_Hygiene",</p><p>        [Needs.Medicine] = "Quest_SatisfyNeed_Medicine",</p><p>    }</p><p>    local Key = tMapping[Needs[self.Need]]</p><p>    if Key then</p><p>        return Key</p><p>    end</p><p>    -- No default message</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der angegebene Spieler muss eine Menge an Siedlern in der Stadt haben.</p><p>-- @param _Amount   Menge an Siedlern</p><p>-- @param _PlayerID ID des Spielers</p><p>-- @within Goal</p><p>    return b_Goal_SettlersNumber:new(...);</p><p>Goal_SettlersNumber</p><p>    Name = "Goal_SettlersNumber",</p><p>    Description = {</p><p>        en = "Goal: Get a given amount of settlers",</p><p>        de = "Ziel: Erreiche eine bestimmte Anzahl Siedler.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Number,   en = "Amount", de = "Anzahl" },</p><p>        { ParameterType.PlayerID, en = "Player", de = "Spieler" },</p><p>    },</p><p>    return {Objective.SettlersNumber, self.PlayerID, self.SettlersAmount };</p><p>    if (_Index == 0) then</p><p>        self.SettlersAmount = _Parameter * 1;</p><p>    elseif (_Index == 1) then</p><p>        self.PlayerID = (_Parameter or 1) * 1;</p><p>    end</p><p>    return "Quest_NumberSettlers";</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der Auftragnehmer muss eine Menge von Ehefrauen in der Stadt haben.</p><p>-- @param _Amount Menge an Ehefrauen</p><p>-- @within Goal</p><p>    return b_Goal_Spouses:new(...);</p><p>Goal_Spouses</p><p>    Name = "Goal_Spouses",</p><p>    Description = {</p><p>        en = "Goal: Get a given amount of spouses",</p><p>        de = "Ziel: Erreiche eine bestimmte Ehefrauenanzahl",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Number, en = "Amount", de = "Anzahl" },</p><p>    },</p><p>    return {Objective.Spouses, self.SpousesAmount }</p><p>    if (_Index == 0) then</p><p>        self.SpousesAmount = _Parameter * 1</p><p>    end</p><p>    return "Quest_NumberSpouses"</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ein Spieler muss eine Menge an Soldaten haben.</p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- Dieses Behavior kann verwendet werden um die Menge an feindlichen</p><p>-- Soldaten zu zählen oder die Menge an Soldaten des Spielers.</p><p>-- @param _PlayerID ID des Spielers</p><p>-- @param _Relation Mengenrelation</p><p>-- @param _Amount   Menge an Soldaten</p><p>-- @within Goal</p><p>    return b_Goal_SoldierCount:new(...);</p><p>Goal_SoldierCount</p><p>    Name = "Goal_SoldierCount",</p><p>    Description = {</p><p>        en = "Goal: Create a specified number of soldiers",</p><p>        de = "Ziel: Erreiche eine Anzahl grösser oder kleiner der angegebenen Menge Soldaten.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.PlayerID, en = "Player", de = "Spieler" },</p><p>        { ParameterType.Custom, en = "Relation", de = "Relation" },</p><p>        { ParameterType.Number, en = "Number of soldiers", de = "Anzahl Soldaten" },</p><p>    },</p><p>    return { Objective.Custom2, {self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.PlayerID = _Parameter * 1</p><p>    elseif (_Index == 1) then</p><p>        self.bRelSmallerThan = tostring(_Parameter) == "true" or tostring(_Parameter) == ""</p><p>    elseif (_Index == 2) then</p><p>        self.NumberOfUnits = _Parameter * 1</p><p>    end</p><p>    if not _Quest.QuestDescription or _Quest.QuestDescription == "" then</p><p>        local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en"</p><p>        local caption = (lang == "de" and "SOLDATENANZAHL {cr}Partei: ") or</p><p>                            "SOLDIERS {cr}faction: "</p><p>        local relation = tostring(self.bRelSmallerThan);</p><p>        local relationText = {</p><p>            ["true"]  = {de = "Weniger als", en = "Less than"},</p><p>            ["false"] = {de = "Mindestens", en = "At least"},</p><p>        };</p><p>        local party = GetPlayerName(self.PlayerID) or "";</p><p>        local text = "{center}" .. caption .. party .. "{cr}{cr}" .. relationText[relation][lang] .. " "..self.NumberOfUnits;</p><p>        Core:ChangeCustomQuestCaptionText(text, _Quest);</p><p>    end</p><p>    local NumSoldiers = Logic.GetCurrentSoldierCount( self.PlayerID )</p><p>    if ( self.bRelSmallerThan and NumSoldiers  self.NumberOfUnits ) then</p><p>        return true</p><p>    elseif ( not self.bRelSmallerThan and NumSoldiers = self.NumberOfUnits ) then</p><p>        return true</p><p>    end</p><p>    return nil</p><p>    local Data = {}</p><p>    if _Index == 1 then</p><p>        table.insert( Data, "=" )</p><p>        table.insert( Data, "" )</p><p>    else</p><p>        assert( false )</p><p>    end</p><p>    return Data</p><p>    return {7,11}</p><p>    return "Quest_Create_Unit"</p><p>    if tonumber(self.NumberOfUnits) == nil or self.NumberOfUnits  0 then</p><p>        fatal("".._Quest.Identifier.." "..self.Name..": amount can not be below 0!");</p><p>        return true;</p><p>    elseif tonumber(self.PlayerID) == nil or self.PlayerID  8 then</p><p>        fatal("".._Quest.Identifier.." "..self.Name..": got an invalid playerID!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der Auftragnehmer muss wenigstens einen bestimmten Titel erreichen.</p><p>-- Folgende Titel können verwendet werden:</p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- @param _Title Titel, der erreicht werden muss</p><p>-- @within Goal</p><p>    return b_Goal_KnightTitle:new(...);</p><p>Goal_KnightTitle</p><p>    Name = "Goal_KnightTitle",</p><p>    Description = {</p><p>        en = "Goal: Reach a specified knight title",</p><p>        de = "Ziel: Erreiche einen vorgegebenen Titel",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Custom, en = "Knight title", de = "Titel" },</p><p>    },</p><p>    return {Objective.KnightTitle, assert( KnightTitles[self.KnightTitle] ) }</p><p>    if (_Index == 0) then</p><p>        self.KnightTitle = _Parameter</p><p>    end</p><p>    return "Quest_KnightTitle"</p><p>    return {"Knight", "Mayor", "Baron", "Earl", "Marquees", "Duke", "Archduke"}</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der angegebene Spieler muss mindestens die Menge an Festen feiern.</p><p>-- Ein Fest wird gewertet, sobald die Metfässer auf dem Markt erscheinen. Diese</p><p>-- Metfässer erscheinen im normalen Spielverlauf nur durch ein Fest!</p><p>-- : Wenn ein Spieler aus einem anderen Grund Metfässer besitzt,</p><p>-- wird dieses Behavior nicht mehr richtig funktionieren!</p><p>-- @param _PlayerID ID des Spielers</p><p>-- @param _Amount   Menge an Festen</p><p>-- @within Goal</p><p>    return b_Goal_Festivals:new(...);</p><p>Goal_Festivals</p><p>    Name = "Goal_Festivals",</p><p>    Description = {</p><p>        en = "Goal: The player has to start the given number of festivals.",</p><p>        de = "Ziel: Der Spieler muss eine gewisse Anzahl Feste gestartet haben.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.PlayerID, en = "Player", de = "Spieler" },</p><p>        { ParameterType.Number, en = "Number of festivals", de = "Anzahl Feste" }</p><p>    }</p><p>    return { Objective.Custom2, {self, self.CustomFunction} };</p><p>    if _Index == 0 then</p><p>        self.PlayerID = tonumber(_Parameter);</p><p>    else</p><p>        assert(_Index == 1, "Error in " .. self.Name .. ": AddParameter: Index is invalid.");</p><p>        self.NeededFestivals = tonumber(_Parameter);</p><p>    end</p><p>    if not _Quest.QuestDescription or _Quest.QuestDescription == "" then</p><p>        local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en"</p><p>        local caption = (lang == "de" and "FESTE FEIERN {cr}{cr}Partei: ") or</p><p>                            "HOLD PARTIES {cr}{cr}faction: "</p><p>        local amount  = (lang == "de" and "Anzahl: ") or "Amount: "</p><p>        local party = GetPlayerName(self.PlayerID) or "";</p><p>        local text = "{center}" .. caption .. party .. "{cr}{cr}" .. amount .. " "..self.NeededFestivals;</p><p>        Core:ChangeCustomQuestCaptionText(text, _Quest);</p><p>    end</p><p>    if Logic.GetStoreHouse( self.PlayerID ) == 0  then</p><p>        return false</p><p>    end</p><p>    local tablesOnFestival = {Logic.GetPlayerEntities(self.PlayerID, Entities.B_TableBeer, 5,0)}</p><p>    local amount = 0</p><p>    for k=2, #tablesOnFestival do</p><p>        local tableID = tablesOnFestival[k]</p><p>        if Logic.GetIndexOnOutStockByGoodType(tableID, Goods.G_Beer) ~= -1 then</p><p>            local goodAmountOnMarketplace = Logic.GetAmountOnOutStockByGoodType(tableID, Goods.G_Beer)</p><p>            amount = amount + goodAmountOnMarketplace</p><p>        end</p><p>    end</p><p>    if not self.FestivalStarted and amount  0 then</p><p>        self.FestivalStarted = true</p><p>        self.FestivalCounter = (self.FestivalCounter and self.FestivalCounter + 1) or 1</p><p>        if self.FestivalCounter = self.NeededFestivals then</p><p>            self.FestivalCounter = nil</p><p>            return true</p><p>        end</p><p>    elseif amount == 0 then</p><p>        self.FestivalStarted = false</p><p>    end</p><p>    if Logic.GetStoreHouse( self.PlayerID ) == 0 then</p><p>        fatal(_Quest.Identifier .. ": Error in " .. self.Name .. ": Player " .. self.PlayerID .. " is dead :-(")</p><p>        return true</p><p>    elseif GetPlayerCategoryType(self.PlayerID) ~= PlayerCategories.City then</p><p>        fatal(_Quest.Identifier .. ": Error in " .. self.Name .. ":  Player "..  self.PlayerID .. " is no city")</p><p>        return true</p><p>    elseif self.NeededFestivals  0 then</p><p>        fatal(_Quest.Identifier .. ": Error in " .. self.Name .. ": Number of Festivals is negative")</p><p>        return true</p><p>    end</p><p>    return false</p><p>    self.FestivalCounter = nil</p><p>    self.FestivalStarted = nil</p><p>    return {4,15}</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der Auftragnehmer muss eine Einheit gefangen nehmen.</p><p>-- @param _ScriptName Ziel</p><p>-- @within Goal</p><p>    return b_Goal_Capture:new(...)</p><p>Goal_Capture</p><p>    Name = "Goal_Capture",</p><p>    Description = {</p><p>        en = "Goal: Capture a cart.",</p><p>        de = "Ziel: Ein Karren muss erobert werden.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Script name", de = "Skriptname" },</p><p>    },</p><p>    return { Objective.Capture, 1, { self.ScriptName } }</p><p>    if (_Index == 0) then</p><p>        self.ScriptName = _Parameter</p><p>    end</p><p>   local ID = GetID(self.ScriptName)</p><p>   if Logic.IsEntityAlive(ID) then</p><p>        ID = Logic.GetEntityType( ID )</p><p>        if ID and ID ~= 0 then</p><p>            if Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableMerchant ) == 1 then</p><p>                return "Quest_Capture_Cart"</p><p>            elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.SiegeEngine ) == 1 then</p><p>                return "Quest_Capture_SiegeEngine"</p><p>            elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.Worker ) == 1</p><p>                or Logic.IsEntityTypeInCategory( ID, EntityCategories.Spouse ) == 1</p><p>                or Logic.IsEntityTypeInCategory( ID, EntityCategories.Hero ) == 1 then</p><p>                return "Quest_Capture_VIPOfPlayer"</p><p>            end</p><p>        end</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der Auftragnehmer muss eine Menge von Einheiten eines Typs von einem</p><p>-- Spieler gefangen nehmen.</p><p>-- @param _Typ      Typ, der gefangen werden soll</p><p>-- @param _Amount   Menge an Einheiten</p><p>-- @param _PlayerID Besitzer der Einheiten</p><p>-- @within Goal</p><p>    return b_Goal_CaptureType:new(...)</p><p>Goal_CaptureType</p><p>    Name = "Goal_CaptureType",</p><p>    Description = {</p><p>        en = "Goal: Capture specified entity types",</p><p>        de = "Ziel: Nimm bestimmte Entitätstypen gefangen",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Custom,     en = "Type name", de = "Typbezeichnung" },</p><p>        { ParameterType.Number,     en = "Amount", de = "Anzahl" },</p><p>        { ParameterType.PlayerID,     en = "Player", de = "Spieler" },</p><p>    },</p><p>    return { Objective.Capture, 2, Entities[self.EntityName], self.Amount, self.PlayerID }</p><p>    if (_Index == 0) then</p><p>        self.EntityName = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.Amount = _Parameter * 1</p><p>    elseif (_Index == 2) then</p><p>        self.PlayerID = _Parameter * 1</p><p>    end</p><p>    local Data = {}</p><p>    if _Index == 0 then</p><p>        for k, v in pairs( Entities ) do</p><p>            if string.find( k, "^U_.+Cart" ) or Logic.IsEntityTypeInCategory( v, EntityCategories.AttackableMerchant ) == 1 then</p><p>                table.insert( Data, k )</p><p>            end</p><p>        end</p><p>        table.sort( Data )</p><p>    elseif _Index == 2 then</p><p>        for i = 0, 8 do</p><p>            table.insert( Data, i )</p><p>        end</p><p>    else</p><p>        assert( false )</p><p>    end</p><p>    return Data</p><p>    local ID = self.EntityName</p><p>    if Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableMerchant ) == 1 then</p><p>        return "Quest_Capture_Cart"</p><p>    elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.SiegeEngine ) == 1 then</p><p>        return "Quest_Capture_SiegeEngine"</p><p>    elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.Worker ) == 1</p><p>        or Logic.IsEntityTypeInCategory( ID, EntityCategories.Spouse ) == 1</p><p>        or Logic.IsEntityTypeInCategory( ID, EntityCategories.Hero ) == 1 then</p><p>        return "Quest_Capture_VIPOfPlayer"</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der Auftragnehmer muss das angegebene Entity beschützen.</p><p>-- Wird ein Wagen zerstört oder in das Lagerhaus / die Burg eines Feindes</p><p>-- gebracht, schlägt das Ziel fehl.</p><p>-- @param _ScriptName Zu beschützendes Entity</p><p>-- @within Goal</p><p>    return b_Goal_Protect:new(...)</p><p>Goal_Protect</p><p>    Name = "Goal_Protect",</p><p>    Description = {</p><p>        en = "Goal: Protect an entity (entity needs a script name",</p><p>        de = "Ziel: Beschütze eine Entität (Entität benötigt einen Skriptnamen)",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Script name", de = "Skriptname" },</p><p>    },</p><p>    return {Objective.Protect, { self.ScriptName }}</p><p>    if (_Index == 0) then</p><p>        self.ScriptName = _Parameter</p><p>    end</p><p>    if Logic.IsEntityAlive(self.ScriptName) then</p><p>        local ID = GetID(self.ScriptName)</p><p>        if ID and ID ~= 0 then</p><p>            ID = Logic.GetEntityType( ID )</p><p>            if ID and ID ~= 0 then</p><p>                if Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableBuilding ) == 1 then</p><p>                    return "Quest_Protect_Building"</p><p>                elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.SpecialBuilding ) == 1 then</p><p>                    local tMapping = {</p><p>                        [PlayerCategories.City]        = "Quest_Protect_City",</p><p>                        [PlayerCategories.Cloister]    = "Quest_Protect_Cloister",</p><p>                        [PlayerCategories.Village]    = "Quest_Protect_Village",</p><p>                    }</p><p>                    local PlayerCategory = GetPlayerCategoryType( Logic.EntityGetPlayer(GetID(self.ScriptName)) )</p><p>                    if PlayerCategory then</p><p>                        local Key = tMapping[PlayerCategory]</p><p>                        if Key then</p><p>                            return Key</p><p>                        end</p><p>                    end</p><p>                    return "Quest_Protect_Building"</p><p>                elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.Hero ) == 1 then</p><p>                    return "Quest_Protect_Knight"</p><p>                elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableMerchant ) == 1 then</p><p>                    return "Quest_Protect_Cart"</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>    return "Quest_Protect"</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der Auftragnehmer muss eine Mine mit einem Geologen wieder auffüllen.</p><p>-- : Dieses Behavior ist nur in "Reich des Ostens" verfügbar.</p><p>-- @param _ScriptName Skriptname der Mine</p><p>-- @within Goal</p><p>    return b_Goal_Refill:new(...)</p><p>Goal_Refill</p><p>    Name = "Goal_Refill",</p><p>    Description = {</p><p>        en = "Goal: Refill an object using a geologist",</p><p>        de = "Ziel: Eine Mine soll durch einen Geologen wieder aufgefuellt werden.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Script name", de = "Skriptname" },</p><p>    },</p><p>   RequiresExtraNo = 1,</p><p>    return { Objective.Refill, { GetID(self.ScriptName) } }</p><p>    return {8,1,1}</p><p>    if (_Index == 0) then</p><p>        self.ScriptName = _Parameter</p><p>    end</p><p>    Core:RegisterBehavior(b_Goal_Refill);</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Eine bestimmte Menge an Rohstoffen in einer Mine muss erreicht werden.</p><p>-- Dieses Behavior eignet sich besonders für den Einsatz als versteckter</p><p>-- Quest um eine Reaktion auszulösen, wenn z.B. eine Mine leer ist.</p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- @param _ScriptName Skriptname der Mine</p><p>-- @param _Relation   Mengenrelation</p><p>-- @param _Amount     Menge an Rohstoffen</p><p>-- @within Goal</p><p>    return b_Goal_ResourceAmount:new(...)</p><p>Goal_ResourceAmount</p><p>    Name = "Goal_ResourceAmount",</p><p>    Description = {</p><p>        en = "Goal: Reach a specified amount of resources in a doodad",</p><p>        de = "Ziel: In einer Mine soll weniger oder mehr als eine angegebene Anzahl an Rohstoffen sein.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Script name", de = "Skriptname" },</p><p>        { ParameterType.Custom, en = "Relation", de = "Relation" },</p><p>        { ParameterType.Number, en = "Amount", de = "Menge" },</p><p>    },</p><p>    return { Objective.Custom2, {self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.ScriptName = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.bRelSmallerThan = _Parameter == ""</p><p>    elseif (_Index == 2) then</p><p>        self.Amount = _Parameter * 1</p><p>    end</p><p>    local ID = GetID(self.ScriptName)</p><p>    if ID and ID ~= 0 and Logic.GetResourceDoodadGoodType(ID) ~= 0 then</p><p>        local HaveAmount = Logic.GetResourceDoodadGoodAmount(ID)</p><p>        if ( self.bRelSmallerThan and HaveAmount = self.Amount ) then</p><p>            return true</p><p>        end</p><p>    end</p><p>    return nil</p><p>    local Data = {}</p><p>    if _Index == 1 then</p><p>        table.insert( Data, "=" )</p><p>        table.insert( Data, "" )</p><p>    else</p><p>        assert( false )</p><p>    end</p><p>    return Data</p><p>    if not IsExisting(self.ScriptName) then</p><p>        fatal("".._Quest.Identifier.." "..self.Name..": entity '" ..self.ScriptName.. "' does not exist!");</p><p>        return true;</p><p>    elseif tonumber(self.Amount) == nil or self.Amount  0 then</p><p>        fatal("".._Quest.Identifier.." "..self.Name..": error at amount! (nil or below 0)");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der Quest schlägt sofort fehl.</p><p>-- @within Goal</p><p>    return b_Goal_InstantFailure:new()</p><p>Goal_InstantFailure</p><p>    Name = "Goal_InstantFailure",</p><p>    Description = {</p><p>        en = "Instant failure, the goal returns false.",</p><p>        de = "Direkter Misserfolg, das Goal sendet false.",</p><p>    },</p><p>    return {Objective.DummyFail};</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der Quest wird sofort erfüllt.</p><p>-- @within Goal</p><p>    return b_Goal_InstantSuccess:new()</p><p>Goal_InstantSuccess</p><p>    Name = "Goal_InstantSuccess",</p><p>    Description = {</p><p>        en = "Instant success, the goal returns true.",</p><p>        de = "Direkter Erfolg, das Goal sendet true.",</p><p>    },</p><p>    return {Objective.Dummy};</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der Zustand des Quests ändert sich niemals</p><p>-- Wenn ein Zeitlimit auf dem Quest liegt, wird dieses Behavior nicht</p><p>-- fehlschlagen sondern automatisch erfüllt.</p><p>-- @within Goal</p><p>    return b_Goal_NoChange:new()</p><p>Goal_NoChange</p><p>    Name = "Goal_NoChange",</p><p>    Description = {</p><p>        en = "The quest state doesn't change. Use reward functions of other quests to change the state of this quest.",</p><p>        de = "Der Questzustand wird nicht verändert. Ein Reward einer anderen Quest sollte den Zustand dieser Quest verändern.",</p><p>    },</p><p>    return { Objective.NoChange }</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Führt eine Funktion im Skript als Goal aus.</p><p>-- Die Funktion muss entweder true, false oder nichts zurückgeben.</p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- Anstelle eines Strings kann beim Einsatz im Skript eine Funktionsreferenz</p><p>-- übergeben werden. In diesem Fall werden alle weiteren Parameter direkt an</p><p>-- die Funktion weitergereicht.</p><p>-- @param _FunctionName Name der Funktion</p><p>-- @within Goal</p><p>    return b_Goal_MapScriptFunction:new(...);</p><p>Goal_MapScriptFunction</p><p>    Name = "Goal_MapScriptFunction",</p><p>    Description = {</p><p>        en = "Goal: Calls a function within the global map script. Return 'true' means success, 'false' means failure and 'nil' doesn't change anything.",</p><p>        de = "Ziel: Ruft eine Funktion im globalen Skript auf, die einen Wahrheitswert zurueckgibt. Rueckgabe 'true' gilt als erfuellt, 'false' als gescheitert und 'nil' ändert nichts.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Default, en = "Function name", de = "Funktionsname" },</p><p>    },</p><p>    return {Objective.Custom2, {self, self.CustomFunction}};</p><p>    if (_Index == 0) then</p><p>        self.FuncName = _Parameter</p><p>    end</p><p>    if type(self.FuncName) == "function" then</p><p>        return self.Function(unpack(self.i47ya_6aghw_frxil));</p><p>    end</p><p>    return _G[self.FuncName](self, _Quest);</p><p>    if not self.FuncName then</p><p>        fatal(_Quest.Identifier.." "..self.Name..": function reference is invalid!");</p><p>        return true;</p><p>    end</p><p>    if type(self.FuncName) == "string" and not _G[self.FuncName] then</p><p>        fatal(_Quest.Identifier.." "..self.Name..": function does not exist!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Eine benutzerdefinierte Variable muss einen bestimmten Wert haben.</p><p>-- Custom Variables können ausschließlich Zahlen enthalten. Bevor eine</p><p>-- Variable in einem Goal abgefragt werden kann, muss sie zuvor mit</p><p>-- Reprisal_CustomVariables oder Reward_CutsomVariables initialisiert</p><p>-- worden sein.</p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- @param _Name     Name der Variable</p><p>-- @param _Relation Vergleichsoperator</p><p>-- @param _Value    Wert oder andere Custom Variable mit wert.</p><p>-- @within Goal</p><p>    return b_Goal_CustomVariables:new(...);</p><p>Goal_CustomVariables</p><p>    Name = "Goal_CustomVariables",</p><p>    Description = {</p><p>        en = "Goal: A customised variable has to assume a certain value.",</p><p>        de = "Ziel: Eine benutzerdefinierte Variable muss einen bestimmten Wert annehmen.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Default, en = "Name of Variable", de = "Variablenname" },</p><p>        { ParameterType.Custom,  en = "Relation", de = "Relation" },</p><p>        { ParameterType.Default, en = "Value or variable", de = "Wert oder Variable" }</p><p>    }</p><p>    return { Objective.Custom2, {self, self.CustomFunction} };</p><p>    if _Index == 0 then</p><p>        self.VariableName = _Parameter</p><p>    elseif _Index == 1 then</p><p>        self.Relation = _Parameter</p><p>    elseif _Index == 2 then</p><p>        local value = tonumber(_Parameter);</p><p>        value = (value ~= nil and value) or tostring(_Parameter);</p><p>        self.Value = value</p><p>    end</p><p>    _G["QSB_CustomVariables_"..self.VariableName] = _G["QSB_CustomVariables_"..self.VariableName] or 0;</p><p>    local Value = (type(self.Value) ~= "string" and self.Value) or _G["QSB_CustomVariables_"..self.Value];</p><p>    if self.Relation == "==" then</p><p>        if _G["QSB_CustomVariables_"..self.VariableName] == Value then</p><p>            return true;</p><p>        end</p><p>    elseif self.Relation == "~=" then</p><p>        if _G["QSB_CustomVariables_"..self.VariableName] == Value then</p><p>            return true;</p><p>        end</p><p>    elseif self.Relation == "" then</p><p>        if _G["QSB_CustomVariables_"..self.VariableName]  Value then</p><p>            return true;</p><p>        end</p><p>    elseif self.Relation == "=" then</p><p>        if _G["QSB_CustomVariables_"..self.VariableName] = Value then</p><p>            return true;</p><p>        end</p><p>    elseif self.Relation == "=" then</p><p>        if _G["QSB_CustomVariables_"..self.VariableName] = Value then</p><p>            return true;</p><p>        end</p><p>    else</p><p>        if _G["QSB_CustomVariables_"..self.VariableName]  Value then</p><p>            return true;</p><p>        end</p><p>    end</p><p>    return nil;</p><p>    return {"==", "~=", "="};</p><p>    local relations = {"==", "~=", "="}</p><p>    local results    = {true, false, nil}</p><p>    if not _G["QSB_CustomVariables_"..self.VariableName] then</p><p>        warn(_Quest.Identifier.." "..self.Name..": variable '"..self.VariableName.."' do not exist!");</p><p>    end</p><p>    if not Inside(self.Relation, relations) then</p><p>        fatal(_Quest.Identifier.." "..self.Name..": '"..self.Relation.."' is an invalid relation!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Lässt den Spieler zwischen zwei Antworten wählen.</p><p>-- Dabei kann zwischen den Labels Ja/Nein und Ok/Abbrechen gewählt werden.</p><p>--  Es können nur geschlossene Fragen gestellt werden. Dialoge</p><p>-- müssen also immer mit Ja oder Nein beantwortbar sein oder auf Okay und</p><p>-- Abbrechen passen.</p><p>-- @param _Title  Fenstertitel</p><p>-- @param _Text   Fenstertext</p><p>-- @param _Labels Label der Buttons</p><p>-- @within Goal</p><p>    return b_Goal_Decide:new(...);</p><p>Goal_Decide</p><p>    Name = "Goal_Decide",</p><p>    Description = {</p><p>        en = "Opens a Yes/No Dialog. Decision = Quest Result",</p><p>        de = "Oeffnet einen Ja/Nein-Dialog. Die Entscheidung bestimmt das Quest-Ergebnis (ja=true, nein=false).",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Default, en = "Text", de = "Text", },</p><p>        { ParameterType.Default, en = "Title", de = "Titel", },</p><p>        { ParameterType.Custom, en = "Button labels", de = "Button Beschriftung", },</p><p>    },</p><p>    return { Objective.Custom2, { self, self.CustomFunction } }</p><p>    if (_Index == 0) then</p><p>        self.Text = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.Title = _Parameter</p><p>    elseif (_Index == 2) then</p><p>        self.Buttons = (_Parameter == "Ok/Cancel")</p><p>    end</p><p>    if not IsBriefingActive or (IsBriefingActive and IsBriefingActive() == false) then</p><p>        if not self.LocalExecuted then</p><p>            if QSB.DialogActive then</p><p>                return;</p><p>            end</p><p>            QSB.DialogActive = true</p><p>            local buttons = (self.Buttons and "true") or "nil"</p><p>            self.LocalExecuted = true</p><p>            local commandString = [[</p><p>                Game.GameTimeSetFactor( GUI.GetPlayerID(), 0 )</p><p>                OpenRequesterDialog(q,</p><p>                                    q,</p><p>                                    "Game.GameTimeSetFactor( GUI.GetPlayerID(), 1 ); GUI.SendScriptCommand( 'QSB.DecisionWindowResult = true ')",</p><p>                                    s ,</p><p>                                    "Game.GameTimeSetFactor( GUI.GetPlayerID(), 1 ); GUI.SendScriptCommand( 'QSB.DecisionWindowResult = false ')")</p><p>            ]];</p><p>            local commandString = string.format(commandString, self.Text, "{center} " .. self.Title, buttons)</p><p>            Logic.ExecuteInLuaLocalState(commandString);</p><p>        end</p><p>        local result = QSB.DecisionWindowResult</p><p>        if result ~= nil then</p><p>            QSB.DecisionWindowResult = nil</p><p>            QSB.DialogActive = false;</p><p>            return result</p><p>        end</p><p>    end</p><p>    self.LocalExecuted = nil;</p><p>    return {4,12}</p><p>    if _Index == 2 then</p><p>        return { "Yes/No", "Ok/Cancel" }</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der Spieler kann durch regelmäßiges Begleichen eines Tributes bessere</p><p>-- Diplomatie zu einen Spieler erreichen.</p><p>-- Die Zeit zum Bezahlen des Tributes muss immer kleiner sein als die</p><p>-- Wiederholungsperiode.</p><p>-- : Je mehr Zeit sich der Spieler lässt um den Tribut zu</p><p>-- begleichen, desto mehr wird sich der Start der nächsten Periode verzögern.</p><p>-- @param _GoldAmount Menge an Gold</p><p>-- @param _Periode    Zahlungsperiode in Sekunden</p><p>-- @param _Time       Zeitbegrenzung in Sekunden</p><p>-- @param _StartMsg   Vorschlagnachricht</p><p>-- @param _SuccessMsg Erfolgsnachricht</p><p>-- @param _FailureMsg Fehlschlagnachricht</p><p>-- @param _Restart    Nach nichtbezahlen neu starten</p><p>-- @within Goal</p><p>    return b_Goal_TributeDiplomacy:new(...);</p><p>Goal_TributeDiplomacy</p><p>    Name = "Goal_TributeDiplomacy",</p><p>    Description = {</p><p>        en = "Goal: AI requests periodical tribute for better Diplomacy",</p><p>        de = "Ziel: Die KI fordert einen regelmässigen Tribut fuer bessere Diplomatie. Der Questgeber ist der fordernde Spieler.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Number, en = "Amount", de = "Menge", },</p><p>        { ParameterType.Number, en = "Time till next peyment in seconds", de = "Zeit bis zur Forderung in Sekunden", },</p><p>        { ParameterType.Number, en = "Time to pay tribute in seconds", de = "Zeit bis zur Zahlung in Sekunden", },</p><p>        { ParameterType.Default, en = "Start Message for TributQuest", de = "Startnachricht der Tributquest", },</p><p>        { ParameterType.Default, en = "Success Message for TributQuest", de = "Erfolgsnachricht der Tributquest", },</p><p>        { ParameterType.Default, en = "Failure Message for TributQuest", de = "Niederlagenachricht der Tributquest", },</p><p>        { ParameterType.Custom, en = "Restart if failed to pay", de = "Nicht-bezahlen beendet die Quest", },</p><p>    },</p><p>    return {Objective.Custom2, {self, self.CustomFunction} };</p><p>    if (_Index == 0) then</p><p>        self.Amount = _Parameter * 1;</p><p>    elseif (_Index == 1) then</p><p>        self.PeriodLength = _Parameter * 1;</p><p>    elseif (_Index == 2) then</p><p>        self.TributTime = _Parameter * 1;</p><p>    elseif (_Index == 3) then</p><p>        self.StartMsg = _Parameter;</p><p>    elseif (_Index == 4) then</p><p>        self.SuccessMsg = _Parameter;</p><p>    elseif (_Index == 5) then</p><p>        self.FailureMsg = _Parameter;</p><p>    elseif (_Index == 6) then</p><p>        self.RestartAtFailure = AcceptAlternativeBoolean(_Parameter);</p><p>    end</p><p>    if not self.InternTributeQuest then</p><p>        local Language = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>        local StartMsg = self.StartMsg;</p><p>        if type(StartMsg) == "table" then</p><p>            StartMsg = StartMsg[Language];</p><p>        end</p><p>        local SuccessMsg = self.SuccessMsg;</p><p>        if type(SuccessMsg) == "table" then</p><p>            SuccessMsg = SuccessMsg[Language];</p><p>        end</p><p>        local FailureMsg = self.FailureMsg;</p><p>        if type(FailureMsg) == "table" then</p><p>            FailureMsg = FailureMsg[Language];</p><p>        end</p><p>        local QuestID, Quest = QuestTemplate:New (</p><p>            _Quest.Identifier.."_TributeDiplomacyQuest" , _Quest.SendingPlayer, _Quest.ReceivingPlayer,</p><p>            {{ Objective.Deliver, {Goods.G_Gold, self.Amount}}},</p><p>            {{ Triggers.Time, 0 }},</p><p>            self.TributTime, nil, nil, nil, nil, true, true, nil,</p><p>            StartMsg,</p><p>            SuccessMsg,</p><p>            FailureMsg</p><p>        );</p><p>        self.InternTributeQuest = Quest;</p><p>    end</p><p>    if self.InternTributeQuest and self.InternTributeQuest.State == QuestState.Over and not self.RestartQuest then</p><p>        if self.InternTributeQuest.Result ~= QuestResult.Success then</p><p>            SetDiplomacyState( _Quest.ReceivingPlayer, _Quest.SendingPlayer, DiplomacyStates.Enemy);</p><p>            if not self.RestartAtFailure then</p><p>                return false;</p><p>            end</p><p>        else</p><p>            SetDiplomacyState(_Quest.ReceivingPlayer, _Quest.SendingPlayer, DiplomacyStates.TradeContact);</p><p>        end</p><p>        self.RestartQuest = true;</p><p>        self.Time = Logic.GetTime();</p><p>    end</p><p>    local storeHouse = Logic.GetStoreHouse(_Quest.SendingPlayer);</p><p>    if (storeHouse == 0 or Logic.IsEntityDestroyed(storeHouse)) then</p><p>        if self.InternTributeQuest and self.InternTributeQuest.State == QuestState.Active then</p><p>            self.InternTributeQuest:Interrupt();</p><p>        end</p><p>        return true;</p><p>    end</p><p>    if self.InternTributeQuest and self.Time and self.RestartQuest and ((Logic.GetTime() - self.Time) = self.PeriodLength) then</p><p>        self.InternTributeQuest.Objectives[1].Completed = nil;</p><p>        self.InternTributeQuest.Objectives[1].Data[3] = nil;</p><p>        self.InternTributeQuest.Objectives[1].Data[4] = nil;</p><p>        self.InternTributeQuest.Objectives[1].Data[5] = nil;</p><p>        self.InternTributeQuest.Result = nil;</p><p>        self.InternTributeQuest.State = QuestState.NotTriggered;</p><p>        Logic.ExecuteInLuaLocalState("LocalScriptCallback_OnQuestStatusChanged("..self.InternTributeQuest.Index..")");</p><p>        Trigger.RequestTrigger(Events.LOGIC_EVENT_EVERY_SECOND, "", QuestTemplate.Loop, 1, 0, { self.InternTributeQuest.QueueID });</p><p>        self.RestartQuest = nil;</p><p>    end</p><p>    -- Tribut Quest erzeugen</p><p>    self:GetTributeQuest(_Quest);</p><p>    -- Status des Tributes prüfen.</p><p>    if self:CheckTributeQuest(_Quest) == false then</p><p>        return false;</p><p>    end</p><p>    -- Status des fordernden Spielers prüfen.</p><p>    if self:CheckTributePlayer(_Quest) == true then</p><p>        return true;</p><p>    end</p><p>    -- Quest neu starten, falls nötig.</p><p>    self:TributQuestRestarter(_Quest);</p><p>    if self.Amount  0 then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": Amount is negative!");</p><p>        return true;</p><p>    end</p><p>    if self.PeriodLength  self.TributTime then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": TributTime too long!");</p><p>        return true;</p><p>    end</p><p>    self.Time = nil;</p><p>    self.InternTributeQuest = nil;</p><p>    self.RestartQuest = nil;</p><p>    if self.InternTributeQuest ~= nil then</p><p>        if self.InternTributeQuest.State == QuestState.Active then</p><p>            self.InternTributeQuest:Interrupt()</p><p>        end</p><p>    end</p><p>    if (_Index == 6) then</p><p>        return {"true", "false"};</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Erlaubt es dem Spieler ein Territorium zu "mieten".</p><p>-- Zerstört der Spieler den Außenposten, schlägt der Quest fehl und das</p><p>-- Territorium wird an den Vermieter übergeben. Wenn der Spieler die Pacht</p><p>-- nicht bezahlt, geht der Besitz an den Vermieter über.</p><p>-- Die Zeit zum Bezahlen des Tributes muss immer kleiner sein als die</p><p>-- Wiederholungsperiode.</p><p>-- : Je mehr Zeit sich der Spieler lässt um den Tribut zu</p><p>-- begleichen, desto mehr wird sich der Start der nächsten Periode verzögern.</p><p>-- @param _Territory  Name des Territorium</p><p>-- @param _PlayerID   PlayerID des Zahlungsanforderer</p><p>-- @param _Cost       Menge an Gold</p><p>-- @param _Periode    Zahlungsperiode in Sekunden</p><p>-- @param _Time       Zeitbegrenzung in Sekunden</p><p>-- @param _StartMsg   Vorschlagnachricht</p><p>-- @param _SuccessMsg Erfolgsnachricht</p><p>-- @param _FailMsg    Fehlschlagnachricht</p><p>-- @param _HowOften   Anzahl an Zahlungen (0 = endlos)</p><p>-- @param _OtherOwner Eroberung durch Dritte beendet Quest</p><p>-- @param _Abort      Nach nichtbezahlen abbrechen</p><p>-- @within Goal</p><p>    return b_Goal_TributeClaim:new(...);</p><p>Goal_TributeClaim</p><p>    Name = "Goal_TributeClaim",</p><p>    Description = {</p><p>        en = "Goal: AI requests periodical tribute for a specified territory. The quest sender is the demanding player.",</p><p>        de = "Ziel: Die KI fordert einen regelmässigen Tribut fuer ein Territorium. Der Questgeber ist der fordernde Spieler.",</p><p>                },</p><p>    Parameter = {</p><p>        { ParameterType.TerritoryName, en = "Territory", de = "Territorium", },</p><p>        { ParameterType.PlayerID, en = "PlayerID", de = "PlayerID", },</p><p>        { ParameterType.Number, en = "Amount", de = "Menge", },</p><p>        { ParameterType.Number, en = "Length of Period in seconds", de = "Sekunden bis zur nächsten Forderung", },</p><p>        { ParameterType.Number, en = "Time to pay Tribut in seconds", de = "Zeit bis zur Zahlung in Sekunden", },</p><p>        { ParameterType.Default, en = "Start Message for TributQuest", de = "Startnachricht der Tributquest", },</p><p>        { ParameterType.Default, en = "Success Message for TributQuest", de = "Erfolgsnachricht der Tributquest", },</p><p>        { ParameterType.Default, en = "Failure Message for TributQuest", de = "Niederlagenachricht der Tributquest", },</p><p>        { ParameterType.Number, en = "How often to pay (0 = forerver)", de = "Anzahl der Tributquests (0 = unendlich)", },</p><p>        { ParameterType.Custom, en = "Other Owner cancels the Quest", de = "Anderer Spieler kann Quest beenden", },</p><p>        { ParameterType.Custom, en = "About if a rate is not payed", de = "Nicht-bezahlen beendet die Quest", },</p><p>    },</p><p>    return {Objective.Custom2, {self, self.CustomFunction} };</p><p>    if (_Index == 0) then</p><p>        if type(_Parameter) == "string" then</p><p>            _Parameter = GetTerritoryIDByName(_Parameter);</p><p>        end</p><p>        self.TerritoryID = _Parameter;</p><p>    elseif (_Index == 1) then</p><p>        self.PlayerID = _Parameter * 1;</p><p>    elseif (_Index == 2) then</p><p>        self.Amount = _Parameter * 1;</p><p>    elseif (_Index == 3) then</p><p>        self.PeriodLength = _Parameter * 1;</p><p>    elseif (_Index == 4) then</p><p>        self.TributTime = _Parameter * 1;</p><p>    elseif (_Index == 5) then</p><p>        self.StartMsg = _Parameter;</p><p>    elseif (_Index == 6) then</p><p>        self.SuccessMsg = _Parameter;</p><p>    elseif (_Index == 7) then</p><p>        self.FailureMsg = _Parameter;</p><p>    elseif (_Index == 8) then</p><p>        self.HowOften = _Parameter * 1;</p><p>    elseif (_Index == 9) then</p><p>        self.OtherOwnerCancels = AcceptAlternativeBoolean(_Parameter);</p><p>    elseif (_Index == 10) then</p><p>        self.DontPayCancels = AcceptAlternativeBoolean(_Parameter);</p><p>    end</p><p>    local Outpost = Logic.GetTerritoryAcquiringBuildingID(self.TerritoryID);</p><p>    if IsExisting(Outpost) and GetHealth(Outpost)  25 and Logic.IsBuildingBeingKnockedDown(Outpost) == false then</p><p>        while (Logic.GetEntityHealth(Outpost)  Logic.GetEntityMaxHealth(Outpost) * 0.6) do</p><p>            Logic.HealEntity(Outpost, 1);</p><p>        end</p><p>    end</p><p>    if self.InternTributeQuest then</p><p>        self.InternTributeQuest.Objectives[1].Completed = nil;</p><p>        self.InternTributeQuest.Objectives[1].Data[3] = nil;</p><p>        self.InternTributeQuest.Objectives[1].Data[4] = nil;</p><p>        self.InternTributeQuest.Objectives[1].Data[5] = nil;</p><p>        self.InternTributeQuest.Result = nil;</p><p>        self.InternTributeQuest.State = QuestState.NotTriggered;</p><p>        Logic.ExecuteInLuaLocalState("LocalScriptCallback_OnQuestStatusChanged("..self.InternTributeQuest.Index..")");</p><p>        Trigger.RequestTrigger(Events.LOGIC_EVENT_EVERY_SECOND, "", QuestTemplate.Loop, 1, 0, { self.InternTributeQuest.QueueID });</p><p>    end</p><p>    if not self.InternTributeQuest then</p><p>        local Language = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>        local StartMsg = self.StartMsg;</p><p>        if type(StartMsg) == "table" then</p><p>            StartMsg = StartMsg[Language];</p><p>        end</p><p>        local SuccessMsg = self.SuccessMsg;</p><p>        if type(SuccessMsg) == "table" then</p><p>            SuccessMsg = SuccessMsg[Language];</p><p>        end</p><p>        local FailureMsg = self.FailureMsg;</p><p>        if type(FailureMsg) == "table" then</p><p>            FailureMsg = FailureMsg[Language];</p><p>        end</p><p>        local OnFinished = function()</p><p>            self.Time = Logic.GetTime();</p><p>        end</p><p>        local QuestID, Quest = QuestTemplate:New(</p><p>            _Quest.Identifier.."_TributeClaimQuest", self.PlayerID, _Quest.ReceivingPlayer,</p><p>            {{ Objective.Deliver, {Goods.G_Gold, self.Amount}}},</p><p>            {{ Triggers.Time, 0 }},</p><p>            self.TributTime, nil, nil, OnFinished, nil, true, true, nil,</p><p>            StartMsg,</p><p>            SuccessMsg,</p><p>            FailureMsg</p><p>        );</p><p>        self.InternTributeQuest = Quest;</p><p>    end</p><p>    local Outpost = Logic.GetTerritoryAcquiringBuildingID(self.TerritoryID);</p><p>    if IsExisting(Outpost) then</p><p>        Logic.ChangeEntityPlayerID(Outpost, self.PlayerID);</p><p>    end</p><p>    Logic.SetTerritoryPlayerID(self.TerritoryID, self.PlayerID);</p><p>    self.InternTributeQuest.State = false;</p><p>    self.Time = nil;</p><p>    if self.DontPayCancels then</p><p>        _Quest:Interrupt();</p><p>    end</p><p>    local Outpost = Logic.GetTerritoryAcquiringBuildingID(self.TerritoryID);</p><p>    if self.InternTributeQuest.Result == QuestResult.Success then</p><p>        if Logic.GetTerritoryPlayerID(self.TerritoryID) == self.PlayerID then</p><p>            if IsExisting(Outpost) then</p><p>                Logic.ChangeEntityPlayerID(Outpost, _Quest.ReceivingPlayer);</p><p>            end</p><p>            Logic.SetTerritoryPlayerID(self.TerritoryID, _Quest.ReceivingPlayer);</p><p>        end</p><p>    end</p><p>    if self.Time and Logic.GetTime() = self.Time + self.PeriodLength then</p><p>        if self.HowOften and self.HowOften ~= 0 then</p><p>            self.TributeCounter = (self.TributeCounter or 0) +1;</p><p>            if self.TributeCounter = self.HowOften then</p><p>                return false;</p><p>            end</p><p>        end</p><p>        self:RestartTributeQuest();</p><p>        self.Time = nil;</p><p>    end</p><p>    self:CreateTributeQuest(_Quest);</p><p>    self:CureOutpost(_Quest);</p><p>    if Logic.GetTerritoryPlayerID(self.TerritoryID) == _Quest.ReceivingPlayer</p><p>    or Logic.GetTerritoryPlayerID(self.TerritoryID) == self.PlayerID then</p><p>        if self.OtherOwner then</p><p>            self:RestartTributeQuest();</p><p>            self.OtherOwner = nil;</p><p>        end</p><p>        -- Quest abgeschlossen</p><p>        if self.InternTributeQuest.State == QuestState.Over then</p><p>            if self.InternTributeQuest.Result == QuestResult.Failure then</p><p>                self:OnTributeFailed(_Quest);</p><p>            else</p><p>                self:OnTributePaid(_Quest);</p><p>            end</p><p>        elseif self.InternTributeQuest.State == false then</p><p>            if self.Time and Logic.GetTime() = self.Time + self.PeriodLength then</p><p>                self:RestartTributeQuest(_Quest);</p><p>            end</p><p>        end</p><p>    -- Keiner besitzt das Territorium - Abbruch</p><p>    elseif Logic.GetTerritoryPlayerID(self.TerritoryID) == 0 and self.InternTributeQuest then</p><p>        if self.InternTributeQuest.State == QuestState.Active then</p><p>            self.InternTributeQuest:Interrupt();</p><p>        end</p><p>    -- Anderer Besitzer - Abbruch</p><p>    elseif Logic.GetTerritoryPlayerID(self.TerritoryID) ~= self.PlayerID then</p><p>        if self.InternTributeQuest.State == QuestState.Active then</p><p>            self.InternTributeQuest:Interrupt();</p><p>        end</p><p>        if self.OtherOwnerCancels then</p><p>            _Quest:Interrupt();</p><p>        end</p><p>        self.OtherOwner = true;</p><p>    end</p><p>    --Fordernder Spieler existiert nicht - Abbruch</p><p>    local storeHouse = Logic.GetStoreHouse(self.PlayerID);</p><p>    if (storeHouse == 0 or Logic.IsEntityDestroyed(storeHouse)) then</p><p>        if self.InternTributeQuest and self.InternTributeQuest.State == QuestState.Active then</p><p>            self.InternTributeQuest:Interrupt();</p><p>        end</p><p>        return true;</p><p>    end</p><p>    if self.TerritoryID == 0 then</p><p>        fatal(_Quest.Identifier .. ": " .. self.Name .. ": Unknown Territory");</p><p>        return true;</p><p>    end</p><p>    if not self.Quest and Logic.GetStoreHouse(self.PlayerID) == 0 then</p><p>        fatal(_Quest.Identifier .. ": " .. self.Name .. ": Player " .. self.PlayerID .. " is dead. :-(");</p><p>        return true;</p><p>    end</p><p>    if self.Amount  0 then</p><p>        fatal(_Quest.Identifier .. ": " .. self.Name .. ": Amount is negative");</p><p>        return true;</p><p>    end</p><p>    if self.PeriodLength  self.TributTime or self.PeriodLength  1 then</p><p>        fatal(_Quest.Identifier .. ": " .. self.Name .. ": Period Length is wrong");</p><p>        return true;</p><p>    end</p><p>    if self.HowOften  0 then</p><p>        fatal(_Quest.Identifier .. ": " .. self.Name .. ": HowOften is negative");</p><p>        return true;</p><p>    end</p><p>    self.InternTributeQuest = nil;</p><p>    self.Time = nil;</p><p>    self.OtherOwner = nil;</p><p>    if type(self.InternTributeQuest) == "table" then</p><p>        if self.InternTributeQuest.State == QuestState.Active then</p><p>            self.InternTributeQuest:Interrupt();</p><p>        end</p><p>    end</p><p>    if (_Index == 9) or (_Index == 10) then</p><p>        return {"false", "true"};</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Reprisal                                                                   --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Deaktiviert ein interaktives Objekt.</p><p>-- @param _ScriptName Skriptname des interaktiven Objektes</p><p>-- @within Reprisal</p><p>    return b_Reprisal_ObjectDeactivate:new(...);</p><p>Reprisal_ObjectDeactivate</p><p>    Name = "Reprisal_ObjectDeactivate",</p><p>    Description = {</p><p>        en = "Reprisal: Deactivates an interactive object",</p><p>        de = "Vergeltung: Deaktiviert ein interaktives Objekt",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Interactive object", de = "Interaktives Objekt" },</p><p>    },</p><p>    return { Reprisal.Custom,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.ScriptName = _Parameter</p><p>    end</p><p>    InteractiveObjectDeactivate(self.ScriptName);</p><p>    if not Logic.IsInteractiveObject(GetID(self.ScriptName)) then</p><p>        warn("".._Quest.Identifier.." "..self.Name..": '" ..self.ScriptName.. "' is not a interactive object!");</p><p>        self.WarningPrinted = true;</p><p>    end</p><p>    local eID = GetID(self.ScriptName);</p><p>    if QSB.InitalizedObjekts[eID] and QSB.InitalizedObjekts[eID] == _Quest.Identifier then</p><p>        fatal("".._Quest.Identifier.." "..self.Name..": you can not deactivate in the same quest the object is initalized!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Aktiviert ein interaktives Objekt.</p><p>-- Der Status bestimmt, wie das Objekt aktiviert wird.</p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- @param _ScriptName Skriptname des interaktiven Objektes</p><p>-- @param _State      Status des Objektes</p><p>-- @within Reprisal</p><p>    return b_Reprisal_ObjectActivate:new(...);</p><p>Reprisal_ObjectActivate</p><p>    Name = "Reprisal_ObjectActivate",</p><p>    Description = {</p><p>        en = "Reprisal: Activates an interactive object",</p><p>        de = "Vergeltung: Aktiviert ein interaktives Objekt",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Interactive object",  de = "Interaktives Objekt" },</p><p>        { ParameterType.Custom,     en = "Availability",         de = "Nutzbarkeit" },</p><p>    },</p><p>    return { Reprisal.Custom,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.ScriptName = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        local parameter = 0</p><p>        if _Parameter == "Always" or 1 then</p><p>            parameter = 1</p><p>        end</p><p>        self.UsingState = parameter * 1</p><p>    end</p><p>    InteractiveObjectActivate(self.ScriptName, self.UsingState);</p><p>    if _Index == 1 then</p><p>        return {"Knight only", "Always"}</p><p>    end</p><p>    if not Logic.IsInteractiveObject(GetID(self.ScriptName)) then</p><p>        warn("".._Quest.Identifier.." "..self.Name..": '" ..self.ScriptName.. "' is not a interactive object!");</p><p>        self.WarningPrinted = true;</p><p>    end</p><p>    local eID = GetID(self.ScriptName);</p><p>    if QSB.InitalizedObjekts[eID] and QSB.InitalizedObjekts[eID] == _Quest.Identifier then</p><p>        fatal("".._Quest.Identifier.." "..self.Name..": you can not activate in the same quest the object is initalized!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der diplomatische Status zwischen Sender und Empfänger verschlechtert sich</p><p>-- um eine Stufe.</p><p>-- @within Reprisal</p><p>    return b_Reprisal_DiplomacyDecrease:new();</p><p>Reprisal_DiplomacyDecrease</p><p>    Name = "Reprisal_DiplomacyDecrease",</p><p>    Description = {</p><p>        en = "Reprisal: Diplomacy decreases slightly to another player.",</p><p>        de = "Vergeltung: Der Diplomatiestatus zum Auftraggeber wird um eine Stufe verringert.",</p><p>    },</p><p>    return { Reprisal.Custom,{self, self.CustomFunction} }</p><p>    local Sender = _Quest.SendingPlayer;</p><p>    local Receiver = _Quest.ReceivingPlayer;</p><p>    local State = GetDiplomacyState(Receiver, Sender);</p><p>    if State  -2 then</p><p>        SetDiplomacyState(Receiver, Sender, State-1);</p><p>    end</p><p>    if (_Index == 0) then</p><p>        self.PlayerID = _Parameter * 1</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Änder den Diplomatiestatus zwischen zwei Spielern.</p><p>-- @param _Party1   ID der ersten Partei</p><p>-- @param _Party2   ID der zweiten Partei</p><p>-- @param _State    Neuer Diplomatiestatus</p><p>-- @within Reprisal</p><p>    return b_Reprisal_Diplomacy:new(...);</p><p>Reprisal_Diplomacy</p><p>    Name = "Reprisal_Diplomacy",</p><p>    Description = {</p><p>        en = "Reprisal: Sets Diplomacy state of two Players to a stated value.",</p><p>        de = "Vergeltung: Setzt den Diplomatiestatus zweier Spieler auf den angegebenen Wert.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.PlayerID,         en = "PlayerID 1", de = "Spieler 1" },</p><p>        { ParameterType.PlayerID,         en = "PlayerID 2", de = "Spieler 2" },</p><p>        { ParameterType.DiplomacyState,   en = "Relation",   de = "Beziehung" },</p><p>    },</p><p>    return { Reprisal.Custom,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.PlayerID1 = _Parameter * 1</p><p>    elseif (_Index == 1) then</p><p>        self.PlayerID2 = _Parameter * 1</p><p>    elseif (_Index == 2) then</p><p>        self.Relation = DiplomacyStates[_Parameter]</p><p>    end</p><p>    SetDiplomacyState(self.PlayerID1, self.PlayerID2, self.Relation);</p><p>    if not tonumber(self.PlayerID1) or self.PlayerID1  8 then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": PlayerID 1 is invalid!");</p><p>        return true;</p><p>    elseif not tonumber(self.PlayerID2) or self.PlayerID2  8 then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": PlayerID 2 is invalid!");</p><p>        return true;</p><p>    elseif not tonumber(self.Relation) or self.Relation  2 then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": '"..self.Relation.."' is a invalid diplomacy state!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ein benanntes Entity wird entfernt.</p><p>-- : Das Entity wird durch ein XD_ScriptEntity ersetzt. Es</p><p>-- behält Name, Besitzer und Ausrichtung.</p><p>-- @param _ScriptName Skriptname des Entity</p><p>-- @within Reprisal</p><p>    return b_Reprisal_DestroyEntity:new(...);</p><p>Reprisal_DestroyEntity</p><p>    Name = "Reprisal_DestroyEntity",</p><p>    Description = {</p><p>        en = "Reprisal: Replaces an entity with an invisible script entity, which retains the entities name.",</p><p>        de = "Vergeltung: Ersetzt eine Entity mit einer unsichtbaren Script-Entity, die den Namen übernimmt.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Entity", de = "Entity" },</p><p>    },</p><p>    return { Reprisal.Custom,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.ScriptName = _Parameter</p><p>    end</p><p>    ReplaceEntity(self.ScriptName, Entities.XD_ScriptEntity);</p><p>    if not IsExisting(self.ScriptName) then</p><p>        warn(_Quest.Identifier.." " ..self.Name..": '" ..self.ScriptName.. "' is already destroyed!");</p><p>        self.WarningPrinted = true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Zerstört einen über ein Behavior erzeugten Effekt.</p><p>-- @param _EffectName Name des Effekts</p><p>-- @within Reprisal</p><p>    return b_Reprisal_DestroyEffect:new(...);</p><p>Reprisal_DestroyEffect</p><p>    Name = "Reprisal_DestroyEffect",</p><p>    Description = {</p><p>        en = "Reprisal: Destroys an effect",</p><p>        de = "Vergeltung: Zerstört einen Effekt",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Default, en = "Effect name", de = "Effektname" },</p><p>    }</p><p>    if _Index == 0 then</p><p>        self.EffectName = _Parameter;</p><p>    end</p><p>    return { Reprisal.Custom, { self, self.CustomFunction } };</p><p>    if not QSB.EffectNameToID[self.EffectName] or not Logic.IsEffectRegistered(QSB.EffectNameToID[self.EffectName]) then</p><p>        return;</p><p>    end</p><p>    Logic.DestroyEffect(QSB.EffectNameToID[self.EffectName]);</p><p>    if not QSB.EffectNameToID[self.EffectName] then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": Effect " .. self.EffectName .. " never created")</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der Spieler verliert das Spiel.</p><p>-- @within Reprisal</p><p>    return b_Reprisal_Defeat:new()</p><p>Reprisal_Defeat</p><p>    Name = "Reprisal_Defeat",</p><p>    Description = {</p><p>        en = "Reprisal: The player loses the game.",</p><p>        de = "Vergeltung: Der Spieler verliert das Spiel.",</p><p>    },</p><p>    return {Reprisal.Defeat};</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Zeigt die Niederlagedekoration am Quest an.</p><p>-- Es handelt sich dabei um reine Optik! Der Spieler wird nicht verlieren.</p><p>-- @within Reprisal</p><p>    return b_Reprisal_FakeDefeat:new();</p><p>Reprisal_FakeDefeat</p><p>    Name = "Reprisal_FakeDefeat",</p><p>    Description = {</p><p>        en = "Reprisal: Displays a defeat icon for a quest",</p><p>        de = "Vergeltung: Zeigt ein Niederlage Icon fuer eine Quest an",</p><p>    },</p><p>    return { Reprisal.FakeDefeat }</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ein Entity wird durch ein neues anderen Typs ersetzt.</p><p>-- Das neue Entity übernimmt Skriptname, Besitzer  und Ausrichtung des </p><p>-- alten Entity.</p><p>-- @param _Entity Skriptname oder ID des Entity</p><p>-- @param _Type   Neuer Typ des Entity</p><p>-- @param _Owner  Besitzer des Entity</p><p>-- @within Reprisal</p><p>    return b_Reprisal_ReplaceEntity:new(...);</p><p>Reprisal_ReplaceEntity</p><p>    Name = "Reprisal_ReplaceEntity",</p><p>    Description = {</p><p>        en = "Reprisal: Replaces an entity with a new one of a different type. The playerID can be changed too.",</p><p>        de = "Vergeltung: Ersetzt eine Entity durch eine neue anderen Typs. Es kann auch die Spielerzugehörigkeit geändert werden.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Target", de = "Ziel" },</p><p>        { ParameterType.Custom, en = "New Type", de = "Neuer Typ" },</p><p>        { ParameterType.Custom, en = "New playerID", de = "Neue Spieler ID" },</p><p>    },</p><p>    return { Reprisal.Custom,{self, self.CustomFunction} }</p><p>   if (_Index == 0) then</p><p>        self.ScriptName = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.NewType = _Parameter</p><p>    elseif (_Index == 2) then</p><p>        self.PlayerID = tonumber(_Parameter);</p><p>    end</p><p>    local eID = GetID(self.ScriptName);</p><p>    local pID = self.PlayerID;</p><p>    if pID == Logic.EntityGetPlayer(eID) then</p><p>        pID = nil;</p><p>    end</p><p>    ReplaceEntity(self.ScriptName, Entities[self.NewType], pID);</p><p>    local Data = {}</p><p>    if _Index == 1 then</p><p>        for k, v in pairs( Entities ) do</p><p>            local name = {"^M_","^XS_","^X_","^XT_","^Z_", "^XB_"}</p><p>            local found = false;</p><p>            for i=1,#name do</p><p>                if k:find(name[i]) then</p><p>                    found = true;</p><p>                    break;</p><p>                end</p><p>            end</p><p>            if not found then</p><p>                table.insert( Data, k );</p><p>            end</p><p>        end</p><p>        table.sort( Data )</p><p>    elseif _Index == 2 then</p><p>        Data = {"-","0","1","2","3","4","5","6","7","8",}</p><p>    end</p><p>    return Data</p><p>    if not Entities[self.NewType] then</p><p>        fatal(_Quest.Identifier.." "..self.Name..": got an invalid entity type!");</p><p>        return true;</p><p>    elseif self.PlayerID ~= nil and (self.PlayerID  8) then</p><p>        fatal(_Quest.Identifier.." "..self.Name..": got an invalid playerID!");</p><p>        return true;</p><p>    end</p><p>    if not IsExisting(self.ScriptName) then</p><p>        self.WarningPrinted = true;</p><p>        warn(_Quest.Identifier.." "..self.Name..": '" ..self.ScriptName.. "' does not exist!");</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet einen Quest neu.</p><p>-- @param _QuestName Name des Quest</p><p>-- @within Reprisal</p><p>    return b_Reprisal_QuestRestart(...)</p><p>Reprisal_QuestRestart</p><p>    Name = "Reprisal_QuestRestart",</p><p>    Description = {</p><p>        en = "Reprisal: Restarts a (completed) quest so it can be triggered and completed again",</p><p>        de = "Vergeltung: Startet eine (beendete) Quest neu, damit diese neu ausgelöst und beendet werden kann",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.QuestName, en = "Quest name", de = "Questname" },</p><p>    },</p><p>    return { Reprisal.Custom,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.QuestName = _Parameter</p><p>    end</p><p>    RestartQuestByName(self.QuestName, true);</p><p>    if not Quests[GetQuestID(self.QuestName)] then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": quest "..  self.QuestName .. " does not exist!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Lässt einen Quest fehlschlagen.</p><p>-- @param _QuestName Name des Quest</p><p>-- @within Reprisal</p><p>    return b_Reprisal_QuestFailure(...)</p><p>Reprisal_QuestFailure</p><p>    Name = "Reprisal_QuestFailure",</p><p>    Description = {</p><p>        en = "Reprisal: Lets another active quest fail",</p><p>        de = "Vergeltung: Lässt eine andere aktive Quest fehlschlagen",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.QuestName, en = "Quest name", de = "Questname" },</p><p>    },</p><p>    return { Reprisal.Custom,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.QuestName = _Parameter</p><p>    end</p><p>    FailQuestByName(self.QuestName, true);</p><p>    if not Quests[GetQuestID(self.QuestName)] then</p><p>        fatal("".._Quest.Identifier.." "..self.Name..": got an invalid quest!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Wertet einen Quest als erfolgreich.</p><p>-- @param _QuestName Name des Quest</p><p>-- @within Reprisal</p><p>    return b_Reprisal_QuestSuccess(...)</p><p>Reprisal_QuestSuccess</p><p>    Name = "Reprisal_QuestSuccess",</p><p>    Description = {</p><p>        en = "Reprisal: Completes another active quest successfully",</p><p>        de = "Vergeltung: Beendet eine andere aktive Quest erfolgreich",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.QuestName, en = "Quest name", de = "Questname" },</p><p>    },</p><p>    return { Reprisal.Custom,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.QuestName = _Parameter</p><p>    end</p><p>    WinQuestByName(self.QuestName, true);</p><p>    if not Quests[GetQuestID(self.QuestName)] then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": quest "..  self.QuestName .. " does not exist!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Triggert einen Quest.</p><p>-- @param _QuestName Name des Quest</p><p>-- @within Reprisal</p><p>    return b_Reprisal_QuestActivate(...)</p><p>Reprisal_QuestActivate</p><p>    Name = "Reprisal_QuestActivate",</p><p>    Description = {</p><p>        en = "Reprisal: Activates another quest that is not triggered yet.",</p><p>        de = "Vergeltung: Aktiviert eine andere Quest die noch nicht ausgelöst wurde.",</p><p>                },</p><p>    Parameter = {</p><p>        {ParameterType.QuestName, en = "Quest name", de = "Questname", },</p><p>    },</p><p>    return {Reprisal.Custom, {self, self.CustomFunction} }</p><p>    if (_Index==0) then</p><p>        self.QuestName = _Parameter</p><p>    else</p><p>        assert(false, "Error in " .. self.Name .. ": AddParameter: Index is invalid")</p><p>    end</p><p>    StartQuestByName(self.QuestName, true);</p><p>    if not IsValidQuest(self.QuestName) then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": Quest: "..  self.QuestName .. " does not exist");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Unterbricht einen Quest.</p><p>-- @param _QuestName Name des Quest</p><p>-- @within Reprisal</p><p>    return b_Reprisal_QuestInterrupt(...)</p><p>Reprisal_QuestInterrupt</p><p>    Name = "Reprisal_QuestInterrupt",</p><p>    Description = {</p><p>        en = "Reprisal: Interrupts another active quest without success or failure",</p><p>        de = "Vergeltung: Beendet eine andere aktive Quest ohne Erfolg oder Misserfolg",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.QuestName, en = "Quest name", de = "Questname" },</p><p>    },</p><p>    return { Reprisal.Custom,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.QuestName = _Parameter</p><p>    end</p><p>    if (GetQuestID(self.QuestName) ~= nil) then</p><p>        local QuestID = GetQuestID(self.QuestName)</p><p>        local Quest = Quests[QuestID]</p><p>        if Quest.State == QuestState.Active then</p><p>            StopQuestByName(self.QuestName, true);</p><p>        end</p><p>    end</p><p>    if not Quests[GetQuestID(self.QuestName)] then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": quest "..  self.QuestName .. " does not exist!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Unterbricht einen Quest, selbst wenn dieser noch nicht ausgelöst wurde.</p><p>-- @param _QuestName   Name des Quest</p><p>-- @param _EndetQuests Bereits beendete unterbrechen</p><p>-- @within Reprisal</p><p>    return b_Reprisal_QuestForceInterrupt(...)</p><p>Reprisal_QuestForceInterrupt</p><p>    Name = "Reprisal_QuestForceInterrupt",</p><p>    Description = {</p><p>        en = "Reprisal: Interrupts another quest (even when it isn't active yet) without success or failure",</p><p>        de = "Vergeltung: Beendet eine andere Quest, auch wenn diese noch nicht aktiv ist ohne Erfolg oder Misserfolg",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.QuestName, en = "Quest name", de = "Questname" },</p><p>        { ParameterType.Custom, en = "Ended quests", de = "Beendete Quests" },</p><p>    },</p><p>    return { Reprisal.Custom,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.QuestName = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.InterruptEnded = AcceptAlternativeBoolean(_Parameter)</p><p>    end</p><p>    local Data = {}</p><p>    if _Index == 1 then</p><p>        table.insert( Data, "false" )</p><p>        table.insert( Data, "true" )</p><p>    else</p><p>        assert( false )</p><p>    end</p><p>    return Data</p><p>    if (GetQuestID(self.QuestName) ~= nil) then</p><p>        local QuestID = GetQuestID(self.QuestName)</p><p>        local Quest = Quests[QuestID]</p><p>        if self.InterruptEnded or Quest.State ~= QuestState.Over then</p><p>            Quest:Interrupt()</p><p>        end</p><p>    end</p><p>    if not Quests[GetQuestID(self.QuestName)] then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": quest "..  self.QuestName .. " does not exist!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ändert den Wert einer benutzerdefinierten Variable.</p><p>-- Benutzerdefinierte Variablen können ausschließlich Zahlen sein. Nutze</p><p>-- dieses Behavior bevor die Variable in einem Goal oder Trigger abgefragt</p><p>-- wird, um sie zu initialisieren!</p><p>---- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- @param _Name     Name der Variable</p><p>-- @param _Operator Rechen- oder Zuweisungsoperator</p><p>-- @param _Value    Wert oder andere Custom Variable</p><p>-- @within Reprisal</p><p>    return b_Reprisal_CustomVariables:new(...);</p><p>Reprisal_CustomVariables</p><p>    Name = "Reprisal_CustomVariables",</p><p>    Description = {</p><p>        en = "Reprisal: Executes a mathematical operation with this variable. The other operand can be a number or another custom variable.",</p><p>        de = "Vergeltung: Fuehrt eine mathematische Operation mit der Variable aus. Der andere Operand kann eine Zahl oder eine Custom-Varible sein.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Default, en = "Name of variable", de = "Variablenname" },</p><p>        { ParameterType.Custom,  en = "Operator", de = "Operator" },</p><p>        { ParameterType.Default,  en = "Value or variable", de = "Wert oder Variable" }</p><p>    }</p><p>    return { Reprisal.Custom, {self, self.CustomFunction} };</p><p>    if _Index == 0 then</p><p>        self.VariableName = _Parameter</p><p>    elseif _Index == 1 then</p><p>        self.Operator = _Parameter</p><p>    elseif _Index == 2 then</p><p>        local value = tonumber(_Parameter);</p><p>        value = (value ~= nil and value) or tostring(_Parameter);</p><p>        self.Value = value</p><p>    end</p><p>    _G["QSB_CustomVariables_"..self.VariableName] = _G["QSB_CustomVariables_"..self.VariableName] or 0;</p><p>    local oldValue = _G["QSB_CustomVariables_"..self.VariableName];</p><p>    if self.Operator == "=" then</p><p>        _G["QSB_CustomVariables_"..self.VariableName] = (type(self.Value) ~= "string" and self.Value) or _G["QSB_CustomVariables_"..self.Value];</p><p>    elseif self.Operator == "+" then</p><p>        _G["QSB_CustomVariables_"..self.VariableName] = oldValue + (type(self.Value) ~= "string" and self.Value) or _G["QSB_CustomVariables_"..self.Value];</p><p>    elseif self.Operator == "-" then</p><p>        _G["QSB_CustomVariables_"..self.VariableName] = oldValue - (type(self.Value) ~= "string" and self.Value) or _G["QSB_CustomVariables_"..self.Value];</p><p>    elseif self.Operator == "*" then</p><p>        _G["QSB_CustomVariables_"..self.VariableName] = oldValue * (type(self.Value) ~= "string" and self.Value) or _G["QSB_CustomVariables_"..self.Value];</p><p>    elseif self.Operator == "/" then</p><p>        _G["QSB_CustomVariables_"..self.VariableName] = oldValue / (type(self.Value) ~= "string" and self.Value) or _G["QSB_CustomVariables_"..self.Value];</p><p>    elseif self.Operator == "^" then</p><p>        _G["QSB_CustomVariables_"..self.VariableName] = oldValue ^ (type(self.Value) ~= "string" and self.Value) or _G["QSB_CustomVariables_"..self.Value];</p><p>    end</p><p>    return {"=", "+", "-", "*", "/", "^"};</p><p>    local operators = {"=", "+", "-", "*", "/", "^"};</p><p>    if not Inside(self.Operator,operators) then</p><p>        fatal(_Quest.Identifier.." "..self.Name..": got an invalid operator!");</p><p>        return true;</p><p>    elseif self.VariableName == "" then</p><p>        fatal(_Quest.Identifier.." "..self.Name..": missing name for variable!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Führt eine Funktion im Skript als Reprisal aus.</p><p>-- Wird ein Funktionsname als String übergeben, wird die Funktion mit den</p><p>-- Daten des Behavors und des zugehörigen Quest aufgerufen (Standard).</p><p>-- Wird eine Funktionsreferenz angegeben, wird die Funktion zusammen mit allen</p><p>-- optionalen Parametern aufgerufen, als sei es ein gewöhnlicher Aufruf im</p><p>-- Skript.</p><p>--  Reprisal_MapScriptFunction(ReplaceEntity, "block", Entities.XD_ScriptEntity);</p><p>-- -- entspricht: ReplaceEntity("block", Entities.XD_ScriptEntity);</p><p>--  Nicht über den Assistenten verfügbar!</p><p>-- @param _Function Name der Funktion oder Funktionsreferenz</p><p>-- @within Reprisal</p><p>    return b_Reprisal_MapScriptFunction:new(...);</p><p>Reprisal_MapScriptFunction</p><p>    Name = "Reprisal_MapScriptFunction",</p><p>    Description = {</p><p>        en = "Reprisal: Calls a function within the global map script if the quest has failed.",</p><p>        de = "Vergeltung: Ruft eine Funktion im globalen Kartenskript auf, wenn die Quest fehlschlägt.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Default, en = "Function name", de = "Funktionsname" },</p><p>    },</p><p>    return {Reprisal.Custom, {self, self.CustomFunction}};</p><p>    if _Index == 0 then</p><p>        self.FuncName = _Parameter;</p><p>    end</p><p>    if type(self.FuncName) == "function" then</p><p>        self.Function(unpack(self.i47ya_6aghw_frxil));</p><p>        return;</p><p>    end</p><p>    _G[self.FuncName](self, _Quest);</p><p>    if not self.FuncName then</p><p>        fatal(_Quest.Identifier.." "..self.Name..": function reference is invalid!");</p><p>        return true;</p><p>    end</p><p>    if type(self.FuncName) == "string" and not _G[self.FuncName] then</p><p>        fatal(_Quest.Identifier.." "..self.Name..": function does not exist!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Erlaubt oder verbietet einem Spieler ein Recht.</p><p>-- @param _PlayerID   ID des Spielers</p><p>-- @param _Lock       Sperren/Entsperren</p><p>-- @param _Technology Name des Rechts</p><p>-- @within Reprisal</p><p>    return b_Reprisal_Technology:new(...);</p><p>Reprisal_Technology</p><p>    Name = "Reprisal_Technology",</p><p>    Description = {</p><p>        en = "Reprisal: Locks or unlocks a technology for the given player",</p><p>        de = "Vergeltung: Sperrt oder erlaubt eine Technolgie fuer den angegebenen Player",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.PlayerID, en = "PlayerID", de = "SpielerID" },</p><p>        { ParameterType.Custom,   en = "Un / Lock", de = "Sperren/Erlauben" },</p><p>        { ParameterType.Custom,   en = "Technology", de = "Technologie" },</p><p>    },</p><p>    return { Reprisal.Custom, {self, self.CustomFunction} }</p><p>    if (_Index ==0) then</p><p>        self.PlayerID = _Parameter*1</p><p>    elseif (_Index == 1) then</p><p>        self.LockType = _Parameter == "Lock"</p><p>    elseif (_Index == 2) then</p><p>        self.Technology = _Parameter</p><p>    end</p><p>    if self.PlayerID</p><p>    and Logic.GetStoreHouse(self.PlayerID) ~= 0</p><p>    and Technologies[self.Technology]</p><p>    then</p><p>        if self.LockType  then</p><p>            LockFeaturesForPlayer(self.PlayerID, Technologies[self.Technology])</p><p>        else</p><p>            UnLockFeaturesForPlayer(self.PlayerID, Technologies[self.Technology])</p><p>        end</p><p>    else</p><p>        return false</p><p>    end</p><p>    local Data = {}</p><p>    if (_Index == 1) then</p><p>        Data[1] = "Lock"</p><p>        Data[2] = "UnLock"</p><p>    elseif (_Index == 2) then</p><p>        for k, v in pairs( Technologies ) do</p><p>            table.insert( Data, k )</p><p>        end</p><p>    end</p><p>    return Data</p><p>    if not Technologies[self.Technology] then</p><p>        fatal("".._Quest.Identifier.." "..self.Name..": got an invalid technology type!");</p><p>        return true;</p><p>    elseif tonumber(self.PlayerID) == nil or self.PlayerID  8 then</p><p>        fatal("".._Quest.Identifier.." "..self.Name..": got an invalid playerID!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Rewards                                                                    --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Deaktiviert ein interaktives Objekt</p><p>-- @param _ScriptName Skriptname des interaktiven Objektes</p><p>-- @within Reward</p><p>    return b_Reward_ObjectDeactivate:new(...);</p><p>Reward_ObjectDeactivate = API.InstanceTable(b_Reprisal_ObjectDeactiva</p><p>Reward_ObjectDeactivate.Name             = "Reward_ObjectDeactiva</p><p>Reward_ObjectDeactivate.Description.de   = "Reward: Deactivates an interactive obje</p><p>Reward_ObjectDeactivate.Description.en   = "Lohn: Deaktiviert ein interaktives Obje</p><p>Reward_ObjectDeactivate.GetReprisalTable = </p><p>Reward_ObjectDeactivate.GetRewardTable = function(self, _Qu</p><p>    return { Reward.Custom,{self, self.CustomFunction} }</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Aktiviert ein interaktives Objekt.</p><p>-- Der Status bestimmt, wie das objekt aktiviert wird.</p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- @param _ScriptName Skriptname des interaktiven Objektes</p><p>-- @param _State Status des Objektes</p><p>-- @within Reward</p><p>    return b_Reward_ObjectActivate:new(...);</p><p>Reward_ObjectActivate = API.InstanceTable(b_Reprisal_ObjectActiva</p><p>Reward_ObjectActivate.Name             = "Reward_ObjectActiva</p><p>Reward_ObjectActivate.Description.de   = "Reward: Activates an interactive obje</p><p>Reward_ObjectActivate.Description.en   = "Lohn: Aktiviert ein interaktives Obje</p><p>Reward_ObjectActivate.GetReprisalTable = </p><p>Reward_ObjectActivate.GetRewardTable = function(self, _Qu</p><p>    return { Reward.Custom,{self, self.CustomFunction} };</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Initialisiert ein interaktives Objekt.</p><p>-- Interaktive Objekte können Kosten und Belohnungen enthalten, müssen sie</p><p>-- jedoch nicht. Ist eine Wartezeit angegeben, kann das Objekt erst nach</p><p>-- Ablauf eines Cooldowns benutzt werden.</p><p>-- @param _ScriptName Skriptname des interaktiven Objektes</p><p>-- @param _Distance   Entfernung zur Aktivierung</p><p>-- @param _Time       Wartezeit bis zur Aktivierung</p><p>-- @param _RType1     Warentyp der Belohnung</p><p>-- @param _RAmount    Menge der Belohnung</p><p>-- @param _CType1     Typ der 1. Ware</p><p>-- @param _CAmount1   Menge der 1. Ware</p><p>-- @param _CType2     Typ der 2. Ware</p><p>-- @param _CAmount2   Menge der 2. Ware</p><p>-- @param _Status     Aktivierung (0: Held, 1: immer, 2: niemals)</p><p>-- @within Reward</p><p>    return b_Reward_ObjectInit:new(...);</p><p>Reward_ObjectInit</p><p>    Name = "Reward_ObjectInit",</p><p>    Description = {</p><p>        en = "Reward: Setup an interactive object with costs and rewards.",</p><p>        de = "Lohn: Initialisiert ein interaktives Objekt mit seinen Kosten und Schätzen.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Interactive object",     de = "Interaktives Objekt" },</p><p>        { ParameterType.Number,     en = "Distance to use",     de = "Nutzungsentfernung" },</p><p>        { ParameterType.Number,     en = "Waittime",             de = "Wartezeit" },</p><p>        { ParameterType.Custom,     en = "Reward good",         de = "Belohnungsware" },</p><p>        { ParameterType.Number,     en = "Reward amount",         de = "Anzahl" },</p><p>        { ParameterType.Custom,     en = "Cost good 1",         de = "Kostenware 1" },</p><p>        { ParameterType.Number,     en = "Cost amount 1",         de = "Anzahl 1" },</p><p>        { ParameterType.Custom,     en = "Cost good 2",         de = "Kostenware 2" },</p><p>        { ParameterType.Number,     en = "Cost amount 2",         de = "Anzahl 2" },</p><p>        { ParameterType.Custom,     en = "Availability",         de = "Verfï¿½gbarkeit" },</p><p>    },</p><p>    return { Reward.Custom,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.ScriptName = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.Distance = _Parameter * 1</p><p>    elseif (_Index == 2) then</p><p>        self.Waittime = _Parameter * 1</p><p>    elseif (_Index == 3) then</p><p>        self.RewardType = _Parameter</p><p>    elseif (_Index == 4) then</p><p>        self.RewardAmount = _Parameter * 1</p><p>    elseif (_Index == 5) then</p><p>        self.FirstCostType = _Parameter</p><p>    elseif (_Index == 6) then</p><p>        self.FirstCostAmount = _Parameter * 1</p><p>    elseif (_Index == 7) then</p><p>        self.SecondCostType = _Parameter</p><p>    elseif (_Index == 8) then</p><p>        self.SecondCostAmount = _Parameter * 1</p><p>    elseif (_Index == 9) then</p><p>        local parameter = nil</p><p>        if _Parameter == "Always" or _Parameter == 1 then</p><p>            parameter = 1</p><p>        elseif _Parameter == "Never" or _Parameter == 2 then</p><p>            parameter = 2</p><p>        elseif _Parameter == "Knight only" or _Parameter == 0 then</p><p>            parameter = 0</p><p>        end</p><p>        self.UsingState = parameter</p><p>    end</p><p>    local eID = GetID(self.ScriptName);</p><p>    if eID == 0 then</p><p>        return;</p><p>    end</p><p>    QSB.InitalizedObjekts[eID] = _Quest.Identifier;</p><p>    Logic.InteractiveObjectClearCosts(eID);</p><p>    Logic.InteractiveObjectClearRewards(eID);</p><p>    Logic.InteractiveObjectSetInteractionDistance(eID, self.Distance);</p><p>    Logic.InteractiveObjectSetTimeToOpen(eID, self.Waittime);</p><p>    if self.RewardType and self.RewardType ~= "-" then</p><p>        Logic.InteractiveObjectAddRewards(eID, Goods[self.RewardType], self.RewardAmount);</p><p>    end</p><p>    if self.FirstCostType and self.FirstCostType ~= "-" then</p><p>        Logic.InteractiveObjectAddCosts(eID, Goods[self.FirstCostType], self.FirstCostAmount);</p><p>    end</p><p>    if self.SecondCostType and self.SecondCostType ~= "-" then</p><p>        Logic.InteractiveObjectAddCosts(eID, Goods[self.SecondCostType], self.SecondCostAmount);</p><p>    end</p><p>    Logic.InteractiveObjectSetAvailability(eID,true);</p><p>    if self.UsingState then</p><p>        for i=1, 8 do</p><p>            Logic.InteractiveObjectSetPlayerState(eID,i, self.UsingState);</p><p>        end</p><p>    end</p><p>    Logic.InteractiveObjectSetRewardResourceCartType(eID,Entities.U_ResourceMerchant);</p><p>    Logic.InteractiveObjectSetRewardGoldCartType(eID,Entities.U_GoldCart);</p><p>    Logic.InteractiveObjectSetCostResourceCartType(eID,Entities.U_ResourceMerchant);</p><p>    Logic.InteractiveObjectSetCostGoldCartType(eID, Entities.U_GoldCart);</p><p>    RemoveInteractiveObjectFromOpenedList(eID);</p><p>    table.insert(HiddenTreasures,eID);</p><p>    if _Index == 3 or _Index == 5 or _Index == 7 then</p><p>        local Data = {</p><p>            "-",</p><p>            "G_Beer",</p><p>            "G_Bread",</p><p>            "G_Broom",</p><p>            "G_Carcass",</p><p>            "G_Cheese",</p><p>            "G_Clothes",</p><p>            "G_Dye",</p><p>            "G_Gold",</p><p>            "G_Grain",</p><p>            "G_Herb",</p><p>            "G_Honeycomb",</p><p>            "G_Iron",</p><p>            "G_Leather",</p><p>            "G_Medicine",</p><p>            "G_Milk",</p><p>            "G_RawFish",</p><p>            "G_Salt",</p><p>            "G_Sausage",</p><p>            "G_SmokedFish",</p><p>            "G_Soap",</p><p>            "G_Stone",</p><p>            "G_Water",</p><p>            "G_Wood",</p><p>            "G_Wool",</p><p>        }</p><p>        if g_GameExtraNo = 1 then</p><p>            Data[#Data+1] = "G_Gems"</p><p>            Data[#Data+1] = "G_MusicalInstrument"</p><p>            Data[#Data+1] = "G_Olibanum"</p><p>        end</p><p>        return Data</p><p>    elseif _Index == 9 then</p><p>        return {"-", "Knight only", "Always", "Never",}</p><p>    end</p><p>    if Logic.IsInteractiveObject(GetID(self.ScriptName)) == false then</p><p>        fatal("".._Quest.Identifier.." "..self.Name..": '"..self.ScriptName.."' is not a interactive object!");</p><p>        return true;</p><p>    end</p><p>    if self.UsingState ~= 1 and self.Distance  50 then</p><p>        warn("".._Quest.Identifier.." "..self.Name..": distance is maybe too short!");</p><p>    end</p><p>    if self.Waittime  0 then</p><p>        fatal("".._Quest.Identifier.." "..self.Name..": waittime must be equal or greater than 0!");</p><p>        return true;</p><p>    end</p><p>    if self.RewardType and self.RewardType ~= "-" then</p><p>        if not Goods[self.RewardType] then</p><p>            fatal("".._Quest.Identifier.." "..self.Name..": '"..self.RewardType.."' is invalid good type!");</p><p>            return true;</p><p>        elseif self.RewardAmount  1 then</p><p>            fatal("".._Quest.Identifier.." "..self.Name..": amount can not be 0 or negative!");</p><p>            return true;</p><p>        end</p><p>    end</p><p>    if self.FirstCostType and self.FirstCostType ~= "-" then</p><p>        if not Goods[self.FirstCostType] then</p><p>            fatal("".._Quest.Identifier.." "..self.Name..": '"..self.FirstCostType.."' is invalid good type!");</p><p>            return true;</p><p>        elseif self.FirstCostAmount  1 then</p><p>            fatal("".._Quest.Identifier.." "..self.Name..": amount can not be 0 or negative!");</p><p>            return true;</p><p>        end</p><p>    end</p><p>    if self.SecondCostType and self.SecondCostType ~= "-" then</p><p>        if not Goods[self.SecondCostType] then</p><p>            fatal("".._Quest.Identifier.." "..self.Name..": '"..self.SecondCostType.."' is invalid good type!");</p><p>            return true;</p><p>        elseif self.SecondCostAmount  1 then</p><p>            fatal("".._Quest.Identifier.." "..self.Name..": amount can not be 0 or negative!");</p><p>            return true;</p><p>        end</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Änder den Diplomatiestatus zwischen zwei Spielern.</p><p>-- @param _Party1   ID der ersten Partei</p><p>-- @param _Party2   ID der zweiten Partei</p><p>-- @param _State    Neuer Diplomatiestatus</p><p>-- @within Reward</p><p>    return b_Reward_Diplomacy:new(...);</p><p>Reward_Diplomacy = API.InstanceTable(b_Reprisal_Diploma</p><p>Reward_Diplomacy.Name             = "Reward_Diploma</p><p>Reward_Diplomacy.Description.de   = "Reward: Sets Diplomacy state of two Players to a stated valu</p><p>Reward_Diplomacy.Description.en   = "Lohn: Setzt den Diplomatiestatus zweier Spieler auf den angegebenen Wer</p><p>Reward_Diplomacy.GetReprisalTable = </p><p>Reward_Diplomacy.GetRewardTable = function(self, _Qu</p><p>    return { Reward.Custom,{self, self.CustomFunction} }</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Verbessert die diplomatischen Beziehungen zwischen Sender und Empfänger</p><p>-- um einen Grad.</p><p>-- @within Reward</p><p>    return b_Reward_DiplomacyIncrease:new();</p><p>Reward_DiplomacyIncrease</p><p>    Name = "Reward_DiplomacyIncrease",</p><p>    Description = {</p><p>        en = "Reward: Diplomacy increases slightly to another player",</p><p>        de = "Lohn: Verbesserug des Diplomatiestatus zu einem anderen Spieler",</p><p>    },</p><p>    return { Reward.Custom,{self, self.CustomFunction} }</p><p>    local Sender = _Quest.SendingPlayer;</p><p>    local Receiver = _Quest.ReceivingPlayer;</p><p>    local State = GetDiplomacyState(Receiver, Sender);</p><p>    if State  2 then</p><p>        SetDiplomacyState(Receiver, Sender, State+1);</p><p>    end</p><p>    if (_Index == 0) then</p><p>        self.PlayerID = _Parameter * 1</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Erzeugt Handelsangebote im Lagerhaus des angegebenen Spielers.</p><p>-- Sollen Angebote gelöscht werden, muss "-" als Ware ausgewählt werden.</p><p>--  Stadtlagerhäuser können keine Söldner anbieten!</p><p>-- @param _PlayerID Partei, die Anbietet</p><p>-- @param _Amount1  Menge des 1. Angebot</p><p>-- @param _Type1    Ware oder Typ des 1. Angebot</p><p>-- @param _Amount2  Menge des 2. Angebot</p><p>-- @param _Type2    Ware oder Typ des 2. Angebot</p><p>-- @param _Amount3  Menge des 3. Angebot</p><p>-- @param _Type3    Ware oder Typ des 3. Angebot</p><p>-- @param _Amount4  Menge des 4. Angebot</p><p>-- @param _Type4    Ware oder Typ des 4. Angebot</p><p>-- @within Reward</p><p>    return b_Reward_TradeOffers:new(...);</p><p>Reward_TradeOffers</p><p>    Name = "Reward_TradeOffers",</p><p>    Description = {</p><p>        en = "Reward: Deletes all existing offers for a merchant and sets new offers, if given",</p><p>        de = "Lohn: Löscht alle Angebote eines Händlers und setzt neue, wenn angegeben",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Custom, en = "PlayerID", de = "PlayerID" },</p><p>        { ParameterType.Custom, en = "Amount 1", de = "Menge 1" },</p><p>        { ParameterType.Custom, en = "Offer 1", de = "Angebot 1" },</p><p>        { ParameterType.Custom, en = "Amount 2", de = "Menge 2" },</p><p>        { ParameterType.Custom, en = "Offer 2", de = "Angebot 2" },</p><p>        { ParameterType.Custom, en = "Amount 3", de = "Menge 3" },</p><p>        { ParameterType.Custom, en = "Offer 3", de = "Angebot 3" },</p><p>        { ParameterType.Custom, en = "Amount 4", de = "Menge 4" },</p><p>        { ParameterType.Custom, en = "Offer 4", de = "Angebot 4" },</p><p>    },</p><p>    return { Reward.Custom,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.PlayerID = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        _Parameter = _Parameter or 0;</p><p>        self.AmountOffer1 = _Parameter * 1;</p><p>    elseif (_Index == 2) then</p><p>        self.Offer1 = _Parameter</p><p>    elseif (_Index == 3) then</p><p>        _Parameter = _Parameter or 0;</p><p>        self.AmountOffer2 = _Parameter * 1;</p><p>    elseif (_Index == 4) then</p><p>        self.Offer2 = _Parameter</p><p>    elseif (_Index == 5) then</p><p>        _Parameter = _Parameter or 0;</p><p>        self.AmountOffer3 = _Parameter * 1;</p><p>    elseif (_Index == 6) then</p><p>        self.Offer3 = _Parameter</p><p>    elseif (_Index == 7) then</p><p>        _Parameter = _Parameter or 0;</p><p>        self.AmountOffer4 = _Parameter * 1;</p><p>    elseif (_Index == 8) then</p><p>        self.Offer4 = _Parameter</p><p>    end</p><p>    if (self.PlayerID  1) and (self.PlayerID  9) then</p><p>        local Storehouse = Logic.GetStoreHouse(self.PlayerID)</p><p>        Logic.RemoveAllOffers(Storehouse)</p><p>        for i =  1,4 do</p><p>            if self["Offer"..i] and self["Offer"..i] ~= "-" then</p><p>                if Goods[self["Offer"..i]] then</p><p>                    AddOffer(Storehouse, self["AmountOffer"..i], Goods[self["Offer"..i]])</p><p>                elseif Logic.IsEntityTypeInCategory(Entities[self["Offer"..i]], EntityCategories.Military) == 1 then</p><p>                    AddMercenaryOffer(Storehouse, self["AmountOffer"..i], Entities[self["Offer"..i]])</p><p>                else</p><p>                    AddEntertainerOffer (Storehouse , Entities[self["Offer"..i]])</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>    if Logic.GetStoreHouse(self.PlayerID ) == 0 then</p><p>        fatal(_Quest.Identifier .. ": Error in " .. self.Name .. ": Player " .. self.PlayerID .. " is dead. :-(")</p><p>        return true</p><p>    end</p><p>    local Players = { "2", "3", "4", "5", "6", "7", "8" }</p><p>    local Amount = { "1", "2", "3", "4", "5", "6", "7", "8", "9" }</p><p>    local Offers = {"-",</p><p>                    "G_Beer",</p><p>                    "G_Bow",</p><p>                    "G_Bread",</p><p>                    "G_Broom",</p><p>                    "G_Candle",</p><p>                    "G_Carcass",</p><p>                    "G_Cheese",</p><p>                    "G_Clothes",</p><p>                    "G_Cow",</p><p>                    "G_Grain",</p><p>                    "G_Herb",</p><p>                    "G_Honeycomb",</p><p>                    "G_Iron",</p><p>                    "G_Leather",</p><p>                    "G_Medicine",</p><p>                    "G_Milk",</p><p>                    "G_RawFish",</p><p>                    "G_Sausage",</p><p>                    "G_Sheep",</p><p>                    "G_SmokedFish",</p><p>                    "G_Soap",</p><p>                    "G_Stone",</p><p>                    "G_Sword",</p><p>                    "G_Wood",</p><p>                    "G_Wool",</p><p>                    "G_Salt",</p><p>                    "G_Dye",</p><p>                    "U_AmmunitionCart",</p><p>                    "U_BatteringRamCart",</p><p>                    "U_CatapultCart",</p><p>                    "U_SiegeTowerCart",</p><p>                    "U_MilitaryBandit_Melee_ME",</p><p>                    "U_MilitaryBandit_Melee_SE",</p><p>                    "U_MilitaryBandit_Melee_NA",</p><p>                    "U_MilitaryBandit_Melee_NE",</p><p>                    "U_MilitaryBandit_Ranged_ME",</p><p>                    "U_MilitaryBandit_Ranged_NA",</p><p>                    "U_MilitaryBandit_Ranged_NE",</p><p>                    "U_MilitaryBandit_Ranged_SE",</p><p>                    "U_MilitaryBow_RedPrince",</p><p>                    "U_MilitaryBow",</p><p>                    "U_MilitarySword_RedPrince",</p><p>                    "U_MilitarySword",</p><p>                    "U_Entertainer_NA_FireEater",</p><p>                    "U_Entertainer_NA_StiltWalker",</p><p>                    "U_Entertainer_NE_StrongestMan_Barrel",</p><p>                    "U_Entertainer_NE_StrongestMan_Stone",</p><p>                    }</p><p>    if g_GameExtraNo and g_GameExtraNo = 1 then</p><p>        table.insert(Offers, "G_Gems")</p><p>        table.insert(Offers, "G_Olibanum")</p><p>        table.insert(Offers, "G_MusicalInstrument")</p><p>        table.insert(Offers, "G_MilitaryBandit_Ranged_AS")</p><p>        table.insert(Offers, "G_MilitaryBandit_Melee_AS")</p><p>        table.insert(Offers, "U_MilitarySword_Khana")</p><p>        table.insert(Offers, "U_MilitaryBow_Khana")</p><p>    end</p><p>    if (_Index == 0) then</p><p>        return Players</p><p>    elseif (_Index == 1) or (_Index == 3) or (_Index == 5) or (_Index == 7) then</p><p>        return Amount</p><p>    elseif (_Index == 2) or (_Index == 4) or (_Index == 6) or (_Index == 8) then</p><p>        return Offers</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ein benanntes Entity wird entfernt.</p><p>-- : Das Entity wird durch ein XD_ScriptEntity ersetzt. Es</p><p>-- behält Name, Besitzer und Ausrichtung.</p><p>-- @param _ScriptName Skriptname des Entity</p><p>-- @within Reward</p><p>    return b_Reward_DestroyEntity:new(...);</p><p>Reward_DestroyEntity = API.InstanceTable(b_Reprisal_DestroyEnti</p><p>Reward_DestroyEntity.Name = "Reward_DestroyEnti</p><p>Reward_DestroyEntity.Description.en = "Reward: Replaces an entity with an invisible script entity, which retains the entities nam</p><p>Reward_DestroyEntity.Description.de = "Lohn: Ersetzt eine Entity mit einer unsichtbaren Script-Entity, die den Namen übernimm</p><p>Reward_DestroyEntity.GetReprisalTable = </p><p>Reward_DestroyEntity.GetRewardTable = function(self, _Qu</p><p>    return { Reward.Custom,{self, self.CustomFunction} }</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Zerstört einen über ein Behavior erzeugten Effekt.</p><p>-- @param _EffectName Name des Effekts</p><p>-- @within Reward</p><p>    return b_Reward_DestroyEffect:new(...);</p><p>Reward_DestroyEffect = API.InstanceTable(b_Reprisal_DestroyEffe</p><p>Reward_DestroyEffect.Name = "Reward_DestroyEffe</p><p>Reward_DestroyEffect.Description.en = "Reward: Destroys an effec</p><p>Reward_DestroyEffect.Description.de = "Lohn: Zerstört einen Effek</p><p>Reward_DestroyEffect.GetReprisalTable = </p><p>Reward_DestroyEffect.GetRewardTable = function(self, _Qu</p><p>    return { Reward.Custom, { self, self.CustomFunction } };</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ersetzt ein Entity mit einem Batallion.</p><p>-- Ist die Position ein Gebäude, werden die Battalione am Eingang erzeugt und</p><p>-- Das Entity wird nicht ersetzt.</p><p>-- Das erzeugte Battalion kann vor der KI des Besitzers versteckt werden.</p><p>-- @param _Position    Skriptname des Entity</p><p>-- @param _PlayerID    PlayerID des Battalion</p><p>-- @param _UnitType    Einheitentyp der Soldaten</p><p>-- @param _Orientation Ausrichtung in °</p><p>-- @param _Soldiers    Anzahl an Soldaten</p><p>-- @param _HideFromAI  Vor KI verstecken</p><p>-- @within Reward</p><p>    return b_Reward_CreateBattalion:new(...);</p><p>Reward_CreateBattalion</p><p>    Name = "Reward_CreateBattalion",</p><p>    Description = {</p><p>        en = "Reward: Replaces a script entity with a battalion, which retains the entities name",</p><p>        de = "Lohn: Ersetzt eine Script-Entity durch ein Bataillon, welches den Namen der Script-Entity übernimmt",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Script entity", de = "Script Entity" },</p><p>        { ParameterType.PlayerID, en = "Player", de = "Spieler" },</p><p>        { ParameterType.Custom, en = "Type name", de = "Typbezeichnung" },</p><p>        { ParameterType.Number, en = "Orientation (in degrees)", de = "Ausrichtung (in Grad)" },</p><p>        { ParameterType.Number, en = "Number of soldiers", de = "Anzahl Soldaten" },</p><p>        { ParameterType.Custom, en = "Hide from AI", de = "Vor KI verstecken" },</p><p>    },</p><p>    return { Reward.Custom,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.ScriptNameEntity = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.PlayerID = _Parameter * 1</p><p>    elseif (_Index == 2) then</p><p>        self.UnitKey = _Parameter</p><p>    elseif (_Index == 3) then</p><p>        self.Orientation = _Parameter * 1</p><p>    elseif (_Index == 4) then</p><p>        self.SoldierCount = _Parameter * 1</p><p>    elseif (_Index == 5) then</p><p>        self.HideFromAI = AcceptAlternativeBoolean(_Parameter)</p><p>    end</p><p>    if not IsExisting( self.ScriptNameEntity ) then</p><p>        return false</p><p>    end</p><p>    local pos = GetPosition(self.ScriptNameEntity)</p><p>    local NewID = Logic.CreateBattalionOnUnblockedLand( Entities[self.UnitKey], pos.X, pos.Y, self.Orientation, self.PlayerID, self.SoldierCount )</p><p>    local posID = GetID(self.ScriptNameEntity)</p><p>    if Logic.IsBuilding(posID) == 0 then</p><p>        DestroyEntity(self.ScriptNameEntity)</p><p>        Logic.SetEntityName( NewID, self.ScriptNameEntity )</p><p>    end</p><p>    if self.HideFromAI then</p><p>        AICore.HideEntityFromAI( self.PlayerID, NewID, true )</p><p>    end</p><p>    local Data = {}</p><p>    if _Index == 2 then</p><p>        for k, v in pairs( Entities ) do</p><p>            if Logic.IsEntityTypeInCategory( v, EntityCategories.Soldier ) == 1 then</p><p>                table.insert( Data, k )</p><p>            end</p><p>        end</p><p>        table.sort( Data )</p><p>    elseif _Index == 5 then</p><p>        table.insert( Data, "false" )</p><p>        table.insert( Data, "true" )</p><p>    else</p><p>        assert( false )</p><p>    end</p><p>    return Data</p><p>    if not Entities[self.UnitKey] then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": got an invalid entity type!");</p><p>        return true;</p><p>    elseif not IsExisting(self.ScriptNameEntity) then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": spawnpoint does not exist!");</p><p>        return true;</p><p>    elseif tonumber(self.PlayerID) == nil or self.PlayerID  8 then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": playerID is wrong!");</p><p>        return true;</p><p>    elseif tonumber(self.Orientation) == nil then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": orientation must be a number!");</p><p>        return true;</p><p>    elseif tonumber(self.SoldierCount) == nil or self.SoldierCount  1 then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": you can not create a empty batallion!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Erzeugt eine Menga von Battalionen an der Position.</p><p>-- Die erzeugten Battalione können vor der KI ihres Besitzers versteckt werden.</p><p>-- @param _Amount      Anzahl erzeugter Battalione</p><p>-- @param _Position    Skriptname des Entity</p><p>-- @param _PlayerID    PlayerID des Battalion</p><p>-- @param _UnitType    Einheitentyp der Soldaten</p><p>-- @param _Orientation Ausrichtung in °</p><p>-- @param _Soldiers    Anzahl an Soldaten</p><p>-- @param _HideFromAI  Vor KI verstecken</p><p>-- @within Reward</p><p>    return b_Reward_CreateSeveralBattalions:new(...);</p><p>Reward_CreateSeveralBattalions</p><p>    Name = "Reward_CreateSeveralBattalions",</p><p>    Description = {</p><p>        en = "Reward: Creates a given amount of battalions",</p><p>        de = "Lohn: Erstellt eine gegebene Anzahl Bataillone",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Number, en = "Amount", de = "Anzahl" },</p><p>        { ParameterType.ScriptName, en = "Script entity", de = "Script Entity" },</p><p>        { ParameterType.PlayerID, en = "Player", de = "Spieler" },</p><p>        { ParameterType.Custom, en = "Type name", de = "Typbezeichnung" },</p><p>        { ParameterType.Number, en = "Orientation (in degrees)", de = "Ausrichtung (in Grad)" },</p><p>        { ParameterType.Number, en = "Number of soldiers", de = "Anzahl Soldaten" },</p><p>        { ParameterType.Custom, en = "Hide from AI", de = "Vor KI verstecken" },</p><p>    },</p><p>    return { Reward.Custom,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.Amount = _Parameter * 1</p><p>    elseif (_Index == 1) then</p><p>        self.ScriptNameEntity = _Parameter</p><p>    elseif (_Index == 2) then</p><p>        self.PlayerID = _Parameter * 1</p><p>    elseif (_Index == 3) then</p><p>        self.UnitKey = _Parameter</p><p>    elseif (_Index == 4) then</p><p>        self.Orientation = _Parameter * 1</p><p>    elseif (_Index == 5) then</p><p>        self.SoldierCount = _Parameter * 1</p><p>    elseif (_Index == 6) then</p><p>        self.HideFromAI = AcceptAlternativeBoolean(_Parameter)</p><p>    end</p><p>    if not IsExisting( self.ScriptNameEntity ) then</p><p>        return false</p><p>    end</p><p>    local tID = GetID(self.ScriptNameEntity)</p><p>    local x,y,z = Logic.EntityGetPos(tID);</p><p>    if Logic.IsBuilding(tID) == 1 then</p><p>        x,y = Logic.GetBuildingApproachPosition(tID)</p><p>    end</p><p>    for i=1, self.Amount do</p><p>        local NewID = Logic.CreateBattalionOnUnblockedLand( Entities[self.UnitKey], x, y, self.Orientation, self.PlayerID, self.SoldierCount )</p><p>        Logic.SetEntityName( NewID, self.ScriptNameEntity .. "_" .. i )</p><p>        if self.HideFromAI then</p><p>            AICore.HideEntityFromAI( self.PlayerID, NewID, true )</p><p>        end</p><p>    end</p><p>    local Data = {}</p><p>    if _Index == 3 then</p><p>        for k, v in pairs( Entities ) do</p><p>            if Logic.IsEntityTypeInCategory( v, EntityCategories.Soldier ) == 1 then</p><p>                table.insert( Data, k )</p><p>            end</p><p>        end</p><p>        table.sort( Data )</p><p>    elseif _Index == 6 then</p><p>        table.insert( Data, "false" )</p><p>        table.insert( Data, "true" )</p><p>    else</p><p>        assert( false )</p><p>    end</p><p>    return Data</p><p>    if not Entities[self.UnitKey] then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": got an invalid entity type!");</p><p>        return true;</p><p>    elseif not IsExisting(self.ScriptNameEntity) then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": spawnpoint does not exist!");</p><p>        return true;</p><p>    elseif tonumber(self.PlayerID) == nil or self.PlayerID  8 then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": playerDI is wrong!");</p><p>        return true;</p><p>    elseif tonumber(self.Orientation) == nil then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": orientation must be a number!");</p><p>        return true;</p><p>    elseif tonumber(self.SoldierCount) == nil or self.SoldierCount  1 then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": you can not create a empty batallion!");</p><p>        return true;</p><p>    elseif tonumber(self.Amount) == nil or self.Amount  0 then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": amount can not be negative!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Erzeugt einen Effekt an der angegebenen Position.</p><p>-- Der Effekt kann über seinen Namen jeder Zeit gelöscht werden.</p><p>-- : Feuereffekte sind bekannt dafür Abstürzue zu verursachen.</p><p>-- Vermeide sie entweder ganz oder unterbinde das Speichern, solange ein</p><p>-- solcher Effekt aktiv ist!</p><p>-- @param _EffectName  Einzigartiger Effektname</p><p>-- @param _TypeName    Typ des Effekt</p><p>-- @param _PlayerID    PlayerID des Effekt</p><p>-- @param _Location    Position des Effekt</p><p>-- @param _Orientation Ausrichtung in °</p><p>-- @within Reward</p><p>    return b_Reward_CreateEffect:new(...);</p><p>Reward_CreateEffect</p><p>    Name = "Reward_CreateEffect",</p><p>    Description = {</p><p>        en = "Reward: Creates an effect at a specified position",</p><p>        de = "Lohn: Erstellt einen Effekt an der angegebenen Position",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Default,    en = "Effect name", de = "Effektname" },</p><p>        { ParameterType.Custom,     en = "Type name", de = "Typbezeichnung" },</p><p>        { ParameterType.PlayerID,   en = "Player", de = "Spieler" },</p><p>        { ParameterType.ScriptName, en = "Location", de = "Ort" },</p><p>        { ParameterType.Number,     en = "Orientation (in degrees)(-1: from locating entity)", de = "Ausrichtung (in Grad)(-1: von Positionseinheit)" },</p><p>    }</p><p>    if _Index == 0 then</p><p>        self.EffectName = _Parameter;</p><p>    elseif _Index == 1 then</p><p>        self.Type = EGL_Effects[_Parameter];</p><p>    elseif _Index == 2 then</p><p>        self.PlayerID = _Parameter * 1;</p><p>    elseif _Index == 3 then</p><p>        self.Location = _Parameter;</p><p>    elseif _Index == 4 then</p><p>        self.Orientation = _Parameter * 1;</p><p>    end</p><p>    return { Reward.Custom, { self, self.CustomFunction } };</p><p>    if Logic.IsEntityDestroyed(self.Location) then</p><p>        return;</p><p>    end</p><p>    local entity = assert(GetID(self.Location), _Quest.Identifier .. "Error in " .. self.Name .. ": CustomFunction: Entity is invalid");</p><p>    if QSB.EffectNameToID[self.EffectName] and Logic.IsEffectRegistered(QSB.EffectNameToID[self.EffectName]) then</p><p>        return;</p><p>    end</p><p>    local posX, posY = Logic.GetEntityPosition(entity);</p><p>    local orientation = tonumber(self.Orientation);</p><p>    local effect = Logic.CreateEffectWithOrientation(self.Type, posX, posY, orientation, self.PlayerID);</p><p>    if self.EffectName ~= "" then</p><p>        QSB.EffectNameToID[self.EffectName] = effect;</p><p>    end</p><p>    if QSB.EffectNameToID[self.EffectName] and Logic.IsEffectRegistered(QSB.EffectNameToID[self.EffectName]) then</p><p>        fatal("".._Quest.Identifier.." "..self.Name..": effect already exists!");</p><p>        return true;</p><p>    elseif not IsExisting(self.Location) then</p><p>        fatal("".._Quest.Identifier.." "..self.Name..": location '" ..self.Location.. "' is missing!");</p><p>        return true;</p><p>    elseif self.PlayerID and (self.PlayerID  8) then</p><p>        fatal("".._Quest.Identifier.." "..self.Name..": invalid playerID!");</p><p>        return true;</p><p>    elseif tonumber(self.Orientation) == nil then</p><p>        fatal("".._Quest.Identifier.." "..self.Name..": invalid orientation!");</p><p>        return true;</p><p>    end</p><p>    assert(_Index == 1, "Error in " .. self.Name .. ": GetCustomData: Index is invalid.");</p><p>    local types = {};</p><p>    for k, v in pairs(EGL_Effects) do</p><p>        table.insert(types, k);</p><p>    end</p><p>    table.sort(types);</p><p>    return types;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ersetzt ein Entity mit dem Skriptnamen durch ein neues Entity.</p><p>-- Ist die Position ein Gebäude, werden die Entities am Eingang erzeugt und</p><p>-- die Position wird nicht ersetzt.</p><p>-- Das erzeugte Entity kann vor der KI des Besitzers versteckt werden.</p><p>-- @param _ScriptName  Skriptname des Entity</p><p>-- @param _PlayerID    PlayerID des Effekt</p><p>-- @param _TypeName    Typname des Entity</p><p>-- @param _Orientation Ausrichtung in °</p><p>-- @param _HideFromAI  Vor KI verstecken</p><p>-- @within Reward</p><p>    return b_Reward_CreateEntity:new(...);</p><p>Reward_CreateEntity</p><p>    Name = "Reward_CreateEntity",</p><p>    Description = {</p><p>        en = "Reward: Replaces an entity by a new one of a given type",</p><p>        de = "Lohn: Ersetzt eine Entity durch eine neue gegebenen Typs",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Script entity", de = "Script Entity" },</p><p>        { ParameterType.PlayerID, en = "Player", de = "Spieler" },</p><p>        { ParameterType.Custom, en = "Type name", de = "Typbezeichnung" },</p><p>        { ParameterType.Number, en = "Orientation (in degrees)", de = "Ausrichtung (in Grad)" },</p><p>        { ParameterType.Custom, en = "Hide from AI", de = "Vor KI verstecken" },</p><p>    },</p><p>    return { Reward.Custom,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.ScriptNameEntity = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.PlayerID = _Parameter * 1</p><p>    elseif (_Index == 2) then</p><p>        self.UnitKey = _Parameter</p><p>    elseif (_Index == 3) then</p><p>        self.Orientation = _Parameter * 1</p><p>    elseif (_Index == 4) then</p><p>        self.HideFromAI = AcceptAlternativeBoolean(_Parameter)</p><p>    end</p><p>    if not IsExisting( self.ScriptNameEntity ) then</p><p>        return false</p><p>    end</p><p>    local pos = GetPosition(self.ScriptNameEntity)</p><p>    local NewID;</p><p>    if Logic.IsEntityTypeInCategory( self.UnitKey, EntityCategories.Soldier ) == 1 then</p><p>        NewID       = Logic.CreateBattalionOnUnblockedLand( Entities[self.UnitKey], pos.X, pos.Y, self.Orientation, self.PlayerID, 1 )</p><p>        local l,s = {Logic.GetSoldiersAttachedToLeader(NewID)}</p><p>        Logic.SetOrientation(s,self.Orientation)</p><p>    else</p><p>        NewID = Logic.CreateEntityOnUnblockedLand( Entities[self.UnitKey], pos.X, pos.Y, self.Orientation, self.PlayerID )</p><p>    end</p><p>    local posID = GetID(self.ScriptNameEntity)</p><p>    if Logic.IsBuilding(posID) == 0 then</p><p>        DestroyEntity(self.ScriptNameEntity)</p><p>        Logic.SetEntityName( NewID, self.ScriptNameEntity )</p><p>    end</p><p>    if self.HideFromAI then</p><p>        AICore.HideEntityFromAI( self.PlayerID, NewID, true )</p><p>    end</p><p>    local Data = {}</p><p>    if _Index == 2 then</p><p>        for k, v in pairs( Entities ) do</p><p>            local name = {"^M_*","^XS_*","^X_*","^XT_*","^Z_*"}</p><p>            local found = false;</p><p>            for i=1,#name do</p><p>                if k:find(name[i]) then</p><p>                    found = true;</p><p>                    break;</p><p>                end</p><p>            end</p><p>            if not found then</p><p>                table.insert( Data, k );</p><p>            end</p><p>        end</p><p>        table.sort( Data )</p><p>    elseif _Index == 4 or _Index == 5 then</p><p>        table.insert( Data, "false" )</p><p>        table.insert( Data, "true" )</p><p>    else</p><p>        assert( false )</p><p>    end</p><p>    return Data</p><p>    if not Entities[self.UnitKey] then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": got an invalid entity type!");</p><p>        return true;</p><p>    elseif not IsExisting(self.ScriptNameEntity) then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": spawnpoint does not exist!");</p><p>        return true;</p><p>    elseif tonumber(self.PlayerID) == nil or self.PlayerID  8 then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": playerID is not valid!");</p><p>        return true;</p><p>    elseif tonumber(self.Orientation) == nil then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": orientation must be a number!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Erzeugt mehrere Entities an der angegebenen Position.</p><p>-- Die erzeugten Entities können vor der KI ihres Besitzers versteckt werden.</p><p>-- @param _Amount      Anzahl an Entities</p><p>-- @param _ScriptName  Skriptname des Entity</p><p>-- @param _PlayerID    PlayerID des Effekt</p><p>-- @param _TypeName    Einzigartiger Effektname</p><p>-- @param _Orientation Ausrichtung in °</p><p>-- @param _HideFromAI  Vor KI verstecken</p><p>-- @within Reward</p><p>    return b_Reward_CreateSeveralEntities:new(...);</p><p>Reward_CreateSeveralEntities</p><p>    Name = "Reward_CreateSeveralEntities",</p><p>    Description = {</p><p>        en = "Reward: Creating serveral battalions at the position of a entity. They retains the entities name and a _[index] suffix",</p><p>        de = "Lohn: Erzeugt mehrere Entities an der Position der Entity. Sie übernimmt den Namen der Script Entity und den Suffix _[index]",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Number, en = "Amount", de = "Anzahl" },</p><p>        { ParameterType.ScriptName, en = "Script entity", de = "Script Entity" },</p><p>        { ParameterType.PlayerID, en = "Player", de = "Spieler" },</p><p>        { ParameterType.Custom, en = "Type name", de = "Typbezeichnung" },</p><p>        { ParameterType.Number, en = "Orientation (in degrees)", de = "Ausrichtung (in Grad)" },</p><p>        { ParameterType.Custom, en = "Hide from AI", de = "Vor KI verstecken" },</p><p>    },</p><p>    return { Reward.Custom,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.Amount = _Parameter * 1</p><p>    elseif (_Index == 1) then</p><p>        self.ScriptNameEntity = _Parameter</p><p>    elseif (_Index == 2) then</p><p>        self.PlayerID = _Parameter * 1</p><p>    elseif (_Index == 3) then</p><p>        self.UnitKey = _Parameter</p><p>    elseif (_Index == 4) then</p><p>        self.Orientation = _Parameter * 1</p><p>    elseif (_Index == 5) then</p><p>        self.HideFromAI = AcceptAlternativeBoolean(_Parameter)</p><p>    end</p><p>    if not IsExisting( self.ScriptNameEntity ) then</p><p>        return false</p><p>    end</p><p>    local pos = GetPosition(self.ScriptNameEntity)</p><p>    local NewID;</p><p>    for i=1, self.Amount do</p><p>        if Logic.IsEntityTypeInCategory( self.UnitKey, EntityCategories.Soldier ) == 1 then</p><p>            NewID       = Logic.CreateBattalionOnUnblockedLand( Entities[self.UnitKey], pos.X, pos.Y, self.Orientation, self.PlayerID, 1 )</p><p>            local l,s = {Logic.GetSoldiersAttachedToLeader(NewID)}</p><p>            Logic.SetOrientation(s,self.Orientation)</p><p>        else</p><p>            NewID = Logic.CreateEntityOnUnblockedLand( Entities[self.UnitKey], pos.X, pos.Y, self.Orientation, self.PlayerID )</p><p>        end</p><p>        Logic.SetEntityName( NewID, self.ScriptNameEntity .. "_" .. i )</p><p>        if self.HideFromAI then</p><p>            AICore.HideEntityFromAI( self.PlayerID, NewID, true )</p><p>        end</p><p>    end</p><p>    local Data = {}</p><p>    if _Index == 3 then</p><p>        for k, v in pairs( Entities ) do</p><p>            local name = {"^M_*","^XS_*","^X_*","^XT_*","^Z_*"}</p><p>            local found = false;</p><p>            for i=1,#name do</p><p>                if k:find(name[i]) then</p><p>                    found = true;</p><p>                    break;</p><p>                end</p><p>            end</p><p>            if not found then</p><p>                table.insert( Data, k );</p><p>            end</p><p>        end</p><p>        table.sort( Data )</p><p>    elseif _Index == 5 or _Index == 6 then</p><p>        table.insert( Data, "false" )</p><p>        table.insert( Data, "true" )</p><p>    else</p><p>        assert( false )</p><p>    end</p><p>    return Data</p><p>    if not Entities[self.UnitKey] then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": got an invalid entity type!");</p><p>        return true;</p><p>    elseif not IsExisting(self.ScriptNameEntity) then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": spawnpoint does not exist!");</p><p>        return true;</p><p>    elseif tonumber(self.PlayerID) == nil or self.PlayerID  8 then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": spawnpoint does not exist!");</p><p>        return true;</p><p>    elseif tonumber(self.Orientation) == nil then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": orientation must be a number!");</p><p>        return true;</p><p>    elseif tonumber(self.Amount) == nil or self.Amount  0 then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": amount can not be negative!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Bewegt einen Siedler, einen Helden oder ein Battalion zum angegebenen </p><p>-- Zielort.</p><p>-- @param _Settler     Einheit, die bewegt wird</p><p>-- @param _Destination Bewegungsziel</p><p>-- @within Reward</p><p>    return b_Reward_MoveSettler:new(...);</p><p>Reward_MoveSettler</p><p>    Name = "Reward_MoveSettler",</p><p>    Description = {</p><p>        en = "Reward: Moves a (NPC) settler to a destination. Must not be AI controlled, or it won't move",</p><p>        de = "Lohn: Bewegt einen (NPC) Siedler zu einem Zielort. Darf keinem KI Spieler gehören, ansonsten wird sich der Siedler nicht bewegen",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Settler", de = "Siedler" },</p><p>        { ParameterType.ScriptName, en = "Destination", de = "Ziel" },</p><p>    },</p><p>    return { Reward.Custom,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.ScriptNameUnit = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.ScriptNameDest = _Parameter</p><p>    end</p><p>    if Logic.IsEntityDestroyed( self.ScriptNameUnit ) or Logic.IsEntityDestroyed( self.ScriptNameDest ) then</p><p>        return false</p><p>    end</p><p>    local DestID = GetID( self.ScriptNameDest )</p><p>    local DestX, DestY = Logic.GetEntityPosition( DestID )</p><p>    if Logic.IsBuilding( DestID ) == 1 then</p><p>        DestX, DestY = Logic.GetBuildingApproachPosition( DestID )</p><p>    end</p><p>    Logic.MoveSettler( GetID( self.ScriptNameUnit ), DestX, DestY )</p><p>    if not IsExisting(self.ScriptNameUnit) then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": mover entity does not exist!");</p><p>        return true;</p><p>    elseif not IsExisting(self.ScriptNameDest) then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": destination does not exist!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der Spieler gewinnt das Spiel.</p><p>-- @within Reward</p><p>    return b_Reward_Victory:new()</p><p>Reward_Victory</p><p>    Name = "Reward_Victory",</p><p>    Description = {</p><p>        en = "Reward: The player wins the game.",</p><p>        de = "Lohn: Der Spieler gewinnt das Spiel.",</p><p>    },</p><p>    return {Reward.Victory};</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der Spieler verliert das Spiel.</p><p>-- @within Reward</p><p>    return b_Reward_Defeat:new()</p><p>Reward_Defeat</p><p>    Name = "Reward_Defeat",</p><p>    Description = {</p><p>        en = "Reward: The player loses the game.",</p><p>        de = "Lohn: Der Spieler verliert das Spiel.",</p><p>    },</p><p>    return { Reward.Custom, {self, self.CustomFunction} }</p><p>    _Quest:TerminateEventsAndStuff()</p><p>    Logic.ExecuteInLuaLocalState("GUI_Window.MissionEndScreenSetVictoryReasonText(".. g_VictoryAndDefeatType.DefeatMissionFailed ..")")</p><p>    Defeated(_Quest.ReceivingPlayer)</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Zeigt die Siegdekoration an dem Quest an.</p><p>-- Dies ist reine Optik! Der Spieler wird dadurch nicht das Spiel gewinnen.</p><p>-- @within Reward</p><p>    return b_Reward_FakeVictory:new();</p><p>Reward_FakeVictory</p><p>    Name = "Reward_FakeVictory",</p><p>    Description = {</p><p>        en = "Reward: Display a victory icon for a quest",</p><p>        de = "Lohn: Zeigt ein Siegesicon fuer diese Quest",</p><p>    },</p><p>    return { Reward.FakeVictory }</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Erzeugt eine Armee, die das angegebene Territorium angreift.</p><p>-- Die Armee wird versuchen Gebäude auf dem Territrium zu zerstören.</p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- @param _PlayerID   PlayerID der Angreifer</p><p>-- @param _SpawnPoint Skriptname des Entstehungspunkt</p><p>-- @param _Territory  Zielterritorium</p><p>-- @param _Sword      Anzahl Schwertkämpfer (Battalion)</p><p>-- @param _Bow        Anzahl Bogenschützen (Battalion)</p><p>-- @param _Cata       Anzahl Katapulte</p><p>-- @param _Towers     Anzahl Belagerungstürme</p><p>-- @param _Rams       Anzahl Rammen</p><p>-- @param _Ammo       Anzahl Munitionswagen</p><p>-- @param _Type       Typ der Soldaten</p><p>-- @param _Reuse      Freie Truppen wiederverwenden</p><p>-- @within Reward</p><p>    return b_Reward_AI_SpawnAndAttackTerritory:new(...);</p><p>Reward_AI_SpawnAndAttackTerritory</p><p>    Name = "Reward_AI_SpawnAndAttackTerritory",</p><p>    Description = {</p><p>        en = "Reward: Spawns AI troops and attacks a territory (Hint: Use for hidden quests as a surprise)",</p><p>        de = "Lohn: Erstellt KI Truppen und greift ein Territorium an (Tipp: Fuer eine versteckte Quest als Ueberraschung verwenden)",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.PlayerID, en = "AI Player", de = "KI Spieler" },</p><p>        { ParameterType.ScriptName, en = "Spawn point", de = "Erstellungsort" },</p><p>        { ParameterType.TerritoryName, en = "Territory", de = "Territorium" },</p><p>        { ParameterType.Number, en = "Sword", de = "Schwert" },</p><p>        { ParameterType.Number, en = "Bow", de = "Bogen" },</p><p>        { ParameterType.Number, en = "Catapults", de = "Katapulte" },</p><p>        { ParameterType.Number, en = "Siege towers", de = "Belagerungstuerme" },</p><p>        { ParameterType.Number, en = "Rams", de = "Rammen" },</p><p>        { ParameterType.Number, en = "Ammo carts", de = "Munitionswagen" },</p><p>        { ParameterType.Custom, en = "Soldier type", de = "Soldatentyp" },</p><p>        { ParameterType.Custom, en = "Reuse troops", de = "Verwende bestehende Truppen" },</p><p>    },</p><p>    return { Reward.Custom,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.AIPlayerID = _Parameter * 1</p><p>    elseif (_Index == 1) then</p><p>        self.Spawnpoint = _Parameter</p><p>    elseif (_Index == 2) then</p><p>        self.TerritoryID = tonumber(_Parameter)</p><p>        if not self.TerritoryID then</p><p>            self.TerritoryID = GetTerritoryIDByName(_Parameter)</p><p>        end</p><p>    elseif (_Index == 3) then</p><p>        self.NumSword = _Parameter * 1</p><p>    elseif (_Index == 4) then</p><p>        self.NumBow = _Parameter * 1</p><p>    elseif (_Index == 5) then</p><p>        self.NumCatapults = _Parameter * 1</p><p>    elseif (_Index == 6) then</p><p>        self.NumSiegeTowers = _Parameter * 1</p><p>    elseif (_Index == 7) then</p><p>        self.NumRams = _Parameter * 1</p><p>    elseif (_Index == 8) then</p><p>        self.NumAmmoCarts = _Parameter * 1</p><p>    elseif (_Index == 9) then</p><p>        if _Parameter == "Normal" or _Parameter == false then</p><p>            self.TroopType = false</p><p>        elseif _Parameter == "RedPrince" or _Parameter == true then</p><p>            self.TroopType = true</p><p>        elseif _Parameter == "Bandit" or _Parameter == 2 then</p><p>            self.TroopType = 2</p><p>        elseif _Parameter == "Cultist" or _Parameter == 3 then</p><p>            self.TroopType = 3</p><p>        else</p><p>            assert(false)</p><p>        end</p><p>    elseif (_Index == 10) then</p><p>        self.ReuseTroops = AcceptAlternativeBoolean(_Parameter)</p><p>    end</p><p>    local Data = {}</p><p>    if _Index == 9 then</p><p>        table.insert( Data, "Normal" )</p><p>        table.insert( Data, "RedPrince" )</p><p>        table.insert( Data, "Bandit" )</p><p>        if g_GameExtraNo = 1 then</p><p>            table.insert( Data, "Cultist" )</p><p>        end</p><p>    elseif _Index == 10 then</p><p>        table.insert( Data, "false" )</p><p>        table.insert( Data, "true" )</p><p>    else</p><p>        assert( false )</p><p>    end</p><p>    return Data</p><p>    local TargetID = Logic.GetTerritoryAcquiringBuildingID( self.TerritoryID )</p><p>    if TargetID ~= 0 then</p><p>        AIScript_SpawnAndAttackCity( self.AIPlayerID, TargetID, self.Spawnpoint, self.NumSword, self.NumBow, self.NumCatapults, self.NumSiegeTowers, self.NumRams, self.NumAmmoCarts, self.TroopType, self.ReuseTroops)</p><p>    end</p><p>    if self.AIPlayerID  2 then</p><p>        fatal(_Quest.Identifier .. ": Error in " .. self.Name .. ": Player " .. self.AIPlayerID .. " is wrong")</p><p>        return true</p><p>    elseif Logic.IsEntityDestroyed(self.Spawnpoint) then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": Entity " .. self.SpawnPoint .. " is missing")</p><p>        return true</p><p>    elseif self.TerritoryID == 0 then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": Territory unknown")</p><p>        return true</p><p>    elseif self.NumSword  0 then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": Number of Swords is negative")</p><p>        return true</p><p>    elseif self.NumBow  0 then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": Number of Bows is negative")</p><p>        return true</p><p>    elseif self.NumBow + self.NumSword  1 then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": No Soldiers?")</p><p>        return true</p><p>    elseif self.NumCatapults  0 then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": Catapults is negative")</p><p>        return true</p><p>    elseif self.NumSiegeTowers  0 then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": SiegeTowers is negative")</p><p>        return true</p><p>    elseif self.NumRams  0 then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": Rams is negative")</p><p>        return true</p><p>    elseif self.NumAmmoCarts  0 then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": AmmoCarts is negative")</p><p>        return true</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Erzeugt eine Armee, die sich zum Zielpunkt bewegt und das Gebiet angreift.</p><p>-- Dabei werden die Soldaten alle erreichbaren Gebäude in Brand stecken. Ist</p><p>-- Das Zielgebiet eingemauert, können die Soldaten nicht angreifen und werden</p><p>-- sich zurückziehen.</p><p>-- @param _PlayerID   PlayerID des Angreifers</p><p>-- @param _SpawnPoint Skriptname des Entstehungspunktes</p><p>-- @param _Target     Skriptname des Ziels</p><p>-- @param _Radius     Aktionsradius um das Ziel</p><p>-- @param _Sword      Anzahl Schwertkämpfer (Battalione)</p><p>-- @param _Bow        Anzahl Bogenschützen (Battalione)</p><p>-- @param _Soldier    Typ der Soldaten</p><p>-- @param _Reuse      Freie Truppen wiederverwenden</p><p>-- @within Reward</p><p>    return b_Reward_AI_SpawnAndAttackArea:new(...);</p><p>Reward_AI_SpawnAndAttackArea</p><p>    Name = "Reward_AI_SpawnAndAttackArea",</p><p>    Description = {</p><p>        en = "Reward: Spawns AI troops and attacks everything within the specified area, except the players main buildings",</p><p>        de = "Lohn: Erstellt KI Truppen und greift ein angegebenes Gebiet an, aber nicht die Hauptgebauede eines Spielers",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.PlayerID, en = "AI Player", de = "KI Spieler" },</p><p>        { ParameterType.ScriptName, en = "Spawn point", de = "Erstellungsort" },</p><p>        { ParameterType.ScriptName, en = "Target", de = "Ziel" },</p><p>        { ParameterType.Number, en = "Radius", de = "Radius" },</p><p>        { ParameterType.Number, en = "Sword", de = "Schwert" },</p><p>        { ParameterType.Number, en = "Bow", de = "Bogen" },</p><p>        { ParameterType.Custom, en = "Soldier type", de = "Soldatentyp" },</p><p>        { ParameterType.Custom, en = "Reuse troops", de = "Verwende bestehende Truppen" },</p><p>    },</p><p>    return { Reward.Custom,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.AIPlayerID = _Parameter * 1</p><p>    elseif (_Index == 1) then</p><p>        self.Spawnpoint = _Parameter</p><p>    elseif (_Index == 2) then</p><p>        self.TargetName = _Parameter</p><p>    elseif (_Index == 3) then</p><p>        self.Radius = _Parameter * 1</p><p>    elseif (_Index == 4) then</p><p>        self.NumSword = _Parameter * 1</p><p>    elseif (_Index == 5) then</p><p>        self.NumBow = _Parameter * 1</p><p>    elseif (_Index == 6) then</p><p>        if _Parameter == "Normal" or _Parameter == false then</p><p>            self.TroopType = false</p><p>        elseif _Parameter == "RedPrince" or _Parameter == true then</p><p>            self.TroopType = true</p><p>        elseif _Parameter == "Bandit" or _Parameter == 2 then</p><p>            self.TroopType = 2</p><p>        elseif _Parameter == "Cultist" or _Parameter == 3 then</p><p>            self.TroopType = 3</p><p>        else</p><p>            assert(false)</p><p>        end</p><p>    elseif (_Index == 7) then</p><p>        self.ReuseTroops = AcceptAlternativeBoolean(_Parameter)</p><p>    end</p><p>    local Data = {}</p><p>    if _Index == 6 then</p><p>        table.insert( Data, "Normal" )</p><p>        table.insert( Data, "RedPrince" )</p><p>        table.insert( Data, "Bandit" )</p><p>        if g_GameExtraNo = 1 then</p><p>            table.insert( Data, "Cultist" )</p><p>        end</p><p>    elseif _Index == 7 then</p><p>        table.insert( Data, "false" )</p><p>        table.insert( Data, "true" )</p><p>    else</p><p>        assert( false )</p><p>    end</p><p>    return Data</p><p>    if Logic.IsEntityAlive( self.TargetName ) and Logic.IsEntityAlive( self.Spawnpoint ) then</p><p>        local TargetID = GetID( self.TargetName )</p><p>        AIScript_SpawnAndRaidSettlement( self.AIPlayerID, TargetID, self.Spawnpoint, self.Radius, self.NumSword, self.NumBow, self.TroopType, self.ReuseTroops )</p><p>    end</p><p>    if self.AIPlayerID  2 then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": Player " .. self.AIPlayerID .. " is wrong")</p><p>        return true</p><p>    elseif Logic.IsEntityDestroyed(self.Spawnpoint) then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": Entity " .. self.SpawnPoint .. " is missing")</p><p>        return true</p><p>    elseif Logic.IsEntityDestroyed(self.TargetName) then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": Entity " .. self.TargetName .. " is missing")</p><p>        return true</p><p>    elseif self.Radius  1 then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": Radius is to small or negative")</p><p>        return true</p><p>    elseif self.NumSword  0 then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": Number of Swords is negative")</p><p>        return true</p><p>    elseif self.NumBow  0 then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": Number of Bows is negative")</p><p>        return true</p><p>    elseif self.NumBow + self.NumSword  1 then</p><p>        fatal(_Quest.Identifier .. ": Error in " .. self.Name .. ": No Soldiers?")</p><p>        return true</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Erstellt eine Armee, die das Zielgebiet verteidigt.</p><p>-- @param _PlayerID     PlayerID des Angreifers</p><p>-- @param _SpawnPoint   Skriptname des Entstehungspunktes</p><p>-- @param _Target       Skriptname des Ziels</p><p>-- @param _Radius       Bewachtes Gebiet</p><p>-- @param _Time         Dauer der Bewachung (-1 für unendlich)</p><p>-- @param _Sword        Anzahl Schwertkämpfer (Battalione)</p><p>-- @param _Bow          Anzahl Bogenschützen (Battalione)</p><p>-- @param _CaptureCarts Soldaten greifen Karren an</p><p>-- @param _Type         Typ der Soldaten</p><p>-- @param _Reuse        Freie Truppen wiederverwenden</p><p>-- @within Reward</p><p>    return b_Reward_AI_SpawnAndProtectArea:new(...);</p><p>Reward_AI_SpawnAndProtectArea</p><p>    Name = "Reward_AI_SpawnAndProtectArea",</p><p>    Description = {</p><p>        en = "Reward: Spawns AI troops and defends a specified area",</p><p>        de = "Lohn: Erstellt KI Truppen und verteidigt ein angegebenes Gebiet",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.PlayerID, en = "AI Player", de = "KI Spieler" },</p><p>        { ParameterType.ScriptName, en = "Spawn point", de = "Erstellungsort" },</p><p>        { ParameterType.ScriptName, en = "Target", de = "Ziel" },</p><p>        { ParameterType.Number, en = "Radius", de = "Radius" },</p><p>        { ParameterType.Number, en = "Time (-1 for infinite)", de = "Zeit (-1 fuer unendlich)" },</p><p>        { ParameterType.Number, en = "Sword", de = "Schwert" },</p><p>        { ParameterType.Number, en = "Bow", de = "Bogen" },</p><p>        { ParameterType.Custom, en = "Capture tradecarts", de = "Handelskarren angreifen" },</p><p>        { ParameterType.Custom, en = "Soldier type", de = "Soldatentyp" },</p><p>        { ParameterType.Custom, en = "Reuse troops", de = "Verwende bestehende Truppen" },</p><p>    },</p><p>    return { Reward.Custom,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.AIPlayerID = _Parameter * 1</p><p>    elseif (_Index == 1) then</p><p>        self.Spawnpoint = _Parameter</p><p>    elseif (_Index == 2) then</p><p>        self.TargetName = _Parameter</p><p>    elseif (_Index == 3) then</p><p>        self.Radius = _Parameter * 1</p><p>    elseif (_Index == 4) then</p><p>        self.Time = _Parameter * 1</p><p>    elseif (_Index == 5) then</p><p>        self.NumSword = _Parameter * 1</p><p>    elseif (_Index == 6) then</p><p>        self.NumBow = _Parameter * 1</p><p>    elseif (_Index == 7) then</p><p>        self.CaptureTradeCarts = AcceptAlternativeBoolean(_Parameter)</p><p>    elseif (_Index == 8) then</p><p>        if _Parameter == "Normal" or _Parameter == true then</p><p>            self.TroopType = false</p><p>        elseif _Parameter == "RedPrince" or _Parameter == false then</p><p>            self.TroopType = true</p><p>        elseif _Parameter == "Bandit" or _Parameter == 2 then</p><p>            self.TroopType = 2</p><p>        elseif _Parameter == "Cultist" or _Parameter == 3 then</p><p>            self.TroopType = 3</p><p>        else</p><p>            assert(false)</p><p>        end</p><p>    elseif (_Index == 9) then</p><p>        self.ReuseTroops = AcceptAlternativeBoolean(_Parameter)</p><p>    end</p><p>    local Data = {}</p><p>    if _Index == 7 then</p><p>        table.insert( Data, "false" )</p><p>        table.insert( Data, "true" )</p><p>    elseif _Index == 8 then</p><p>        table.insert( Data, "Normal" )</p><p>        table.insert( Data, "RedPrince" )</p><p>        table.insert( Data, "Bandit" )</p><p>        if g_GameExtraNo = 1 then</p><p>            table.insert( Data, "Cultist" )</p><p>        end</p><p>    elseif _Index == 9 then</p><p>        table.insert( Data, "false" )</p><p>        table.insert( Data, "true" )</p><p>    else</p><p>        assert( false )</p><p>    end</p><p>    return Data</p><p>    if Logic.IsEntityAlive( self.TargetName ) and Logic.IsEntityAlive( self.Spawnpoint ) then</p><p>        local TargetID = GetID( self.TargetName )</p><p>        AIScript_SpawnAndProtectArea( self.AIPlayerID, TargetID, self.Spawnpoint, self.Radius, self.NumSword, self.NumBow, self.Time, self.TroopType, self.ReuseTroops, self.CaptureTradeCarts )</p><p>    end</p><p>    if self.AIPlayerID  2 then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": Player " .. self.AIPlayerID .. " is wrong")</p><p>        return true</p><p>    elseif Logic.IsEntityDestroyed(self.Spawnpoint) then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": Entity " .. self.SpawnPoint .. " is missing")</p><p>        return true</p><p>    elseif Logic.IsEntityDestroyed(self.TargetName) then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": Entity " .. self.TargetName .. " is missing")</p><p>        return true</p><p>    elseif self.Radius  1 then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": Radius is to small or negative")</p><p>        return true</p><p>    elseif self.Time  -1 then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": Time is smaller than -1")</p><p>        return true</p><p>    elseif self.NumSword  0 then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": Number of Swords is negative")</p><p>        return true</p><p>    elseif self.NumBow  0 then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": Number of Bows is negative")</p><p>        return true</p><p>    elseif self.NumBow + self.NumSword  1 then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": No Soldiers?")</p><p>        return true</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ändert die Konfiguration eines KI-Spielers.</p><p>-- Optionen:</p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- @param _PlayerID PlayerID des KI</p><p>-- @param _Fact     Konfigurationseintrag</p><p>-- @param _Value    Neuer Wert</p><p>-- @within Reward</p><p>    return b_Reward_AI_SetNumericalFact:new(...);</p><p>Reward_AI_SetNumericalFact</p><p>    Name = "Reward_AI_SetNumericalFact",</p><p>    Description = {</p><p>        en = "Reward: Sets a numerical fact for the AI player",</p><p>        de = "Lohn: Setzt eine Verhaltensregel fuer den KI-Spieler. ",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.PlayerID, en = "AI Player",      de = "KI Spieler" },</p><p>        { ParameterType.Custom,   en = "Numerical Fact", de = "Verhaltensregel" },</p><p>        { ParameterType.Number,   en = "Value",          de = "Wert" },</p><p>    },</p><p>    return { Reward.Custom,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.AIPlayerID = _Parameter * 1</p><p>    elseif (_Index == 1) then</p><p>        -- mapping of numerical facts</p><p>        local fact = {</p><p>            ["Courage"]               = "FEAR",</p><p>            ["Reconstruction"]        = "BARB",</p><p>            ["Build Order"]           = "BPMX",</p><p>            ["Conquer Outposts"]      = "FCOP",</p><p>            ["Mount Outposts"]        = "FMOP",</p><p>            ["max. Bowmen"]           = "FMBM",</p><p>            ["max. Swordmen"]         = "FMSM",</p><p>            ["max. Rams"]             = "FMRA",</p><p>            ["max. Catapults"]        = "FMCA",</p><p>            ["max. Ammunition Carts"] = "FMAC",</p><p>            ["max. Siege Towers"]     = "FMST",</p><p>            ["max. Wall Catapults"]   = "FMBA",</p><p>            ["FEAR"]                  = "FEAR", --  0</p><p>            ["BARB"]                  = "BARB", -- 1 or 0</p><p>            ["BPMX"]                  = "BPMX", -- = 0</p><p>            ["FCOP"]                  = "FCOP", -- 1 or 0</p><p>            ["FMOP"]                  = "FMOP", -- 1 or 0</p><p>            ["FMBM"]                  = "FMBM", -- = 0</p><p>            ["FMSM"]                  = "FMSM", -- = 0</p><p>            ["FMRA"]                  = "FMRA", -- = 0</p><p>            ["FMCA"]                  = "FMCA", -- = 0</p><p>            ["FMAC"]                  = "FMAC", -- = 0</p><p>            ["FMST"]                  = "FMST", -- = 0</p><p>            ["FMBA"]                  = "FMBA", -- = 0</p><p>        }</p><p>        self.NumericalFact = fact[_Parameter]</p><p>    elseif (_Index == 2) then</p><p>        self.Value = _Parameter * 1</p><p>    end</p><p>    AICore.SetNumericalFact( self.AIPlayerID, self.NumericalFact, self.Value )</p><p>    if (_Index == 1) then</p><p>        return {</p><p>            "Courage",</p><p>            "Reconstruction",</p><p>            "Build Order",</p><p>            "Conquer Outposts",</p><p>            "Mount Outposts",</p><p>            "max. Bowmen",</p><p>            "max. Swordmen",</p><p>            "max. Rams",</p><p>            "max. Catapults",</p><p>            "max. Ammunition Carts",</p><p>            "max. Siege Towers",</p><p>            "max. Wall Catapults",</p><p>        };</p><p>    end</p><p>    if Logic.GetStoreHouse(self.AIPlayerID) == 0 then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": Player " .. self.AIPlayerID .. " is wrong or dead!");</p><p>        return true;</p><p>    elseif not self.NumericalFact then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": invalid numerical fact choosen!");</p><p>        return true;</p><p>    else</p><p>        if self.NumericalFact == "BARB" or self.NumericalFact == "FCOP" or self.NumericalFact == "FMOP" then</p><p>            if self.Value ~= 0 and self.Value ~= 1 then</p><p>                fatal(_Quest.Identifier .. " " .. self.Name .. ": BARB, FCOP, FMOP: value must be 1 or 0!");</p><p>                return true;</p><p>            end</p><p>        elseif self.NumericalFact == "FEAR" then</p><p>            if self.Value = 0 then</p><p>                fatal(_Quest.Identifier .. " " .. self.Name .. ": FEAR: value must greater than 0!");</p><p>                return true;</p><p>            end</p><p>        else</p><p>            if self.Value  0 then</p><p>                fatal(_Quest.Identifier .. " " .. self.Name .. ": value must always greater than or equal 0!");</p><p>                return true;</p><p>            end</p><p>        end</p><p>    end</p><p>    return false</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Stellt den Aggressivitätswert des KI-Spielers nachträglich ein.</p><p>-- @param _PlayerID         PlayerID des KI-Spielers</p><p>-- @param _Aggressiveness   Aggressivitätswert (1 bis 3)</p><p>-- @within Reward</p><p>    return b_Reward_AI_Aggressiveness:new(...);</p><p>Reward_AI_Aggressiveness</p><p>    Name = "Reward_AI_Aggressiveness",</p><p>    Description = {</p><p>        en = "Reward: Sets the AI player's aggressiveness.",</p><p>        de = "Lohn: Setzt die Aggressivität des KI-Spielers fest.",</p><p>    },</p><p>    Parameter =</p><p>    {</p><p>        { ParameterType.PlayerID, en = "AI player", de = "KI-Spieler" },</p><p>        { ParameterType.Custom, en = "Aggressiveness (1-3)", de = "Aggressivität (1-3)" }</p><p>    }</p><p>    return {Reward.Custom, {self, self.CustomFunction} };</p><p>    if _Index == 0 then</p><p>        self.AIPlayer = _Parameter * 1;</p><p>    elseif _Index == 1 then</p><p>        self.Aggressiveness = tonumber(_Parameter);</p><p>    end</p><p>    local player = (PlayerAIs[self.AIPlayer]</p><p>        or AIPlayerTable[self.AIPlayer]</p><p>        or AIPlayer:new(self.AIPlayer, AIPlayerProfile_City));</p><p>    PlayerAIs[self.AIPlayer] = player;</p><p>    if self.Aggressiveness = 2 then</p><p>        player.m_ProfileLoop = AIProfile_Skirmish;</p><p>        player.Skirmish = player.Skirmish or {};</p><p>        player.Skirmish.Claim_MinTime = SkirmishDefault.Claim_MinTime + (self.Aggressiveness - 2) * 390;</p><p>        player.Skirmish.Claim_MaxTime = player.Skirmish.Claim_MinTime * 2;</p><p>    else</p><p>        player.m_ProfileLoop = AIPlayerProfile_City;</p><p>    end</p><p>    if self.AIPlayer  2 or Logic.GetStoreHouse(self.AIPlayer) == 0 then</p><p>        fatal(_Quest.Identifier .. ": Error in " .. self.Name .. ": Player " .. self.PlayerID .. " is wrong")</p><p>        return true</p><p>    end</p><p>    assert(_Index == 1, "Error in " .. self.Name .. ": GetCustomData: Index is invalid.");</p><p>    return { "1", "2", "3" };</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Stellt den Feind des Skirmish-KI ein.</p><p>-- Der Skirmish-KI (maximale Aggressivität) kann nur einen Spieler als Feind</p><p>-- behandeln. Für gewöhnlich ist dies der menschliche Spieler.</p><p>-- @param _PlayerID      PlayerID des KI</p><p>-- @param _EnemyPlayerID PlayerID des Feindes</p><p>-- @within Reward</p><p>    return b_Reward_AI_SetEnemy:new(...);</p><p>Reward_AI_SetEnemy</p><p>    Name = "Reward_AI_SetEnemy",</p><p>    Description = {</p><p>        en = "Reward:Sets the enemy of an AI player (the AI only handles one enemy properly).",</p><p>        de = "Lohn: Legt den Feind eines KI-Spielers fest (die KI behandelt nur einen Feind korrekt).",</p><p>    },</p><p>    Parameter =</p><p>    {</p><p>        { ParameterType.PlayerID, en = "AI player", de = "KI-Spieler" },</p><p>        { ParameterType.PlayerID, en = "Enemy", de = "Feind" }</p><p>    }</p><p>    return {Reward.Custom, {self, self.CustomFunction} };</p><p>    if _Index == 0 then</p><p>        self.AIPlayer = _Parameter * 1;</p><p>    elseif _Index == 1 then</p><p>        self.Enemy = _Parameter * 1;</p><p>    end</p><p>    local player = PlayerAIs[self.AIPlayer];</p><p>    if player and player.Skirmish then</p><p>        player.Skirmish.Enemy = self.Enemy;</p><p>    end</p><p>    if self.AIPlayer = 8 or Logic.PlayerGetIsHumanFlag(self.AIPlayer) then</p><p>        fatal(_Quest.Identifier .. ": Error in " .. self.Name .. ": Player " .. self.AIPlayer .. " is wrong")</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ein Entity wird durch ein neues anderen Typs ersetzt.</p><p>-- Das neue Entity übernimmt Skriptname, Besitzer und Ausrichtung des</p><p>-- alten Entity.</p><p>-- @param _Entity Skriptname oder ID des Entity</p><p>-- @param _Type   Neuer Typ des Entity</p><p>-- @param _Owner  Besitzer des Entity</p><p>-- @within Reward</p><p>    return b_Reward_ReplaceEntity:new(...);</p><p>Reward_ReplaceEntity = API.InstanceTable(b_Reprisal_ReplaceEnti</p><p>Reward_ReplaceEntity.Name = "Reward_ReplaceEnti</p><p>Reward_ReplaceEntity.Description.en = "Reward: Replaces an entity with a new one of a different type. The playerID can be changed to</p><p>Reward_ReplaceEntity.Description.de = "Lohn: Ersetzt eine Entity durch eine neue anderen Typs. Es kann auch die Spielerzugehörigkeit geändert werde</p><p>Reward_ReplaceEntity.GetReprisalTable = </p><p>Reward_ReplaceEntity.GetRewardTable = function(self, _Qu</p><p>    return { Reward.Custom,{self, self.CustomFunction} }</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Setzt die Menge von Rohstoffen in einer Mine.</p><p>--  Im Reich des Ostens darf die Mine nicht eingestürzt sein!</p><p>-- Außerdem bringt dieses Behavior die Nachfüllmechanik durcheinander.</p><p>-- @param _ScriptName Skriptname der Mine</p><p>-- @param _Amount     Menge an Rohstoffen</p><p>-- @within Reward</p><p>    return b_Reward_SetResourceAmount:new(...);</p><p>Reward_SetResourceAmount</p><p>    Name = "Reward_SetResourceAmount",</p><p>    Description = {</p><p>        en = "Reward: Set the current and maximum amount of a resource doodad (the amount can also set to 0)",</p><p>        de = "Lohn: Setzt die aktuellen sowie maximalen Resourcen in einem Doodad (auch 0 ist möglich)",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Ressource", de = "Resource" },</p><p>        { ParameterType.Number, en = "Amount", de = "Menge" },</p><p>    },</p><p>    return { Reward.Custom,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.ScriptName = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.Amount = _Parameter * 1</p><p>    end</p><p>    if Logic.IsEntityDestroyed( self.ScriptName ) then</p><p>        return false</p><p>    end</p><p>    local EntityID = GetID( self.ScriptName )</p><p>    if Logic.GetResourceDoodadGoodType( EntityID ) == 0 then</p><p>        return false</p><p>    end</p><p>    Logic.SetResourceDoodadGoodAmount( EntityID, self.Amount )</p><p>    if not IsExisting(self.ScriptName) then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": resource entity does not exist!")</p><p>        return true</p><p>    elseif not type(self.Amount) == "number" or self.Amount  0 then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": resource amount can not be negative!")</p><p>        return true</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Fügt dem Lagerhaus des Auftragnehmers eine Menge an Rohstoffen hinzu. Die</p><p>-- Rohstoffe werden direkt ins Lagerhaus bzw. die Schatzkammer gelegt.</p><p>-- @param _Type   Rohstofftyp</p><p>-- @param _Amount Menge an Rohstoffen</p><p>-- @within Reward</p><p>    return b_Reward_Resources:new(...);</p><p>Reward_Resources</p><p>    Name = "Reward_Resources",</p><p>    Description = {</p><p>        en = "Reward: The player receives a given amount of Goods in his store.",</p><p>        de = "Lohn: Legt der Partei die angegebenen Rohstoffe ins Lagerhaus.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.RawGoods, en = "Type of good", de = "Resourcentyp" },</p><p>        { ParameterType.Number, en = "Amount of good", de = "Anzahl der Resource" },</p><p>    },</p><p>    if (_Index == 0) then</p><p>        self.GoodTypeName = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.GoodAmount = _Parameter * 1</p><p>    end</p><p>    local GoodType = Logic.GetGoodTypeID(self.GoodTypeName)</p><p>    return { Reward.Resources, GoodType, self.GoodAmount }</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Entsendet einen Karren zum angegebenen Spieler.</p><p>-- Wenn der Spawnpoint ein Gebäude ist, wird der Wagen am Eingang erstellt.</p><p>-- Andernfalls kann der Spawnpoint gelöscht werden und der Wagen übernimmt</p><p>-- dann den Skriptnamen.</p><p>-- @param _ScriptName    Skriptname des Spawnpoint</p><p>-- @param _Owner         Empfänger der Lieferung</p><p>-- @param _Type          Typ des Wagens</p><p>-- @param _Good          Typ der Ware</p><p>-- @param _Amount        Menge an Waren</p><p>-- @param _OtherPlayer   Anderer Empfänger als Auftraggeber</p><p>-- @param _NoReservation Platzreservation auf dem Markt ignorieren (Sinnvoll?)</p><p>-- @param _Replace       Spawnpoint ersetzen</p><p>-- @within Reward</p><p>    return b_Reward_SendCart:new(...);</p><p>Reward_SendCart</p><p>    Name = "Reward_SendCart",</p><p>    Description = {</p><p>        en = "Reward: Sends a cart to a player. It spawns at a building or by replacing an entity. The cart can replace the entity if it's not a building.",</p><p>        de = "Lohn: Sendet einen Karren zu einem Spieler. Der Karren wird an einem Gebäude oder einer Entity erstellt. Er ersetzt die Entity, wenn diese kein Gebäude ist.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Script entity", de = "Script Entity" },</p><p>        { ParameterType.PlayerID, en = "Owning player", de = "Besitzer" },</p><p>        { ParameterType.Custom, en = "Type name", de = "Typbezeichnung" },</p><p>        { ParameterType.Custom, en = "Good type", de = "Warentyp" },</p><p>        { ParameterType.Number, en = "Amount", de = "Anzahl" },</p><p>        { ParameterType.Custom, en = "Override target player", de = "Anderer Zielspieler" },</p><p>        { ParameterType.Custom, en = "Ignore reservations", de = "Ignoriere Reservierungen" },</p><p>        { ParameterType.Custom, en = "Replace entity", de = "Entity ersetzen" },</p><p>    },</p><p>    return { Reward.Custom,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.ScriptNameEntity = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.PlayerID = _Parameter * 1</p><p>    elseif (_Index == 2) then</p><p>        self.UnitKey = _Parameter</p><p>    elseif (_Index == 3) then</p><p>        self.GoodType = _Parameter</p><p>    elseif (_Index == 4) then</p><p>        self.GoodAmount = _Parameter * 1</p><p>    elseif (_Index == 5) then</p><p>        self.OverrideTargetPlayer = tonumber(_Parameter)</p><p>    elseif (_Index == 6) then</p><p>        self.IgnoreReservation = AcceptAlternativeBoolean(_Parameter)</p><p>    elseif (_Index == 7) then</p><p>        self.ReplaceEntity = AcceptAlternativeBoolean(_Parameter)</p><p>    end</p><p>    if not IsExisting( self.ScriptNameEntity ) then</p><p>        return false;</p><p>    end</p><p>    local ID = SendCart(self.ScriptNameEntity, self.PlayerID, Goods[self.GoodType], self.GoodAmount, Entities[self.UnitKey], self.IgnoreReservation);</p><p>    if self.ReplaceEntity and Logic.IsBuilding(GetID(self.ScriptNameEntity)) == 0 then</p><p>        DestroyEntity(self.ScriptNameEntity);</p><p>        Logic.SetEntityName(ID, self.ScriptNameEntity);</p><p>    end</p><p>    if self.OverrideTargetPlayer then</p><p>        Logic.ResourceMerchant_OverrideTargetPlayerID(ID,self.OverrideTargetPlayer);</p><p>    end</p><p>    local Data = {};</p><p>    if _Index == 2 then</p><p>        Data = { "U_ResourceMerchant", "U_Medicus", "U_Marketer", "U_ThiefCart", "U_GoldCart", "U_Noblemen_Cart", "U_RegaliaCart" };</p><p>    elseif _Index == 3 then</p><p>        for k, v in pairs( Goods ) do</p><p>            if string.find( k, "^G_" ) then</p><p>                table.insert( Data, k );</p><p>            end</p><p>        end</p><p>        table.sort( Data );</p><p>    elseif _Index == 5 then</p><p>        table.insert( Data, "-" );</p><p>        for i = 1, 8 do</p><p>            table.insert( Data, i );</p><p>        end</p><p>    elseif _Index == 6 then</p><p>        table.insert( Data, "false" );</p><p>        table.insert( Data, "true" );</p><p>    elseif _Index == 7 then</p><p>        table.insert( Data, "false" );</p><p>        table.insert( Data, "true" );</p><p>    end</p><p>    return Data;</p><p>    if not IsExisting(self.ScriptNameEntity) then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": spawnpoint does not exist!");</p><p>        return true;</p><p>    elseif not tonumber(self.PlayerID) or self.PlayerID  8 then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": got a invalid playerID!");</p><p>        return true;</p><p>    elseif not Entities[self.UnitKey] then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": entity type '"..self.UnitKey.."' is invalid!");</p><p>        return true;</p><p>    elseif not Goods[self.GoodType] then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": good type '"..self.GoodType.."' is invalid!");</p><p>        return true;</p><p>    elseif not tonumber(self.GoodAmount) or self.GoodAmount  1 then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": good amount can not be below 1!");</p><p>        return true;</p><p>    elseif tonumber(self.OverrideTargetPlayer) and (self.OverrideTargetPlayer  8) then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": overwrite target player with invalid playerID!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Gibt dem Auftragnehmer eine Menge an Einheiten.</p><p>-- Die Einheiten erscheinen an der Burg. Hat der Spieler keine Burg, dann</p><p>-- erscheinen sie vorm Lagerhaus.</p><p>-- @param _Type   Typ der Einheit</p><p>-- @param _Amount Menge an Einheiten</p><p>-- @within Reward</p><p>    return b_Reward_Units:new(...)</p><p>Reward_Units</p><p>    Name = "Reward_Units",</p><p>    Description = {</p><p>        en = "Reward: Units",</p><p>        de = "Lohn: Einheiten",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Entity, en = "Type name", de = "Typbezeichnung" },</p><p>        { ParameterType.Number, en = "Amount", de = "Anzahl" },</p><p>    },</p><p>    if (_Index == 0) then</p><p>        self.EntityName = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.Amount = _Parameter * 1</p><p>    end</p><p>    return { Reward.Units, assert( Entities[self.EntityName] ), self.Amount }</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet einen Quest neu.</p><p>-- @param _QuestName Name des Quest</p><p>-- @within Reward</p><p>    return b_Reward_QuestRestart:new(...)</p><p>Reward_QuestRestart = API.InstanceTable(b_Reprisal_QuestResta</p><p>Reward_QuestRestart.Name = "Reward_QuestResta</p><p>Reward_QuestRestart.Description.en = "Reward: Restarts a (completed) quest so it can be triggered and completed agai</p><p>Reward_QuestRestart.Description.de = "Lohn: Startet eine (beendete) Quest neu, damit diese neu ausgelöst und beendet werden kan</p><p>Reward_QuestRestart.GetReprisalTable = </p><p>Reward_QuestRestart.GetRewardTable = function(self, _Qu</p><p>    return { Reward.Custom,{self, self.CustomFunction} }</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Lässt einen Quest fehlschlagen.</p><p>-- @param _QuestName Name des Quest</p><p>-- @within Reward</p><p>    return b_Reward_QuestFailure:new(...)</p><p>Reward_QuestFailure = API.InstanceTable(b_Reprisal_QuestFailu</p><p>Reward_QuestFailure.Name = "Reward_QuestFailu</p><p>Reward_QuestFailure.Description.en = "Reward: Lets another active quest fai</p><p>Reward_QuestFailure.Description.de = "Lohn: Lässt eine andere aktive Quest fehlschlage</p><p>Reward_QuestFailure.GetReprisalTable = </p><p>Reward_QuestFailure.GetRewardTable = function(self, _Qu</p><p>    return { Reward.Custom,{self, self.CustomFunction} }</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Wertet einen Quest als erfolgreich.</p><p>-- @param _QuestName Name des Quest</p><p>-- @within Reward</p><p>    return b_Reward_QuestSuccess:new(...)</p><p>Reward_QuestSuccess = API.InstanceTable(b_Reprisal_QuestSucce</p><p>Reward_QuestSuccess.Name = "Reward_QuestSucce</p><p>Reward_QuestSuccess.Description.en = "Reward: Completes another active quest successfull</p><p>Reward_QuestSuccess.Description.de = "Lohn: Beendet eine andere aktive Quest erfolgreic</p><p>Reward_QuestSuccess.GetReprisalTable = </p><p>Reward_QuestSuccess.GetRewardTable = function(self, _Qu</p><p>    return { Reward.Custom,{self, self.CustomFunction} }</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Triggert einen Quest.</p><p>-- @param _QuestName Name des Quest</p><p>-- @within Reward</p><p>    return b_Reward_QuestActivate:new(...)</p><p>Reward_QuestActivate = API.InstanceTable(b_Reprisal_QuestActiva</p><p>Reward_QuestActivate.Name = "Reward_QuestActiva</p><p>Reward_QuestActivate.Description.en = "Reward: Activates another quest that is not triggered ye</p><p>Reward_QuestActivate.Description.de = "Lohn: Aktiviert eine andere Quest die noch nicht ausgelöst wurd</p><p>Reward_QuestActivate.GetReprisalTable = </p><p>Reward_QuestActivate.GetRewardTable = function(self, _Qu</p><p>    return {Reward.Custom, {self, self.CustomFunction} }</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Unterbricht einen Quest.</p><p>-- @param _QuestName Name des Quest</p><p>-- @within Reward</p><p>    return b_Reward_QuestInterrupt:new(...)</p><p>Reward_QuestInterrupt = API.InstanceTable(b_Reprisal_QuestInterru</p><p>Reward_QuestInterrupt.Name = "Reward_QuestInterru</p><p>Reward_QuestInterrupt.Description.en = "Reward: Interrupts another active quest without success or failur</p><p>Reward_QuestInterrupt.Description.de = "Lohn: Beendet eine andere aktive Quest ohne Erfolg oder Misserfol</p><p>Reward_QuestInterrupt.GetReprisalTable = </p><p>Reward_QuestInterrupt.GetRewardTable = function(self, _Qu</p><p>    return { Reward.Custom,{self, self.CustomFunction} }</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Unterbricht einen Quest, selbst wenn dieser noch nicht ausgelöst wurde.</p><p>-- @param _QuestName   Name des Quest</p><p>-- @param _EndetQuests Bereits beendete unterbrechen</p><p>-- @within Reward</p><p>    return b_Reward_QuestForceInterrupt:new(...)</p><p>Reward_QuestForceInterrupt = API.InstanceTable(b_Reprisal_QuestForceInterru</p><p>Reward_QuestForceInterrupt.Name = "Reward_QuestForceInterru</p><p>Reward_QuestForceInterrupt.Description.en = "Reward: Interrupts another quest (even when it isn't active yet) without success or failur</p><p>Reward_QuestForceInterrupt.Description.de = "Lohn: Beendet eine andere Quest, auch wenn diese noch nicht aktiv ist ohne Erfolg oder Misserfol</p><p>Reward_QuestForceInterrupt.GetReprisalTable = </p><p>Reward_QuestForceInterrupt.GetRewardTable = function(self, _Qu</p><p>    return { Reward.Custom,{self, self.CustomFunction} }</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ändert den Wert einer benutzerdefinierten Variable.</p><p>-- Benutzerdefinierte Variablen können ausschließlich Zahlen sein. Nutze</p><p>-- dieses Behavior bevor die Variable in einem Goal oder Trigger abgefragt</p><p>-- wird, um sie zu initialisieren!</p><p>---- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- @param _Name     Name der Variable</p><p>-- @param _Operator Rechen- oder Zuweisungsoperator</p><p>-- @param _Value    Wert oder andere Custom Variable</p><p>-- @within Reward</p><p>    return b_Reward_CustomVariables:new(...);</p><p>Reward_CustomVariables = API.InstanceTable(b_Reprisal_CustomVariabl</p><p>Reward_CustomVariables.Name = "Reward_CustomVariabl</p><p>Reward_CustomVariables.Description.en = "Reward: Executes a mathematical operation with this variable. The other operand can be a number or another custom variabl</p><p>Reward_CustomVariables.Description.de = "Lohn: Fuehrt eine mathematische Operation mit der Variable aus. Der andere Operand kann eine Zahl oder eine Custom-Varible sei</p><p>Reward_CustomVariables.GetReprisalTable = </p><p>Reward_CustomVariables.GetRewardTable = function(self, _Qu</p><p>    return { Reward.Custom, {self, self.CustomFunction} };</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Führt eine Funktion im Skript als Reward aus.</p><p>-- Wird ein Funktionsname als String übergeben, wird die Funktion mit den</p><p>-- Daten des Behavors und des zugehörigen Quest aufgerufen (Standard).</p><p>-- Wird eine Funktionsreferenz angegeben, wird die Funktion zusammen mit allen</p><p>-- optionalen Parametern aufgerufen, als sei es ein gewöhnlicher Aufruf im</p><p>-- Skript.</p><p>-- Reward_MapScriptFunction(ReplaceEntity, "block", Entities.XD_ScriptEntity);</p><p>-- -- entspricht: ReplaceEntity("block", Entities.XD_ScriptEntity);</p><p>--  Nicht über den Assistenten verfügbar!</p><p>-- @param _FunctionName Name der Funktion oder Funktionsreferenz</p><p>-- @within Reward</p><p>    return b_Reward_MapScriptFunction:new(...);</p><p>Reward_MapScriptFunction = API.InstanceTable(b_Reprisal_MapScriptFuncti</p><p>Reward_MapScriptFunction.Name = "Reward_MapScriptFuncti</p><p>Reward_MapScriptFunction.Description.en = "Reward: Calls a function within the global map script if the quest has faile</p><p>Reward_MapScriptFunction.Description.de = "Lohn: Ruft eine Funktion im globalen Kartenskript auf, wenn die Quest fehlschläg</p><p>Reward_MapScriptFunction.GetReprisalTable = </p><p>Reward_MapScriptFunction.GetRewardTable = function(self, _Qu</p><p>    return {Reward.Custom, {self, self.CustomFunction}};</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Erlaubt oder verbietet einem Spieler ein Recht.</p><p>-- @param _PlayerID   ID des Spielers</p><p>-- @param _Lock       Sperren/Entsperren</p><p>-- @param _Technology Name des Rechts</p><p>-- @within Reward</p><p>    return b_Reward_Technology:new(...);</p><p>Reward_Technology = API.InstanceTable(b_Reprisal_Technolo</p><p>Reward_Technology.Name = "Reward_Technolo</p><p>Reward_Technology.Description.en = "Reward: Locks or unlocks a technology for the given playe</p><p>Reward_Technology.Description.de = "Lohn: Sperrt oder erlaubt eine Technolgie fuer den angegebenen Playe</p><p>Reward_Technology.GetReprisalTable = </p><p>Reward_Technology.GetRewardTable = function(self, _Qu</p><p>    return { Reward.Custom, {self, self.CustomFunction} }</p><p>-- Gibt dem Auftragnehmer eine Anzahl an Prestigepunkten.</p><p>-- Prestige hat i.d.R. keine Funktion und wird nur als Zusatzpunkte in der</p><p>-- Statistik angezeigt.</p><p>-- @param _Amount Menge an Prestige</p><p>-- @within Reward</p><p>    return b_Reward_PrestigePoints:mew(...);</p><p>Reward_PrestigePoints </p><p>    Name = "Reward_PrestigePoints",</p><p>    Description = {</p><p>        en = "Reward: Prestige",</p><p>        de = "Lohn: Prestige",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Number, en = "Points", de = "Punkte" },</p><p>    },</p><p>    if (_Index == 0) then</p><p>        self.Points = _Parameter</p><p>    end</p><p>    return { Reward.PrestigePoints, self.Points }</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Besetzt einen Außenposten mit Soldaten.</p><p>-- @param _ScriptName Skriptname des Außenposten</p><p>-- @param _Type       Soldatentyp</p><p>-- @within Reward</p><p>    return b_Reward_AI_MountOutpost:new(...);</p><p>Reward_AI_MountOutpost</p><p>    Name = "Reward_AI_MountOutpost",</p><p>    Description = {</p><p>        en = "Reward: Places a troop of soldiers on a named outpost.",</p><p>        de = "Lohn: Platziert einen Trupp Soldaten auf einem Aussenposten der KI.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Script name", de = "Skriptname" },</p><p>        { ParameterType.Custom,      en = "Soldiers type", de = "Soldatentyp" },</p><p>    },</p><p>    return { Reward.Custom,{self, self.CustomFunction} }</p><p>    if _Index == 0 then</p><p>        self.Scriptname = _Parameter</p><p>    else</p><p>        self.SoldiersType = _Parameter</p><p>    end</p><p>    local outpostID = assert(</p><p>        not Logic.IsEntityDestroyed(self.Scriptname) and GetID(self.Scriptname),</p><p>       _Quest.Identifier .. ": Error in " .. self.Name .. ": CustomFunction: Outpost is invalid"</p><p>    )</p><p>    local AIPlayerID = Logic.EntityGetPlayer(outpostID)</p><p>    local ax, ay = Logic.GetBuildingApproachPosition(outpostID)</p><p>    local TroopID = Logic.CreateBattalionOnUnblockedLand(Entities[self.SoldiersType], ax, ay, 0, AIPlayerID, 0)</p><p>    AICore.HideEntityFromAI(AIPlayerID, TroopID, true)</p><p>    Logic.CommandEntityToMountBuilding(TroopID, outpostID)</p><p>    if _Index == 1 then</p><p>        local Data = {}</p><p>        for k,v in pairs(Entities) do</p><p>            if string.find(k, "U_MilitaryBandit") or string.find(k, "U_MilitarySword") or string.find(k, "U_MilitaryBow") then</p><p>                Data[#Data+1] = k</p><p>            end</p><p>        end</p><p>        return Data</p><p>    end</p><p>    if Logic.IsEntityDestroyed(self.Scriptname) then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": Outpost " .. self.Scriptname .. " is missing")</p><p>        return true</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet einen Quest neu und lößt ihn sofort aus.</p><p>-- @param _QuestName Name des Quest</p><p>-- @within Reward</p><p>    return b_Reward_QuestRestartForceActive:new(...);</p><p>Reward_QuestRestartForceActive</p><p>    Name = "Reward_QuestRestartForceActive",</p><p>    Description = {</p><p>        en = "Reward: Restarts a (completed) quest and triggers it immediately.",</p><p>        de = "Lohn: Startet eine (beendete) Quest neu und triggert sie sofort.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.QuestName, en = "Quest name", de = "Questname" },</p><p>    },</p><p>    return { Reward.Custom,{self, self.CustomFunction} }</p><p>    assert(_Index == 0, "Error in " .. self.Name .. ": AddParameter: Index is invalid.")</p><p>    self.QuestName = _Parameter</p><p>    local QuestID, Quest = self:ResetQuest(_Quest);</p><p>    if QuestID then</p><p>        Quest:SetMsgKeyOverride()</p><p>        Quest:SetIconOverride()</p><p>        Quest:Trigger()</p><p>    end</p><p>Reward_QuestRestartForceActive.ResetQuest = b_Reward_QuestRestart.CustomFunct</p><p>    if not Quests[GetQuestID(self.QuestName)] then</p><p>        fatal(_Quest.Identifier .. ": Error in " .. self.Name .. ": Quest: "..  self.QuestName .. " does not exist");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Baut das angegebene Gabäude um eine Stufe aus. Das Gebäude wird durch einen</p><p>-- Arbeiter um eine Stufe erweitert. Der Arbeiter muss zuerst aus dem Lagerhaus</p><p>-- kommen und sich zum Gebäude bewegen.</p><p>--  Ein Gebäude muss erst fertig ausgebaut sein, bevor ein</p><p>-- weiterer Ausbau begonnen werden kann!</p><p>-- @param _ScriptName Skriptname des Gebäudes</p><p>-- @within Reward</p><p>    return b_Reward_UpgradeBuilding:new(...);</p><p>Reward_UpgradeBuilding</p><p>    Name = "Reward_UpgradeBuilding",</p><p>    Description = {</p><p>        en = "Reward: Upgrades a building",</p><p>        de = "Lohn: Baut ein Gebäude aus"</p><p>    },</p><p>    Parameter =    {</p><p>        { ParameterType.ScriptName, en = "Building", de = "Gebäude" }</p><p>    }</p><p>    return {Reward.Custom, {self, self.CustomFunction}};</p><p>    if _Index == 0 then</p><p>        self.Building = _Parameter;</p><p>    end</p><p>    local building = GetID(self.Building);</p><p>    if building ~= 0</p><p>    and Logic.IsBuilding(building) == 1</p><p>    and Logic.IsBuildingUpgradable(building, true)</p><p>    and Logic.IsBuildingUpgradable(building, false)</p><p>    then</p><p>        Logic.UpgradeBuilding(building);</p><p>    end</p><p>    local building = GetID(self.Building);</p><p>    if not (building ~= 0</p><p>            and Logic.IsBuilding(building) == 1</p><p>            and Logic.IsBuildingUpgradable(building, true)</p><p>            and Logic.IsBuildingUpgradable(building, false) )</p><p>    then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": Building is wrong")</p><p>        return true</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Trigger                                                                    --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Starte den Quest, wenn ein anderer Spieler entdeckt wurde.</p><p>-- Ein Spieler ist dann entdeckt, wenn sein Heimatterritorium aufgedeckt wird.</p><p>-- @param _PlayerID Zu entdeckender Spieler</p><p>-- @within Trigger</p><p>    return b_Trigger_PlayerDiscovered:new(...);</p><p>Trigger_PlayerDiscovered</p><p>    Name = "Trigger_PlayerDiscovered",</p><p>    Description = {</p><p>        en = "Trigger: if a given player has been discovered",</p><p>        de = "Auslöser: wenn ein angegebener Spieler entdeckt wurde",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.PlayerID, en = "Player", de = "Spieler" },</p><p>    },</p><p>    return {Triggers.PlayerDiscovered, self.PlayerID}</p><p>    if (_Index == 0) then</p><p>        self.PlayerID = _Parameter * 1;</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Starte den Quest, wenn zwischen dem Empfänger und der angegebenen Partei</p><p>-- der geforderte Diplomatiestatus herrscht.</p><p>-- @param _PlayerID ID der Partei</p><p>-- @param _State    Diplomatie-Status</p><p>-- @within Trigger</p><p>    return b_Trigger_OnDiplomacy:new(...);</p><p>Trigger_OnDiplomacy</p><p>    Name = "Trigger_OnDiplomacy",</p><p>    Description = {</p><p>        en = "Trigger: if diplomatic relations have been established with a player",</p><p>        de = "Auslöser: wenn ein angegebener Diplomatie-Status mit einem Spieler erreicht wurde.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.PlayerID, en = "Player", de = "Spieler" },</p><p>        { ParameterType.DiplomacyState, en = "Relation", de = "Beziehung" },</p><p>    },</p><p>    return {Triggers.Diplomacy, self.PlayerID, assert( DiplomacyStates[self.DiplState] ) }</p><p>    if (_Index == 0) then</p><p>        self.PlayerID = _Parameter * 1</p><p>    elseif (_Index == 1) then</p><p>        self.DiplState = _Parameter</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Starte den Quest, sobald ein Bedürfnis nicht erfüllt wird.</p><p>-- @param _PlayerID ID des Spielers</p><p>-- @param _Need     Bedürfnis</p><p>-- @param _Amount   Menge an skreikenden Siedlern</p><p>-- @within Trigger</p><p>    return b_Trigger_OnNeedUnsatisfied:new(...);</p><p>Trigger_OnNeedUnsatisfied</p><p>    Name = "Trigger_OnNeedUnsatisfied",</p><p>    Description = {</p><p>        en = "Trigger: if a specified need is unsatisfied",</p><p>        de = "Auslöser: wenn ein bestimmtes Beduerfnis nicht befriedigt ist.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.PlayerID, en = "Player", de = "Spieler" },</p><p>        { ParameterType.Need, en = "Need", de = "Beduerfnis" },</p><p>        { ParameterType.Number, en = "Workers on strike", de = "Streikende Arbeiter" },</p><p>    },</p><p>    return { Triggers.Custom2,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.PlayerID = _Parameter * 1</p><p>    elseif (_Index == 1) then</p><p>        self.Need = _Parameter</p><p>    elseif (_Index == 2) then</p><p>        self.WorkersOnStrike = _Parameter * 1</p><p>    end</p><p>    return Logic.GetNumberOfStrikingWorkersPerNeed( self.PlayerID, Needs[self.Need] ) = self.WorkersOnStrike</p><p>    if Logic.GetStoreHouse(self.PlayerID) == 0 then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": " .. self.PlayerID .. " does not exist.")</p><p>        return true</p><p>    elseif not Needs[self.Need] then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": " .. self.Need .. " does not exist.")</p><p>        return true</p><p>    elseif self.WorkersOnStrike  0 then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": WorkersOnStrike value negative")</p><p>        return true</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet den Quest, wenn die angegebene Mine erschöpft ist.</p><p>-- @param _ScriptName Skriptname der Mine</p><p>-- @within Trigger</p><p>    return b_Trigger_OnResourceDepleted:new(...);</p><p>Trigger_OnResourceDepleted</p><p>    Name = "Trigger_OnResourceDepleted",</p><p>    Description = {</p><p>        en = "Trigger: if a resource is (temporarily) depleted",</p><p>        de = "Auslöser: wenn eine Ressource (zeitweilig) verbraucht ist",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Script name", de = "Skriptname" },</p><p>    },</p><p>    return { Triggers.Custom2,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.ScriptName = _Parameter</p><p>    end</p><p>    local ID = GetID(self.ScriptName)</p><p>    return not ID or ID == 0 or Logic.GetResourceDoodadGoodType(ID) == 0 or Logic.GetResourceDoodadGoodAmount(ID) == 0</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet den Quest, sobald der angegebene Spieler eine Menge an Rohstoffen</p><p>-- im Lagerhaus hat.</p><p>-- @param  _PlayerID ID des Spielers</p><p>-- @param  _Type     Typ des Rohstoffes</p><p>-- @param _Amount    Menge an Rohstoffen</p><p>-- @within Trigger</p><p>    return b_Trigger_OnAmountOfGoods:new(...);</p><p>Trigger_OnAmountOfGoods</p><p>    Name = "Trigger_OnAmountOfGoods",</p><p>    Description = {</p><p>        en = "Trigger: if the player has gathered a given amount of resources in his storehouse",</p><p>        de = "Auslöser: wenn der Spieler eine bestimmte Menge einer Ressource in seinem Lagerhaus hat",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.PlayerID, en = "Player", de = "Spieler" },</p><p>        { ParameterType.RawGoods, en = "Type of good", de = "Resourcentyp" },</p><p>        { ParameterType.Number, en = "Amount of good", de = "Anzahl der Resource" },</p><p>    },</p><p>    return { Triggers.Custom2,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.PlayerID = _Parameter * 1</p><p>    elseif (_Index == 1) then</p><p>        self.GoodTypeName = _Parameter</p><p>    elseif (_Index == 2) then</p><p>        self.GoodAmount = _Parameter * 1</p><p>    end</p><p>    local StoreHouseID = Logic.GetStoreHouse(self.PlayerID)</p><p>    if (StoreHouseID == 0) then</p><p>        return false</p><p>    end</p><p>    local GoodType = Logic.GetGoodTypeID(self.GoodTypeName)</p><p>    local GoodAmount = Logic.GetAmountOnOutStockByGoodType(StoreHouseID, GoodType)</p><p>    if (GoodAmount = self.GoodAmount)then</p><p>        return true</p><p>    end</p><p>    return false</p><p>    if Logic.GetStoreHouse(self.PlayerID) == 0 then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": " .. self.PlayerID .. " does not exist.")</p><p>        return true</p><p>    elseif not Goods[self.GoodTypeName] then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": Good type is wrong.")</p><p>        return true</p><p>    elseif self.GoodAmount  0 then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": Good amount is negative.")</p><p>        return true</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet den Quest, sobald ein anderer aktiv ist.</p><p>-- @param _QuestName Name des Quest</p><p>-- @param _Time      Wartezeit</p><p>-- return Table mit Behavior</p><p>-- @within Trigger</p><p>    return b_Trigger_OnQuestActive:new(...);</p><p>Trigger_OnQuestActive</p><p>    Name = "Trigger_OnQuestActive",</p><p>    Description = {</p><p>        en = "Trigger: if a given quest has been activated. Waiting time optional",</p><p>        de = "Auslöser: wenn eine angegebene Quest aktiviert wurde. Optional mit Wartezeit",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.QuestName, en = "Quest name", de = "Questname" },</p><p>        { ParameterType.Number,     en = "Waiting time", de = "Wartezeit"},</p><p>    },</p><p>    return { Triggers.Custom2,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.QuestName = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.WaitTime = (_Parameter ~= nil and tonumber(_Parameter)) or 0</p><p>    end</p><p>    local QuestID = GetQuestID(self.QuestName)</p><p>    if QuestID ~= nil then</p><p>        assert(type(QuestID) == "number");</p><p>        if (Quests[QuestID].State == QuestState.Active) then</p><p>            self.WasActivated = self.WasActivated or true;</p><p>        end</p><p>        if self.WasActivated then</p><p>            if self.WaitTime and self.WaitTime  0 then</p><p>                self.WaitTimeTimer = self.WaitTimeTimer or Logic.GetTime();</p><p>                if Logic.GetTime() = self.WaitTimeTimer + self.WaitTime then</p><p>                    return true;</p><p>                end</p><p>            else</p><p>                return true;</p><p>            end</p><p>        end</p><p>    end</p><p>    return false;</p><p>    if type(self.QuestName) ~= "string" then</p><p>        fatal("".._Quest.Identifier.." "..self.Name..": invalid quest name!");</p><p>        return true;</p><p>    elseif self.WaitTime and (type(self.WaitTime) ~= "number" or self.WaitTime  0) then</p><p>        dbg("".._Quest.Identifier.." "..self.Name..": waitTime must be a number!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>    -- does this realy matter after interrupt?</p><p>    -- self.WaitTimeTimer = nil;</p><p>    -- self.WasActivated = nil;</p><p>    self.WaitTimeTimer = nil;</p><p>    self.WasActivated = nil;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet einen Quest, sobald ein anderer fehlschlägt.</p><p>-- @param _QuestName Name des Quest</p><p>-- @param _Time      Wartezeit</p><p>-- return Table mit Behavior</p><p>-- @within Trigger</p><p>    return b_Trigger_OnQuestFailure:new(...);</p><p>Trigger_OnQuestFailure</p><p>    Name = "Trigger_OnQuestFailure",</p><p>    Description = {</p><p>        en = "Trigger: if a given quest has failed. Waiting time optional",</p><p>        de = "Auslöser: wenn eine angegebene Quest fehlgeschlagen ist. Optional mit Wartezeit",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.QuestName,     en = "Quest name", de = "Questname" },</p><p>        { ParameterType.Number,     en = "Waiting time", de = "Wartezeit"},</p><p>    },</p><p>    return { Triggers.Custom2,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.QuestName = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.WaitTime = (_Parameter ~= nil and tonumber(_Parameter)) or 0</p><p>    end</p><p>    if (GetQuestID(self.QuestName) ~= nil) then</p><p>        local QuestID = GetQuestID(self.QuestName)</p><p>        if (Quests[QuestID].Result == QuestResult.Failure) then</p><p>            if self.WaitTime and self.WaitTime  0 then</p><p>                self.WaitTimeTimer = self.WaitTimeTimer or Logic.GetTime();</p><p>                if Logic.GetTime() = self.WaitTimeTimer + self.WaitTime then</p><p>                    return true;</p><p>                end</p><p>            else</p><p>                return true;</p><p>            end</p><p>        end</p><p>    end</p><p>    return false;</p><p>    if type(self.QuestName) ~= "string" then</p><p>        fatal("".._Quest.Identifier.." "..self.Name..": invalid quest name!");</p><p>        return true;</p><p>    elseif self.WaitTime and (type(self.WaitTime) ~= "number" or self.WaitTime  0) then</p><p>        dbg("".._Quest.Identifier.." "..self.Name..": waitTime must be a number!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>    self.WaitTimeTimer = nil;</p><p>    self.WaitTimeTimer = nil;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet einen Quest, wenn ein anderer noch nicht ausgelöst wurde.</p><p>-- @param _QuestName Name des Quest</p><p>-- @param _Time      Wartezeit</p><p>-- return Table mit Behavior</p><p>-- @within Trigger</p><p>    return b_Trigger_OnQuestNotTriggered:new(...);</p><p>Trigger_OnQuestNotTriggered</p><p>    Name = "Trigger_OnQuestNotTriggered",</p><p>    Description = {</p><p>        en = "Trigger: if a given quest is not yet active. Should be used in combination with other triggers.",</p><p>        de = "Auslöser: wenn eine angegebene Quest noch inaktiv ist. Sollte mit weiteren Triggern kombiniert werden.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.QuestName,     en = "Quest name", de = "Questname" },</p><p>    },</p><p>    return { Triggers.Custom2,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.QuestName = _Parameter</p><p>    end</p><p>    if (GetQuestID(self.QuestName) ~= nil) then</p><p>        local QuestID = GetQuestID(self.QuestName)</p><p>        if (Quests[QuestID].State == QuestState.NotTriggered) then</p><p>            return true;</p><p>        end</p><p>    end</p><p>    return false;</p><p>    if type(self.QuestName) ~= "string" then</p><p>        fatal("".._Quest.Identifier.." "..self.Name..": invalid quest name!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet den Quest, sobald ein anderer unterbrochen wurde.</p><p>-- @param _QuestName Name des Quest</p><p>-- @param _Time      Wartezeit</p><p>-- return Table mit Behavior</p><p>-- @within Trigger</p><p>    return b_Trigger_OnQuestInterrupted:new(...);</p><p>Trigger_OnQuestInterrupted</p><p>    Name = "Trigger_OnQuestInterrupted",</p><p>    Description = {</p><p>        en = "Trigger: if a given quest has been interrupted. Should be used in combination with other triggers.",</p><p>        de = "Auslöser: wenn eine angegebene Quest abgebrochen wurde. Sollte mit weiteren Triggern kombiniert werden.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.QuestName,     en = "Quest name", de = "Questname" },</p><p>        { ParameterType.Number,     en = "Waiting time", de = "Wartezeit"},</p><p>    },</p><p>    return { Triggers.Custom2,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.QuestName = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.WaitTime = (_Parameter ~= nil and tonumber(_Parameter)) or 0</p><p>    end</p><p>    if (GetQuestID(self.QuestName) ~= nil) then</p><p>        local QuestID = GetQuestID(self.QuestName)</p><p>        if (Quests[QuestID].State == QuestState.Over and Quests[QuestID].Result == QuestResult.Interrupted) then</p><p>            if self.WaitTime and self.WaitTime  0 then</p><p>                self.WaitTimeTimer = self.WaitTimeTimer or Logic.GetTime();</p><p>                if Logic.GetTime() = self.WaitTimeTimer + self.WaitTime then</p><p>                    return true;</p><p>                end</p><p>            else</p><p>                return true;</p><p>            end</p><p>        end</p><p>    end</p><p>    return false;</p><p>    if type(self.QuestName) ~= "string" then</p><p>        fatal("".._Quest.Identifier.." "..self.Name..": invalid quest name!");</p><p>        return true;</p><p>    elseif self.WaitTime and (type(self.WaitTime) ~= "number" or self.WaitTime  0) then</p><p>        dbg("".._Quest.Identifier.." "..self.Name..": waitTime must be a number!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>    self.WaitTimeTimer = nil;</p><p>    self.WaitTimeTimer = nil;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet den Quest, sobald ein anderer bendet wurde.</p><p>-- Dabei ist das Resultat egal. Der Quest kann entweder erfolgreich beendet</p><p>-- wurden oder fehlgeschlagen sein.</p><p>-- @param _QuestName Name des Quest</p><p>-- @param _Time      Wartezeit</p><p>-- return Table mit Behavior</p><p>-- @within Trigger</p><p>    return b_Trigger_OnQuestOver:new(...);</p><p>Trigger_OnQuestOver</p><p>    Name = "Trigger_OnQuestOver",</p><p>    Description = {</p><p>        en = "Trigger: if a given quest has been finished, regardless of its result. Waiting time optional",</p><p>        de = "Auslöser: wenn eine angegebene Quest beendet wurde, unabhängig von deren Ergebnis. Wartezeit optional",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.QuestName,     en = "Quest name", de = "Questname" },</p><p>        { ParameterType.Number,     en = "Waiting time", de = "Wartezeit"},</p><p>    },</p><p>    return { Triggers.Custom2,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.QuestName = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.WaitTime = (_Parameter ~= nil and tonumber(_Parameter)) or 0</p><p>    end</p><p>    if (GetQuestID(self.QuestName) ~= nil) then</p><p>        local QuestID = GetQuestID(self.QuestName)</p><p>        if (Quests[QuestID].State == QuestState.Over and Quests[QuestID].Result ~= QuestResult.Interrupted) then</p><p>            if self.WaitTime and self.WaitTime  0 then</p><p>                self.WaitTimeTimer = self.WaitTimeTimer or Logic.GetTime();</p><p>                if Logic.GetTime() = self.WaitTimeTimer + self.WaitTime then</p><p>                    return true;</p><p>                end</p><p>            else</p><p>                return true;</p><p>            end</p><p>        end</p><p>    end</p><p>    return false;</p><p>    if type(self.QuestName) ~= "string" then</p><p>        fatal("".._Quest.Identifier.." "..self.Name..": invalid quest name!");</p><p>        return true;</p><p>    elseif self.WaitTime and (type(self.WaitTime) ~= "number" or self.WaitTime  0) then</p><p>        dbg("".._Quest.Identifier.." "..self.Name..": waitTime must be a number!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>    self.WaitTimeTimer = nil;</p><p>    self.WaitTimeTimer = nil;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet den Quest, sobald ein anderer Quest erfolgreich abgeschlossen wurde.</p><p>-- @param _QuestName Name des Quest</p><p>-- @param _Time      Wartezeit</p><p>-- return Table mit Behavior</p><p>-- @within Trigger</p><p>    return b_Trigger_OnQuestSuccess:new(...);</p><p>Trigger_OnQuestSuccess</p><p>    Name = "Trigger_OnQuestSuccess",</p><p>    Description = {</p><p>        en = "Trigger: if a given quest has been finished successfully. Waiting time optional",</p><p>        de = "Auslöser: wenn eine angegebene Quest erfolgreich abgeschlossen wurde. Wartezeit optional",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.QuestName,     en = "Quest name", de = "Questname" },</p><p>        { ParameterType.Number,     en = "Waiting time", de = "Wartezeit"},</p><p>    },</p><p>    return { Triggers.Custom2,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.QuestName = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.WaitTime = (_Parameter ~= nil and tonumber(_Parameter)) or 0</p><p>    end</p><p>    if (GetQuestID(self.QuestName) ~= nil) then</p><p>        local QuestID = GetQuestID(self.QuestName)</p><p>        if (Quests[QuestID].Result == QuestResult.Success) then</p><p>            if self.WaitTime and self.WaitTime  0 then</p><p>                self.WaitTimeTimer = self.WaitTimeTimer or Logic.GetTime();</p><p>                if Logic.GetTime() = self.WaitTimeTimer + self.WaitTime then</p><p>                    return true;</p><p>                end</p><p>            else</p><p>                return true;</p><p>            end</p><p>        end</p><p>    end</p><p>    return false;</p><p>    if type(self.QuestName) ~= "string" then</p><p>        fatal("".._Quest.Identifier.." "..self.Name..": invalid quest name!");</p><p>        return true;</p><p>    elseif self.WaitTime and (type(self.WaitTime) ~= "number" or self.WaitTime  0) then</p><p>        dbg("".._Quest.Identifier.." "..self.Name..": waittime must be a number!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>    self.WaitTimeTimer = nil;</p><p>    self.WaitTimeTimer = nil;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet den Quest, wenn eine benutzerdefinierte Variable einen bestimmten</p><p>-- Wert angenommen hat.</p><p>-- Benutzerdefinierte Variablen müssen Zahlen sein. Bevor eine</p><p>-- Variable in einem Goal abgefragt werden kann, muss sie zuvor mit</p><p>-- Reprisal_CustomVariables oder Reward_CutsomVariables initialisiert</p><p>-- worden sein.</p><p>-- @param _Name     Name der Variable</p><p>-- @param _Relation Vergleichsoperator</p><p>-- @param _Value    Wert oder Custom Variable</p><p>-- @within Trigger</p><p>    return b_Trigger_CustomVariables:new(...);</p><p>Trigger_CustomVariables</p><p>    Name = "Trigger_CustomVariables",</p><p>    Description = {</p><p>        en = "Trigger: if the variable has a certain value.",</p><p>        de = "Auslöser: wenn die Variable einen bestimmen Wert eingenommen hat.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Default, en = "Name of Variable", de = "Variablennamen" },</p><p>        { ParameterType.Custom,  en = "Relation", de = "Relation" },</p><p>        { ParameterType.Default, en = "Value", de = "Wert" }</p><p>    }</p><p>    return { Triggers.Custom2, {self, self.CustomFunction} };</p><p>    if _Index == 0 then</p><p>        self.VariableName = _Parameter</p><p>    elseif _Index == 1 then</p><p>        self.Relation = _Parameter</p><p>    elseif _Index == 2 then</p><p>        local value = tonumber(_Parameter);</p><p>        value = (value ~= nil and value) or _Parameter;</p><p>        self.Value = value</p><p>    end</p><p>    _G["QSB_CustomVariables_"..self.VariableName] = _G["QSB_CustomVariables_"..self.VariableName] or 0;</p><p>    if self.Relation == "==" then</p><p>        return _G["QSB_CustomVariables_"..self.VariableName] == ((type(self.Value) ~= "string" and self.Value) or _G["QSB_CustomVariables_"..self.Value]);</p><p>    elseif self.Relation ~= "~=" then</p><p>        return _G["QSB_CustomVariables_"..self.VariableName] ~= ((type(self.Value) ~= "string" and self.Value) or _G["QSB_CustomVariables_"..self.Value]);</p><p>    elseif self.Relation == "" then</p><p>        return _G["QSB_CustomVariables_"..self.VariableName]  ((type(self.Value) ~= "string" and self.Value) or _G["QSB_CustomVariables_"..self.Value]);</p><p>    elseif self.Relation == "=" then</p><p>        return _G["QSB_CustomVariables_"..self.VariableName] = ((type(self.Value) ~= "string" and self.Value) or _G["QSB_CustomVariables_"..self.Value]);</p><p>    elseif self.Relation == "=" then</p><p>        return _G["QSB_CustomVariables_"..self.VariableName] = ((type(self.Value) ~= "string" and self.Value) or _G["QSB_CustomVariables_"..self.Value]);</p><p>    else</p><p>        return _G["QSB_CustomVariables_"..self.VariableName]  ((type(self.Value) ~= "string" and self.Value) or _G["QSB_CustomVariables_"..self.Value]);</p><p>    end</p><p>    return false;</p><p>    if _Index == 1 then</p><p>        return {"==", "~=", "="};</p><p>    end</p><p>    local relations = {"==", "~=", "="}</p><p>    local results    = {true, false, nil}</p><p>    if not _G["QSB_CustomVariables_"..self.VariableName] then</p><p>        warn(_Quest.Identifier.." "..self.Name..": variable '"..self.VariableName.."' do not exist!");</p><p>    end</p><p>    if not Inside(self.Relation,relations) then</p><p>        fatal(_Quest.Identifier.." "..self.Name..": '"..self.Relation.."' is an invalid relation!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet den Quest sofort.</p><p>-- @within Trigger</p><p>    return b_Trigger_AlwaysActive:new()</p><p>Trigger_AlwaysActive</p><p>    Name = "Trigger_AlwaysActive",</p><p>    Description = {</p><p>        en = "Trigger: the map has been started.",</p><p>        de = "Auslöser: Start der Karte.",</p><p>    },</p><p>    return {Triggers.Time, 0 }</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet den Quest im angegebenen Monat.</p><p>-- @param _Month Monat</p><p>-- @within Trigger</p><p>    return b_Trigger_OnMonth:new(...);</p><p>Trigger_OnMonth</p><p>    Name = "Trigger_OnMonth",</p><p>    Description = {</p><p>        en = "Trigger: a specified month",</p><p>        de = "Auslöser: ein bestimmter Monat",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Custom, en = "Month", de = "Monat" },</p><p>    },</p><p>    return { Triggers.Custom2,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.Month = _Parameter * 1</p><p>    end</p><p>    return self.Month == Logic.GetCurrentMonth()</p><p>    local Data = {}</p><p>    if _Index == 0 then</p><p>        for i = 1, 12 do</p><p>            table.insert( Data, i )</p><p>        end</p><p>    else</p><p>        assert( false )</p><p>    end</p><p>    return Data</p><p>    if self.Month  12 then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": Month has the wrong value")</p><p>        return true</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet den Quest sobald der Monsunregen einsetzt.</p><p>--  Dieses Behavior ist nur für Reich des Ostens verfügbar.</p><p>-- @within Trigger</p><p>    return b_Trigger_OnMonsoon:new();</p><p>Trigger_OnMonsoon</p><p>    Name = "Trigger_OnMonsoon",</p><p>    Description = {</p><p>        en = "Trigger: on monsoon.",</p><p>        de = "Auslöser: wenn der Monsun beginnt.",</p><p>    },</p><p>    RequiresExtraNo = 1,</p><p>    return { Triggers.Custom2,{self, self.CustomFunction} }</p><p>    if Logic.GetWeatherDoesShallowWaterFlood(0) then</p><p>        return true</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet den Quest sobald der Timer abgelaufen ist.</p><p>-- Der Timer zählt immer vom Start der Map an.</p><p>-- @param _Time Zeit bis zum Start</p><p>-- @within Trigger</p><p>    return b_Trigger_Time:new(...);</p><p>Trigger_Time</p><p>    Name = "Trigger_Time",</p><p>    Description = {</p><p>        en = "Trigger: a given amount of time since map start",</p><p>        de = "Auslöser: eine gewisse Anzahl Sekunden nach Spielbeginn",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Number, en = "Time (sec.)", de = "Zeit (Sek.)" },</p><p>    },</p><p>    return {Triggers.Time, self.Time }</p><p>    if (_Index == 0) then</p><p>        self.Time = _Parameter * 1</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet den Quest sobald das Wasser gefriert.</p><p>-- @within Trigger</p><p>    return b_Trigger_OnWaterFreezes:new();</p><p>Trigger_OnWaterFreezes</p><p>    Name = "Trigger_OnWaterFreezes",</p><p>    Description = {</p><p>        en = "Trigger: if the water starts freezing",</p><p>        de = "Auslöser: wenn die Gewässer gefrieren",</p><p>    },</p><p>    return { Triggers.Custom2,{self, self.CustomFunction} }</p><p>    if Logic.GetWeatherDoesWaterFreeze(0) then</p><p>        return true</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet den Quest niemals.</p><p>-- Quests, für die dieser Trigger gesetzt ist, müssen durch einen anderen</p><p>-- Quest über Reward_QuestActive oder Reprisal_QuestActive gestartet werden.</p><p>-- @within Trigger</p><p>    return b_Trigger_NeverTriggered:new();</p><p>Trigger_NeverTriggered</p><p>    Name = "Trigger_NeverTriggered",</p><p>    Description = {</p><p>        en = "Never triggers a Quest. The quest may be set active by Reward_QuestActivate or Reward_QuestRestartForceActive",</p><p>        de = "Löst nie eine Quest aus. Die Quest kann von Reward_QuestActivate oder Reward_QuestRestartForceActive aktiviert werden.",</p><p>    },</p><p>    return {Triggers.Custom2, {self, function() end} }</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet den Quest, sobald wenigstens einer von zwei Quests fehlschlägt.</p><p>-- @param _QuestName1 Name des ersten Quest</p><p>-- @param _QuestName2 Name des zweiten Quest</p><p>-- @within Trigger</p><p>    return b_Trigger_OnAtLeastOneQuestFailure:new(...);</p><p>Trigger_OnAtLeastOneQuestFailure</p><p>    Name = "Trigger_OnAtLeastOneQuestFailure",</p><p>    Description = {</p><p>        en = "Trigger: if one or both of the given quests have failed.",</p><p>        de = "Auslöser: wenn einer oder beide der angegebenen Aufträge fehlgeschlagen sind.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.QuestName, en = "Quest Name 1", de = "Questname 1" },</p><p>        { ParameterType.QuestName, en = "Quest Name 2", de = "Questname 2" },</p><p>    },</p><p>    return {Triggers.Custom2, {self, self.CustomFunction}};</p><p>    self.QuestTable = {};</p><p>    if (_Index == 0) then</p><p>        self.Quest1 = _Parameter;</p><p>    elseif (_Index == 1) then</p><p>        self.Quest2 = _Parameter;</p><p>    end</p><p>    local Quest1 = Quests[GetQuestID(self.Quest1)];</p><p>    local Quest2 = Quests[GetQuestID(self.Quest2)];</p><p>    if (Quest1.State == QuestState.Over and Quest1.Result == QuestResult.Failure)</p><p>    or (Quest2.State == QuestState.Over and Quest2.Result == QuestResult.Failure) then</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>    if self.Quest1 == self.Quest2 then</p><p>        fatal(_Quest.Identifier..": "..self.Name..": Both quests are identical!");</p><p>        return true;</p><p>    elseif not IsValidQuest(self.Quest1) then</p><p>        fatal(_Quest.Identifier..": "..self.Name..": Quest '"..self.Quest1.."' does not exist!");</p><p>        return true;</p><p>    elseif not IsValidQuest(self.Quest2) then</p><p>        fatal(_Quest.Identifier..": "..self.Name..": Quest '"..self.Quest2.."' does not exist!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet den Quest, sobald wenigstens einer von zwei Quests erfolgreich ist.</p><p>-- @param _QuestName1 Name des ersten Quest</p><p>-- @param _QuestName2 Name des zweiten Quest</p><p>-- @within Trigger</p><p>    return b_Trigger_OnAtLeastOneQuestSuccess:new(...);</p><p>Trigger_OnAtLeastOneQuestSuccess</p><p>    Name = "Trigger_OnAtLeastOneQuestSuccess",</p><p>    Description = {</p><p>        en = "Trigger: if one or both of the given quests are won.",</p><p>        de = "Auslöser: wenn einer oder beide der angegebenen Aufträge gewonnen wurden.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.QuestName, en = "Quest Name 1", de = "Questname 1" },</p><p>        { ParameterType.QuestName, en = "Quest Name 2", de = "Questname 2" },</p><p>    },</p><p>    return {Triggers.Custom2, {self, self.CustomFunction}};</p><p>    self.QuestTable = {};</p><p>    if (_Index == 0) then</p><p>        self.Quest1 = _Parameter;</p><p>    elseif (_Index == 1) then</p><p>        self.Quest2 = _Parameter;</p><p>    end</p><p>    local Quest1 = Quests[GetQuestID(self.Quest1)];</p><p>    local Quest2 = Quests[GetQuestID(self.Quest2)];</p><p>    if (Quest1.State == QuestState.Over and Quest1.Result == QuestResult.Success)</p><p>    or (Quest2.State == QuestState.Over and Quest2.Result == QuestResult.Success) then</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>    if self.Quest1 == self.Quest2 then</p><p>        fatal(_Quest.Identifier..": "..self.Name..": Both quests are identical!");</p><p>        return true;</p><p>    elseif not IsValidQuest(self.Quest1) then</p><p>        fatal(_Quest.Identifier..": "..self.Name..": Quest '"..self.Quest1.."' does not exist!");</p><p>        return true;</p><p>    elseif not IsValidQuest(self.Quest2) then</p><p>        fatal(_Quest.Identifier..": "..self.Name..": Quest '"..self.Quest2.."' does not exist!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet den Quest, sobald mindestens X von Y Quests erfolgreich sind.</p><p>-- @param _MinAmount   Mindestens zu erfüllen (max. 5)</p><p>-- @param _QuestAmount Anzahl geprüfter Quests (max. 5 und = _MinAmount)</p><p>-- @param _Quest1      Name des 1. Quest</p><p>-- @param _Quest2      Name des 2. Quest</p><p>-- @param _Quest3      Name des 3. Quest</p><p>-- @param _Quest4      Name des 4. Quest</p><p>-- @param _Quest5      Name des 5. Quest</p><p>-- @within Trigger</p><p>    return b_Trigger_OnAtLeastXOfYQuestsSuccess:new(...);</p><p>Trigger_OnAtLeastXOfYQuestsSuccess</p><p>    Name = "Trigger_OnAtLeastXOfYQuestsSuccess",</p><p>    Description = {</p><p>        en = "Trigger: if at least X of Y given quests has been finished successfully.",</p><p>        de = "Auslöser: wenn X von Y angegebener Quests erfolgreich abgeschlossen wurden.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Custom, en = "Least Amount", de = "Mindest Anzahl" },</p><p>        { ParameterType.Custom, en = "Quest Amount", de = "Quest Anzahl" },</p><p>        { ParameterType.QuestName, en = "Quest name 1", de = "Questname 1" },</p><p>        { ParameterType.QuestName, en = "Quest name 2", de = "Questname 2" },</p><p>        { ParameterType.QuestName, en = "Quest name 3", de = "Questname 3" },</p><p>        { ParameterType.QuestName, en = "Quest name 4", de = "Questname 4" },</p><p>        { ParameterType.QuestName, en = "Quest name 5", de = "Questname 5" },</p><p>    },</p><p>    return { Triggers.Custom2,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.LeastAmount = tonumber(_Parameter)</p><p>    elseif (_Index == 1) then</p><p>        self.QuestAmount = tonumber(_Parameter)</p><p>    elseif (_Index == 2) then</p><p>        self.QuestName1 = _Parameter</p><p>    elseif (_Index == 3) then</p><p>        self.QuestName2 = _Parameter</p><p>    elseif (_Index == 4) then</p><p>        self.QuestName3 = _Parameter</p><p>    elseif (_Index == 5) then</p><p>        self.QuestName4 = _Parameter</p><p>    elseif (_Index == 6) then</p><p>        self.QuestName5 = _Parameter</p><p>    end</p><p>    local least = 0</p><p>    for i = 1, self.QuestAmount do</p><p>        local QuestID = GetQuestID(self["QuestName"..i]);</p><p>        if IsValidQuest(QuestID) then</p><p>    end</p><p>    return false</p><p>    local leastAmount = self.LeastAmount</p><p>    local questAmount = self.QuestAmount</p><p>    if leastAmount 5 then</p><p>        fatal(_Quest.Identifier .. ": Error in " .. self.Name .. ": LeastAmount is wrong")</p><p>        return true</p><p>    elseif questAmount  5 then</p><p>        fatal(_Quest.Identifier .. ": Error in " .. self.Name .. ": QuestAmount is wrong")</p><p>        return true</p><p>    elseif leastAmount  questAmount then</p><p>        fatal(_Quest.Identifier .. ": Error in " .. self.Name .. ": LeastAmount is greater than QuestAmount")</p><p>        return true</p><p>    end</p><p>    for i = 1, questAmount do</p><p>        if not IsValidQuest(self["QuestName"..i]) then</p><p>            fatal(_Quest.Identifier .. ": Error in " .. self.Name .. ": Quest ".. self["QuestName"..i] .. " not found")</p><p>            return true</p><p>        end</p><p>    end</p><p>    return false</p><p>    if (_Index == 0) or (_Index == 1) then</p><p>        return {"1", "2", "3", "4", "5"}</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Führt eine Funktion im Skript als Trigger aus.</p><p>-- Die Funktion muss entweder true or false zurückgeben.</p><p>-- Nur Skipt: Wird statt einem Funktionsnamen (String) eine Funktionsreferenz</p><p>-- übergeben, werden alle weiteren Parameter an die Funktion weitergereicht.</p><p>-- @param _FunctionName Name der Funktion</p><p>-- @within Trigger</p><p>    return b_Trigger_MapScriptFunction:new(...);</p><p>Trigger_MapScriptFunction</p><p>    Name = "Trigger_MapScriptFunction",</p><p>    Description = {</p><p>        en = "Calls a function within the global map script. If the function returns true the quest will be started",</p><p>        de = "Ruft eine Funktion im globalen Skript auf. Wenn sie true sendet, wird die Quest gestartet.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Default, en = "Function name", de = "Funktionsname" },</p><p>    },</p><p>    return {Triggers.Custom2, {self, self.CustomFunction}};</p><p>    if (_Index == 0) then</p><p>        self.FuncName = _Parameter</p><p>    end</p><p>    if type(self.FuncName) == "function" then</p><p>        return self.Function(unpack(self.i47ya_6aghw_frxil));</p><p>    end</p><p>    return _G[self.FuncName](self, _Quest);</p><p>    if not self.FuncName then</p><p>        fatal(_Quest.Identifier.." "..self.Name..": function reference is invalid!");</p><p>        return true;</p><p>    end</p><p>    if type(self.FuncName) == "string" and not _G[self.FuncName] then</p><p>        fatal(_Quest.Identifier.." "..self.Name..": function does not exist!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Veränderte Behavior (Build 1410)                                           --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der Spieler muss im Chatdialog eine Eingabe tätigen.</p><p>-- Die Eingabe wird im Quest gespeichert und kann zur späteren Verarbeitung</p><p>-- angefragt werden.</p><p>-- Das Behaviour kann auch eingesetzt werden, um ein Passwort zu prüfen.</p><p>-- In diesem Fall wird die Eingabe mit dem Passwort verglichen. Die Anzal der</p><p>-- Versuche bestimmt, wie oft falsch eingegeben werden darf.</p><p>-- Wenn die Anzahl der Versuche begrenzt ist, wird eine Srandardnachricht mit</p><p>-- den übrigen Versuchen angezeigt. Optional kann eine Nachricht angegeben</p><p>-- werden, die stattdessen nach  der</p><p>-- letzten, angezeigt wird.</p><p>-- @param _Passwords Liste der Passwörter</p><p>-- @param _Trials    Anzahl versuche (0 für unendlich)</p><p>-- @param _Message   Alternative Fehlernachricht</p><p>-- @within Goal</p><p>    return b_Goal_InputDialog:new(...);</p><p>Goal_InputDialog </p><p>    Name = "Goal_InputDialog",</p><p>    Description = {</p><p>        en = "Goal: Player must type in something. The passwords have to be seperated by ; and whitespaces will be ignored.",</p><p>        de = "Ziel: Oeffnet einen Dialog, der Spieler muss Lösungswörter eingeben. Diese sind durch ; abzutrennen. Leerzeichen werden ignoriert.",</p><p>    },</p><p>    DefaultMessage = {</p><p>        de = "Versuche bis zum Fehlschlag: ",</p><p>        en = "Trials remaining until failure: "</p><p>    },</p><p>    Parameter = {</p><p>        {ParameterType.Default, en = "Password to enter", de = "Einzugebendes Passwort" },</p><p>        {ParameterType.Number, en = "Trials till failure (0 endless)", de = "Versuche bis Fehlschlag (0 endlos)" },</p><p>        {ParameterType.Default, en = "Wrong password message", de = "Text bei Falscheingabe" },</p><p>    }</p><p>    return { Objective.Custom2, {self, self.CustomFunction}}</p><p>    if (_Index == 0) then</p><p>        self.Password = self:LowerCase(_Parameter or "");</p><p>    elseif (_Index == 1) then</p><p>        self.Trials = (_Parameter or 0) * 1;</p><p>    elseif (_Index == 2) then</p><p>        self.Message = _Parameter;</p><p>        local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>        if type(self.Message) == "table" then</p><p>            self.Message = self.Message[lang];</p><p>        end</p><p>    end</p><p>    local Box = function(_QuestName)</p><p>        if not self.Shown then</p><p>            self:InitReturnVariable(_QuestName);</p><p>            self:ShowBox();</p><p>            self.Shown = true;</p><p>        end</p><p>    end</p><p>    if not IsBriefingActive or (IsBriefingActive and IsBriefingActive() == false) then</p><p>        if (not self.Trials) or (self.Trials) == 0 then</p><p>            Box(_Quest.Identifier);</p><p>        elseif not self.Shown then</p><p>            self.TrialCounter = self.TrialCounter or self.Trials;</p><p>            Box(_Quest.Identifier);</p><p>            self.TrialCounter = self.TrialCounter - 1;</p><p>        end</p><p>        if _Quest.InputDialogResult then</p><p>            Logic.ExecuteInLuaLocalState([[</p><p>                GUI_Chat.Confirm = GUI_Chat.Confirm_Orig_Goal_InputDialog</p><p>                GUI_Chat.Confirm_Orig_Goal_InputDialog = nil</p><p>                GUI_Chat.Abort = GUI_Chat.Abort_Orig_Goal_InputDialog</p><p>                GUI_Chat.Abort_Orig_Goal_InputDialog = nil</p><p>            ]]);</p><p>            if self.Password ~= nil and self.Password ~= "" then</p><p>                self.Shown = nil;</p><p>                if self:LowerCase(_Quest.InputDialogResult) == self.Password then</p><p>                    return true;</p><p>                elseif (self.Trials == 0) or (self.Trials  0 and self.TrialCounter  0) then</p><p>                    self:OnWrongInput(_Quest);</p><p>                    return;</p><p>                else</p><p>                    return false;</p><p>                end</p><p>            end</p><p>            return true;</p><p>        end</p><p>    end</p><p>    if self.Trials  0 and not self.Message then</p><p>        local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>        Logic.DEBUG_AddNote(self.DefaultMessage .. self.TrialCounter);</p><p>        return;</p><p>    end</p><p>    if self.Message then</p><p>        Logic.DEBUG_AddNote(self.Message);</p><p>    end</p><p>    _Quest.InputDialogResult = nil;</p><p>    _Text = _Text:lower(_Text);</p><p>    -- Umlaute manuell austauschen</p><p>    -- FIXME: Ausländische Umlaute auch anpassen.</p><p>    _Text = _Text:gsub("Ä", "ä");</p><p>    _Text = _Text:gsub("Ö", "ö");</p><p>    _Text = _Text:gsub("Ü", "ü");</p><p>    return _Text;</p><p>    Logic.ExecuteInLuaLocalState([[</p><p>        Input.ChatMode()</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/ChatInput",1)</p><p>        XGUIEng.SetText("/InGame/Root/Normal/ChatInput/ChatInput", "")</p><p>        XGUIEng.SetFocus("/InGame/Root/Normal/ChatInput/ChatInput")</p><p>    ]])</p><p>    Logic.ExecuteInLuaLocalState([[</p><p>        GUI_Chat.Abort_Orig_Goal_InputDialog = GUI_Chat.Abort</p><p>        GUI_Chat.Confirm_Orig_Goal_InputDialog = GUI_Chat.Confirm</p><p>        GUI_Chat.Confirm = function()</p><p>            Input.GameMode()</p><p>            XGUIEng.ShowWidget("/InGame/Root/Normal/ChatInput",0)</p><p>            local ChatMessage = XGUIEng.GetText("/InGame/Root/Normal/ChatInput/ChatInput")</p><p>            g_Chat.JustClosed = 1</p><p>            GUI.SendScriptCommand("Quests[GetQuestID(']].. _QuestName ..[[')].InputDialogResult = '"..ChatMessage.."'")</p><p>        end</p><p>        GUI_Chat.Abort = function()</p><p>        end</p><p>    ]])</p><p>    return false;</p><p>    return {12,2};</p><p>    _Quest.InputDialogResult = nil;</p><p>    self.TrialCounter = nil;</p><p>    self.Shown = nil;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Behavior Nachimplementiert(Build 1420)                                     --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet den Quest, sobald ein Effekt zerstört wird oder verschwindet.</p><p>-- : Das Behavior kann nur auf Effekte angewand werden, die</p><p>-- über Effekt-Behavior erzeugt wurden.</p><p>-- @param _EffectName Name des Effekt</p><p>-- @within Trigger</p><p>    return b_Trigger_OnEffectDestroyed:new(...);</p><p>Trigger_OnEffectDestroyed</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Setzt das Upgrade Level des angegebenen Gebäudes.</p><p>-- Ein Geböude erhält sofort eine neue Stufe, ohne dass ein Arbeiter kommen</p><p>-- und es ausbauen muss. Für eine Werkstatt wird ein neuer Arbeiter gespawnt.</p><p>-- @param _ScriptName Skriptname des Gebäudes</p><p>-- @param _Level Upgrade Level</p><p>-- @within Reward</p><p>    return b_Reward_SetBuildingUpgradeLevel:new(...);</p><p>Reward_SetBuildingUpgradeLevel</p><p> </p><p> </p><p> </p><p>    if _Index == 1 then</p><p>        return { "0", "1", "2", "3" };</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {},</p><p>    Local = {}</p><p>-- Global Script ---------------------------------------------------------------</p><p>-- Initialisiert das Bundle im globalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    self:OverrideIsObjectiveCompleted();</p><p>-- Gibt das im Quest gespeicherte Resultat von Goal_InputDialog zurück.</p><p>-- : Es wird nur die letzte Eingabe zurückgegeben.</p><p>-- @param[type=string] _QuestName Name des Quest</p><p>-- @return[type=string] Eingabe des Spielers</p><p>-- @within Internal</p><p>-- @local</p><p>    local Quest = Quests[GetQuestID(_QuestName)];</p><p>    if not Quest then</p><p>        return;</p><p>    end</p><p>    return Quest.InputDialogResult;</p><p>-- Überschreibt IsObjectiveCompleted und behebt einen Fehler in dem</p><p>-- Objective "DestroyAllPlayerUnits", der Baustellen ignorierte.</p><p>-- @within Internal</p><p>-- @local</p><p>    QuestTemplate.IsObjectiveCompleted_Orig_QSB_ClassicBehaviors = QuestTemplate.IsObjectiveCompleted;</p><p>    QuestTemplate.IsObjectiveCompleted = function(self, objective)</p><p>        local objectiveType = objective.Type;</p><p>        if objective.Completed ~= nil then</p><p>            return objective.Completed;</p><p>        end</p><p>        local data = objective.Data;</p><p>        if objectiveType == Objective.DestroyAllPlayerUnits then</p><p>            local PlayerEntities = GetPlayerEntities(data, 0);</p><p>            local IllegalEntities = {};</p><p>            </p><p>            for i= #PlayerEntities, 1, -1 do</p><p>                local Type = Logic.GetEntityType(PlayerEntities[i]);</p><p>                if Logic.IsEntityInCategory(PlayerEntities[i], EntityCategories.AttackableBuilding) == 0 or Logic.IsEntityInCategory(PlayerEntities[i], EntityCategories.Wall) == 0 then</p><p>                    if Logic.IsConstructionComplete(PlayerEntities[i]) == 0 then</p><p>                        table.insert(IllegalEntities, PlayerEntities[i]);</p><p>                    end</p><p>                end</p><p>                local IndestructableEntities = {Entities.XD_ScriptEntity, Entities.S_AIHomePosition, Entities.S_AIAreaDefinition};</p><p>                if Inside(Type, IndestructableEntities) then</p><p>                    table.insert(IllegalEntities, PlayerEntities[i]);</p><p>                end</p><p>            end</p><p>            if #PlayerEntities == 0 or #PlayerEntities - #IllegalEntities == 0 then</p><p>                objective.Completed = true;</p><p>            end</p><p>        else</p><p>            return self:IsObjectiveCompleted_Orig_QSB_ClassicBehaviors(objective);</p><p>        end</p><p>    end</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundleconstructioncontrol.lua.html">
            <div class='doclink'>
                <div>BundleConstructionControl</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia BundleConstructionControl                                    # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Mit diesem Bundle kann der Bau von Gebäudetypen oder Gebäudekategorien</p><p>-- unterbunden werden. Verbote können für bestimmte Bereiche (kreisförmige</p><p>-- Gebiete um ein Zentrum) oder ganze Territorien vereinbart werden.</p><p>-- Das wichtigste Auf einen Blick:</p><p>-- </p><p>-- </p><p>-- Den Bau von Gebäuden an bestimmten Orten steuern.</p><p>-- ,</p><p>-- </p><p>-- </p><p>-- </p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Untersagt den Bau des Typs im Territorium.</p><p>-- @param[type=number] _type      Entitytyp</p><p>-- @param[type=number] _territory Territorium</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.BanTypeAtTerritory(Entities.B_Bakery, 1);</p><p>function API.BanTypeAtTerritory(_type, _territory)</p><p>    if GUI then</p><p>        local Territory = (type(_center) == "string" and "'" .._territory.. "'") or _territory;</p><p>        GUI.SendScriptCommand("API.BanTypeAtTerritory(" .._type.. ", " ..Territory.. ")");</p><p>        return;</p><p>    end</p><p>    if type(_territory) == "string" then</p><p>        _territory = GetTerritoryIDByName(_territory);</p><p>    end</p><p>    BundleConstructionControl.Global.Data.TerritoryBlockEntities[_type] = BundleConstructionControl.Global.Data.TerritoryBlockEntities[_type] or {};</p><p>    if not Inside(_territory, BundleConstructionControl.Global.Data.TerritoryBlockEntities[_type]) then</p><p>        table.insert(BundleConstructionControl.Global.Data.TerritoryBlockEntities[_type], _territory);</p><p>    end</p><p>-- Untersagt den Bau der Kategorie im Territorium.</p><p>-- @param[type=number] _eCat      Entitykategorie</p><p>-- @param[type=number] _territory Territorium</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.BanCategoryAtTerritory(EntityCategories.AttackableBuilding, 2);</p><p>function API.BanCategoryAtTerritory(_eCat, _territory)</p><p>    if GUI then</p><p>        local Territory = (type(_center) == "string" and "'" .._territory.. "'") or _territory;</p><p>        GUI.SendScriptCommand("API.BanTypeAtTerritory(" .._eCat.. ", " ..Territory.. ")");</p><p>        return;</p><p>    end</p><p>    if type(_territory) == "string" then</p><p>        _territory = GetTerritoryIDByName(_territory);</p><p>    end</p><p>    BundleConstructionControl.Global.Data.TerritoryBlockCategories[_eCat] = BundleConstructionControl.Global.Data.TerritoryBlockCategories[_eCat] or {};</p><p>    if not Inside(_territory, BundleConstructionControl.Global.Data.TerritoryBlockCategories[_eCat]) then</p><p>        table.insert(BundleConstructionControl.Global.Data.TerritoryBlockCategories[_eCat], _territory);</p><p>    end</p><p>-- Untersagt den Bau des Typs im Gebiet.</p><p>-- @param[type=number] _type   Entitytyp</p><p>-- @param[type=string] _center Gebietszentrum</p><p>-- @param[type=number] _area   Gebietsgröße</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.BanTypeInArea(Entities.B_Bakery, "groundZero", 4000);</p><p>function API.BanTypeInArea(_type, _center, _area)</p><p>    if GUI then</p><p>        local Center = (type(_center) == "string" and "'" .._center.. "'") or _center;</p><p>        GUI.SendScriptCommand("API.BanTypeInArea(" .._type.. ", " ..Center.. ", " .._area.. ")");</p><p>        return;</p><p>    end</p><p>    BundleConstructionControl.Global.Data.AreaBlockEntities[_center] = BundleConstructionControl.Global.Data.AreaBlockEntities[_center] or {};</p><p>    if not Inside(_type, BundleConstructionControl.Global.Data.AreaBlockEntities[_center], true) then</p><p>        table.insert(BundleConstructionControl.Global.Data.AreaBlockEntities[_center], {_type, _area});</p><p>    end</p><p>-- Untersagt den Bau der Kategorie im Gebiet.</p><p>-- @param[type=number] _eCat   Entitytyp</p><p>-- @param[type=string] _center Gebietszentrum</p><p>-- @param[type=number] _area   Gebietsgröße</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.BanTypeInArea(EntityCategories.CityBuilding, "groundZero", 4000);</p><p>function API.BanCategoryInArea(_eCat, _center, _area)</p><p>    if GUI then</p><p>        local Center = (type(_center) == "string" and "'" .._center.. "'") or _center;</p><p>        GUI.SendScriptCommand("API.BanCategoryInArea(" .._eCat.. ", " ..Center.. ", " .._area.. ")");</p><p>        return;</p><p>    end</p><p>    BundleConstructionControl.Global.Data.AreaBlockCategories[_center] = BundleConstructionControl.Global.Data.AreaBlockCategories[_center] or {};</p><p>    if not Inside(_eCat, BundleConstructionControl.Global.Data.AreaBlockCategories[_center], true) then</p><p>        table.insert(BundleConstructionControl.Global.Data.AreaBlockCategories[_center], {_eCat, _area});</p><p>    end</p><p>-- Gibt einen Typ zum Bau im Territorium wieder frei.</p><p>-- @param[type=number] _type      Entitytyp</p><p>-- @param[type=number] _territory Territorium</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.UnbanTypeAtTerritory(Entities.B_Bakery, 1);</p><p>function API.UnbanTypeAtTerritory(_type, _territory)</p><p>    if GUI then</p><p>        local Territory = (type(_center) == "string" and "'" .._territory.. "'") or _territory;</p><p>        GUI.SendScriptCommand("API.UnbanTypeAtTerritory(" .._type.. ", " ..Territory.. ")");</p><p>        return;</p><p>    end</p><p>    if type(_territory) == "string" then</p><p>        _territory = GetTerritoryIDByName(_territory);</p><p>    end</p><p>    if not BundleConstructionControl.Global.Data.TerritoryBlockEntities[_type] then</p><p>        return;</p><p>    end</p><p>    for i= #BundleConstructionControl.Global.Data.TerritoryBlockEntities[_type], 1, -1 do</p><p>        if BundleConstructionControl.Global.Data.TerritoryBlockEntities[_type][i] == _territory then</p><p>            table.remove(BundleConstructionControl.Global.Data.TerritoryBlockEntities[_type], i);</p><p>            break;</p><p>        end</p><p>    end</p><p>-- Gibt eine Kategorie zum Bau im Territorium wieder frei.</p><p>-- @param[type=number] _eCat      Entitykategorie</p><p>-- @param[type=number] _territory Territorium</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.UnbanCategoryAtTerritory(EntityCategories.AttackableBuilding, 1);</p><p>function API.UnbanCategoryAtTerritory(_eCat, _territory)</p><p>    if GUI then</p><p>        local Territory = (type(_center) == "string" and "'" .._territory.. "'") or _territory;</p><p>        GUI.SendScriptCommand("API.UnbanTypeAtTerritory(" .._eCat.. ", " ..Territory.. ")");</p><p>        return;</p><p>    end</p><p>    if type(_territory) == "string" then</p><p>        _territory = GetTerritoryIDByName(_territory);</p><p>    end</p><p>    if not BundleConstructionControl.Global.Data.TerritoryBlockCategories[_eCat] then</p><p>        return;</p><p>    end</p><p>    for i= #BundleConstructionControl.Global.Data.TerritoryBlockCategories[_eCat], 1, -1 do</p><p>        if BundleConstructionControl.Global.Data.TerritoryBlockCategories[_eCat][i] == _territory then</p><p>            table.remove(BundleConstructionControl.Global.Data.TerritoryBlockCategories[_eCat], i);</p><p>            break;</p><p>        end</p><p>    end</p><p>-- Gibt einen Typ zum Bau im Gebiet wieder frei.</p><p>-- @param[type=number] _type   Entitytyp</p><p>-- @param[type=string] _center Gebiet</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.UnbanTypeInArea(Entities.B_Bakery, "groundZero");</p><p>function API.UnbanTypeInArea(_type, _center)</p><p>    if GUI then</p><p>        local Center = (type(_center) == "string" and "'" .._center.. "'") or _center;</p><p>        GUI.SendScriptCommand("API.UnbanTypeInArea(" .._eCat.. ", " ..Center.. ")");</p><p>        return;</p><p>    end</p><p>    if not BundleConstructionControl.Global.Data.AreaBlockEntities[_center] then</p><p>        return;</p><p>    end</p><p>    for i= #BundleConstructionControl.Global.Data.AreaBlockEntities[_center], 1, -1 do</p><p>        if BundleConstructionControl.Global.Data.AreaBlockEntities[_center][i][1] == _type then</p><p>            table.remove(BundleConstructionControl.Global.Data.AreaBlockEntities[_center], i);</p><p>            break;</p><p>        end</p><p>    end</p><p>-- Gibt eine Kategorie zum Bau im Gebiet wieder frei.</p><p>-- @param[type=number] _eCat   Entitykategorie</p><p>-- @param[type=string] _center Gebiet</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.UnbanCategoryInArea(EntityCategories.CityBuilding, "groundZero");</p><p>function API.UnbanCategoryInArea(_eCat, _center)</p><p>    if GUI then</p><p>        local Center = (type(_center) == "string" and "'" .._center.. "'") or _center;</p><p>        GUI.SendScriptCommand("API.UnbanCategoryInArea(" .._type.. ", " ..Center.. ")");</p><p>        return;</p><p>    end</p><p>    if not BundleConstructionControl.Global.Data.AreaBlockCategories[_center] then</p><p>        return;</p><p>    end</p><p>    for i= #BundleConstructionControl.Global.Data.AreaBlockCategories[_center], 1, -1 do</p><p>        if BundleConstructionControl.Global.Data.AreaBlockCategories[_center][i][1] == _eCat then</p><p>            table.remove(BundleConstructionControl.Global.Data.AreaBlockCategories[_center], i);</p><p>            break;</p><p>        end</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {</p><p>        Data = {</p><p>            TerritoryBlockCategories = {},</p><p>            TerritoryBlockEntities = {},</p><p>            AreaBlockCategories = {},</p><p>            AreaBlockEntities = {},</p><p>        }</p><p>    },</p><p>-- Global Script ---------------------------------------------------------------</p><p>-- Initalisiert das Bundle im globalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    Core:AppendFunction(</p><p>        "GameCallback_CanPlayerPlaceBuilding",</p><p>        BundleConstructionControl.Global.CanPlayerPlaceBuilding</p><p>    );</p><p>-- Verhindert den Bau von Entities in Gebieten und Territorien.</p><p>-- @param[type=number] _PlayerID Spieler</p><p>-- @param[type=number] _Type     Gebäudetyp</p><p>-- @param[type=number] _x        X-Position</p><p>-- @param[type=number] _y        Y-Position</p><p>-- @within Internal</p><p>-- @local</p><p>    -- Auf Territorium ---------------------------------------------</p><p>    -- Prüfe Kategorien</p><p>    for k,v in pairs(BundleConstructionControl.Global.Data.TerritoryBlockCategories) do</p><p>        if v then</p><p>            for key, val in pairs(v) do</p><p>                if val and Logic.GetTerritoryAtPosition(_x, _y) == val then</p><p>                    if Logic.IsEntityTypeInCategory(_Type, k) == 1 then</p><p>                        return false;</p><p>                    end</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>    -- Prüfe Typen</p><p>    for k,v in pairs(BundleConstructionControl.Global.Data.TerritoryBlockEntities) do</p><p>        if v then</p><p>            for key,val in pairs(v) do</p><p>                if val and Logic.GetTerritoryAtPosition(_x, _y) == val then</p><p>                    if _Type == k then</p><p>                        return false;</p><p>                    end</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>    -- In einem Gebiet ---------------------------------------------</p><p>    -- Prüfe Kategorien</p><p>    for k, v in pairs(BundleConstructionControl.Global.Data.AreaBlockCategories) do</p><p>        if v then</p><p>            for key, val in pairs(v) do</p><p>                if Logic.IsEntityTypeInCategory(_Type, val[1]) == 1 then</p><p>                    if GetDistance(k, {X= _x, Y= _y})  val[2] then</p><p>                        return false;</p><p>                    end</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>    -- Prüfe Typen</p><p>    for k, v in pairs(BundleConstructionControl.Global.Data.AreaBlockEntities) do</p><p>        if v then</p><p>            for key, val in pairs(v) do</p><p>                if _Type == val[1] then</p><p>                    if GetDistance(k, {X= _x, Y= _y})  val[2] then</p><p>                        return false;</p><p>                    end</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>    return true;</p><p>-- -------------------------------------------------------------------------- --</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundledestructioncontrol.lua.html">
            <div class='doclink'>
                <div>BundleDestructionControl</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia BundleDestructionControl                                     # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ermöglicht es einzelne Gebäude, Typen oder Kategorien von Gebäuden vor</p><p>-- dem Abriss zu schützen. Ebenso kann jeglicher Abriss von Gebäuden auf</p><p>-- einem Territrium komplett unterbunden werden.</p><p>-- Das wichtigste Auf einen Blick:</p><p>-- </p><p>-- </p><p>-- Den Abriss für bestimmte Entities steuern.</p><p>-- ,</p><p>-- </p><p>-- </p><p>-- </p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Fügt ein Entity hinzu, dass nicht abgerissen werden darf.</p><p>-- @param[type=string] _entry Nicht abreißbares Entity</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.ProtectEntity("bakery");</p><p>function API.ProtectEntity(_entry)</p><p>    if not GUI then</p><p>        API.Bridge([[</p><p>            API.ProtectEntity("]].._entry..[[")</p><p>        ]]);</p><p>    else</p><p>        if not Inside(_enitry, BundleDestructionControl.Local.Data.Entities) then</p><p>            table.insert(BundleDestructionControl.Local.Data.Entities, _entry);</p><p>        end</p><p>    end</p><p>-- Fügt einen Entitytyp hinzu, der nicht abgerissen werden darf.</p><p>-- @param[type=number] _entry Nicht abreißbarer Typ</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.ProtectEntityType(Entities.B_Bakery);</p><p>function API.ProtectEntityType(_entry)</p><p>    if not GUI then</p><p>        API.Bridge([[</p><p>            API.ProtectEntityType(]].._entry..[[)</p><p>        ]]);</p><p>    else</p><p>        if not Inside(_enitry, BundleDestructionControl.Local.Data.EntityTypes) then</p><p>            table.insert(BundleDestructionControl.Local.Data.EntityTypes, _entry);</p><p>        end</p><p>    end</p><p>-- Fügt eine Kategorie hinzu, die nicht abgerissen werden darf.</p><p>-- @param[type=number] _entry Nicht abreißbare Kategorie</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.ProtectCategory(EntityCategories.CityBuilding);</p><p>function API.ProtectCategory(_entry)</p><p>    if not GUI then</p><p>        API.Bridge([[</p><p>            API.ProtectCategory(]].._entry..[[)</p><p>        ]]);</p><p>    else</p><p>        if not Inside(_enitry, BundleDestructionControl.Local.Data.EntityCategories) then</p><p>            table.insert(BundleDestructionControl.Local.Data.EntityCategories, _entry);</p><p>        end</p><p>    end</p><p>-- Fügt ein Territory hinzu, auf dem nichts abgerissen werden kann.</p><p>-- @param[type=number] _entry Geschütztes Territorium</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.ProtectTerritory(1);</p><p>function API.ProtectTerritory(_entry)</p><p>    if not GUI then</p><p>        API.Bridge([[</p><p>            API.ProtectTerritory(]].._entry..[[)</p><p>        ]]);</p><p>    else</p><p>        if not Inside(_entry, BundleDestructionControl.Local.Data.OnTerritory) then</p><p>            table.insert(BundleDestructionControl.Local.Data.OnTerritory, _entry);</p><p>        end</p><p>    end</p><p>-- Entfernt ein Entity, dass nicht abgerissen werden darf.</p><p>-- @param[type=string] _entry Nicht abreißbares Entity</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.UnprotectEntity("bakery");</p><p>function API.UnprotectEntity(_entry)</p><p>    if not GUI then</p><p>        API.Bridge([[</p><p>            API.UnprotectEntity("]].._entry..[[")</p><p>        ]]);</p><p>    else</p><p>        for i=1,#BundleDestructionControl.Local.Data.Entities do</p><p>            if BundleDestructionControl.Local.Data.Entities[i] == _entry then</p><p>                table.remove(BundleDestructionControl.Local.Data.Entities, i);</p><p>                return;</p><p>            end</p><p>        end</p><p>    end</p><p>-- Entfernt einen Entitytyp, der nicht abgerissen werden darf.</p><p>-- @param[type=number] _entry Nicht abreißbarer Typ</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.UnprotectEntityType(Entities.B_Bakery);</p><p>function API.UnprotectEntityType(_entry)</p><p>    if not GUI then</p><p>        API.Bridge([[</p><p>            API.UnprotectEntityType(]].._entry..[[)</p><p>        ]]);</p><p>    else</p><p>        for i=1,#BundleDestructionControl.Local.Data.EntityTypes do</p><p>            if BundleDestructionControl.Local.Data.EntityTypes[i] == _entry then</p><p>                table.remove(BundleDestructionControl.Local.Data.EntityTypes, i);</p><p>                return;</p><p>            end</p><p>        end</p><p>    end</p><p>-- Entfernt eine Kategorie, die nicht abgerissen werden darf.</p><p>-- @param[type=number] _entry Nicht abreißbare Kategorie</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.UnprotectCategory(EntityCategories.CityBuilding);</p><p>function API.UnprotectCategory(_entry)</p><p>    if not GUI then</p><p>        API.Bridge([[</p><p>            API.UnprotectCategory(]].._entry..[[)</p><p>        ]]);</p><p>    else</p><p>        for i=1,#BundleDestructionControl.Local.Data.EntityCategories do</p><p>            if BundleDestructionControl.Local.Data.EntityCategories[i] == _entry then</p><p>                table.remove(BundleDestructionControl.Local.Data.EntityCategories, i);</p><p>                return;</p><p>            end</p><p>        end</p><p>    end</p><p>-- Entfernt ein Territory, auf dem nichts abgerissen werden kann.</p><p>-- @param[type=number] _entry Geschütztes Territorium</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.UnprotectTerritory(1);</p><p>function API.UnprotectTerritory(_entry)</p><p>    if not GUI then</p><p>        API.Bridge([[</p><p>            API.UnprotectTerritory(]].._entry..[[)</p><p>        ]]);</p><p>    else</p><p>        for i=1,#BundleDestructionControl.Local.Data.OnTerritory do</p><p>            if BundleDestructionControl.Local.Data.OnTerritory[i] == _entry then</p><p>                table.remove(BundleDestructionControl.Local.Data.OnTerritory, i);</p><p>                return;</p><p>            end</p><p>        end</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Local = {</p><p>        Data = {</p><p>            Entities = {},</p><p>            EntityTypes = {},</p><p>            EntityCategories = {},</p><p>            OnTerritory = {},</p><p>        }</p><p>    },</p><p>-- Local Script ----------------------------------------------------------------</p><p>-- Initalisiert das Bundle im lokalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    Core:AppendFunction(</p><p>        "GameCallback_GUI_DeleteEntityStateBuilding",</p><p>        BundleDestructionControl.Local.DeleteEntityStateBuilding</p><p>    );</p><p>-- Verhindert den Abriss von Entities.</p><p>-- @param[type=number] _BuildingID EntityID des Gebäudes</p><p>-- @within Internal</p><p>-- @local</p><p>    local eType = Logic.GetEntityType(_BuildingID);</p><p>    local eName = Logic.GetEntityName(_BuildingID);</p><p>    local tID   = GetTerritoryUnderEntity(_BuildingID);</p><p>    if Logic.IsConstructionComplete(_BuildingID) == 1 then</p><p>        -- Prüfe auf Namen</p><p>        if Inside(eName, BundleDestructionControl.Local.Data.Entities) then</p><p>            GUI.CancelBuildingKnockDown(_BuildingID);</p><p>            return;</p><p>        end</p><p>        -- Prüfe auf Typen</p><p>        if Inside(eType, BundleDestructionControl.Local.Data.EntityTypes) then</p><p>            GUI.CancelBuildingKnockDown(_BuildingID);</p><p>            return;</p><p>        end</p><p>        -- Prüfe auf Territorien</p><p>        if Inside(tID, BundleDestructionControl.Local.Data.OnTerritory) then</p><p>            GUI.CancelBuildingKnockDown(_BuildingID);</p><p>            return;</p><p>        end</p><p>        -- Prüfe auf Category</p><p>        for k,v in pairs(BundleDestructionControl.Local.Data.EntityCategories) do</p><p>            if Logic.IsEntityInCategory(_BuildingID, v) == 1 then</p><p>                GUI.CancelBuildingKnockDown(_BuildingID);</p><p>                return;</p><p>            end</p><p>        end</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundledialogwindows.lua.html">
            <div class='doclink'>
                <div>BundleDialogWindows</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia BundleDialogWindows                                          # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Mit diesem Bundle können Dialogfenster ernstellt werden. Über Dialogfenster</p><p>-- kann der Spieler informiert werden. Er kann aber auch aufgefordert werden</p><p>-- eine Antwort auf eine Frage zu geben. Sollte bereits ein Dialog zu sehen</p><p>-- sein, werden neue Dialoge einer Warteschlange hinzugefügt und nacheinander</p><p>-- angezeigt.</p><p>-- Zudem bietet das Bundle ein Textfenster an, welches eine nicht limitierte</p><p>-- Menge an Text anzeigen kann. Erreicht der Text eine entsprechende Menge,</p><p>-- wird automatisch eine Scrollbar eingeblendet.</p><p>-- Das wichtigste Auf einen Blick:</p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Öffnet einen Info-Dialog. Sollte bereits ein Dialog zu sehen sein, wird</p><p>-- der Dialog der Dialogwarteschlange hinzugefügt.</p><p>-- : UserOpenDialog</p><p>-- @param[type=string]   _Title  Titel des Dialog</p><p>-- @param[type=string]   _Text   Text des Dialog</p><p>-- @param[type=function] _Action Callback-Funktion</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.DialogInfoBox("Wichtige Information", "Diese Information ist Spielentscheidend!");</p><p>function API.DialogInfoBox(_Title, _Text, _Action)</p><p>    if not GUI then</p><p>        API.Fatal("API.DialogInfoBox: Can only be used in the local script!");</p><p>        return;</p><p>    end</p><p>    local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>    if type(_Title) == "table" then</p><p>       _Title = _Title[lang];</p><p>    end</p><p>    if type(_Text) == "table" then</p><p>       _Text = _Text[lang];</p><p>    end</p><p>    return BundleDialogWindows.Local:OpenDialog(_Title, _Text, _Action);</p><p>-- Öffnet einen Ja-Nein-Dialog. Sollte bereits ein Dialog zu sehen sein, wird</p><p>-- der Dialog der Dialogwarteschlange hinzugefügt.</p><p>-- Um die Entscheigung des Spielers abzufragen, wird ein Callback benötigt.</p><p>-- Das Callback bekommt eine Boolean übergeben, sobald der Spieler die</p><p>-- Entscheidung getroffen hat.</p><p>-- : UserOpenRequesterDialog</p><p>-- @param[type=string]   _Title    Titel des Dialog</p><p>-- @param[type=string]   _Text     Text des Dialog</p><p>-- @param[type=function] _Action   Callback-Funktion</p><p>-- @param[type=boolean]  _OkCancel Okay/Abbrechen statt Ja/Nein</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- function YesNoAction(_yes)</p><p>--     if _yes then GUI.AddNote("Ja wurde gedrückt"); end</p><p>-- end</p><p>-- API.DialogRequestBox("Frage", "Möchtest du das wirklich tun?", YesNoAction, false);</p><p>function API.DialogRequestBox(_Title, _Text, _Action, _OkCancel)</p><p>    if not GUI then</p><p>        API.Fatal("API.DialogRequestBox: Can only be used in the local script!");</p><p>        return;</p><p>    end</p><p>    local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>    if type(_Title) == "table" then</p><p>       _Title = _Title[lang];</p><p>    end</p><p>    if type(_Text) == "table" then</p><p>       _Text = _Text[lang];</p><p>    end</p><p>    return BundleDialogWindows.Local:OpenRequesterDialog(_Title, _Text, _Action, _OkCancel);</p><p>-- Öffnet einen Auswahldialog. Sollte bereits ein Dialog zu sehen sein, wird</p><p>-- der Dialog der Dialogwarteschlange hinzugefügt.</p><p>-- In diesem Dialog wählt der Spieler eine Option aus einer Liste von Optionen</p><p>-- aus. Anschließend erhält das Callback den Index der selektierten Option.</p><p>-- : UserOpenSelectionDialog</p><p>-- @param[type=string]   _Title  Titel des Dialog</p><p>-- @param[type=string]   _Text   Text des Dialog</p><p>-- @param[type=function] _Action Callback-Funktion</p><p>-- @param[type=table]    _List   Liste der Optionen</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- function OptionsAction(_idx)</p><p>--     GUI.AddNote(_idx.. " wurde ausgewählt!");</p><p>-- end</p><p>-- local List = {"Option A", "Option B", "Option C"};</p><p>-- API.DialogSelectBox("Auswahl", "Wähle etwas aus!", OptionsAction, List);</p><p>function API.DialogSelectBox(_Title, _Text, _Action, _List)</p><p>    if not GUI then</p><p>        API.Fatal("API.DialogSelectBox: Can only be used in the local script!");</p><p>        return;</p><p>    end</p><p>    local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>    if type(_Title) == "table" then</p><p>       _Title = _Title[lang];</p><p>    end</p><p>    if type(_Text) == "table" then</p><p>       _Text = _Text[lang];</p><p>    end</p><p>    _Text = _Text .. "{cr}";</p><p>    return BundleDialogWindows.Local:OpenSelectionDialog(_Title, _Text, _Action, _List);</p><p>-- Öffnet ein einfaches Textfenster mit dem angegebenen Text.</p><p>-- Die Länge des Textes ist nicht beschränkt. Überschreitet der Text die</p><p>-- Größe des Fensters, wird automatisch eine Bildlaufleiste eingeblendet.</p><p>-- @param[type=string] _Caption Titel des Fenster</p><p>-- @param[type=string] _content Inhalt des Fenster</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- local Text = "Lorem ipsum dolor sit amet, consetetur sadipscing elitr, "..</p><p>--              "sed diam nonumy eirmod tempor invidunt ut labore et dolore"..</p><p>--              "magna aliquyam erat, sed diam voluptua. At vero eos et"..</p><p>--              " accusam et justo duo dolores et ea rebum. Stet clita kasd"..</p><p>--              " gubergren, no sea takimata sanctus est Lorem ipsum dolor"..</p><p>--              " sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing"..</p><p>--              " elitr, sed diam nonumy eirmod tempor invidunt ut labore et"..</p><p>--              " dolore magna aliquyam erat, sed diam voluptua. At vero eos"..</p><p>--              " et accusam et justo duo dolores et ea rebum. Stet clita"..</p><p>--              " kasd gubergren, no sea takimata sanctus est Lorem ipsum"..</p><p>--              " dolor sit amet.";</p><p>-- API.SimpleTextWindow("Überschrift", Text);</p><p>function API.SimpleTextWindow(_Caption, _Content)</p><p>    local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>    if type(_Caption) == "table" then</p><p>       _Caption = _Caption[lang];</p><p>    end</p><p>    if type(_Content) == "table" then</p><p>       _Content = _Content[lang];</p><p>    end</p><p>    if not GUI then</p><p>        API.Bridge("API.SimpleTextWindow('" .._Caption.. "', '" .._Content.. "')");</p><p>        return;</p><p>    end</p><p>    QSB.TextWindow:New(_Caption, _Content):Show();</p><p>-- Blendet einen Text Zeichen für Zeichen auf schwarzem Grund ein.</p><p>-- Diese Funktion ist der offizielle Nachfolger der Laufschrift!</p><p>-- Der Effekt startet erst, nachdem die Map geladen ist. Wenn ein Briefing</p><p>-- läuft, wird gewartet, bis das Briefing beendet ist. Wärhend der Effekt</p><p>-- läuft, können wiederrum keine Briefings starten.</p><p>-- : Steuerzeichen wie {cr} oder {@color} werden als ein Token</p><p>-- gewertet und immer sofort eingeblendet. Steht z.B. {cr}{cr} im Text, werden</p><p>-- die Zeichen atomar behandelt, als seien sie ein einzelnes Zeichen.</p><p>-- Gibt es mehr als 1 Leerzeichen hintereinander, werden alle zusammenhängenden</p><p>-- Leerzeichen auf ein Leerzeichen reduziert!</p><p>-- @param[type=string]   _Text     Anzuzeigender Text</p><p>-- @param[type=function] _Callback Funktion nach Ende des Effekt</p><p>-- @usage</p><p>-- local Text = "Lorem ipsum dolor sit amet, consetetur sadipscing elitr, "..</p><p>--              "sed diam nonumy eirmod tempor invidunt ut labore et dolore"..</p><p>--              "magna aliquyam erat, sed diam voluptua. At vero eos et"..</p><p>--              " accusam et justo duo dolores et ea rebum. Stet clita kasd"..</p><p>--              " gubergren, no sea takimata sanctus est Lorem ipsum dolor"..</p><p>--              " sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing"..</p><p>--              " elitr, sed diam nonumy eirmod tempor invidunt ut labore et"..</p><p>--              " dolore magna aliquyam erat, sed diam voluptua. At vero eos"..</p><p>--              " et accusam et justo duo dolores et ea rebum. Stet clita"..</p><p>--              " kasd gubergren, no sea takimata sanctus est Lorem ipsum"..</p><p>--              " dolor sit amet.";</p><p>-- local Callback = function(_Data)</p><p>--     -- Hier kann was passieren</p><p>-- end</p><p>-- API.SimpleTypewriter(Text, Callback);</p><p>-- @within Anwenderfunktionen</p><p>function API.SimpleTypewriter(_Text, _Callback)</p><p>    local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>    if GUI then</p><p>        API.Fatal("API.SimpleTypewriter: Can only be used from global script!");</p><p>        return;</p><p>    end</p><p>    local Text = _Text;</p><p>    if type(Text) == "table" then</p><p>        Text = Text[lang];</p><p>    end</p><p>    QSB.SimpleTypewriter:New(_Text, _Callback):Start();</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {</p><p>        Data = {}</p><p>    },</p><p>    Local = {</p><p>        Data = {</p><p>            Requester = {</p><p>                ActionFunction = nil,</p><p>                ActionRequester = nil,</p><p>                Next = nil,</p><p>                Queue = {},</p><p>            },</p><p>        },</p><p>    },</p><p>-- Typewriter class ------------------------------------------------------------</p><p>    m_Tokens     = {},</p><p>    m_Waittime   = 80,</p><p>    m_Speed      = 1,</p><p>    m_Index      = 0,</p><p>    m_Text       = nil,</p><p>    m_JobID      = nil,</p><p>    m_Callback   = nil,</p><p>    m_Loadscreen = true,</p><p>-- Erzeugt eine Neue Instanz der Schreibmaschinenschrift.</p><p>-- @param[type=string]   _Text     Anzuzeigender Text</p><p>-- @param[type=function] _Callback Funktion, die am Ende ausgeführt wird</p><p>-- @return[type=table] Neue Instanz</p><p>-- @within QSB.SimpleTypewriter</p><p>-- @local</p><p>    local typewriter = API.InstanceTable(self);</p><p>    typewriter.m_Text = _Text;</p><p>    typewriter.m_Callback = _Callback;</p><p>    return typewriter;</p><p>-- Stellt ein, wie viele Zeichen in einer Interation angezeigt werden.</p><p>-- @param[type=number] _Speed Anzahl an Character pro 1/10 Sekunde</p><p>-- @within QSB.SimpleTypewriter</p><p>-- @local</p><p>    self.m_Speed = _Speed;</p><p>-- Stellt ein, wie lange nach Ausgabe des letzten Zeichens gewartet wird, bis</p><p>-- die Schreibmaschine endet.</p><p>-- @param[type=number] _Waittime Zeit in 1/10 Sekunden (8 Sekunden = 80)</p><p>-- @within QSB.SimpleTypewriter</p><p>-- @local</p><p>    self.m_Waittime = _Waittime;</p><p>-- Startet die Laufschrift. Wenn ein Briefing aktiv ist, oder die Map noch</p><p>-- nicht geladen ist, wird gewartet.</p><p>-- @within QSB.SimpleTypewriter</p><p>-- @local</p><p>    if self:CanBePlayed() then</p><p>        self:Play();</p><p>        return;</p><p>    end</p><p>    StartSimpleHiResJobEx(self.WaitForBriefingEnd, self);</p><p>-- Spielt die Schreibmaschine ab.</p><p>-- @within QSB.SimpleTypewriter</p><p>-- @local</p><p>    if BriefingSystem then</p><p>        BriefingSystem.isActive = true;</p><p>    end</p><p>    self:TokenizeText();</p><p>    API.Bridge([[</p><p>        XGUIEng.PushPage("/InGame/Root/Normal/NotesWindow", false)</p><p>        XGUIEng.PushPage("/InGame/Root/Normal/PauseScreen", false)</p><p>        XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal",0)</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/NotesWindow",1)</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/PauseScreen", 1)</p><p>        XGUIEng.SetMaterialColor("/InGame/Root/Normal/PauseScreen", 0, 0, 0, 0, 255)</p><p>        g_Typewriter_GameSpeedBackup = Game.GameTimeGetFactor(GUI.GetPlayerID())</p><p>        Game.GameTimeSetFactor(GUI.GetPlayerID(), 1)</p><p>        Input.CutsceneMode()</p><p>    ]]);</p><p>    self.m_JobID = StartSimpleHiResJobEx(self.ControllerJob, self);</p><p>-- Stoppt eine aktive Schreibmaschine.</p><p>-- @within QSB.SimpleTypewriter</p><p>-- @local</p><p>    if BriefingSystem then</p><p>        BriefingSystem.isActive = false;</p><p>    end</p><p>    API.Bridge([[</p><p>        GUI.ClearNotes()</p><p>        Game.GameTimeSetFactor(GUI.GetPlayerID(), g_Typewriter_GameSpeedBackup or 1)</p><p>        Input.GameMode()</p><p>        XGUIEng.PopPage()</p><p>        XGUIEng.PopPage()</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/PauseScreen", 0)</p><p>        XGUIEng.SetMaterialColor("/InGame/Root/Normal/PauseScreen", 0, 40, 40, 40, 180)</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/AnimatedCameraMovement", 1)</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight",1)</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomLeft",1)</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft",1)</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft/TopBar",1)</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/InteractiveObjects",1)</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/InteractiveObjects/Update",1)</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopRight",1)</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/Selected_Merchant",1)</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopCenter",1)</p><p>        if g_PatchIdentifierExtra1 then</p><p>            XGUIEng.ShowWidget("/InGame/Root/Normal/Selected_Tradepost",1)</p><p>        end</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/TextMessages",1)</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/PauseScreen",0)</p><p>        XGUIEng.ShowWidget("/InGame/Root/3dOnScreenDisplay",1)</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/ShowUi",1)</p><p>        XGUIEng.ShowWidget("/InGame/Root/3dWorldView",1)</p><p>    ]]);</p><p>    API.EndJob(self.m_JobID);</p><p>-- Spaltet den Text in Tokens auf und speichert die Tokens für die Wiedergabe.</p><p>-- @within QSB.SimpleTypewriter</p><p>-- @local</p><p>    self.m_Text = self.m_Text:gsub("s+", " ");</p><p>    local TempTokens = {};</p><p>    local Text = self.m_Text;</p><p>    while (true) do</p><p>        local s, e = Text:find(" ");</p><p>        if not s then</p><p>            table.insert(TempTokens, Text);</p><p>            break;</p><p>        end</p><p>        local NewToken = Text:sub(1, s-1);</p><p>        if NewToken:find("}") then</p><p>            for i= #NewToken, 1, -1 do</p><p>                local Char = NewToken:sub(i, i);</p><p>                if Char == "}" then</p><p>                    table.insert(TempTokens, NewToken:sub(1, i));</p><p>                    table.insert(TempTokens, NewToken:sub(i+1));</p><p>                    break;</p><p>                end</p><p>            end</p><p>        else</p><p>            table.insert(TempTokens, NewToken);</p><p>        end</p><p>        table.insert(TempTokens, " ");</p><p>        Text = Text:sub(e+1);</p><p>    end</p><p>    for i= 1, #TempTokens, 1 do</p><p>        if TempTokens[i] == " " or TempTokens[i]:find("{") then</p><p>            table.insert(self.m_Tokens, TempTokens[i]);</p><p>        else</p><p>            local Index = 1;</p><p>            while (Index = #TempTokens[i]) do</p><p>                if string.byte(TempTokens[i]:sub(Index, Index)) == 195 then</p><p>                    table.insert(self.m_Tokens, TempTokens[i]:sub(Index, Index+1));</p><p>                    Index = Index +1;</p><p>                else</p><p>                    table.insert(self.m_Tokens, TempTokens[i]:sub(Index, Index)); </p><p>                end</p><p>                Index = Index +1;</p><p>            end</p><p>        end</p><p>    end</p><p>-- Prüft, ob die Schreibmaschine gestartet werden kann.</p><p>-- @return[type=boolean] Schreibmaschine kann starten</p><p>-- @within QSB.SimpleTypewriter</p><p>-- @local</p><p>    if QSB.SimpleTypewriter.m_Loadscreen then</p><p>        API.Bridge([[</p><p>            if XGUIEng.IsWidgetShownEx("/LoadScreen/LoadScreen") == 0 then</p><p>                API.Bridge("QSB.SimpleTypewriter.m_Loadscreen = false")</p><p>            end</p><p>        ]])</p><p>        return false;</p><p>    end</p><p>    if BriefingSystem and BriefingSystem.isActive then</p><p>        return false;</p><p>    end</p><p>    return true;</p><p>-- Job: Warte solange, bis Briefings beendet sind.</p><p>-- @param[type=table] Data</p><p>-- @within QSB.SimpleTypewriter</p><p>-- @local</p><p>    if _Data:CanBePlayed() == true then</p><p>        _Data:Play();</p><p>        return true;</p><p>    end</p><p>-- Job: Kontrolliert die Anzeige der Schreibmaschine.</p><p>-- @param[type=table] Data</p><p>-- @within QSB.SimpleTypewriter</p><p>-- @local</p><p>    _Data.m_Index = _Data.m_Index + _Data.m_Speed;</p><p>    if _Data.m_Index  #_Data.m_Tokens then</p><p>        _Data.m_Index = #_Data.m_Tokens;</p><p>    end</p><p>    local Index = math.ceil(_Data.m_Index);</p><p>    local Text = "";</p><p>    for i= 1, Index, 1 do</p><p>        Text = Text .. _Data.m_Tokens[i];</p><p>    end</p><p>    API.Bridge([[</p><p>        GUI.ClearNotes()</p><p>        GUI.AddNote("]] ..Text.. [[");</p><p>    ]])</p><p>    </p><p>    if Index == #_Data.m_Tokens then</p><p>        _Data.m_Waittime = _Data.m_Waittime -1;</p><p>        if _Data.m_Waittime = 0 then</p><p>            _Data:Stop();</p><p>            if _Data.m_Callback then</p><p>                _Data.m_Callback(_Data);</p><p>            end</p><p>            return true;</p><p>        end</p><p>    end</p><p>-- TextWindow class ------------------------------------------------------------</p><p>    Data = {</p><p>        Shown       = false,</p><p>        Caption     = "",</p><p>        Text        = "",</p><p>        ButtonText  = "",</p><p>        Picture     = nil,</p><p>        Action      = nil,</p><p>        Callback    = function() end,</p><p>    },</p><p>-- Erzeugt ein Textfenster, dass einen beliebig großen Text anzeigen kann.</p><p>-- Optional kann ein Button genutzt werden, der eine Aktion ausführt, wenn</p><p>-- er gedrückt wird.</p><p>-- </p><p>-- Parameterliste:</p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- @param ... Parameterliste</p><p>-- @return[type=table] Instanz des konfigurierten Fensters</p><p>-- @within QSB.TextWindow</p><p>-- @local</p><p>-- @usage</p><p>-- local MyWindow = TextWindow:New("Fenster", "Das ist ein Text");</p><p>    assert(self == QSB.TextWindow, "Can not be used from instance!")</p><p>    local window           = API.InstanceTable(self);</p><p>    window.Data.Caption    = arg[1] or window.Data.Caption;</p><p>    window.Data.Text       = arg[2] or window.Data.Text;</p><p>    window.Data.Action     = arg[3];</p><p>    window.Data.ButtonText = arg[4] or window.Data.ButtonText;</p><p>    window.Data.Callback   = arg[5] or window.Data.Callback;</p><p>    return window;</p><p>-- Fügt einen beliebigen Parameter hinzu. Parameter müssen immer als</p><p>-- Schlüssel-Wert-Paare angegeben werden und dürfen vorhandene Pare nicht</p><p>-- überschreiben.</p><p>-- </p><p>-- @param[type=string] _Key   Schlüssel</p><p>-- @param              _Value Wert</p><p>-- @return self</p><p>-- @within QSB.TextWindow</p><p>-- @local</p><p>-- @usage</p><p>-- MyWindow:AddParameter("Name", "Horst");</p><p>    assert(self ~= QSB.TextWindow, "Can not be used in static context!");</p><p>    assert(self.Data[_Key] ~= nil, "Key '" .._Key.. "' already exists!");</p><p>    self.Data[_Key] = _Value;</p><p>    return self;</p><p>-- Setzt die Überschrift des TextWindow.</p><p>-- </p><p>-- @param[type=string] _Text Titel des Textfenster</p><p>-- @return self</p><p>-- @within QSB.TextWindow</p><p>-- @local</p><p>-- @usage</p><p>-- MyWindow:SetCaption("Das ist der Titel");</p><p>    assert(self ~= QSB.TextWindow, "Can not be used in static context!");</p><p>    local Language = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>    if type(_Text) == "table" then</p><p>        _Text = _Text[Language];</p><p>    end</p><p>    assert(type(_Text) == "string");</p><p>    self.Data.Caption = _Text;</p><p>    return self;</p><p>-- Setzt den Inhalt des TextWindow.</p><p>-- </p><p>-- @param[type=string] _Text Inhalt des Textfenster</p><p>-- @return self</p><p>-- @within QSB.TextWindow</p><p>-- @local</p><p>-- @usage</p><p>-- MyWindow:SetCaption("Das ist der Text. Er ist sehr informativ!");</p><p>    assert(self ~= QSB.TextWindow, "Can not be used in static context!");</p><p>    local Language = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>    if type(_Text) == "table" then</p><p>        _Text = _Text[Language];</p><p>    end</p><p>    assert(type(_Text) == "string");</p><p>    self.Data.Text = _Text;</p><p>    return self;</p><p>-- Setzt die Close Action des TextWindow. Die Funktion wird beim schließen</p><p>-- des Fensters ausgeführt.</p><p>-- </p><p>-- @param[type=function] _Function Close Callback</p><p>-- @return self</p><p>-- @within QSB.TextWindow</p><p>-- @local</p><p>-- @usage</p><p>-- local MyAction = function(_Window)</p><p>--     -- Something is done here!</p><p>-- end</p><p>-- MyWindow:SetAction(MyAction);</p><p>    assert(self ~= QSB.TextWindow, "Can not be used in static context!");</p><p>    assert(nil or type(_Function) == "function");</p><p>    self.Data.Callback = _Function;</p><p>    return self;</p><p>-- Setzt einen Aktionsbutton im TextWindow.</p><p>-- Der Button muss mit einer Funktion versehen werden. Sobald der Button</p><p>-- betätigt wird, wird die Funktion ausgeführt.</p><p>-- </p><p>-- @param[type=string]   _Text     Beschriftung des Buttons</p><p>-- @param[type=function] _Callback Aktion des Buttons</p><p>-- @return self</p><p>-- @within QSB.TextWindow</p><p>-- @local</p><p>-- @usage</p><p>-- local MyButtonAction = function(_Window)</p><p>--     -- Something is done here!</p><p>-- end</p><p>-- MyWindow:SetAction("Button Text", MyButtonAction);</p><p>    assert(self ~= QSB.TextWindow, "Can not be used in static context!");</p><p>    if _Text then</p><p>        local Language = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>        if type(_Text) == "table" then</p><p>            _Text = _Text[Language];</p><p>        end</p><p>        assert(type(_Text) == "string");</p><p>        assert(type(_Callback) == "function");</p><p>    end</p><p>    self.Data.ButtonText = _Text;</p><p>    self.Data.Action     = _Callback;</p><p>    return self;</p><p>-- Zeigt ein erzeigtes Fenster an.</p><p>-- </p><p>-- @within QSB.TextWindow</p><p>-- @local</p><p>-- @usage</p><p>-- MyWindow:Show();</p><p>    assert(self ~= QSB.TextWindow, "Can not be used in static context!");</p><p>    QSB.TextWindow.Data.Shown = true;</p><p>    self.Data.Shown = true;</p><p>    self:Prepare();</p><p>    XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions",1);</p><p>    XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/ToggleWhisperTarget",1);</p><p>    if not self.Data.Action then</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/ToggleWhisperTarget",0);</p><p>    end</p><p>    XGUIEng.SetText("/InGame/Root/Normal/MessageLog/Name","{center}"..self.Data.Caption);</p><p>    XGUIEng.SetText("/InGame/Root/Normal/ChatOptions/ToggleWhisperTarget","{center}"..self.Data.ButtonText);</p><p>    GUI_Chat.ClearMessageLog();</p><p>    GUI_Chat.ChatlogAddMessage(self.Data.Text);</p><p>    local stringlen = string.len(self.Data.Text);</p><p>    local iterator  = 1;</p><p>    local carreturn = 0;</p><p>    while (true)</p><p>    do</p><p>        local s,e = string.find(self.Data.Text, "{cr}", iterator);</p><p>        if not e then</p><p>            break;</p><p>        end</p><p>        if e-iterator = 58 then</p><p>            stringlen = stringlen + 58-(e-iterator);</p><p>        end</p><p>        iterator = e+1;</p><p>    end</p><p>    if (stringlen + (carreturn*55))  1000 then</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/ChatLogSlider",1);</p><p>    end</p><p>    Game.GameTimeSetFactor(GUI.GetPlayerID(), 0);</p><p>-- Initialisiert das TextWindow, bevor es angezeigt wird.</p><p>-- @within QSB.TextWindow</p><p>-- @local</p><p>    function GUI_Chat.CloseChatMenu()</p><p>        QSB.TextWindow.Data.Shown = false;</p><p>        self.Data.Shown = false;</p><p>        if self.Data.Callback then</p><p>            self.Data.Callback(self);</p><p>        end</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions",0);</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog",0);</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog/BG",1);</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog/Close",1);</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog/Slider",1);</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog/Text",1);</p><p>        Game.GameTimeReset(GUI.GetPlayerID());</p><p>    end</p><p>    function GUI_Chat.ToggleWhisperTargetUpdate()</p><p>        Game.GameTimeSetFactor(GUI.GetPlayerID(), 0);</p><p>    end</p><p>    function GUI_Chat.CheckboxMessageTypeWhisperUpdate()</p><p>        XGUIEng.SetText("/InGame/Root/Normal/ChatOptions/TextCheckbox","{center}"..self.Data.Caption);</p><p>    end</p><p>    function GUI_Chat.ToggleWhisperTarget()</p><p>        if self.Data.Action then</p><p>            self.Data.Action(self);</p><p>        end</p><p>    end</p><p>    function GUI_Chat.ClearMessageLog()</p><p>        g_Chat.ChatHistory = {}</p><p>    end</p><p>    function GUI_Chat.ChatlogAddMessage(_Message)</p><p>        table.insert(g_Chat.ChatHistory, _Message)</p><p>        local ChatlogMessage = ""</p><p>        for i,v in ipairs(g_Chat.ChatHistory) do</p><p>            ChatlogMessage = ChatlogMessage .. v .. "{cr}"</p><p>        end</p><p>        XGUIEng.SetText("/InGame/Root/Normal/ChatOptions/ChatLog", ChatlogMessage)</p><p>    end</p><p>    local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>    if type(self.Data.Caption) == "table" then</p><p>        self.Data.Caption = self.Data.Caption[lang];</p><p>    end</p><p>    if type(self.Data.ButtonText) == "table" then</p><p>        self.Data.ButtonText = self.Data.ButtonText[lang];</p><p>    end</p><p>    if type(self.Data.Text) == "table" then</p><p>        self.Data.Text = self.Data.Text[lang];</p><p>    end</p><p>    XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/ChatModeAllPlayers",0);</p><p>    XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/ChatModeTeam",0);</p><p>    XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/ChatModeWhisper",0);</p><p>    XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/ChatChooseModeCaption",0);</p><p>    XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/Background/TitleBig",1);</p><p>    XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/Background/TitleBig/Info",0);</p><p>    XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/ChatLogCaption",0);</p><p>    XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/BGChoose",0);</p><p>    XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/BGChatLog",0);</p><p>    XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/ChatLogSlider",0);</p><p>    XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog",1);</p><p>    XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog/BG",0);</p><p>    XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog/Close",0);</p><p>    XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog/Slider",0);</p><p>    XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog/Text",0);</p><p>    XGUIEng.DisableButton("/InGame/Root/Normal/ChatOptions/ToggleWhisperTarget",0);</p><p>    XGUIEng.SetWidgetLocalPosition("/InGame/Root/Normal/MessageLog",0,95);</p><p>    XGUIEng.SetWidgetLocalPosition("/InGame/Root/Normal/MessageLog/Name",0,0);</p><p>    XGUIEng.SetTextColor("/InGame/Root/Normal/MessageLog/Name",51,51,121,255);</p><p>    XGUIEng.SetWidgetLocalPosition("/InGame/Root/Normal/ChatOptions/ChatLog",140,150);</p><p>    XGUIEng.SetWidgetSize("/InGame/Root/Normal/ChatOptions/Background/DialogBG/1 (2)/2",150,400);</p><p>    XGUIEng.SetWidgetPositionAndSize("/InGame/Root/Normal/ChatOptions/Background/DialogBG/1 (2)/3",400,500,350,400);</p><p>    XGUIEng.SetWidgetSize("/InGame/Root/Normal/ChatOptions/ChatLog",640,580);</p><p>    XGUIEng.SetWidgetSize("/InGame/Root/Normal/ChatOptions/ChatLogSlider",46,660);</p><p>    XGUIEng.SetWidgetLocalPosition("/InGame/Root/Normal/ChatOptions/ChatLogSlider",780,130);</p><p>    XGUIEng.SetWidgetLocalPosition("/InGame/Root/Normal/ChatOptions/ToggleWhisperTarget",110,760);</p><p>-- Global Script ---------------------------------------------------------------</p><p>-- Initalisiert das Bundle im globalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>-- Local Script ----------------------------------------------------------------</p><p>-- Initalisiert das Bundle im lokalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    self:DialogOverwriteOriginal();</p><p>-- Führt das Callback eines Info-Fensters oder eines Selektionsfensters aus.</p><p>-- @within Internal</p><p>-- @local</p><p>    if self.Data.Requester.ActionFunction then</p><p>        self.Data.Requester.ActionFunction(CustomGame.Knight + 1);</p><p>    end</p><p>    self:OnDialogClosed();</p><p>-- Führt das Callback eines Ja-Nein-Dialogs aus.</p><p>-- @param[type=boolean] _yes Gegebene Antwort</p><p>-- @within Internal</p><p>-- @local</p><p>    if self.Data.Requester.ActionRequester then</p><p>        self.Data.Requester.ActionRequester(_yes);</p><p>    end</p><p>    self:OnDialogClosed();</p><p>-- Läd den nächsten Dialog aus der Warteschlange und stellt die Speicher-Hotkeys</p><p>-- wieder her.</p><p>-- @within Internal</p><p>-- @local</p><p>    self:DialogQueueStartNext();</p><p>    self:RestoreSaveGame();</p><p>-- Startet den nächsten Dialog in der Warteschlange, sofern möglich.</p><p>-- @within Internal</p><p>-- @local</p><p>    self.Data.Requester.Next = table.remove(self.Data.Requester.Queue, 1);</p><p>    DialogQueueStartNext_HiResControl = function()</p><p>        local Entry = BundleDialogWindows.Local.Data.Requester.Next;</p><p>        if Entry and Entry[1] and Entry[2] then</p><p>            local Methode = Entry[1];</p><p>            BundleDialogWindows.Local[Methode]( BundleDialogWindows.Local, unpack(Entry[2]) );</p><p>            BundleDialogWindows.Local.Data.Requester.Next = nil;</p><p>        end</p><p>        return true;</p><p>    end</p><p>    StartSimpleHiResJob("DialogQueueStartNext_HiResControl");</p><p>-- Fügt der Dialogwarteschlange einen neuen Dialog hinten an.</p><p>-- @param[type=string] _Methode Dialogfunktion als String</p><p>-- @param[type=table] _Args    Argumente als Table</p><p>-- @within Internal</p><p>-- @local</p><p>    local Entry = {_Methode, _Args};</p><p>    table.insert(self.Data.Requester.Queue, Entry);</p><p>-- Öffnet einen Info-Dialog. Sollte bereits ein Dialog zu sehen sein, wird</p><p>-- der Dialog der Dialogwarteschlange hinzugefügt.</p><p>-- @param[type=string]   _Title  Titel des Dialog</p><p>-- @param[type=string]   _Text   Text des Dialog</p><p>-- @param[type=function] _Action Callback-Funktion</p><p>-- @within Internal</p><p>-- @local</p><p>    if XGUIEng.IsWidgetShown(RequesterDialog) == 0 then</p><p>        assert(type(_Title) == "string");</p><p>        assert(type(_Text) == "string");</p><p>        _Title = "{center}" .. _Title;</p><p>        if string.len(_Text)  35 then</p><p>            _Text = _Text .. "{cr}";</p><p>        end</p><p>        g_MapAndHeroPreview.SelectKnight = function()</p><p>        end</p><p>        XGUIEng.ShowAllSubWidgets("/InGame/Dialog/BG",1);</p><p>        XGUIEng.ShowWidget("/InGame/Dialog/Backdrop",0);</p><p>        XGUIEng.ShowWidget(RequesterDialog,1);</p><p>        XGUIEng.ShowWidget(RequesterDialog_Yes,0);</p><p>        XGUIEng.ShowWidget(RequesterDialog_No,0);</p><p>        XGUIEng.ShowWidget(RequesterDialog_Ok,1);</p><p>        if type(_Action) == "function" then</p><p>            self.Data.Requester.ActionFunction = _Action;</p><p>            local Action = "XGUIEng.ShowWidget(RequesterDialog, 0)";</p><p>            Action = Action .. "; XGUIEng.PopPage()";</p><p>            Action = Action .. "; BundleDialogWindows.Local.Callback(BundleDialogWindows.Local)";</p><p>            XGUIEng.SetActionFunction(RequesterDialog_Ok, Action);</p><p>        else</p><p>            self.Data.Requester.ActionFunction = nil;</p><p>            local Action = "XGUIEng.ShowWidget(RequesterDialog, 0)";</p><p>            Action = Action .. "; XGUIEng.PopPage()";</p><p>            Action = Action .. "; BundleDialogWindows.Local.Callback(BundleDialogWindows.Local)";</p><p>            XGUIEng.SetActionFunction(RequesterDialog_Ok, Action);</p><p>        end</p><p>        XGUIEng.SetText(RequesterDialog_Message, "{center}" .. _Text);</p><p>        XGUIEng.SetText(RequesterDialog_Title, _Title);</p><p>        XGUIEng.SetText(RequesterDialog_Title.."White", _Title);</p><p>        XGUIEng.PushPage(RequesterDialog,false);</p><p>        XGUIEng.ShowWidget("/InGame/InGame/MainMenu/Container/QuickSave", 0);</p><p>        XGUIEng.ShowWidget("/InGame/InGame/MainMenu/Container/SaveGame", 0);</p><p>        if not KeyBindings_SaveGame_Orig_QSB_Windows then</p><p>            KeyBindings_SaveGame_Orig_QSB_Windows = KeyBindings_SaveGame;</p><p>            KeyBindings_SaveGame = function() end;</p><p>        end</p><p>    else</p><p>        self:DialogQueuePush("OpenDialog", {_Title, _Text, _Action});</p><p>    end</p><p>-- Öffnet einen Ja-Nein-Dialog. Sollte bereits ein Dialog zu sehen sein, wird</p><p>-- der Dialog der Dialogwarteschlange hinzugefügt.</p><p>-- @param[type=string]   _Title    Titel des Dialog</p><p>-- @param[type=string]   _Text     Text des Dialog</p><p>-- @param[type=function] _Action   Callback-Funktion</p><p>-- @param[type=boolean]  _OkCancel Okay/Abbrechen statt Ja/Nein</p><p>-- @within Internal</p><p>-- @local</p><p>    if XGUIEng.IsWidgetShown(RequesterDialog) == 0 then</p><p>        assert(type(_Title) == "string");</p><p>        assert(type(_Text) == "string");</p><p>        _Title = "{center}" .. _Title;</p><p>        self:OpenDialog(_Title, _Text, _Action);</p><p>        XGUIEng.ShowWidget(RequesterDialog_Yes,1);</p><p>        XGUIEng.ShowWidget(RequesterDialog_No,1);</p><p>        XGUIEng.ShowWidget(RequesterDialog_Ok,0);</p><p>        if _OkCancel ~= nil then</p><p>            XGUIEng.SetText(RequesterDialog_Yes, XGUIEng.GetStringTableText("UI_Texts/Ok_center"));</p><p>            XGUIEng.SetText(RequesterDialog_No, XGUIEng.GetStringTableText("UI_Texts/Cancel_center"));</p><p>        else</p><p>            XGUIEng.SetText(RequesterDialog_Yes, XGUIEng.GetStringTableText("UI_Texts/Yes_center"));</p><p>            XGUIEng.SetText(RequesterDialog_No, XGUIEng.GetStringTableText("UI_Texts/No_center"));</p><p>        end</p><p>        self.Data.Requester.ActionRequester = nil;</p><p>        if _Action then</p><p>            assert(type(_Action) == "function");</p><p>            self.Data.Requester.ActionRequester = _Action;</p><p>        end</p><p>        local Action = "XGUIEng.ShowWidget(RequesterDialog, 0)";</p><p>        Action = Action .. "; XGUIEng.PopPage()";</p><p>        Action = Action .. "; BundleDialogWindows.Local.CallbackRequester(BundleDialogWindows.Local, true)";</p><p>        XGUIEng.SetActionFunction(RequesterDialog_Yes, Action);</p><p>        local Action = "XGUIEng.ShowWidget(RequesterDialog, 0)";</p><p>        Action = Action .. "; XGUIEng.PopPage()";</p><p>        Action = Action .. "; BundleDialogWindows.Local.CallbackRequester(BundleDialogWindows.Local, false)"</p><p>        XGUIEng.SetActionFunction(RequesterDialog_No, Action);</p><p>    else</p><p>        self:DialogQueuePush("OpenRequesterDialog", {_Title, _Text, _Action, _OkCancel});</p><p>    end</p><p>-- Öffnet einen Auswahldialog. Sollte bereits ein Dialog zu sehen sein, wird</p><p>-- der Dialog der Dialogwarteschlange hinzugefügt.</p><p>-- @param[type=string]   _Title  Titel des Dialog</p><p>-- @param[type=string]   _Text   Text des Dialog</p><p>-- @param[type=function] _Action Callback-Funktion</p><p>-- @param[type=table]    _List   Liste der Optionen</p><p>-- @within Internal</p><p>-- @local</p><p>    if XGUIEng.IsWidgetShown(RequesterDialog) == 0 then</p><p>        self:OpenDialog(_Title, _Text, _Action);</p><p>        local HeroComboBoxID = XGUIEng.GetWidgetID(CustomGame.Widget.KnightsList);</p><p>        XGUIEng.ListBoxPopAll(HeroComboBoxID);</p><p>        for i=1,#_List do</p><p>            XGUIEng.ListBoxPushItem(HeroComboBoxID, _List[i] );</p><p>        end</p><p>        XGUIEng.ListBoxSetSelectedIndex(HeroComboBoxID, 0);</p><p>        CustomGame.Knight = 0;</p><p>        local Action = "XGUIEng.ShowWidget(RequesterDialog, 0)";</p><p>        Action = Action .. "; XGUIEng.PopPage()";</p><p>        Action = Action .. "; XGUIEng.PopPage()";</p><p>        Action = Action .. "; XGUIEng.PopPage()";</p><p>        Action = Action .. "; BundleDialogWindows.Local.Callback(BundleDialogWindows.Local)";</p><p>        XGUIEng.SetActionFunction(RequesterDialog_Ok, Action);</p><p>        local Container = "/InGame/Singleplayer/CustomGame/ContainerSelection/";</p><p>        XGUIEng.SetText(Container .. "HeroComboBoxMain/HeroComboBox", "");</p><p>        if _List[1] then</p><p>            XGUIEng.SetText(Container .. "HeroComboBoxMain/HeroComboBox", _List[1]);</p><p>        end</p><p>        XGUIEng.PushPage(Container .. "HeroComboBoxContainer", false);</p><p>        XGUIEng.PushPage(Container .. "HeroComboBoxMain",false);</p><p>        XGUIEng.ShowWidget(Container .. "HeroComboBoxContainer", 0);</p><p>        local screen = {GUI.GetScreenSize()};</p><p>        local x1, y1 = XGUIEng.GetWidgetScreenPosition(RequesterDialog_Ok);</p><p>        XGUIEng.SetWidgetScreenPosition(Container .. "HeroComboBoxMain", x1-25, y1-90);</p><p>        XGUIEng.SetWidgetScreenPosition(Container .. "HeroComboBoxContainer", x1-25, y1-20);</p><p>    else</p><p>        self:DialogQueuePush("OpenSelectionDialog", {_Title, _Text, _Action, _List});</p><p>    end</p><p>-- Stellt die Hotkeys zum Speichern des Spiels wieder her.</p><p>-- @within Internal</p><p>-- @local</p><p>    if BundleGameHelperFunctions and not BundleGameHelperFunctions.Local.Data.ForbidSave then</p><p>        XGUIEng.ShowWidget("/InGame/InGame/MainMenu/Container/QuickSave", 1);</p><p>        XGUIEng.ShowWidget("/InGame/InGame/MainMenu/Container/SaveGame", 1);</p><p>    end</p><p>    if KeyBindings_SaveGame_Orig_QSB_Windows then</p><p>        KeyBindings_SaveGame = KeyBindings_SaveGame_Orig_QSB_Windows;</p><p>        KeyBindings_SaveGame_Orig_QSB_Windows = nil;</p><p>    end</p><p>-- Überschreibt die originalen Dialogfunktionen, um Fehler in den vorhandenen</p><p>-- Funktionen zu vermeiden.</p><p>-- @within Internal</p><p>-- @local</p><p>    OpenDialog_Orig_Windows = OpenDialog;</p><p>    OpenDialog = function(_Message, _Title, _IsMPError)</p><p>        if XGUIEng.IsWidgetShown(RequesterDialog) == 0 then</p><p>            local Action = "XGUIEng.ShowWidget(RequesterDialog, 0)";</p><p>            Action = Action .. "; XGUIEng.PopPage()";</p><p>            XGUIEng.SetActionFunction(RequesterDialog_Ok, Action);</p><p>            OpenDialog_Orig_Windows(_Title, _Message);</p><p>        end</p><p>    end</p><p>    OpenRequesterDialog_Orig_Windows = OpenRequesterDialog;</p><p>    OpenRequesterDialog = function(_Message, _Title, action, _OkCancel, no_action)</p><p>        if XGUIEng.IsWidgetShown(RequesterDialog) == 0 then</p><p>            local Action = "XGUIEng.ShowWidget(RequesterDialog, 0)";</p><p>            Action = Action .. "; XGUIEng.PopPage()";</p><p>            XGUIEng.SetActionFunction(RequesterDialog_Yes, Action);</p><p>            local Action = "XGUIEng.ShowWidget(RequesterDialog, 0)";</p><p>            Action = Action .. "; XGUIEng.PopPage()";</p><p>            XGUIEng.SetActionFunction(RequesterDialog_No, Action);</p><p>            OpenRequesterDialog_Orig_Windows(_Message, _Title, action, _OkCancel, no_action);</p><p>        end</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundleentitycommandfunctions.lua.html">
            <div class='doclink'>
                <div>BundleEntityCommandFunctions</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia BundleEntityCommandFunctions                                 # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Stellt Hilfsfunktionen bereit um Entities Befehle zu erteilen oder sie</p><p>-- von A nach B zu bewegen.</p><p>-- Das wichtigste Auf einen Blick:</p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Setzt ein Entity oder ein Battalion an eine neue Position.</p><p>-- </p><p>-- @param _Entity   Entity zum versetzen (Skriptname oder ID)</p><p>-- @param _Position Neue Position (Skriptname, ID oder Position)</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.SetPostion("hakim", "hakimPos1");</p><p>function API.SetPosition(_Entity, _Position)</p><p>    if GUI then</p><p>        local Subject = (type(_Entity) ~= "string" and _Entity) or "'" .._Entity.. "'";</p><p>        local Position = _Position;</p><p>        if type(Position) == "table" then</p><p>            Position = "{X= " ..tostring(Position.X).. ", Y= " ..tostring(Position.Y).. "}";</p><p>        end</p><p>        API.Bridge("API.SetPosition(" ..Subject.. ", " ..Position.. ")")</p><p>        return;</p><p>    end</p><p>    if not IsExisting(_Entity) then</p><p>        local Subject = (type(_Entity) ~= "string" and _Entity) or "'" .._Entity.. "'";</p><p>        API.Fatal("API.SetPosition: Entity " ..Subject.. " does not exist!");</p><p>        return;</p><p>    end</p><p>    local Position = API.LocateEntity(_Position)</p><p>    if not API.ValidatePosition(Position) then</p><p>        API.Fatal("API.SetPosition: Position is invalid!");</p><p>        return;</p><p>    end</p><p>    return BundleEntityCommandFunctions.Global:SetPosition(_Entity, Position);</p><p>-- Das Entity wird relativ zu einem Winkel zum Ziel bewegt. Nachdem das Entity</p><p>-- angekommen ist, wird es zum Ziel ausgerichtet.</p><p>-- : Beim Alias MoveEntityToPositionToAnotherOne sind die</p><p>-- Parameter _Position und _Distance im Sinne der Kompatibelität vertauscht!</p><p>-- </p><p>-- </p><p>-- @param               _Entity       Entity zum versetzen (Skriptname oder ID)</p><p>-- @param               _Position     Neue Position (Skriptname oder ID)</p><p>-- @param[type=number]  _Distance     Entfernung zum Ziel</p><p>-- @param[type=number]  _Angle        Winkel</p><p>-- @param[type=boolean] _moveAsEntity Blocking ignorieren</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.MoveToPosition("hakim", "saraya", 300, 0);</p><p>function API.MoveToPosition(_Entity, _Position, _Distance, _Angle, _moveAsEntity)</p><p>    if GUI then</p><p>        API.Bridge("API.MoveToPosition(" ..GetID(_Entity).. ", " ..GetID(_Position).. ", " .._Distance.. ", " .._Angle.. ", " ..tostring(_moveAsEntity).. ")")</p><p>        return;</p><p>    end</p><p>    if not IsExisting(_Entity) then</p><p>        local Subject = (type(_Entity) ~= "string" and _Entity) or "'" .._Entity.. "'";</p><p>        API.Fatal("API.MoveToPosition: Entity " ..Subject.. " does not exist!");</p><p>        return;</p><p>    end</p><p>    if not IsExisting(_Position) then</p><p>        local Subject = (type(_Position) ~= "string" and _Position) or "'" .._Position.. "'";</p><p>        API.Fatal("API.MoveToPosition: Entity " ..Subject.. " does not exist!");</p><p>        return;</p><p>    end</p><p>    return BundleEntityCommandFunctions.Global:MoveToPosition(_Entity, _Position, _Distance, _Angle, _moveAsEntity);</p><p>    API.MoveToPosition(_Entity, _Position, _Distance, _Angle, _moveAsEntity);</p><p>-- Das Entity wird zum Ziel bewegt und schaut es anschließend an.</p><p>-- : Beim Alias MoveEntityFaceToFaceToAnotherOne sind die</p><p>-- Parameter _Position und _Distance im Sinne der Kompatibelität vertauscht!</p><p>-- </p><p>-- @param               _Entity       Entity zum versetzen (Skriptname oder ID)</p><p>-- @param               _Position     Neue Ziel (Skriptname oder ID)</p><p>-- @param[type=number]  _Distance     Entfernung zum Ziel</p><p>-- @param[type=boolean] _moveAsEntity Blocking ignorieren</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.MoveAndLookAt("hakim", "saraya", 300);</p><p>function API.MoveAndLookAt(_Entity, _Position, _Distance, _moveAsEntity)</p><p>    if GUI then</p><p>        API.Bridge("API.MoveAndLookAt(" ..GetID(_Entity).. ", " ..GetID(_Position).. ", " .._Distance.. ", " ..tostring(_moveAsEntity).. ")")</p><p>        return;</p><p>    end</p><p>    if not IsExisting(_Entity) then</p><p>        local Subject = (type(_Entity) ~= "string" and _Entity) or "'" .._Entity.. "'";</p><p>        API.Fatal("API.MoveAndLookAt: Entity " ..Subject.. " does not exist!");</p><p>        return;</p><p>    end</p><p>    if not IsExisting(_Position) then</p><p>        local Subject = (type(_Position) ~= "string" and _Position) or "'" .._Position.. "'";</p><p>        API.Fatal("API.MoveAndLookAt: Entity " ..Subject.. " does not exist!");</p><p>        return;</p><p>    end</p><p>    return BundleEntityCommandFunctions.Global:MoveToPosition(_Entity, _Position, _Distance, 0, _moveAsEntity);</p><p>    API.MoveAndLookAt(_Entity, _Position, _Distance, _moveAsEntity)</p><p>-- Das Entity wird relativ zu einem Winkel zum Zielpunkt gesetzt.</p><p>-- : Beim Alias PlaceEntityToPositionToAnotherOne sind die</p><p>-- Parameter _Position und _Distance im Sinne der Kompatibelität vertauscht!</p><p>-- </p><p>-- @param               _Entity   Entity zum versetzen (Skriptname oder ID)</p><p>-- @param               _Position Neue Ziel (Skriptname oder ID)</p><p>-- @param[type=number]  _Distance Entfernung zum Ziel</p><p>-- @param[type=number]  _Angle    Winkel</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.PlaceToPosition("hakim", "saraya", 300, 45);</p><p>function API.PlaceToPosition(_Entity, _Position, _Distance, _Angle)</p><p>    if GUI then</p><p>        API.Bridge("API.PlaceToPosition(" ..GetID(_Entity).. ", " ..GetID(_Position).. ", " .._Distance.. ", " .._Angle.. ")")</p><p>        return;</p><p>    end</p><p>    if not IsExisting(_Entity) then</p><p>        local Subject = (type(_Entity) ~= "string" and _Entity) or "'" .._Entity.. "'";</p><p>        API.Fatal("API.PlaceToPosition: Entity " ..Subject.. " does not exist!");</p><p>        return;</p><p>    end</p><p>    if not IsExisting(_Position) then</p><p>        local Subject = (type(_Position) ~= "string" and _Position) or "'" .._Position.. "'";</p><p>        API.Fatal("API.PlaceToPosition: Entity " ..Subject.. " does not exist!");</p><p>        return;</p><p>    end</p><p>    local Position = BundleEntityCommandFunctions.Shared:GetRelativePos(_Position, _Distance, _Angle, true);</p><p>    API.SetPosition(_Entity, Position);</p><p>    API.PlaceToPosition(_Entity, _Position, _Distance, _Angle);</p><p>-- Das Entity wird zum Zielpunkt gesetzt und schaut das Ziel an.</p><p>-- : Beim Alias PlaceEntityFaceToFaceToAnotherOne sind die</p><p>-- Parameter _Position und _Distance im Sinne der Kompatibelität vertauscht!</p><p>-- </p><p>-- </p><p>-- @param              _Entity   Entity zum versetzen (Skriptname oder ID)</p><p>-- @param              _Position Neue Ziel (Skriptname oder ID)</p><p>-- @param[type=number] _Distance Entfernung</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.PlaceAndLookAt("hakim", "saraya", 300);</p><p>function API.PlaceAndLookAt(_Entity, _Position, _Distance)</p><p>    if GUI then</p><p>        API.Bridge("API.PlaceAndLookAt(" ..GetID(_Entity).. ", " ..GetID(_Position).. ", " .._Distance.. ")")</p><p>        return;</p><p>    end</p><p>    API.PlaceToPosition(_Entity, _Position, _Distance, 0);</p><p>    LookAt(_Entity, _Position);</p><p>    API.PlaceAndLookAt(_Entity, _Position, _Distance);</p><p>-- Das Entity greift ein anderes Entity an, sofern möglich.</p><p>-- </p><p>-- @param _Entity Entity zum versetzen (Skriptname oder ID)</p><p>-- @param _Target Neue Ziel (Skriptname oder ID)</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.CommandAttack("hakim", "marcus");</p><p>function API.CommandAttack(_Entity, _Target)</p><p>    if GUI then</p><p>        API.Bridge("API.CommandAttack(" ..GetID(_Entity).. ", " ..GetID(_Target).. ")")</p><p>        return;</p><p>    end</p><p>    if not IsExisting(_Entity) then</p><p>        local Subject = (type(_Entity) == "string" and "'" .._Entity.. "'") or _Entity;</p><p>        API.Fatal("API.CommandAttack: Entity " ..Subject.. " does not exist!");</p><p>        return;</p><p>    end</p><p>    if not IsExisting(_Target) then</p><p>        local Subject = (type(_Target) == "string" and "'" .._Target.. "'") or _Target;</p><p>        API.Fatal("API.CommandAttack: Target " ..Subject.. " does not exist!");</p><p>        return;</p><p>    end</p><p>    local EntityID = GetID(_Entity);</p><p>    local TargetID = GetID(_Target);</p><p>    Logic.GroupAttack(EntityID, TargetID);</p><p>-- Ein Entity oder ein Battalion wird zu einer Position laufen und</p><p>-- alle gültigen Ziele auf dem Weg angreifen.</p><p>-- </p><p>-- @param              _Entity   Angreifendes Entity (Skriptname oder ID)</p><p>-- @param[type=string] _Position Zielposition</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.CommandAttackMove("hakim", "area");</p><p>function API.CommandAttackMove(_Entity, _Position)</p><p>    if GUI then</p><p>        API.Fatal("API.CommandAttackMove: Cannot be used from local script!");</p><p>        return;</p><p>    end</p><p>    if not IsExisting(_Entity) then</p><p>        local Subject = (type(_Entity) == "string" and "'" .._Entity.. "'") or _Entity;</p><p>        API.Fatal("API.CommandAttackMove: Entity " ..Subject.. " does not exist!");</p><p>        return;</p><p>    end</p><p>    local Position = API.LocateEntity(_Position)</p><p>    if not API.ValidatePosition(Position) then</p><p>        API.Fatal("API.CommandAttackMove: Position is invalid!");</p><p>        return;</p><p>    end</p><p>    local EntityID = GetID(_Entity);</p><p>    local Position = GetPosition(_Position);</p><p>    Logic.GroupAttackMove(EntityID, Position.X, Position.Y);</p><p>-- Bewegt das Entity zur Zielposition.</p><p>-- </p><p>-- @param             _Entity   Angreifendes Entity (Skriptname oder ID)</p><p>-- @param[type=table] _Position  Positionstable</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.CommandMove("hakim", "pos");</p><p>function API.CommandMove(_Entity, _Position)</p><p>    if GUI then</p><p>        API.Fatal("API.CommandMove: Cannot be used from local script!");</p><p>        return;</p><p>    end</p><p>    if not IsExisting(_Entity) then</p><p>        local Subject = (type(_Entity) == "string" and "'" .._Entity.. "'") or _Entity;</p><p>        API.Fatal("API.CommandMove: Entity " ..Subject.. " does not exist!");</p><p>        return;</p><p>    end</p><p>    local Position = API.LocateEntity(_Position)</p><p>    if not API.ValidatePosition(Position) then</p><p>        API.Fatal("API.CommandMove: Position is invalid!");</p><p>        return;</p><p>    end</p><p>    local EntityID = GetID(_Entity);</p><p>    local Position = GetPosition(_Position);</p><p>    Logic.MoveSettler(EntityID, Position.X, Position.Y);</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {</p><p>        Data = {}</p><p>    },</p><p>    Shared = {</p><p>        Data = {}</p><p>    },</p><p>-- Global Script ---------------------------------------------------------------</p><p>-- Initalisiert das Bundle im globalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>-- Setzt ein Entity oder ein Battalion an eine neue Position.</p><p>-- @param _Entity   Entity zum versetzen (Skriptname oder ID)</p><p>-- @param _Position Neue Position (Skriptname, ID oder Position)</p><p>-- @within Internal</p><p>-- @local</p><p>    if not IsExisting(_Entity)then</p><p>        return</p><p>    end</p><p>    local EntityID = GetEntityId(_Entity);</p><p>    Logic.DEBUG_SetSettlerPosition(EntityID, _Position.X, _Position.Y);</p><p>    if Logic.IsLeader(EntityID) == 1 then</p><p>        local soldiers = {Logic.GetSoldiersAttachedToLeader(EntityID)};</p><p>        if soldiers[1]  0 then</p><p>            for i=1,#soldiers do</p><p>                Logic.DEBUG_SetSettlerPosition(soldiers[i], _Position.X, _Position.Y);</p><p>            end</p><p>        end</p><p>    end</p><p>-- Das Entity wird relativ zu einem Winkel zum Zielpunkt bewegt.</p><p>-- @param               _Entity       Entity zum versetzen (Skriptname oder ID)</p><p>-- @param               _Position     Neue Position (Skriptname oder ID)</p><p>-- @param[type=number]  _Distance     Entfernung zum Ziel</p><p>-- @param[type=number]  _Angle        Winkel</p><p>-- @param[type=boolean] _moveAsEntity Blocking ignorieren</p><p>-- @within Internal</p><p>-- @local</p><p>    if not IsExisting(_Entity)then</p><p>        return</p><p>    end</p><p>    local eID = GetID(_Entity);</p><p>    local tID = GetID(_Position);</p><p>    local pos = BundleEntityCommandFunctions.Shared:GetRelativePos(_Position, _Distance or 0, _Angle or 0);</p><p>    if _moveAsEntity then</p><p>        Logic.MoveEntity(eID, pos.X, pos.Y);</p><p>    else</p><p>        Logic.MoveSettler(eID, pos.X, pos.Y);</p><p>    end</p><p>    StartSimpleJobEx( function(_EntityID, _TargetID)</p><p>        if not IsExisting(_EntityID) or not IsExisting(_EntityID) then</p><p>            return true;</p><p>        end</p><p>        if not Logic.IsEntityMoving(_EntityID) then</p><p>            LookAt(_EntityID, _TargetID);</p><p>            return true;</p><p>        end</p><p>    end, eID, tID);</p><p>-- Shared ----------------------------------------------------------------------</p><p>-- Errechnet eine Position relativ im angegebenen Winkel und Position zur</p><p>-- Basisposition. Die Basis kann ein Entity oder eine Positionstabelle sein.</p><p>-- @param               _target          Basisposition (Skriptname, ID oder Position)</p><p>-- @param[type=number]  _distance        Entfernung</p><p>-- @param[type=number]  _angle           Winkel</p><p>-- @param[type=boolean] _buildingRealPos Gebäudemitte statt Gebäudeeingang</p><p>-- @return[type=table] Position</p><p>-- @within Internal</p><p>-- @local</p><p>    if not type(_target) == "table" and not IsExisting(_target)then</p><p>        return</p><p>    end</p><p>    if _angle == nil then</p><p>        _angle = 0;</p><p>    end</p><p>    local pos1;</p><p>    if type(_target) == "table" then</p><p>        local pos = _target;</p><p>        local ori = 0+_angle;</p><p>        pos1 = { X= pos.X+_distance * math.cos(math.rad(ori)),</p><p>                 Y= pos.Y+_distance * math.sin(math.rad(ori))};</p><p>    else</p><p>        local eID = GetID(_target);</p><p>        local pos = GetPosition(eID);</p><p>        local ori = Logic.GetEntityOrientation(eID)+_angle;</p><p>        if Logic.IsBuilding(eID) == 1 and not _buildingRealPos then</p><p>            x, y = Logic.GetBuildingApproachPosition(eID);</p><p>            pos = {X= x, Y= y};</p><p>            ori = ori -90;</p><p>        end</p><p>        pos1 = { X= pos.X+_distance * math.cos(math.rad(ori)),</p><p>                 Y= pos.Y+_distance * math.sin(math.rad(ori))};</p><p>    end</p><p>    return pos1;</p><p>-- -------------------------------------------------------------------------- --</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundleentityhelperfunctions.lua.html">
            <div class='doclink'>
                <div>BundleEntityHelperFunctions</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia BundleEntityHelperFunctions                                  # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Stellt Hilfsfunktionen bereit um die Eigenschaften von Entities zu</p><p>-- ermitteln oder zu verändern.</p><p>-- Das wichtigste Auf einen Blick:</p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Sucht auf den angegebenen Territorium nach Entities mit bestimmten</p><p>-- Kategorien. Dabei kann für eine Partei oder für mehrere Parteien gesucht</p><p>-- werden.</p><p>-- </p><p>-- </p><p>-- @param _player      PlayerID [0-8] oder Table mit PlayerIDs (Einzelne Spielernummer oder Table)</p><p>-- @param _category    Kategorien oder Table mit Kategorien (Einzelne Kategorie oder Table)</p><p>-- @param _territory   Zielterritorium oder Table mit Territorien (Einzelnes Territorium oder Table)</p><p>-- @return[type=table] Liste mit Resultaten</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- local Result = API.GetEntitiesOfCategoriesInTerritories({1, 2, 3}, EntityCategories.Hero, {5, 12, 23, 24});</p><p>function API.GetEntitiesOfCategoriesInTerritories(_player, _category, _territory)</p><p>    -- Tables erzwingen</p><p>    local p = (type(_player) == "table" and _player) or {_player};</p><p>    local c = (type(_category) == "table" and _category) or {_category};</p><p>    local t = (type(_territory) == "table" and _territory) or {_territory};</p><p>    local PlayerEntities = {};</p><p>    for i=1, #p, 1 do</p><p>        for j=1, #c, 1 do</p><p>            for k=1, #t, 1 do</p><p>                local Units = API.GetEntitiesOfCategoryInTerritory(p[i], c[j], t[k]);</p><p>                PlayerEntities = Array_Append(PlayerEntities, Units);</p><p>            end</p><p>        end</p><p>    end</p><p>    return PlayerEntities;</p><p>-- Gibt alle Entities zurück, deren Name mit dem Prefix beginnt.</p><p>-- </p><p>-- @param[type=string] _Prefix Präfix des Skriptnamen</p><p>-- @return[type=table] Liste mit Entities</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- -- Alle Entities mit "entranceCave" - entranceCave1, entranceCave2, ...</p><p>-- local Result = API.GetEntitiesByPrefix("entranceCave");</p><p>function API.GetEntitiesByPrefix(_Prefix)</p><p>    local list = {};</p><p>    local i = 1;</p><p>    local bFound = true;</p><p>    while bFound do</p><p>        local entity = GetID(_Prefix ..i);</p><p>        if entity ~= 0 then</p><p>            table.insert(list, entity);</p><p>        else</p><p>            bFound = false;</p><p>        end</p><p>        i = i + 1;</p><p>    end</p><p>    return list;</p><p>-- Setzt die Menge an Rohstoffen und die durchschnittliche Auffüllmenge</p><p>-- in einer Mine.</p><p>-- </p><p>-- @param              _Entity       Rohstoffvorkommen (Skriptname oder ID)</p><p>-- @param[type=number] _StartAmount  Menge an Rohstoffen</p><p>-- @param[type=number] _RefillAmount Minimale Nachfüllmenge ( 0)</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.SetResourceAmount("mine1", 250, 150);</p><p>function API.SetResourceAmount(_Entity, _StartAmount, _RefillAmount)</p><p>    if GUI then</p><p>        local Subject = (type(_Entity) ~= "string" and _Entity) or "'" .._Entity.. "'";</p><p>        API.Bridge("API.SetResourceAmount(" ..Subject..", " .._StartAmount.. ", " .._RefillAmount.. ")")</p><p>        return;</p><p>    end</p><p>    if not IsExisting(_Entity) then</p><p>        local Subject = (type(_Entity) ~= "string" and _Entity) or "'" .._Entity.. "'";</p><p>        API.Fatal("API.SetResourceAmount: Entity " ..Subject.. " does not exist!");</p><p>        return;</p><p>    end</p><p>    return BundleEntityHelperFunctions.Global:SetResourceAmount(_Entity, _StartAmount, _RefillAmount);</p><p>-- Errechnet eine Position relativ im angegebenen Winkel und Position zur</p><p>-- Basisposition. Die Basis kann ein Entity oder eine Positionstabelle sein.</p><p>-- </p><p>-- @param               _target          Basisposition (Skriptname, ID oder Position)</p><p>-- @param[type=number]  _distance        Entfernung</p><p>-- @param[type=number]  _angle           Winkel</p><p>-- @param[type=boolean] _buildingRealPos Gebäudemitte statt Gebäudeeingang</p><p>-- @return[type=table] Position</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- local RelativePostion = API.GetRelativePosition("pos1", 1000, 32);</p><p>function API.GetRelativePosition(_target, _distance, _angle, _buildingRealPos)</p><p>    if not API.ValidatePosition(_target) then</p><p>        if not IsExisting(_target) then</p><p>            API.Fatal("API.GetRelativePosition: Target is invalid!");</p><p>            return;</p><p>        end</p><p>    end</p><p>    return BundleEntityHelperFunctions.Shared:GetRelativePos(_target, _distance, _angle, _buildingRealPos);</p><p>-- Gibt den Skriptnamen des Entity zurück.</p><p>-- </p><p>-- @param[type=number] _entity Gesuchtes Entity</p><p>-- @return[type=string] Skriptname</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- local Name = API.EntityGetName(SomeEntityID);</p><p>function API.EntityGetName(_entity)</p><p>    if not IsExisting(_entity) then</p><p>        local Subject = (type(_entity) ~= "string" and _entity) or "'" .._entity.. "'";</p><p>        API.Warn("API.EntityGetName: Entity " ..Subject.. " does not exist!");</p><p>        return nil;</p><p>    end</p><p>    return Logic.GetEntityName(GetID(_entity));</p><p>-- Setzt den Skriptnamen des Entity.</p><p>-- </p><p>-- @param[type=number] _entity Entity</p><p>-- @param[type=string] _name   Skriptname</p><p>-- @return[type=string] Skriptname</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.EntitySetName(SomeEntityID, "myEntity");</p><p>function API.EntitySetName(_entity, _name)</p><p>    if GUI then</p><p>        API.Bridge("API.EntitySetName(" ..GetID(_EntityID).. ", '" .._name.. "')")</p><p>        return;</p><p>    end</p><p>    if IsExisting(_name) then</p><p>        API.Fatal("API.EntitySetName: Entity '" .._name.. "' already exists!");</p><p>        return;</p><p>    end</p><p>    return Logic.SetEntityName(GetID(_entity), _name);</p><p>-- Setzt die Orientierung des Entity.</p><p>-- </p><p>-- @param              _entity Betreffendes Entity (Skriptname oder ID)</p><p>-- @param[type=number] _ori    Ausrichtung in Grad</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.EntitySetOrientation("marcus", 52);</p><p>function API.EntitySetOrientation(_entity, _ori)</p><p>    if GUI then</p><p>        API.Bridge("API.EntitySetOrientation(" ..GetID(_entity).. ", " .._ori.. ")")</p><p>        return;</p><p>    end</p><p>    if not IsExisting(_entity) then</p><p>        local Subject = (type(_entity) ~= "string" and _entity) or "'" .._entity.. "'";</p><p>        API.Fatal("API.EntitySetOrientation: Entity " ..Subject.. " does not exist!");</p><p>        return;</p><p>    end</p><p>    return Logic.SetOrientation(GetID(_entity), _ori);</p><p>-- Gibt die Orientierung des Entity zurück.</p><p>-- </p><p>-- @param _entity       Betreffendes Entity (Skriptname oder ID)</p><p>-- @return[type=number] Orientierung in Grad</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- local Orientation = API.EntityGetOrientation("marcus");</p><p>function API.EntityGetOrientation(_entity)</p><p>    if not IsExisting(_entity) then</p><p>        local Subject = (type(_entity) ~= "string" and _entity) or "'" .._entity.. "'";</p><p>        API.Warn("API.EntityGetOrientation: Entity " ..Subject.. " does not exist!");</p><p>        return 0;</p><p>    end</p><p>    return Logic.GetEntityOrientation(GetID(_entity));</p><p>-- Ermittelt den Helden eines Spielers, ders dem Basis-Entity am nächsten ist.</p><p>-- </p><p>-- @param[type=number] _eID      Basis-Entity</p><p>-- @param[type=number] _playerID Besitzer der Helden</p><p>-- @return[type=number] Nächstes Entity</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- local Knight = API.GetKnightsNearby(GetID("IO1"), 1);</p><p>function API.GetKnightsNearby(_eID, _playerID)</p><p>    local Knights = {};</p><p>    Logic.GetKnights(_playerID, Knights);</p><p>    return API.GetEntitiesNearby(_eID, Knights);</p><p>-- Ermittelt aus einer liste von Entity-IDs das Entity, dass dem Basis-Entity</p><p>-- am nächsten ist.</p><p>-- </p><p>-- @param[type=number] _eID      Basis-Entity</p><p>-- @param[type=table]  _entities Liste von Entities</p><p>-- @return[type=number] Nächstes Entity</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- local EntityList = API.GetEntitiesOfCategoriesInTerritories({1, 2, 3}, EntityCategories.Hero, {5, 12, 23, 24});</p><p>-- local Knight = API.GetEntitiesNearby(GetID("IO1"), EntityList);</p><p>function API.GetEntitiesNearby(_eID, _entities)</p><p>    if not IsExisting(_eID) then</p><p>        return;</p><p>    end</p><p>    if #_entities == 0 then</p><p>        API.Fatal("API.GetEntitiesNearby: The target list is empty!");</p><p>        return;</p><p>    end</p><p>    for i= 1, #_entities, 1 do</p><p>        if not IsExisting(_entities[i]) then</p><p>            API.Fatal("API.GetEntitiesNearby: At least one target entity is dead!");</p><p>            return;</p><p>        end</p><p>    end</p><p>    return BundleEntityHelperFunctions.Shared:GetNearestEntity(_eID,_entities);</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {</p><p>        Data = {</p><p>            RefillAmounts = {},</p><p>        }</p><p>    },</p><p>    Shared = {</p><p>        Data = {}</p><p>    },</p><p>-- Global Script ---------------------------------------------------------------</p><p>-- Initalisiert das Bundle im globalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    BundleEntityHelperFunctions.Global:OverwriteGeologistRefill();</p><p>-- Überschreibt das Auffüll-Callback, wenn es vorhanden ist, um Auffüllmengen</p><p>-- auch während des Spiels setzen zu können.</p><p>-- @within Internal</p><p>-- @local</p><p>    if Framework.GetGameExtraNo() = 1 then</p><p>        GameCallback_OnGeologistRefill_Orig_QSBPlusComforts1 = GameCallback_OnGeologistRefill</p><p>        GameCallback_OnGeologistRefill = function( _PlayerID, _TargetID, _GeologistID )</p><p>            GameCallback_OnGeologistRefill_Orig_QSBPlusComforts1( _PlayerID, _TargetID, _GeologistID )</p><p>            if BundleEntityHelperFunctions.Global.Data.RefillAmounts[_TargetID] then</p><p>                local RefillAmount = BundleEntityHelperFunctions.Global.Data.RefillAmounts[_TargetID];</p><p>                local RefillRandom = RefillAmount + math.random(1, math.floor((RefillAmount * 0.2) + 0.5));</p><p>                Logic.SetResourceDoodadGoodAmount(_TargetID, RefillRandom);</p><p>            end</p><p>        end</p><p>    end</p><p>-- Setzt die Menge an Rohstoffen und die durchschnittliche Auffüllmenge</p><p>-- in einer Mine.</p><p>-- @param              _Entity       Rohstoffvorkommen (Skriptname oder ID)</p><p>-- @param[type=number] _StartAmount  Menge an Rohstoffen</p><p>-- @param[type=number] _RefillAmount Minimale Nachfüllmenge ( 0)</p><p>-- @return[type=boolean] Operation erfolgreich</p><p>-- @within Internal</p><p>-- @local</p><p>    assert(type(_StartAmount) == "number");</p><p>    assert(type(_RefillAmount) == "number");</p><p>    local EntityID = GetID(_Entity);</p><p>    if not IsExisting(EntityID) or Logic.GetResourceDoodadGoodType(EntityID) == 0 then</p><p>        API.Fatal("SetResourceAmount: Resource entity is invalid!");</p><p>        return false;</p><p>    end</p><p>    if Logic.GetResourceDoodadGoodAmount(EntityID) == 0 then</p><p>        EntityID = ReplaceEntity(EntityID, Logic.GetEntityType(EntityID));</p><p>    end</p><p>    Logic.SetResourceDoodadGoodAmount(EntityID, _StartAmount);</p><p>    if _RefillAmount then</p><p>        self.Data.RefillAmounts[EntityID] = _RefillAmount;</p><p>    end</p><p>    return true;</p><p>-- Shared ----------------------------------------------------------------------</p><p>-- Errechnet eine Position relativ im angegebenen Winkel und Position zur</p><p>-- Basisposition. Die Basis kann ein Entity oder eine Positionstabelle sein.</p><p>-- @param               _target          Basisposition (Skriptname, ID oder Position)</p><p>-- @param[type=number]  _distance        Entfernung</p><p>-- @param[type=number]  _angle           Winkel</p><p>-- @param[type=boolean] _buildingRealPos Gebäudemitte statt Gebäudeeingang</p><p>-- @return[type=table] Position</p><p>-- @within Internal</p><p>-- @local</p><p>    if not type(_target) == "table" and not IsExisting(_target)then</p><p>        return</p><p>    end</p><p>    if _angle == nil then</p><p>        _angle = 0;</p><p>    end</p><p>    local pos1;</p><p>    if type(_target) == "table" then</p><p>        local pos = _target;</p><p>        local ori = 0+_angle;</p><p>        pos1 = { X= pos.X+_distance * math.cos(math.rad(ori)),</p><p>                 Y= pos.Y+_distance * math.sin(math.rad(ori))};</p><p>    else</p><p>        local eID = GetID(_target);</p><p>        local pos = GetPosition(eID);</p><p>        local ori = Logic.GetEntityOrientation(eID)+_angle;</p><p>        if Logic.IsBuilding(eID) == 1 and not _buildingRealPos then</p><p>            x, y = Logic.GetBuildingApproachPosition(eID);</p><p>            pos = {X= x, Y= y};</p><p>            ori = ori -90;</p><p>        end</p><p>        pos1 = { X= pos.X+_distance * math.cos(math.rad(ori)),</p><p>                 Y= pos.Y+_distance * math.sin(math.rad(ori))};</p><p>    end</p><p>    return pos1;</p><p>-- Ermittelt aus einer liste von Entity-IDs das Entity, dass dem Basis-Entity</p><p>-- am nächsten ist.</p><p>-- @param[type=number] _eID      Basis-Entity</p><p>-- @param[type=table]  _entities Liste von Entities</p><p>-- @return[type=number] Nächstes Entity</p><p>-- @within Internal</p><p>-- @local</p><p>    local bestDistance = Logic.WorldGetSize();</p><p>    local best = nil;</p><p>    for i=1,#_entities do</p><p>        local distanceBetween = Logic.GetDistanceBetweenEntities(_entities[i], _eID);</p><p>        if distanceBetween  bestDistance and _entities[i] ~= _eID then</p><p>            bestDistance = distanceBetween;</p><p>            best = _entities[i];</p><p>        end</p><p>    end</p><p>    return best;</p><p>-- -------------------------------------------------------------------------- --</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundleentityproperties.lua.html">
            <div class='doclink'>
                <div>BundleEntityProperties</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia BundleEntityProperties                                       # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- In diesem Bundle wird eine Klasse bereitgestellt, die alle wichtigen</p><p>-- Abfragen an ein Entity in sich vereint. Mit diesem Properties Wrapper</p><p>-- kannst Du bequem die Eigenschaften von Entities abfragen und ändern.</p><p>-- </p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Backwards compability                                                      --</p><p>-- -------------------------------------------------------------------------- --</p><p>function API.GetEntityScale(_Entity)</p><p>    return QSB.EntityProperty:GetInstance(_Entity):EntitySize();</p><p>function API.GetEntityPlayer(_Entity)</p><p>    return QSB.EntityProperty:GetInstance(_Entity):PlayerID();</p><p>function API.GetMovementTarget(_Entity)</p><p>    return QSB.EntityProperty:GetInstance(_Entity):GetDestination();</p><p>function API.IsActiveNpc(_Entity)</p><p>    return QSB.EntityProperty:GetInstance(_Entity):OnScreenInfo();</p><p>function API.IsEntityVisible(_Entity)</p><p>    return QSB.EntityProperty:GetInstance(_Entity):Visible();</p><p>function API.SetEntityScale(_Entity, _Scale)</p><p>    return QSB.EntityProperty:GetInstance(_Entity):EntitySize(_Scale);</p><p>function API.SetEntityPlayer(_Entity, _PlayerID)</p><p>    return QSB.EntityProperty:GetInstance(_Entity):PlayerID(_PlayerID);</p><p>function API.GetEntityHealth(_Entity)</p><p>    return QSB.EntityProperty:GetInstance(_Entity):Health();</p><p>function API.ChangeEntityHealth(_Entity, _Percentage)</p><p>    return QSB.EntityProperty:GetInstance(_Entity):Health(_Percentage, true);</p><p>function API.SetBuildingOnFire(_Entity, _FireSize)</p><p>    QSB.EntityProperty:GetInstance(_Entity):Burning(_FireSize)</p><p>function API.HurtEntity(_Entity, _Damage, _Attacker)</p><p>    QSB.EntityProperty:GetInstance(_Entity):Hurt(_Damage);</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Scripting Values Class                                                     --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Konstruktor</p><p>-- @param[type=string] _Entity Skriptname des Entity</p><p>-- @return[type=table] Neue Instanz</p><p>-- @within QSB.EntityProperty</p><p>    assert(self == QSB.EntityProperty, "Can not be used from instance!");</p><p>    local property = API.InstanceTable(self);</p><p>    property.m_EntityName = _Entity;</p><p>    QSB.EntityPropertyObjects[_Entity] = property;</p><p>    return property;</p><p>-- Gibt die Properties Instanz des Entity zurück.</p><p>-- Wenn zu dem Entity keine Instanz existiert, wird eine neue</p><p>-- Instanz erzeugt.</p><p>-- @param[type=string] _Entity Skriptname des Entity</p><p>-- @return[type=table] Instanz</p><p>-- @within QSB.EntityProperty</p><p>    assert(self == QSB.EntityProperty, "Can not be used from instance!");</p><p>    if not QSB.EntityPropertyObjects[_Entity] then</p><p>        QSB.EntityPropertyObjects[_Entity] = QSB.EntityProperty:New(_Entity);</p><p>    end</p><p>    return QSB.EntityPropertyObjects[_Entity];</p><p>-- Gibt die Größe des Entity zurück. Optional kann der</p><p>-- Größenfaktor geändert werden.</p><p>-- @param[type=number] _Scale (Optional) Neuer Größenfaktor</p><p>-- @return[type=number] Größenfaktor</p><p>-- @within QSB.EntityProperty</p><p>    assert(self ~= QSB.EntityProperty, "Can not be used in static context!");</p><p>    if _Scale then</p><p>        local EntityID = GetID(self.m_EntityName);</p><p>        if EntityID  0 then</p><p>            Logic.SetEntityScriptingValue(EntityID, -45, self:Float2Int(_Scale));</p><p>            if Logic.IsSettler(EntityID) == 1 then</p><p>                Logic.SetSpeedFactor(EntityID, _Scale);</p><p>            end</p><p>        end</p><p>    end</p><p>    return self:GetValueAsFloat(-45);</p><p>-- Gibt die Ausrichtung des Entity zurück. Optional kann die</p><p>-- Ausrichtung geändert werden.</p><p>-- @param[type=number] _Orientation (Optional) Neue Ausrichtung</p><p>-- @return[type=number] Ausrichtung in Grad</p><p>-- @within QSB.EntityProperty</p><p>    assert(self ~= QSB.EntityProperty, "Can not be used in static context!");</p><p>    local EntityID = GetID(self.m_EntityName);</p><p>    if EntityID == 0 then</p><p>        return 0;</p><p>    end</p><p>    if _Orientation then</p><p>        Logic.SetOrientation(EntityID, _Orientation);</p><p>    end</p><p>    return Logic.GetEntityOrientation(EntityID);</p><p>-- Gibt die Menge an Rohstoffen des Entity zurück. Optional kann</p><p>-- eine neue Menge gesetzt werden.</p><p>-- @param[type=number] _Amount (Optional) Menge an Rohstoffen</p><p>-- @return[type=number] Menge an Rohstoffen</p><p>-- @within QSB.EntityProperty</p><p>    assert(self ~= QSB.EntityProperty, "Can not be used in static context!");</p><p>    local EntityID = GetID(self.m_EntityName);</p><p>    if EntityID == 0 or Logic.GetResourceDoodadGoodType(EntityID) == 0 then</p><p>        return 0;</p><p>    end</p><p>    if _Amount then</p><p>        if Logic.GetResourceDoodadGoodAmount(EntityID) == 0 then</p><p>            EntityID = ReplaceEntity(EntityID, Logic.GetEntityType(EntityID));</p><p>        end</p><p>        Logic.SetResourceDoodadGoodAmount(EntityID, _Amount);</p><p>    end</p><p>    return Logic.GetResourceDoodadGoodAmount(EntityID);</p><p>-- Gibt den Besitzer des Entity zurück. Optional kann das</p><p>-- Entity einem neuen Besitzer zugeordnet werden.</p><p>-- @param[type=number] _PlayerID (Optional) Neuer Besitzer des Entity</p><p>-- @return[type=number] Besitzer</p><p>-- @within QSB.EntityProperty</p><p>    assert(self ~= QSB.EntityProperty, "Can not be used in static context!");</p><p>    if _PlayerID then</p><p>        local EntityID = GetID(self.m_EntityName);</p><p>        if EntityID  0 then</p><p>            if Logic.IsLeader(EntityID) == 1 then</p><p>                Logic.ChangeSettlerPlayerID(EntityID, _PlayerID);</p><p>            else</p><p>                Logic.SetEntityScriptingValue(EntityID, -71, _PlayerID);</p><p>            end</p><p>        end</p><p>    end</p><p>    return self:GetValueAsInteger(-71);</p><p>-- Gibt die Gesundheit des Entity zurück. Optional kann die</p><p>-- Gesundheit geändert werden.</p><p>-- @param[type=number]  _Health   (Optional) Neue aktuelle Gesundheit</p><p>-- @param[type=boolean] _Relative (Optional) Relativ zur maximalen Gesundheit</p><p>-- @return[type=number] Aktuelle Gesundheit</p><p>-- @within QSB.EntityProperty</p><p>    assert(self ~= QSB.EntityProperty, "Can not be used in static context!");</p><p>    local EntityID = GetID(self.m_EntityName);</p><p>    if EntityID == 0 or Logic.IsLeader(EntityID) == 1 then</p><p>        return 0;</p><p>    end</p><p>    if _Health then</p><p>        local NewHealth = _Health;</p><p>        -- Relative Gesundheit berechnen</p><p>        if _Relative then</p><p>            _Health = (_Health  0 and 0) or _Health;</p><p>            _Health = (_Health  100 and 100) or _Health;</p><p>            local MaxHealth = Logic.GetEntityMaxHealth(EntityID);</p><p>            NewHealth = math.ceil((MaxHealth) * (_Health/100));</p><p>        end</p><p>        Logic.SetEntityScriptingValue(EntityID, -41, NewHealth);</p><p>    end</p><p>    return self:GetValueAsInteger(-41);</p><p>-- Heilt das Entity um die angegebene Menge an Gesundheit.</p><p>-- @param[type=number]  _Amount   Geheilte Gesundheit</p><p>-- @within QSB.EntityProperty</p><p>    assert(self ~= QSB.EntityProperty, "Can not be used in static context!");</p><p>    local EntityID = GetID(self.m_EntityName);</p><p>    if EntityID == 0 or Logic.IsLeader(EntityID) == 1 then</p><p>        return;</p><p>    end</p><p>    self:Health(self:Health() + _Amount);</p><p>-- Verwundet ein Entity oder ein Battallion um die angegebene</p><p>-- Menge an Schaden. Bei einem Battalion wird der Schaden solange</p><p>-- auf Soldaten aufgeteilt, bis er komplett verrechnet wurde.</p><p>-- @param[type=number] _Damage   Schaden</p><p>-- @within QSB.EntityProperty</p><p>    assert(self ~= QSB.EntityProperty, "Can not be used in static context!");</p><p>    local EntityID = GetID(self.m_EntityName);</p><p>    if EntityID == 0 then</p><p>        return;</p><p>    end</p><p>    if self:InGategory(EntityCategories.Soldier) then</p><p>        local Leader = GiveEntityName(self:GetLeader());</p><p>        QSB.EntityProperty:GetInstance(Leader):Hurt(_Damage);</p><p>        return;</p><p>    end</p><p>    local EntityToHurt = EntityID;</p><p>    local IsLeader = self:InGategory(EntityCategories.Leader);</p><p>    if IsLeader then</p><p>        EntityToHurt = self:GetSoldiers()[1];</p><p>    end</p><p>    local EntityKilled = false;</p><p>    local Health = Logic.GetEntityHealth(EntityToHurt);</p><p>    if EntityToHurt then</p><p>        if Health = _Damage then</p><p>            _Damage = _Damage - Health;</p><p>            EntityKilled = true;</p><p>            Logic.HurtEntity(EntityToHurt, Health);</p><p>            if IsLeader and _Damage  0 then</p><p>                self:Hurt(_Damage);</p><p>            end</p><p>        else</p><p>            Logic.HurtEntity(EntityToHurt, _Damage);</p><p>        end</p><p>    end</p><p>-- Gibt zurück, ob das Gebäude brennt. Optional kann die Stärke</p><p>-- des Feuers verändert werden.</p><p>-- @param[type=number]  _FireSize (Optional) Neue aktuelle Gesundheit</p><p>-- @return[type=boolean] Gebäude steht in Flammen</p><p>-- @within QSB.EntityProperty</p><p>    assert(self ~= QSB.EntityProperty, "Can not be used in static context!");</p><p>    local EntityID = GetID(self.m_EntityName);</p><p>    if EntityID == 0 or Logic.IsBuilding(EntityID) == 0 then</p><p>        return false;</p><p>    end</p><p>    -- TODO: Gebäude per Skript löschen!</p><p>    if _FireSize and _FireSize  0 then</p><p>        Logic.DEBUG_SetBuildingOnFire(EntityID, _FireSize);</p><p>    end</p><p>    return Logic.IsBurning(EntityID);</p><p>-- Gibt zurück, ob das Entity sichtbar ist. Optional</p><p>-- kann die Sichtbarkeit neu gesetzt werden.</p><p>-- @param[type=boolean] _Visible (Optional) Sichtbarkeit ändern</p><p>-- @return[type=boolean] Ist sichtbar</p><p>-- @within QSB.EntityProperty</p><p>    assert(self ~= QSB.EntityProperty, "Can not be used in static context!");</p><p>    local EntityID = GetID(self.m_EntityName);</p><p>    if EntityID == 0 then</p><p>        return false;</p><p>    end</p><p>    if _Visble ~= nil then</p><p>        Logic.SetVisible(EntityID, _Visble);</p><p>    end</p><p>    return self:GetValueAsInteger(-50) == 801280;</p><p>-- Prüft, ob das Entity krank ist. Optional kann das Entity vorher</p><p>-- krank gemacht werden.</p><p>-- @param[type=boolean] _SetIll (Optional) Entity krank machen</p><p>-- @return[type=boolean] Entity ist krank</p><p>-- @within QSB.EntityProperty</p><p>    assert(self ~= QSB.EntityProperty, "Can not be used in static context!");</p><p>    local EntityID = GetID(self.m_EntityName);</p><p>    local FarmAnimal = false;</p><p>    if self:InGategory(EntityCategories.CattlePasture) or self:InGategory(EntityCategories.SheepPasture) then</p><p>        FarmAnimal = true;</p><p>    end</p><p>    if EntityID == 0 or (Logic.IsSettler(EntityID) == 0 and FarmAnimal == false) then</p><p>        return false;</p><p>    end</p><p>    if FarmAnimal then</p><p>        if _SetIll == true then</p><p>            Logic.MakeFarmAnimalIll(EntityID);</p><p>        end</p><p>        return Logic.IsFarmAnimalIll(EntityID);</p><p>    else</p><p>        if _SetIll == true then</p><p>            Logic.MakeSettlerIll(EntityID);</p><p>        end</p><p>        return Logic.IsIll(EntityID);</p><p>    end</p><p>-- Gibt zurück, ob eine NPC-Interaktion mit dem Siedler möglich ist.</p><p>-- @return[type=boolean] Ist NPC</p><p>-- @within QSB.EntityProperty</p><p>    assert(self ~= QSB.EntityProperty, "Can not be used in static context!");</p><p>    local EntityID = GetID(self.m_EntityName);</p><p>    if EntityID == 0 or Logic.IsSettler(EntityID) == 0 then</p><p>        return false;</p><p>    end</p><p>    return self:GetValueAsInteger(6)  0;</p><p>-- Gibt das Bewegungsziel des Entity zurück.</p><p>-- @return[type=table] Positionstabelle</p><p>-- @within QSB.EntityProperty</p><p>    assert(self ~= QSB.EntityProperty, "Can not be used in static context!");</p><p>    local EntityID = GetID(self.m_EntityName);</p><p>    if EntityID  0 then</p><p>        return {X= self:GetValueAsFloat(19), Y= self:GetValueAsFloat(20)};</p><p>    end</p><p>    return {X= 0, Y= 0};</p><p>-- Gibt die Mänge an Soldaten zurück, die dem Entity unterstehen</p><p>-- @return[type=number] Menge an Soldaten</p><p>-- @within QSB.EntityProperty</p><p>    assert(self ~= QSB.EntityProperty, "Can not be used in static context!");</p><p>    local EntityID = GetID(self.m_EntityName);</p><p>    if EntityID  0 and Logic.IsLeader(EntityID) == 1 then</p><p>        return self:GetValueAsInteger(-57);</p><p>    end</p><p>    return 0;</p><p>-- Gibt die IDs aller Soldaten zurück, die zum Battalion gehören.</p><p>-- @return[type=table] Liste aller Soldaten</p><p>-- @within QSB.EntityProperty</p><p>    assert(self ~= QSB.EntityProperty, "Can not be used in static context!");</p><p>    local EntityID = GetID(self.m_EntityName);</p><p>    if EntityID  0 and Logic.IsLeader(EntityID) == 1 then</p><p>        local SoldierTable = {Logic.GetSoldiersAttachedToLeader(EntityID)};</p><p>        table.remove(SoldierTable, 1);</p><p>        return SoldierTable;</p><p>    end</p><p>    return {};</p><p>-- Gibt den Leader des Soldaten zurück.</p><p>-- @return[type=number] Menge an Soldaten</p><p>-- @within QSB.EntityProperty</p><p>    assert(self ~= QSB.EntityProperty, "Can not be used in static context!");</p><p>    local EntityID = GetID(self.m_EntityName);</p><p>    if EntityID  0 and Logic.IsEntityInCategory(EntityID, EntityCategories.Soldier) == 1 then</p><p>        return self:GetValueAsInteger(46);</p><p>    end</p><p>    return 0;</p><p>-- Gibt den Typen des Entity zurück. Optinal kann das Entity</p><p>-- mit einem neuen Entity anderen Typs ersetzt werden.</p><p>-- @param[type=number] _NewType (optional) Typ neues Entity</p><p>-- @return[type=number] Typ des Entity</p><p>-- @within QSB.EntityProperty</p><p>    assert(self ~= QSB.EntityProperty, "Can not be used in static context!");</p><p>    local EntityID = GetID(self.m_EntityName);</p><p>    if EntityID == 0 then</p><p>        return 0;</p><p>    end</p><p>    if _NewType then</p><p>        EntityID = ReplaceEntity(EntityID, _NewType);</p><p>    end</p><p>    return Logic.GetEntityType(EntityID);</p><p>-- Gibt den Typnamen des Entity zurück.</p><p>-- @return[type=string] Typname des Entity</p><p>-- @within QSB.EntityProperty</p><p>    assert(self ~= QSB.EntityProperty, "Can not be used in static context!");</p><p>    local EntityID = GetID(self.m_EntityName);</p><p>    if EntityID == 0 then</p><p>        return;</p><p>    end</p><p>    return Logic.GetEntityTypeName(self:Type());</p><p>-- Gibt alle Kategorien zurück, zu denen das Entity gehört.</p><p>-- @return[type=table] Kategorien des Entity</p><p>-- @within QSB.EntityProperty</p><p>    assert(self ~= QSB.EntityProperty, "Can not be used in static context!");</p><p>    local EntityID = GetID(self.m_EntityName);</p><p>    if EntityID == 0 then</p><p>        return {};</p><p>    end</p><p>    local Categories = {};</p><p>    for k, v in pairs(EntityCategories) do</p><p>        if Logic.IsEntityInCategory(EntityID, v) == 1 then </p><p>            Categories[#Categories+1] = v;</p><p>        end</p><p>    end</p><p>    return Categories;</p><p>-- Prüft, ob das Entity zur angegebenen Kategorie gehört.</p><p>-- @param[type=number] _Category Kategorie</p><p>-- @return[type=boolean] Entity hat Kategorie</p><p>-- @within QSB.EntityProperty</p><p>    assert(self ~= QSB.EntityProperty, "Can not be used in static context!");</p><p>    return Inside(_Category, self:GetGategories());</p><p>-- Gibt die Scripting Value des Entity als Ganzzahl zurück.</p><p>-- @param[type=number] _index  Index im RAM</p><p>-- @return[type=number] Ganzzahl</p><p>-- @within QSB.EntityProperty</p><p>    assert(self ~= QSB.EntityProperty, "Can not be used in static context!");</p><p>    local EntityID = GetID(self.m_EntityName);</p><p>    if EntityID == 0 then</p><p>        return 0;</p><p>    end</p><p>    return math.floor(Logic.GetEntityScriptingValue(EntityID, _index) + 0.5);</p><p>-- Gibt die Scripting Value des Entity als Dezimalzahl zurück.</p><p>-- @param[type=number] _index  Index im RAM</p><p>-- @return[type=number] Dezimalzahl</p><p>-- @within QSB.EntityProperty</p><p>    assert(self ~= QSB.EntityProperty, "Can not be used in static context!");</p><p>    local EntityID = GetID(self.m_EntityName);</p><p>    if EntityID == 0 then</p><p>        return 0.0;</p><p>    end</p><p>    return self:Int2Float(Logic.GetEntityScriptingValue(EntityID,_index));</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Bestimmt das Modul b der Zahl a.</p><p>-- @param[type=number] a Zahl</p><p>-- @param[type=number] b Modul</p><p>-- @return[type=number] qmod der Zahl</p><p>-- @within QSB.EntityProperty</p><p>-- @local</p><p>    return a - math.floor(a/b)*b</p><p>-- Konvertiert eine Ganzzahl in eine Dezimalzahl.</p><p>-- @param[type=number] num Integer</p><p>-- @return[type=number] Integer als Float</p><p>-- @within QSB.EntityProperty</p><p>-- @local</p><p>    if(num == 0) then return 0 end</p><p>    local sign = 1</p><p>    if(num  0) then num = 2147483648 + num; sign = -1 end</p><p>    local frac = self:qmod(num, 8388608)</p><p>    local headPart = (num-frac)/8388608</p><p>    local expNoSign = self:qmod(headPart, 256)</p><p>    local exp = expNoSign-127</p><p>    local fraction = 1</p><p>    local fp = 0.5</p><p>    local check = 4194304</p><p>    for i = 23, 0, -1 do</p><p>        if(frac - check)  0 then fraction = fraction + fp; frac = frac - check end</p><p>        check = check / 2; fp = fp / 2</p><p>    end</p><p>    return fraction * math.pow(2, exp) * sign</p><p>-- Gibt den Integer als Bits zurück.</p><p>-- @param[type=number] num Bits</p><p>-- @return[type=table] Table mit Bits</p><p>-- @within QSB.EntityProperty</p><p>-- @local</p><p>    local t={}</p><p>    while num0 do</p><p>        rest=self:qmod(num, 2) table.insert(t,1,rest) num=(num-rest)/2</p><p>    end</p><p>    table.remove(t, 1)</p><p>    return t</p><p>-- Stellt eine Zahl als eine Folge von Bits in einer Table dar.</p><p>-- @param[type=number] num Integer</p><p>-- @param[type=table]  t   Table</p><p>-- @return[type=table] Table mit Bits</p><p>-- @within QSB.EntityProperty</p><p>-- @local</p><p>    for i = 1, 48 do</p><p>        num = num * 2</p><p>        if(num = 1) then table.insert(t, 1); num = num - 1 else table.insert(t, 0) end</p><p>        if(num == 0) then return t end</p><p>    end</p><p>    return t</p><p>-- Konvertiert eine Dezimalzahl in eine Ganzzahl.</p><p>-- @param[type=number] fval Float</p><p>-- @return[type=number] Float als Integer</p><p>-- @within QSB.EntityProperty</p><p>-- @local</p><p>    if(fval == 0) then return 0 end</p><p>    local signed = false</p><p>    if(fval  0) then signed = true; fval = fval * -1 end</p><p>    local outval = 0;</p><p>    local bits</p><p>    local exp = 0</p><p>    if fval = 1 then</p><p>        local intPart = math.floor(fval); local fracPart = fval - intPart;</p><p>        bits = self:bitsInt(intPart); exp = table.getn(bits); self:bitsFrac(fracPart, bits)</p><p>    else</p><p>        bits = {}; self:bitsFrac(fval, bits)</p><p>        while(bits[1] == 0) do exp = exp - 1; table.remove(bits, 1) end</p><p>        exp = exp - 1</p><p>        table.remove(bits, 1)</p><p>    end</p><p>    local bitVal = 4194304; local start = 1</p><p>    for bpos = start, 23 do</p><p>        local bit = bits[bpos]</p><p>        if(not bit) then break; end</p><p>        if(bit == 1) then outval = outval + bitVal end</p><p>        bitVal = bitVal / 2</p><p>    end</p><p>    outval = outval + (exp+127)*8388608</p><p>    if(signed) then outval = outval - 2147483648 end</p><p>    return outval;</p><p>-- -------------------------------------------------------------------------- --</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundleentityselection.lua.html">
            <div class='doclink'>
                <div>BundleEntitySelection</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia BundleEntitySelection                                        # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Mit diesem Bundle kann die Selektion von Entities gesteuert werden.</p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Deaktiviert oder aktiviert das Nachfüllen von Trebuchets.</p><p>-- @param[type=boolean] _Flag Deaktiviert (false) / Aktiviert (true)</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.DisableRefillTrebuchet(true);</p><p>function API.DisableRefillTrebuchet(_Flag)</p><p>    if not GUI then</p><p>        API.Bridge("API.DisableRefillTrebuchet(" ..tostring(_Flag).. ")");</p><p>        return;</p><p>    end</p><p>    API.Bridge("BundleEntitySelection.Local.Data.RefillTrebuchet = " ..tostring(not _Flag));</p><p>    BundleEntitySelection.Local.Data.RefillTrebuchet = not _Flag;</p><p>-- Deaktiviert oder aktiviert das Entlassen von Dieben.</p><p>-- @param[type=boolean] _Flag Deaktiviert (false) / Aktiviert (true)</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.DisableReleaseThieves(false);</p><p>function API.DisableReleaseThieves(_Flag)</p><p>    if not GUI then</p><p>        API.Bridge("API.DisableReleaseThieves(" ..tostring(_Flag).. ")");</p><p>        return;</p><p>    end</p><p>    BundleEntitySelection.Local.Data.ThiefRelease = not _Flag;</p><p>-- Deaktiviert oder aktiviert das Entlassen von Kriegsmaschinen.</p><p>-- @param[type=boolean] _Flag Deaktiviert (false) / Aktiviert (true)</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.DisableReleaseSiegeEngines(true);</p><p>function API.DisableReleaseSiegeEngines(_Flag)</p><p>    if not GUI then</p><p>        API.Bridge("API.DisableReleaseSiegeEngines(" ..tostring(_Flag).. ")");</p><p>        return;</p><p>    end</p><p>    BundleEntitySelection.Local.Data.SiegeEngineRelease = not _Flag;</p><p>-- Deaktiviert oder aktiviert das Entlassen von Soldaten.</p><p>-- @param[type=boolean] _Flag Deaktiviert (false) / Aktiviert (true)</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.DisableReleaseSoldiers(false);</p><p>function API.DisableReleaseSoldiers(_Flag)</p><p>    if not GUI then</p><p>        API.Bridge("API.DisableReleaseSoldiers(" ..tostring(_Flag).. ")");</p><p>        return;</p><p>    end</p><p>    BundleEntitySelection.Local.Data.MilitaryRelease = not _Flag;</p><p>-- Prüpft ob das Entity selektiert ist.</p><p>-- @param _Entity Entity das selektiert sein soll (Skriptname oder ID)</p><p>-- @return[type=boolean] Entity ist selektiert</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- if API.IsEntityInSelection("hakim") then</p><p>--     -- Do something</p><p>-- end</p><p>function API.IsEntityInSelection(_Entity)</p><p>    if IsExisting(_Entity) then</p><p>        local EntityID = GetID(_Entity);</p><p>        local SelectedEntities = BundleEntitySelection.Global.Data.SelectedEntities;</p><p>        if GUI then</p><p>            SelectedEntities = {GUI.GetSelectedEntities()};</p><p>        end</p><p>        for i= 1, #SelectedEntities, 1 do</p><p>            if SelectedEntities[i] == EntityID then</p><p>                return true;</p><p>            end</p><p>        end</p><p>    end</p><p>    return false;</p><p>-- Gibt die ID des selektierten Entity zurück.</p><p>-- Wenn mehr als ein Entity selektiert sind, wird das erste Entity</p><p>-- zurückgegeben. Sind keine Entities selektiert, wird 0 zurückgegeben.</p><p>-- @return[type=number] ID des selektierten Entities</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- local SelectedEntity = API.GetSelectedEntity();</p><p>function API.GetSelectedEntity()</p><p>    local SelectedEntity = BundleEntitySelection.Global.Data.SelectedEntities[1];</p><p>    if GUI then</p><p>        SelectedEntity = GUI.GetSelectedEntity();</p><p>    end</p><p>    return SelectedEntity or 0;</p><p>-- Gibt alle selektierten Entities zurück.</p><p>-- @return[type=table] ID des selektierten Entities</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- local Selection = API.GetSelectedEntities();</p><p>function API.GetSelectedEntities()</p><p>    local SelectedEntities = BundleEntitySelection.Global.Data.SelectedEntities;</p><p>    if GUI then</p><p>        SelectedEntities = {GUI.GetSelectedEntities()};</p><p>    end</p><p>    return SelectedEntities;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {</p><p>        Data = {</p><p>            RefillTrebuchet = true,</p><p>            AmmunitionUnderway = {},</p><p>            TrebuchetIDToCart = {},</p><p>            SelectedEntities = {};</p><p>        },</p><p>    },</p><p>    Local = {</p><p>        Data = {</p><p>            RefillTrebuchet = true,</p><p>            ThiefRelease = false,</p><p>            SiegeEngineRelease = true,</p><p>            MilitaryRelease = true,</p><p>            Tooltips = {</p><p>                KnightButton = {</p><p>                    Title = {</p><p>                        de = "Ritter selektieren",</p><p>                        en = "Select Knight",</p><p>                    },</p><p>                    Text = {</p><p>                        de = "- Klick selektiert den Ritter {cr}- Doppelklick springt zum Ritter{cr}- STRG halten selektiert alle Ritter",</p><p>                        en = "- Click selects the knight {cr}- Double click jumps to knight{cr}- Press CTRL to select all knights",</p><p>                    },</p><p>                },</p><p>                BattalionButton = {</p><p>                    Title = {</p><p>                        de = "Militär selektieren",</p><p>                        en = "Select Units",</p><p>                    },</p><p>                    Text = {</p><p>                        de = "- Selektiert alle Militäreinheiten {cr}- SHIFT halten um auch Munitionswagen und Trebuchets auszuwählen",</p><p>                        en = "- Selects all military units {cr}- Press SHIFT to additionally select ammunition carts and trebuchets",</p><p>                    },</p><p>                },</p><p>                ReleaseSoldiers = {</p><p>                    Title = {</p><p>                        de = "Militär entlassen",</p><p>                        en = "Release military unit",</p><p>                    },</p><p>                    Text = {</p><p>                        de = "- Eine Militäreinheit entlassen {cr}- Soldaten werden nacheinander entlassen",</p><p>                        en = "- Dismiss a military unit {cr}- Soldiers will be dismissed each after another",</p><p>                    },</p><p>                    Disabled = {</p><p>                        de = "Kann nicht entlassen werden!",</p><p>                        en = "Releasing is impossible!",</p><p>                    },</p><p>                },</p><p>                TrebuchetCart = {</p><p>                    Title = {</p><p>                        de = "Trebuchetwagen",</p><p>                        en = "Trebuchet cart",</p><p>                    },</p><p>                    Text = {</p><p>                        de = "- Kann einmalig zum Trebuchet ausgebaut werden",</p><p>                        en = "- Can uniquely be transmuted into a trebuchet",</p><p>                    },</p><p>                },</p><p>                Trebuchet = {</p><p>                    Title = {</p><p>                        de = "Trebuchet",</p><p>                        en = "Trebuchet",</p><p>                    },</p><p>                    Text = {</p><p>                        de = "- Kann über weite Strecken Gebäude angreifen {cr}- Kann Gebäude in Brand stecken {cr}- Kann nur durch Munitionsanforderung befüllt werden {cr}- Trebuchet kann manuell zurückgeschickt werden",</p><p>                        en = "- Can perform long range attacks on buildings {cr}- Can set buildings on fire {cr}- Can only be filled by ammunition request {cr}- The trebuchet can be manually send back to the city",</p><p>                    },</p><p>                },</p><p>                TrebuchetRefiller = {</p><p>                    Title = {</p><p>                        de = "Aufladen",</p><p>                        en = "Refill",</p><p>                    },</p><p>                    Text = {</p><p>                        de = "- Läd das Trebuchet mit Karren aus dem Lagerhaus nach {cr}- Benötigt die Differenz an Steinen {cr}- Kann jeweils nur einen Wagen zu selben Zeit senden",</p><p>                        en = "- Refill the Trebuchet with a cart from the storehouse {cr}- Stones for missing ammunition required {cr}- Only one cart at the time allowed",</p><p>                    },</p><p>                },</p><p>            },</p><p>        },</p><p>    },</p><p>-- Global Script ---------------------------------------------------------------</p><p>-- Initialisiert das Bundle im globalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>-- Deaktiviert oder aktiviert das Nachfüllen von Trebuchets.</p><p>-- @param[type=boolean] _Boolean Nachfüllen deaktiviert</p><p>-- @within Internal</p><p>-- @local</p><p>    self.Data.RefillTrebuchet = not _Boolean;</p><p>    Logic.ExecuteInLuaLocalState([[</p><p>        BundleEntitySelection.Local:DeactivateRefillTrebuchet(]]..tostring(_Boolean)..[[)</p><p>    ]]);</p><p>-- Baut ein Trebuchet zu einem Trebuchet-Wagen ab.</p><p>-- @param[type=number] _EntityID EntityID of Trebuchet</p><p>-- @within Internal</p><p>-- @local</p><p>    local x,y,z = Logic.EntityGetPos(_EntityID);</p><p>    local PlayerID = Logic.EntityGetPlayer(_EntityID);</p><p>    -- Externes Callback für das Kartenskript</p><p>    -- Bricht die Ausführung dieser Funktion ab!</p><p>    if GameCallback_QSB_OnDisambleTrebuchet then</p><p>        GameCallback_QSB_OnDisambleTrebuchet(_EntityID, PlayerID, x, y, z);</p><p>        return;</p><p>    end</p><p>    if self.Data.AmmunitionUnderway[_EntityID] then</p><p>        API.Message {</p><p>            de = "Eine Munitionslieferung ist auf dem Weg!",</p><p>            en = "A ammunition card is on the way!",</p><p>        };</p><p>        return;</p><p>    end</p><p>    Logic.CreateEffect(EGL_Effects.E_Shockwave01, x, y, 0);</p><p>    Logic.SetEntityInvulnerabilityFlag(_EntityID, 1);</p><p>    Logic.SetEntitySelectableFlag(_EntityID, 0);</p><p>    Logic.SetVisible(_EntityID, false);</p><p>    local TrebuchetCart = self.Data.TrebuchetIDToCart[_EntityID];</p><p>    if TrebuchetCart ~= nil then</p><p>        Logic.SetEntityInvulnerabilityFlag(TrebuchetCart, 0);</p><p>        Logic.SetEntitySelectableFlag(TrebuchetCart, 1);</p><p>        Logic.SetVisible(TrebuchetCart, true);</p><p>    else</p><p>        TrebuchetCart = Logic.CreateEntity(Entities.U_SiegeEngineCart, x, y, 0, PlayerID);</p><p>        self.Data.TrebuchetIDToCart[_EntityID] = TrebuchetCart;</p><p>    end</p><p>    Logic.DEBUG_SetSettlerPosition(TrebuchetCart, x, y);</p><p>    Logic.SetTaskList(TrebuchetCart, TaskLists.TL_NPC_IDLE);</p><p>    Logic.ExecuteInLuaLocalState([[</p><p>        GUI.SelectEntity(]]..TrebuchetCart..[[)</p><p>    ]]);</p><p>-- Baut einen Trebuchet-Wagen zu einem Trebuchet aus.</p><p>-- @param[type=number] _EntityID EntityID of Trebuchet</p><p>-- @within Internal</p><p>-- @local</p><p>    local x,y,z = Logic.EntityGetPos(_EntityID);</p><p>    local PlayerID = Logic.EntityGetPlayer(_EntityID);</p><p>    -- Externes Callback für das Kartenskript</p><p>    -- Bricht die Ausführung dieser Funktion ab!</p><p>    if GameCallback_QSB_OnErectTrebuchet then</p><p>        GameCallback_QSB_OnErectTrebuchet(_EntityID, PlayerID, x, y, z);</p><p>        return;</p><p>    end</p><p>    Logic.CreateEffect(EGL_Effects.E_Shockwave01, x, y, 0);</p><p>    Logic.SetEntityInvulnerabilityFlag(_EntityID, 1);</p><p>    Logic.SetEntitySelectableFlag(_EntityID, 0);</p><p>    Logic.SetVisible(_EntityID, false);</p><p>    local Trebuchet;</p><p>    for k, v in pairs(self.Data.TrebuchetIDToCart) do</p><p>        if v == _EntityID then</p><p>            Trebuchet = tonumber(k);</p><p>        end</p><p>    end</p><p>    if Trebuchet == nil then</p><p>        Trebuchet = Logic.CreateEntity(Entities.U_Trebuchet, x, y, 0, PlayerID);</p><p>        self.Data.TrebuchetIDToCart[Trebuchet] = _EntityID;</p><p>    end</p><p>    Logic.SetEntityInvulnerabilityFlag(Trebuchet, 0);</p><p>    Logic.SetEntitySelectableFlag(Trebuchet, 1);</p><p>    Logic.SetVisible(Trebuchet, true);</p><p>    Logic.DEBUG_SetSettlerPosition(Trebuchet, x, y);</p><p>    Logic.ExecuteInLuaLocalState([[</p><p>        GUI.SelectEntity(]]..Trebuchet..[[)</p><p>    ]]);</p><p>-- Erzeugt einen Wagen, der zu dem Trebuchet fährt und es auffüll.</p><p>-- @param[type=number] _EntityID EntityID of Trebuchet</p><p>-- @within Internal</p><p>-- @local</p><p>    local PlayerID = Logic.EntityGetPlayer(_EntityID);</p><p>    local StoreID = Logic.GetStoreHouse(PlayerID);</p><p>    local HaveAmount = Logic.GetAmmunitionAmount(_EntityID);</p><p>    local Stones = GetPlayerResources(Goods.G_Stone, PlayerID)</p><p>    -- Externes Callback für das Kartenskript</p><p>    -- Bricht die Ausführung dieser Funktion ab!</p><p>    if GameCallback_tHEA_OnRefillerCartCalled then</p><p>        GameCallback_tHEA_OnRefillerCartCalled(_EntityID, PlayerID, StoreID, HaveAmount, Stones);</p><p>        return;</p><p>    end</p><p>    if self.Data.AmmunitionUnderway[_EntityID] or StoreID == 0 then</p><p>        API.Message {</p><p>            de = "Eine Munitionslieferung ist auf dem Weg!",</p><p>            en = "A ammunition card is on the way!",</p><p>        };</p><p>        return;</p><p>    end</p><p>    if HaveAmount == 10 or Stones  10-HaveAmount then</p><p>        API.Message {</p><p>            de = "Nicht genug Steine oder das Trebuchet ist voll!",</p><p>            en = "Not enough stones or the trebuchet is full!",</p><p>        };</p><p>        return;</p><p>    end</p><p>    local x,y = Logic.GetBuildingApproachPosition(StoreID);</p><p>    local CartID = Logic.CreateEntity(Entities.U_AmmunitionCart, x, y, 0, PlayerID);</p><p>    self.Data.AmmunitionUnderway[_EntityID] = {CartID, 10-HaveAmount};</p><p>    Logic.SetEntityInvulnerabilityFlag(CartID, 1);</p><p>    Logic.SetEntitySelectableFlag(CartID, 0);</p><p>    AddGood(Goods.G_Stone, (10-HaveAmount)*(-1), PlayerID);</p><p>    StartSimpleJobEx( function(_Trebuchet)</p><p>        local CartID = self.Data.AmmunitionUnderway[_EntityID][1];</p><p>        local Amount = self.Data.AmmunitionUnderway[_EntityID][2];</p><p>        if not IsExisting(CartID) or not IsExisting(_Trebuchet) then</p><p>            self.Data.AmmunitionUnderway[_EntityID] = nil;</p><p>            return true;</p><p>        end</p><p>        if not Logic.IsEntityMoving(CartID) then</p><p>            local x,y,z = Logic.EntityGetPos(_Trebuchet);</p><p>            Logic.MoveSettler(CartID, x, y);</p><p>        end</p><p>        if IsNear(CartID, _Trebuchet, 500) then</p><p>            for i=1, Amount, 1 do</p><p>                Logic.RefillAmmunitions(_Trebuchet);</p><p>            end</p><p>            DestroyEntity(CartID);</p><p>        end</p><p>    end, _EntityID);</p><p>-- Local Script ----------------------------------------------------------------</p><p>-- Initialisiert das Bundle im lokalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    self:OverwriteSelectAllUnits();</p><p>    self:OverwriteSelectKnight();</p><p>    self:OverwriteNamesAndDescription();</p><p>    self:OverwriteThiefDeliver();</p><p>    self:OverwriteMilitaryDismount();</p><p>    self:OverwriteMultiselectIcon();</p><p>    self:OverwriteMilitaryDisamble();</p><p>    self:OverwriteMilitaryErect();</p><p>    self:OverwriteMilitaryCommands();</p><p>    self:OverwriteGetStringTableText();</p><p>    Core:AppendFunction(</p><p>        "GameCallback_GUI_SelectionChanged",</p><p>        self.OnSelectionCanged</p><p>    );</p><p>-- Deaktiviert oder aktiviert das Nachfüllen von Trebuchets.</p><p>-- @param[type=boolean] _Boolean Nachfüllen deaktiviert</p><p>-- @within Internal</p><p>-- @local</p><p>    self.Data.RefillTrebuchet = not _Boolean;</p><p>-- Callback-Funktion, die aufgerufen wird, wenn sich die Selektion ändert.</p><p>-- @param[type=number] _Source Selection Source</p><p>-- @within Internal</p><p>-- @local</p><p>    local SelectedEntities = {GUI.GetSelectedEntities()}</p><p>    local PlayerID = GUI.GetPlayerID();</p><p>    local EntityID = GUI.GetSelectedEntity();</p><p>    local EntityType = Logic.GetEntityType(EntityID);</p><p>    -- Schreibe die selektierten Entities ins globale Skript</p><p>    local SelectedEntitiesString = API.ConvertTableToString(SelectedEntities);</p><p>    API.Bridge("BundleEntitySelection.Global.Data.SelectedEntities = " ..SelectedEntitiesString);</p><p>    if EntityID ~= nil then</p><p>        if EntityType == Entities.U_SiegeEngineCart then</p><p>            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection", 1);</p><p>            XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomRight/Selection", 0);</p><p>            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/BGMilitary", 1);</p><p>            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/DialogButtons", 1);</p><p>            XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomRight/DialogButtons", 0);</p><p>            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/DialogButtons/SiegeEngineCart", 1);</p><p>        elseif EntityType == Entities.U_Trebuchet then</p><p>            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection", 1);</p><p>            XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomRight/Selection", 0);</p><p>            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/BGMilitary", 1);</p><p>            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/DialogButtons", 1);</p><p>            XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomRight/DialogButtons", 0);</p><p>            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/DialogButtons/Military", 1);</p><p>            XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomRight/DialogButtons/Military", 1);</p><p>            if BundleEntitySelection.Local.Data.RefillTrebuchet then</p><p>                XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/DialogButtons/Military/Attack", 1);</p><p>            else</p><p>                XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/DialogButtons/Military/Attack", 0);</p><p>            end</p><p>            GUI_Military.StrengthUpdate();</p><p>            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/DialogButtons/SiegeEngine", 1);</p><p>        end</p><p>    end</p><p>-- Überscheibt die Funktion, die die Ingame-Texte aus den Quellen ausließt,</p><p>-- sodass eigene Texte für Keys angezeigt werden.</p><p>-- @within Internal</p><p>-- @local</p><p>    GetStringTableText_Orig_BundleEntitySelection = XGUIEng.GetStringTableText;</p><p>    XGUIEng.GetStringTableText = function(_key)</p><p>        local Language = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>        if _key == "UI_ObjectDescription/Attack" then</p><p>            local EntityID = GUI.GetSelectedEntity();</p><p>            if Logic.GetEntityType(EntityID) == Entities.U_Trebuchet then</p><p>                return BundleEntitySelection.Local.Data.Tooltips.TrebuchetRefiller.Text[Language];</p><p>            end</p><p>        end</p><p>        if _key == "UI_ObjectNames/Attack" then</p><p>            local EntityID = GUI.GetSelectedEntity();</p><p>            if Logic.GetEntityType(EntityID) == Entities.U_Trebuchet then</p><p>                return BundleEntitySelection.Local.Data.Tooltips.TrebuchetRefiller.Title[Language];</p><p>            end</p><p>        end</p><p>        return GetStringTableText_Orig_BundleEntitySelection(_key);</p><p>    end</p><p>-- Überschreibt die Millitärkommandos "Stop" und "Angreifen".</p><p>-- @within Internal</p><p>-- @local</p><p>    GUI_Military.AttackClicked = function()</p><p>        Sound.FXPlay2DSound( "ui\\menu_click");</p><p>        local SelectedEntities = {GUI.GetSelectedEntities()};</p><p>        local EntityType = Logic.GetEntityType(SelectedEntities[1]);</p><p>        if EntityType == Entities.U_Trebuchet then</p><p>            for i=1, #SelectedEntities, 1 do</p><p>                EntityType = Logic.GetEntityType(SelectedEntities[i]);</p><p>                if EntityType == Entities.U_Trebuchet then</p><p>                    GUI.SendScriptCommand([[</p><p>                        BundleEntitySelection.Global:MilitaryCallForRefiller(]]..SelectedEntities[i]..[[)</p><p>                    ]]);</p><p>                end</p><p>            end</p><p>        else</p><p>            GUI.ActivateExplicitAttackCommandState();</p><p>        end</p><p>    end</p><p>    GUI_Military.StandGroundClicked = function()</p><p>        Sound.FXPlay2DSound( "ui\\menu_click");</p><p>        local SelectedEntities = {GUI.GetSelectedEntities()};</p><p>        for i=1,#SelectedEntities do</p><p>            local LeaderID = SelectedEntities[i];</p><p>            local eType = Logic.GetEntityType(LeaderID);</p><p>            GUI.SendCommandStationaryDefend(LeaderID);</p><p>            if eType == Entities.U_Trebuchet then</p><p>                GUI.SendScriptCommand([[</p><p>                    Logic.SetTaskList(]]..LeaderID..[[, TaskLists.TL_NPC_IDLE)</p><p>                ]]);</p><p>            end</p><p>        end</p><p>    end</p><p>    GUI_Military.StandGroundUpdate = function()</p><p>        local WidgetAttack = "/InGame/Root/Normal/AlignBottomRight/DialogButtons/Military/Attack";</p><p>        local SelectedEntities = {GUI.GetSelectedEntities()};</p><p>        SetIcon(WidgetAttack, {12, 4});</p><p>        if #SelectedEntities == 1 then</p><p>            local eID = SelectedEntities[1];</p><p>            local eType = Logic.GetEntityType(eID);</p><p>            if eType == Entities.U_Trebuchet then</p><p>                if Logic.GetAmmunitionAmount(eID)  0 then</p><p>                    XGUIEng.ShowWidget(WidgetAttack, 0);</p><p>                else</p><p>                    XGUIEng.ShowWidget(WidgetAttack, 1);</p><p>                end</p><p>                SetIcon(WidgetAttack, {1, 10});</p><p>            else</p><p>                XGUIEng.ShowWidget(WidgetAttack, 1);</p><p>            end</p><p>        end</p><p>    end</p><p>-- Überschreibt das Aufbauen von Kriegsmaschinen, sodass auch Trebuchets</p><p>-- auf- und abgebaut werden können.</p><p>-- @within Internal</p><p>-- @local</p><p>    GUI_Military.ErectClicked_Orig_BundleEntitySelection = GUI_Military.ErectClicked;</p><p>    GUI_Military.ErectClicked = function()</p><p>        GUI_Military.ErectClicked_Orig_BundleEntitySelection();</p><p>        local PlayerID = GUI.GetPlayerID();</p><p>        local SelectedEntities = {GUI.GetSelectedEntities()};</p><p>        for i=1, #SelectedEntities, 1 do</p><p>            local EntityType = Logic.GetEntityType(SelectedEntities[i]);</p><p>            if EntityType == Entities.U_SiegeEngineCart then</p><p>                GUI.SendScriptCommand([[</p><p>                    BundleEntitySelection.Global:MilitaryErectTrebuchet(]]..SelectedEntities[i]..[[)</p><p>                ]]);</p><p>            end</p><p>        end</p><p>    end</p><p>    GUI_Military.ErectUpdate_Orig_BundleEntitySelection = GUI_Military.ErectUpdate;</p><p>    GUI_Military.ErectUpdate = function()</p><p>        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();</p><p>        local SiegeCartID = GUI.GetSelectedEntity();</p><p>        local PlayerID = GUI.GetPlayerID();</p><p>        local EntityType = Logic.GetEntityType(SiegeCartID);</p><p>        if EntityType == Entities.U_SiegeEngineCart then</p><p>            XGUIEng.DisableButton(CurrentWidgetID, 0);</p><p>            SetIcon(CurrentWidgetID, {12, 6});</p><p>        else</p><p>            GUI_Military.ErectUpdate_Orig_BundleEntitySelection();</p><p>        end</p><p>    end</p><p>    GUI_Military.ErectMouseOver_Orig_BundleEntitySelection = GUI_Military.ErectMouseOver;</p><p>    GUI_Military.ErectMouseOver = function()</p><p>        local SiegeCartID = GUI.GetSelectedEntity();</p><p>        local TooltipTextKey;</p><p>        if Logic.GetEntityType(SiegeCartID) == Entities.U_SiegeEngineCart then</p><p>            TooltipTextKey = "ErectCatapult";</p><p>        else</p><p>            GUI_Military.ErectMouseOver_Orig_BundleEntitySelection();</p><p>            return;</p><p>        end</p><p>        GUI_Tooltip.TooltipNormal(TooltipTextKey, "Erect");</p><p>    end</p><p>-- Überschreibt das Abbauen von Kriegsmaschinen, sodass auch Trebuchets</p><p>-- abgebaut werden können.</p><p>-- @within Internal</p><p>-- @local</p><p>    GUI_Military.DisassembleClicked_Orig_BundleEntitySelection = GUI_Military.DisassembleClicked;</p><p>    GUI_Military.DisassembleClicked = function()</p><p>        GUI_Military.DisassembleClicked_Orig_BundleEntitySelection();</p><p>        local PlayerID = GUI.GetPlayerID();</p><p>        local SelectedEntities = {GUI.GetSelectedEntities()};</p><p>        for i=1, #SelectedEntities, 1 do</p><p>            local EntityType = Logic.GetEntityType(SelectedEntities[i]);</p><p>            if EntityType == Entities.U_Trebuchet then</p><p>                GUI.SendScriptCommand([[</p><p>                    BundleEntitySelection.Global:MilitaryDisambleTrebuchet(]]..SelectedEntities[i]..[[)</p><p>                ]]);</p><p>            end</p><p>        end</p><p>    end</p><p>    GUI_Military.DisassembleUpdate_Orig_BundleEntitySelection = GUI_Military.DisassembleUpdate;</p><p>    GUI_Military.DisassembleUpdate = function()</p><p>        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();</p><p>        local PlayerID = GUI.GetPlayerID();</p><p>        local SiegeEngineID = GUI.GetSelectedEntity();</p><p>        local EntityType = Logic.GetEntityType(SiegeEngineID);</p><p>        if EntityType == Entities.U_Trebuchet then</p><p>            XGUIEng.DisableButton(CurrentWidgetID, 0);</p><p>            SetIcon(CurrentWidgetID, {12, 9});</p><p>        else</p><p>            GUI_Military.DisassembleUpdate_Orig_BundleEntitySelection();</p><p>        end</p><p>    end</p><p>-- Überschreibt die Multiselektion, damit Trebuchets ein Icon bekommen.</p><p>-- @within Internal</p><p>-- @local</p><p>    GUI_MultiSelection.IconUpdate_Orig_BundleEntitySelection = GUI_MultiSelection.IconUpdate;</p><p>    GUI_MultiSelection.IconUpdate = function()</p><p>        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();</p><p>        local CurrentMotherID = XGUIEng.GetWidgetsMotherID(CurrentWidgetID);</p><p>        local CurrentMotherName = XGUIEng.GetWidgetNameByID(CurrentMotherID);</p><p>        local Index = CurrentMotherName + 0;</p><p>        local CurrentMotherPath = XGUIEng.GetWidgetPathByID(CurrentMotherID);</p><p>        local HealthWidgetPath = CurrentMotherPath .. "/Health";</p><p>        local EntityID = g_MultiSelection.EntityList[Index];</p><p>        local EntityType = Logic.GetEntityType(EntityID);</p><p>        local HealthState = Logic.GetEntityHealth(EntityID);</p><p>        local EntityMaxHealth = Logic.GetEntityMaxHealth(EntityID);</p><p>        if EntityType ~= Entities.U_SiegeEngineCart and EntityType ~= Entities.U_Trebuchet then</p><p>            GUI_MultiSelection.IconUpdate_Orig_BundleEntitySelection();</p><p>            return;</p><p>        end</p><p>        if Logic.IsEntityAlive(EntityID) == false then</p><p>            XGUIEng.ShowWidget(CurrentMotherID, 0);</p><p>            GUI_MultiSelection.CreateEX();</p><p>            return;</p><p>        end</p><p>        SetIcon(CurrentWidgetID, g_TexturePositions.Entities[EntityType]);</p><p>        HealthState = math.floor(HealthState / EntityMaxHealth * 100);</p><p>        if HealthState  50 then</p><p>            local green = math.floor(2*255* (HealthState/100));</p><p>            XGUIEng.SetMaterialColor(HealthWidgetPath,0,255,green, 20,255);</p><p>        else</p><p>            local red = 2*255 - math.floor(2*255* (HealthState/100));</p><p>            XGUIEng.SetMaterialColor(HealthWidgetPath,0,red, 255, 20,255);</p><p>        end</p><p>        XGUIEng.SetProgressBarValues(HealthWidgetPath,HealthState, 100);</p><p>    end</p><p>    GUI_MultiSelection.IconMouseOver_Orig_BundleEntitySelection = GUI_MultiSelection.IconMouseOver;</p><p>    GUI_MultiSelection.IconMouseOver = function()</p><p>        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();</p><p>        local CurrentMotherID = XGUIEng.GetWidgetsMotherID(CurrentWidgetID);</p><p>        local CurrentMotherName = XGUIEng.GetWidgetNameByID(CurrentMotherID);</p><p>        local Index = tonumber(CurrentMotherName);</p><p>        local EntityID = g_MultiSelection.EntityList[Index];</p><p>        local EntityType = Logic.GetEntityType(EntityID);</p><p>        if EntityType ~= Entities.U_SiegeEngineCart and EntityType ~= Entities.U_Trebuchet then</p><p>            GUI_MultiSelection.IconMouseOver_Orig_BundleEntitySelection();</p><p>            return;</p><p>        end</p><p>        local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>        if EntityType == Entities.U_SiegeEngineCart then</p><p>            local TooltipData = BundleEntitySelection.Local.Data.Tooltips.TrebuchetCart;</p><p>            BundleEntitySelection.Local:SetTooltip(TooltipData.Title[lang], TooltipData.Text[lang]);</p><p>        elseif EntityType == Entities.U_Trebuchet then</p><p>            local TooltipData = BundleEntitySelection.Local.Data.Tooltips.Trebuchet;</p><p>            BundleEntitySelection.Local:SetTooltip(TooltipData.Title[lang], TooltipData.Text[lang]);</p><p>        end</p><p>    end</p><p>-- Überschreibt die Funktion zur Beendigung der Eskorte, damit Einheiten auch</p><p>-- entlassen werden können.</p><p>-- @within Internal</p><p>-- @local</p><p>    GUI_Military.DismountClicked_Orig_BundleEntitySelection = GUI_Military.DismountClicked;</p><p>    GUI_Military.DismountClicked = function()</p><p>        local Selected = GUI.GetSelectedEntity(Selected);</p><p>        local Type = Logic.GetEntityType(Selected);</p><p>        local PlayerID = GUI.GetPlayerID();</p><p>        if Logic.GetGuardianEntityID(Selected) == 0 and Logic.IsKnight(Selected) == false then</p><p>            if (Type == Entities.U_SiegeEngineCart or Type == Entities.U_MilitarySiegeTower or</p><p>                Type == Entities.U_MilitaryCatapult or Type == Entities.U_MilitaryBatteringRam or</p><p>                Type == Entities.U_SiegeTowerCart or Type == Entities.U_CatapultCart or</p><p>                Type == Entities.U_BatteringRamCart or Type == Entities.U_AmmunitionCart)</p><p>            and BundleEntitySelection.Local.Data.SiegeEngineRelease then</p><p>                Sound.FXPlay2DSound( "ui\\menu_click");</p><p>                GUI.SendScriptCommand([[DestroyEntity(]]..Selected..[[)]]);</p><p>                return;</p><p>            end</p><p>            if (Logic.IsLeader(Selected) == 1 and BundleEntitySelection.Local.Data.MilitaryRelease) then</p><p>                Sound.FXPlay2DSound( "ui\\menu_click");</p><p>                local Soldiers = {Logic.GetSoldiersAttachedToLeader(Selected)};</p><p>                GUI.SendScriptCommand([[DestroyEntity(]]..Soldiers[#Soldiers]..[[)]]);</p><p>                return;</p><p>            end</p><p>        else</p><p>            GUI_Military.DismountClicked_Orig_BundleEntitySelection();</p><p>        end</p><p>    end</p><p>    GUI_Military.DismountUpdate_Orig_BundleEntitySelection = GUI_Military.DismountUpdate;</p><p>    GUI_Military.DismountUpdate = function()</p><p>        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();</p><p>        local Selected = GUI.GetSelectedEntity();</p><p>        local Type = Logic.GetEntityType(Selected);</p><p>        if (Logic.GetGuardianEntityID(Selected) == 0 and Logic.IsKnight(Selected) == false and Logic.IsEntityInCategory(Selected, EntityCategories.AttackableMerchant) == 0) then</p><p>            if Logic.IsLeader(Selected) == 1 and not BundleEntitySelection.Local.Data.MilitaryRelease then</p><p>                XGUIEng.DisableButton(CurrentWidgetID, 1);</p><p>            elseif  Logic.IsLeader(Selected) == 0 then</p><p>                if not BundleEntitySelection.Local.Data.SiegeEngineRelease then</p><p>                    XGUIEng.DisableButton(CurrentWidgetID, 1);</p><p>                end</p><p>                if Type == Entities.U_Trebuchet then</p><p>                    XGUIEng.DisableButton(CurrentWidgetID, 1);</p><p>                end</p><p>            else</p><p>                SetIcon(CurrentWidgetID, {12, 1});</p><p>                XGUIEng.DisableButton(CurrentWidgetID, 0);</p><p>            end</p><p>            SetIcon(CurrentWidgetID, {14, 12});</p><p>        else</p><p>            SetIcon(CurrentWidgetID, {12, 1});</p><p>            GUI_Military.DismountUpdate_Orig_BundleEntitySelection();</p><p>        end</p><p>    end</p><p>-- Überschreibt "Beute abließern", sodass Diebe entlassen werden können.</p><p>-- @within Internal</p><p>-- @local</p><p>    GUI_Thief.ThiefDeliverClicked_Orig_BundleEntitySelection = GUI_Thief.ThiefDeliverClicked;</p><p>    GUI_Thief.ThiefDeliverClicked = function()</p><p>        if not BundleEntitySelection.Local.Data.ThiefRelease then</p><p>            GUI_Thief.ThiefDeliverClicked_Orig_BundleEntitySelection();</p><p>            return;</p><p>        end</p><p>        Sound.FXPlay2DSound( "ui\\menu_click");</p><p>        local PlayerID = GUI.GetPlayerID();</p><p>        local ThiefID = GUI.GetSelectedEntity()</p><p>        if ThiefID == nil or Logic.GetEntityType(ThiefID) ~= Entities.U_Thief then</p><p>            return;</p><p>        end</p><p>        GUI.SendScriptCommand([[DestroyEntity(]]..ThiefID..[[)]]);</p><p>    end</p><p>    GUI_Thief.ThiefDeliverMouseOver_Orig_BundleEntitySelection = GUI_Thief.ThiefDeliverMouseOver;</p><p>    GUI_Thief.ThiefDeliverMouseOver = function()</p><p>        if not BundleEntitySelection.Local.Data.ThiefRelease then</p><p>            GUI_Thief.ThiefDeliverMouseOver_Orig_BundleEntitySelection();</p><p>            return;</p><p>        end</p><p>        local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>        BundleEntitySelection.Local:SetTooltip(</p><p>            BundleEntitySelection.Local.Data.Tooltips.ReleaseSoldiers.Title[lang],</p><p>            BundleEntitySelection.Local.Data.Tooltips.ReleaseSoldiers.Text[lang]</p><p>        );</p><p>    end</p><p>    GUI_Thief.ThiefDeliverUpdate_Orig_BundleEntitySelection = GUI_Thief.ThiefDeliverUpdate;</p><p>    GUI_Thief.ThiefDeliverUpdate = function()</p><p>        if not BundleEntitySelection.Local.Data.ThiefRelease then</p><p>            GUI_Thief.ThiefDeliverUpdate_Orig_BundleEntitySelection();</p><p>            return;</p><p>        end</p><p>        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();</p><p>        local ThiefID = GUI.GetSelectedEntity();</p><p>        if ThiefID == nil or Logic.GetEntityType(ThiefID) ~= Entities.U_Thief then</p><p>            XGUIEng.DisableButton(CurrentWidgetID, 1);</p><p>        else</p><p>            XGUIEng.DisableButton(CurrentWidgetID, 0);</p><p>        end</p><p>        SetIcon(CurrentWidgetID, {14, 12});</p><p>    end</p><p>-- Hängt eine Funktion an die GUI_Tooltip.SetNameAndDescription an, sodass</p><p>-- Tooltips überschrieben werden können.</p><p>-- @within Internal</p><p>-- @local</p><p>    GUI_Tooltip.SetNameAndDescription_Orig_QSB_EntitySelection = GUI_Tooltip.SetNameAndDescription;</p><p>    GUI_Tooltip.SetNameAndDescription = function(_TooltipNameWidget, _TooltipDescriptionWidget, _OptionalTextKeyName, _OptionalDisabledTextKeyName, _OptionalMissionTextFileBoolean)</p><p>        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();</p><p>        local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>        if XGUIEng.GetWidgetID("/InGame/Root/Normal/AlignBottomRight/MapFrame/KnightButton") == CurrentWidgetID then</p><p>            BundleEntitySelection.Local:SetTooltip(</p><p>                BundleEntitySelection.Local.Data.Tooltips.KnightButton.Title[lang],</p><p>                BundleEntitySelection.Local.Data.Tooltips.KnightButton.Text[lang]</p><p>            );</p><p>            return;</p><p>        end</p><p>        if XGUIEng.GetWidgetID("/InGame/Root/Normal/AlignBottomRight/MapFrame/BattalionButton") == CurrentWidgetID then</p><p>            BundleEntitySelection.Local:SetTooltip(</p><p>                BundleEntitySelection.Local.Data.Tooltips.BattalionButton.Title[lang],</p><p>                BundleEntitySelection.Local.Data.Tooltips.BattalionButton.Text[lang]</p><p>            );</p><p>            return;</p><p>        end</p><p>        if XGUIEng.GetWidgetID("/InGame/Root/Normal/AlignBottomRight/DialogButtons/SiegeEngineCart/Dismount") == CurrentWidgetID </p><p>        or XGUIEng.GetWidgetID("/InGame/Root/Normal/AlignBottomRight/DialogButtons/AmmunitionCart/Dismount") == CurrentWidgetID </p><p>        or XGUIEng.GetWidgetID("/InGame/Root/Normal/AlignBottomRight/DialogButtons/Military/Dismount") == CurrentWidgetID </p><p>        then</p><p>            local SelectedEntity = GUI.GetSelectedEntity();</p><p>            if SelectedEntity ~= 0 then</p><p>                if Logic.IsEntityInCategory(SelectedEntity, EntityCategories.Military) == 1</p><p>                and Logic.IsEntityInCategory(SelectedEntity, EntityCategories.Hero) == 0</p><p>                then</p><p>                    local GuardianEntity = Logic.GetGuardianEntityID(SelectedEntity)</p><p>                    if GuardianEntity == nil or GuardianEntity == 0 then</p><p>                        BundleEntitySelection.Local:SetTooltip(</p><p>                            BundleEntitySelection.Local.Data.Tooltips.ReleaseSoldiers.Title[lang],</p><p>                            BundleEntitySelection.Local.Data.Tooltips.ReleaseSoldiers.Text[lang],</p><p>                            BundleEntitySelection.Local.Data.Tooltips.ReleaseSoldiers.Disabled[lang]</p><p>                        );</p><p>                        return;</p><p>                    end</p><p>                end</p><p>            end</p><p>        end</p><p>        GUI_Tooltip.SetNameAndDescription_Orig_QSB_EntitySelection(_TooltipNameWidget, _TooltipDescriptionWidget, _OptionalTextKeyName, _OptionalDisabledTextKeyName, _OptionalMissionTextFileBoolean);</p><p>    end</p><p>-- Schreibt einen anderen Text in einen normalen Tooltip.</p><p>-- @param[type=string] _TitleText    Titel des Tooltip</p><p>-- @param[type=string] _DescText     Text des Tooltip</p><p>-- @param[type=string] _DisabledText Disabled Text des Tooltip</p><p>-- @within Internal</p><p>-- @local</p><p>    local TooltipContainerPath = "/InGame/Root/Normal/TooltipNormal";</p><p>    local TooltipContainer = XGUIEng.GetWidgetID(TooltipContainerPath);</p><p>    local TooltipNameWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Name");</p><p>    local TooltipDescriptionWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Text");</p><p>    local PositionWidget = XGUIEng.GetCurrentWidgetID();</p><p>    _DisabledText = _DisabledText or "";</p><p>    local DisabledText = "";</p><p>    if XGUIEng.IsButtonDisabled(PositionWidget) == 1 and _disabledText ~= "" and _text ~= "" then</p><p>        DisabledText = DisabledText .. "{cr}{@color:255,32,32,255}" .. _DisabledText;</p><p>    end</p><p>    XGUIEng.SetText(TooltipNameWidget, "{center}" .. _TitleText);</p><p>    XGUIEng.SetText(TooltipDescriptionWidget, _DescText .. DisabledText);</p><p>    local Height = XGUIEng.GetTextHeight(TooltipDescriptionWidget, true);</p><p>    local W, H = XGUIEng.GetWidgetSize(TooltipDescriptionWidget);</p><p>    XGUIEng.SetWidgetSize(TooltipDescriptionWidget, W, Height);</p><p>-- Überschreibt den SelectKnight-Button. Durch drücken von CTLR können alle</p><p>-- Helden selektiert werden, die der Spieler kontrolliert.</p><p>-- @within Internal</p><p>-- @local</p><p>    GUI_Knight.JumpToButtonClicked = function()</p><p>        local PlayerID = GUI.GetPlayerID();</p><p>        local KnightID = Logic.GetKnightID(PlayerID);</p><p>        if KnightID  0 then</p><p>            g_MultiSelection.EntityList = {};</p><p>            g_MultiSelection.Highlighted = {};</p><p>            GUI.ClearSelection();</p><p>            if XGUIEng.IsModifierPressed(Keys.ModifierControl) then</p><p>                local knights = {}</p><p>                Logic.GetKnights(PlayerID, knights);</p><p>                for i=1,#knights do</p><p>                    GUI.SelectEntity(knights[i]);</p><p>                end</p><p>            else</p><p>                GUI.SelectEntity(Logic.GetKnightID(PlayerID));</p><p>                if ((Framework.GetTimeMs() - g_Selection.LastClickTime )  g_Selection.MaxDoubleClickTime) then</p><p>                    local pos = GetPosition(KnightID);</p><p>                    Camera.RTS_SetLookAtPosition(pos.X, pos.Y);</p><p>                else</p><p>                    Sound.FXPlay2DSound("ui\\mini_knight");</p><p>                end</p><p>                g_Selection.LastClickTime = Framework.GetTimeMs();</p><p>            end</p><p>            GUI_MultiSelection.CreateMultiSelection(g_SelectionChangedSource.User);</p><p>        else</p><p>            GUI.AddNote("Debug: You do not have a knight");</p><p>        end</p><p>    end</p><p>-- Überschreibt die Militärselektion, sodass der Spieler mit SHIFT zusätzlich</p><p>-- die Munitionswagen und Trebuchets selektieren kann.</p><p>-- @within Internal</p><p>-- @local</p><p>    GUI_MultiSelection.SelectAllPlayerUnitsClicked = function()</p><p>        if XGUIEng.IsModifierPressed(Keys.ModifierShift) then</p><p>            BundleEntitySelection.Local:ExtendedLeaderSortOrder();</p><p>        else</p><p>            BundleEntitySelection.Local:NormalLeaderSortOrder();</p><p>        end</p><p>        Sound.FXPlay2DSound("ui\\menu_click");</p><p>        GUI.ClearSelection();</p><p>        local PlayerID = GUI.GetPlayerID()</p><p>        for i = 1, #LeaderSortOrder do</p><p>            local EntitiesOfThisType = GetPlayerEntities(PlayerID, LeaderSortOrder[i])</p><p>            for j = 1, #EntitiesOfThisType do</p><p>                GUI.SelectEntity(EntitiesOfThisType[j])</p><p>            end</p><p>        end</p><p>        local Knights = {}</p><p>        Logic.GetKnights(PlayerID, Knights)</p><p>        for k = 1, #Knights do</p><p>            GUI.SelectEntity(Knights[k])</p><p>        end</p><p>        GUI_MultiSelection.CreateMultiSelection(g_SelectionChangedSource.User);</p><p>    end</p><p>-- Erzeugt die normale Sortierung ohne Munitionswagen und Trebuchets.</p><p>-- @within Internal</p><p>-- @local</p><p>    g_MultiSelection = {};</p><p>    g_MultiSelection.EntityList = {};</p><p>    g_MultiSelection.Highlighted = {};</p><p>    LeaderSortOrder     = {};</p><p>    LeaderSortOrder[1]  = Entities.U_MilitarySword;</p><p>    LeaderSortOrder[2]  = Entities.U_MilitaryBow;</p><p>    LeaderSortOrder[3]  = Entities.U_MilitarySword_RedPrince;</p><p>    LeaderSortOrder[4]  = Entities.U_MilitaryBow_RedPrince;</p><p>    LeaderSortOrder[5]  = Entities.U_MilitaryBandit_Melee_ME;</p><p>    LeaderSortOrder[6]  = Entities.U_MilitaryBandit_Melee_NA;</p><p>    LeaderSortOrder[7]  = Entities.U_MilitaryBandit_Melee_NE;</p><p>    LeaderSortOrder[8]  = Entities.U_MilitaryBandit_Melee_SE;</p><p>    LeaderSortOrder[9]  = Entities.U_MilitaryBandit_Ranged_ME;</p><p>    LeaderSortOrder[10] = Entities.U_MilitaryBandit_Ranged_NA;</p><p>    LeaderSortOrder[11] = Entities.U_MilitaryBandit_Ranged_NE;</p><p>    LeaderSortOrder[12] = Entities.U_MilitaryBandit_Ranged_SE;</p><p>    LeaderSortOrder[13] = Entities.U_MilitaryCatapult;</p><p>    LeaderSortOrder[14] = Entities.U_MilitarySiegeTower;</p><p>    LeaderSortOrder[15] = Entities.U_MilitaryBatteringRam;</p><p>    LeaderSortOrder[16] = Entities.U_CatapultCart;</p><p>    LeaderSortOrder[17] = Entities.U_SiegeTowerCart;</p><p>    LeaderSortOrder[18] = Entities.U_BatteringRamCart;</p><p>    LeaderSortOrder[19] = Entities.U_Thief;</p><p>    -- Asien wird nur in der Erweiterung gebraucht.</p><p>    if g_GameExtraNo = 1 then</p><p>        table.insert(LeaderSortOrder,  4, Entities.U_MilitarySword_Khana);</p><p>        table.insert(LeaderSortOrder,  6, Entities.U_MilitaryBow_Khana);</p><p>        table.insert(LeaderSortOrder,  7, Entities.U_MilitaryBandit_Melee_AS);</p><p>        table.insert(LeaderSortOrder, 12, Entities.U_MilitaryBandit_Ranged_AS);</p><p>    end</p><p>-- Erzeugt die erweiterte Selektion mit Munitionswagen und Trebuchets.</p><p>-- @within Internal</p><p>-- @local</p><p>    g_MultiSelection = {};</p><p>    g_MultiSelection.EntityList = {};</p><p>    g_MultiSelection.Highlighted = {};</p><p>    LeaderSortOrder     = {};</p><p>    LeaderSortOrder[1]  = Entities.U_MilitarySword;</p><p>    LeaderSortOrder[2]  = Entities.U_MilitaryBow;</p><p>    LeaderSortOrder[3]  = Entities.U_MilitarySword_RedPrince;</p><p>    LeaderSortOrder[4]  = Entities.U_MilitaryBow_RedPrince;</p><p>    LeaderSortOrder[5]  = Entities.U_MilitaryBandit_Melee_ME;</p><p>    LeaderSortOrder[6]  = Entities.U_MilitaryBandit_Melee_NA;</p><p>    LeaderSortOrder[7]  = Entities.U_MilitaryBandit_Melee_NE;</p><p>    LeaderSortOrder[8]  = Entities.U_MilitaryBandit_Melee_SE;</p><p>    LeaderSortOrder[9]  = Entities.U_MilitaryBandit_Ranged_ME;</p><p>    LeaderSortOrder[10] = Entities.U_MilitaryBandit_Ranged_NA;</p><p>    LeaderSortOrder[11] = Entities.U_MilitaryBandit_Ranged_NE;</p><p>    LeaderSortOrder[12] = Entities.U_MilitaryBandit_Ranged_SE;</p><p>    LeaderSortOrder[13] = Entities.U_MilitaryCatapult;</p><p>    LeaderSortOrder[14] = Entities.U_Trebuchet;</p><p>    LeaderSortOrder[15] = Entities.U_MilitarySiegeTower;</p><p>    LeaderSortOrder[16] = Entities.U_MilitaryBatteringRam;</p><p>    LeaderSortOrder[17] = Entities.U_CatapultCart;</p><p>    LeaderSortOrder[18] = Entities.U_SiegeTowerCart;</p><p>    LeaderSortOrder[19] = Entities.U_BatteringRamCart;</p><p>    LeaderSortOrder[20] = Entities.U_AmmunitionCart;</p><p>    LeaderSortOrder[21] = Entities.U_Thief;</p><p>    -- Asien wird nur in der Erweiterung gebraucht.</p><p>    if g_GameExtraNo = 1 then</p><p>        table.insert(LeaderSortOrder,  4, Entities.U_MilitarySword_Khana);</p><p>        table.insert(LeaderSortOrder,  6, Entities.U_MilitaryBow_Khana);</p><p>        table.insert(LeaderSortOrder,  7, Entities.U_MilitaryBandit_Melee_AS);</p><p>        table.insert(LeaderSortOrder, 12, Entities.U_MilitaryBandit_Ranged_AS);</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundleextendedzoom.lua.html">
            <div class='doclink'>
                <div>BundleExtendedZoom</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia BundleExtendedZoom                                           # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Manchmal ist der maximale Zoom nicht genug! Löse Dich von den Fesseln, die</p><p>-- Dich einschränken! Dieses Bundle ermöglicht es den tatsächlichen maximalen</p><p>-- Zoom zu nutzen.</p><p>-- </p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Aktiviert den Hotkey zum Wechsel zwischen normalen und erweiterten Zoom.</p><p>-- </p><p>-- @param _Flag [boolean] Erweiterter Zoom gestattet</p><p>-- @within Anwenderfunktionen</p><p>function API.AllowExtendedZoom(_Flag)</p><p>    if GUI then</p><p>        API.Bridge("API.AllowExtendedZoom(".. tostring(_Flag) ..")");</p><p>        return;</p><p>    end</p><p>    BundleExtendedZoom.Global.Data.ExtendedZoomAllowed = _Flag == true;</p><p>    if _Flag == false then</p><p>        BundleExtendedZoom.Global:DeactivateExtendedZoom();</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {</p><p>        Data = {</p><p>            ExtendedZoomAllowed = true,</p><p>        }</p><p>    },</p><p>    Local = {},</p><p>-- Global Script ---------------------------------------------------------------</p><p>-- Initalisiert das Bundle im globalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    self:InitExtendedZoomHotkeyFunction();</p><p>    self:InitExtendedZoomHotkeyDescription();</p><p>    API.AddSaveGameAction(BundleExtendedZoom.Global.OnSaveGameLoaded);</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Schaltet zwischen dem normalen und dem erweiterten Zoom um.</p><p>-- @within Internal</p><p>-- @local</p><p>    if self.Data.ExtendedZoomAllowed then</p><p>        if self.Data.ExtendedZoomActive then</p><p>            self:DeactivateExtendedZoom();</p><p>        else</p><p>            self:ActivateExtendedZoom();</p><p>        end</p><p>    end</p><p>-- Aktiviert den erweiterten Zoom.</p><p>-- @within Internal</p><p>-- @local</p><p>    self.Data.ExtendedZoomActive = true;</p><p>    API.Bridge("BundleExtendedZoom.Local:ActivateExtendedZoom()");</p><p>-- Deaktiviert den erweiterten Zoom.</p><p>-- @within Internal</p><p>-- @local</p><p>    self.Data.ExtendedZoomActive = false;</p><p>    API.Bridge("BundleExtendedZoom.Local:DeactivateExtendedZoom()");</p><p>-- Initialisiert den erweiterten Zoom.</p><p>-- @within Internal</p><p>-- @local</p><p>    API.Bridge([[</p><p>        BundleExtendedZoom.Local:ActivateExtendedZoomHotkey()</p><p>    ]]);</p><p>-- Initialisiert den erweiterten Zoom.</p><p>-- @within Internal</p><p>-- @local</p><p>    API.Bridge([[</p><p>        BundleExtendedZoom.Local:RegisterExtendedZoomHotkey()</p><p>    ]]);</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Stellt nicht-persistente Änderungen nach dem laden wieder her.</p><p>-- @within Internal</p><p>-- @local</p><p>    -- Geänderter Zoom --</p><p>    if BundleExtendedZoom.Global.Data.ExtendedZoomActive then</p><p>        BundleExtendedZoom.Global:ActivateExtendedZoom();</p><p>    end</p><p>    BundleExtendedZoom.Global:InitExtendedZoomHotkeyFunction();</p><p>-- Local Script ----------------------------------------------------------------</p><p>-- Initalisiert das Bundle im lokalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Schreibt den Hotkey für den erweiterten Zoom in das Hotkey-Register.</p><p>-- @within Internal</p><p>-- @local</p><p>    API.AddHotKey(</p><p>        {de = "Strg + Umschalt + K",       en = "Ctrl + Shift + K"},</p><p>        {de = "Alternativen Zoom ein/aus", en = "Alternative zoom on/off"}</p><p>    )</p><p>-- Aktiviert den Hotkey zum Wechsel zwischen normalen und erweiterten Zoom.</p><p>-- @within Internal</p><p>-- @local</p><p>    Input.KeyBindDown(</p><p>        Keys.ModifierControl + Keys.ModifierShift + Keys.K,</p><p>        "BundleExtendedZoom.Local:ToggleExtendedZoom()",</p><p>        2,</p><p>        false</p><p>    );</p><p>-- Wechselt zwischen erweitertem und normalen Zoom.</p><p>-- @within Internal</p><p>-- @local</p><p>    API.Bridge("BundleExtendedZoom.Global:ToggleExtendedZoom()");</p><p>-- Erweitert die Zoomrestriktion auf das Maximum.</p><p>-- @within Internal</p><p>-- @local</p><p>    Camera.RTS_SetZoomFactorMax(0.8701);</p><p>    Camera.RTS_SetZoomFactor(0.8700);</p><p>    Camera.RTS_SetZoomFactorMin(0.0999);</p><p>-- Stellt die normale Zoomrestriktion wieder her.</p><p>-- @within Internal</p><p>-- @local</p><p>    Camera.RTS_SetZoomFactor(0.5000);</p><p>    Camera.RTS_SetZoomFactorMax(0.5001);</p><p>    Camera.RTS_SetZoomFactorMin(0.0999);</p><p>-- -------------------------------------------------------------------------- --</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundlegamehelperfunctions.lua.html">
            <div class='doclink'>
                <div>BundleGameHelperFunctions</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia BundleGameHelperFunctions                                    # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Dieses Bundle gibt dem Mapper Werkzeuge in die Hand, um einige Features zu</p><p>-- gewähren oder zu entziehen.</p><p>-- Das wichtigste Auf einen Blick:</p><p>-- </p><p>-- </p><p>-- Cheats, Erweiterter</p><p>-- Zoom, Feste feiern für KIs</p><p>-- </p><p>-- </p><p>-- Cheats, Erweiterter</p><p>-- Zoom, Feste feiern für KIs</p><p>-- </p><p>-- </p><p>-- </p><p>-- Maximale Spielgeschwindigkeit festlegen</p><p>-- </p><p>-- </p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Fokusiert die Kamera auf dem Primärritter des Spielers.</p><p>-- </p><p>-- @param[type=number] _Player Partei</p><p>-- @param[type=number] _Rotation Kamerawinkel</p><p>-- @param[type=number] _ZoomFactor Zoomfaktor</p><p>-- @within Anwenderfunktionen</p><p>function API.FocusCameraOnKnight(_Player, _Rotation, _ZoomFactor)</p><p>    API.FocusCameraOnEntity(Logic.GetKnightID(_Player), _Rotation, _ZoomFactor)</p><p>-- Fokusiert die Kamera auf dem Entity.</p><p>-- </p><p>-- @param _Entity Entity (Skriptname oder ID)</p><p>-- @param[type=number] _Rotation Kamerawinkel</p><p>-- @param[type=number] _ZoomFactor Zoomfaktor</p><p>-- @within Anwenderfunktionen</p><p>function API.FocusCameraOnEntity(_Entity, _Rotation, _ZoomFactor)</p><p>    if not GUI then</p><p>        local Subject = (type(_Entity) ~= "string" and _Entity) or "'" .._Entity.. "'";</p><p>        API.Bridge("API.FocusCameraOnEntity(" ..Subject.. ", " .._Rotation.. ", " .._ZoomFactor.. ")")</p><p>        return;</p><p>    end</p><p>    if not IsExisting(_Entity) then</p><p>        local Subject = (type(_Entity) ~= "string" and _Entity) or "'" .._Entity.. "'";</p><p>        API.Warn("API.FocusCameraOnEntity: Entity " ..Subject.. " does not exist!");</p><p>        return;</p><p>    end</p><p>    return BundleGameHelperFunctions.Local:SetCameraToEntity(_Entity, _Rotation, _ZoomFactor);</p><p>-- Setzt die Obergrenze für die Spielgeschwindigkeit fest.</p><p>-- </p><p>-- @param[type=number] _Limit Obergrenze</p><p>-- @within Anwenderfunktionen</p><p>function API.SpeedLimitSet(_Limit)</p><p>    if not GUI then</p><p>        API.Bridge("API.SpeedLimitSet(" .._Limit.. ")");</p><p>        return;</p><p>    end</p><p>    return BundleGameHelperFunctions.Local:SetSpeedLimit(_Limit);</p><p>-- Aktiviert die Speedbremse. Die vorher eingestellte Maximalgeschwindigkeit</p><p>-- kann nicht mehr überschritten werden.</p><p>-- </p><p>-- @param[type=boolean] _Flag Speedbremse ist aktiv</p><p>-- @within Anwenderfunktionen</p><p>function API.SpeedLimitActivate(_Flag)</p><p>    if GUI then</p><p>        API.Bridge("API.SpeedLimitActivate(" ..tostring(_Flag).. ")");</p><p>        return;</p><p>    end</p><p>    return API.Bridge("BundleGameHelperFunctions.Local:ActivateSpeedLimit(" ..tostring(_Flag).. ")");</p><p>-- Deaktiviert die Tastenkombination zum Einschalten der Cheats.</p><p>-- </p><p>-- @within Anwenderfunktionen</p><p>function API.ForbidCheats()</p><p>    if GUI then</p><p>        API.Bridge("API.ForbidCheats()");</p><p>        return;</p><p>    end</p><p>    return BundleGameHelperFunctions.Global:KillCheats();</p><p>-- Aktiviert die Tastenkombination zum Einschalten der Cheats.</p><p>-- </p><p>-- @within Anwenderfunktionen</p><p>function API.AllowCheats()</p><p>    if GUI then</p><p>        API.Bridge("API.AllowCheats()");</p><p>        return;</p><p>    end</p><p>    return BundleGameHelperFunctions.Global:RessurectCheats();</p><p>-- Sperrt das Speichern von Spielständen oder gibt es wieder frei.</p><p>-- </p><p>-- @param[type=boolean] _Flag Speichern gesperrt</p><p>-- @within Anwenderfunktionen</p><p>function API.ForbidSaveGame(_Flag)</p><p>    if GUI then</p><p>        API.Bridge("API.ForbidSaveGame(".. tostring(_Flag) ..")");</p><p>        return;</p><p>    end</p><p>    API.Bridge([[</p><p>        BundleGameHelperFunctions.Local.Data.ForbidSave = ]].. tostring(_Flag) ..[[ == true</p><p>        BundleGameHelperFunctions.Local:DisplaySaveButtons(]].. tostring(_Flag) ..[[)</p><p>    ]]);</p><p>-- Lässt einen Siedler einem Helden folgen. Gibt die ID des Jobs</p><p>-- zurück, der die Verfolgung steuert.</p><p>--  Wenn eines der Entities zerstört wird, oder ins</p><p>-- Koma fällt, wird der Job beendet!</p><p>-- </p><p>-- @param              _Entity Entity das folgt (skriptname oder ID)</p><p>-- @param              _Knight Held (Skriptname oder ID)</p><p>-- @param[type=number] _Distance Entfernung, die uberschritten sein muss</p><p>-- @param[type=number] _Angle Ausrichtung</p><p>-- @return[type=number] Job-ID</p><p>-- @within Anwenderfunktionen</p><p>function API.FollowKnightSaveStart(_Entity, _Knight, _Distance, _Angle)</p><p>    if GUI then</p><p>        local Target = (type(_Entity) == "string" and "'".._Entity.."'") or _Entity;</p><p>        local Knight = (type(_Knight) == "string" and "'".._Knight.."'") or _Knight;</p><p>        API.Bridge("API.FollowKnightSaveStart(" ..Target.. ", " ..Knight.. ", " .._Distance.. "," .._Angle.. ")");</p><p>        return;</p><p>    end</p><p>    return BundleGameHelperFunctions.Global:AddFollowKnightSave(_Entity, _Knight, _Distance, _Angle);</p><p>-- Beendet einen Verfolgungsjob.</p><p>-- </p><p>-- @param[type=number] _JobID Job-ID</p><p>-- @within Anwenderfunktionen</p><p>function API.FollowKnightSaveStop(_JobID)</p><p>    if GUI then</p><p>        API.Bridge("API.FollowKnightSaveStop(" .._JobID.. ")");</p><p>        return;</p><p>    end</p><p>    return BundleGameHelperFunctions.Global:StopFollowKnightSave(_JobID)</p><p>-- Ändert die Bodentextur innerhalb des Quadrates. Offset bestimmt die</p><p>-- Abstände der Eckpunkte zum Zentralpunkt.</p><p>--  Für weitere Informationen zu Terraintexturen siehe</p><p>-- https://siedelwood-neu.de/23879-2/</p><p>-- </p><p>-- @param              _Center Zentralpunkt (Skriptname oder ID)</p><p>-- @param[type=number] _Offset Entfernung der Ecken zum Zentrum</p><p>-- @param[type=number] _TerrainType Textur ID</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.ChangeTerrainTypeInSquare("area", 500, 48)</p><p>function API.ChangeTerrainTypeInSquare(_Center, _Offset, _TerrainType)</p><p>    if GUI then</p><p>        local Target = (type(_Center) == "string" and "'".._Center.."'") or _Center;</p><p>        API.Bridge("API.ChangeTerrainTypeInSquare(" ..Target.. ", " .._Offset.. ", " .._TerrainType.. ")");</p><p>        return;</p><p>    end</p><p>    if not IsExisting(_Center) then</p><p>        API.Fatal("API.ChangeTerrainTypeInSquare: Central point does not exist!");</p><p>        return;</p><p>    end</p><p>    if _Offset  100 then</p><p>        API.Warn("API.ChangeTerrainTypeInSquare: Check your offset! It seems to small!");</p><p>    end</p><p>    return BundleGameHelperFunctions.Global:ChangeTerrainTypeInSquare(_Center, _Offset, _TerrainType);</p><p>-- Ändert die Wasserhöhe in einem Quadrat. Offset bestimmt die Abstände</p><p>-- der Eckpunkte zum Zentrum.</p><p>-- Wird die relative Höhe verwendet, wird die Wasserhöhe nicht absolut</p><p>-- gesetzt sondern von der aktuellen Wasserhöhe ausgegangen.</p><p>-- </p><p>-- @param               _Center Zentralpunkt (Skriptname oder ID)</p><p>-- @param[type=number]  _Offset Entfernung der Ecken zum Zentrum</p><p>-- @param[type=number]  _Height Neue Höhe</p><p>-- @param[type=boolean] _Relative Relative Höhe benutzen</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.ChangeWaterHeightInSquare("area", 500, 5555, true);</p><p>function API.ChangeWaterHeightInSquare(_Center, _Offset, _Height, _Relative)</p><p>    if GUI then</p><p>        local Target = (type(_Center) == "string" and "'".._Center.."'") or _Center;</p><p>        API.Bridge("API.ChangeWaterHeightInSquare(" ..Target.. ", " .._Offset.. ", " .._Height.. ", " ..tostring(_Relative).. ")");</p><p>        return;</p><p>    end</p><p>    if not IsExisting(_Center) then</p><p>        API.Fatal("API.ChangeWaterHeightInSquare: Central point does not exist!");</p><p>        return;</p><p>    end</p><p>    if _Offset  100 then</p><p>        API.Warn("API.ChangeWaterHeightInSquare: Check your offset! It seems to small!");</p><p>    end</p><p>    return BundleGameHelperFunctions.Global:ChangeWaterHeightInSquare(_Center, _Offset, _Height, _Relative);</p><p>-- Ändert die Landhöhe in einem Quadrat. Offset bestimmt die Abstände</p><p>-- der Eckpunkte zum Zentralpunkt.</p><p>-- Wird die relative Höhe verwendet, wird die Landhöhe nicht absolut</p><p>-- gesetzt sondern von der aktuellen Landhöhe ausgegangen. Das Land muss nicht</p><p>-- eben sein. Auf diese Weise können Strukturen unverändert angehoben werden.</p><p>-- </p><p>-- @param               _Center Zentralpunkt (Skriptname oder ID)</p><p>-- @param[type=number]  _Offset Entfernung der Ecken zum Zentrum</p><p>-- @param[type=number]  _Height Neue Höhe</p><p>-- @param[type=boolean] _Relative Relative Höhe benutzen</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.ChangeTerrainHeightInSquare("area", 500, 5555, true);</p><p>function API.ChangeTerrainHeightInSquare(_Center, _Offset, _Height, _Relative)</p><p>    if GUI then</p><p>        local Target = (type(_Center) == "string" and "'".._Center.."'") or _Center;</p><p>        API.Bridge("API.ChangeTerrainHeightInSquare(" ..Target.. ", " .._Offset.. ", " .._Height.. ", " ..tostring(_Relative).. ")");</p><p>        return;</p><p>    end</p><p>    if not IsExisting(_Center) then</p><p>        API.Fatal("API.ChangeTerrainHeightInSquare: Central point does not exist!");</p><p>        return;</p><p>    end</p><p>    if _Offset  100 then</p><p>        API.Warn("API.ChangeTerrainHeightInSquare: Check your offset! It seems to small!");</p><p>    end</p><p>    return BundleGameHelperFunctions.Global:ChangeTerrainHeightInSquare(_Center, _Offset, _Height, _Relative);</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {</p><p>        Data = {</p><p>            HumanPlayerChangedOnce = false,</p><p>            HumanKnightType = 0,</p><p>            HumanPlayerID = 1,</p><p>            FollowKnightSave = {},</p><p>        }</p><p>    },</p><p>    Local = {</p><p>        Data = {</p><p>            SpeedLimit = 32,</p><p>        }</p><p>    },</p><p>-- Global Script ---------------------------------------------------------------</p><p>-- Initalisiert das Bundle im globalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    API.AddSaveGameAction(BundleGameHelperFunctions.Global.OnSaveGameLoaded);</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Deaktiviert die Tastenkombination zum Einschalten der Cheats.</p><p>-- @within Internal</p><p>-- @local</p><p>    self.Data.CheatsForbidden = true;</p><p>    API.Bridge("BundleGameHelperFunctions.Local:KillCheats()");</p><p>-- Aktiviert die Tastenkombination zum Einschalten der Cheats.</p><p>-- @within Internal</p><p>-- @local</p><p>    self.Data.CheatsForbidden = false;</p><p>    API.Bridge("BundleGameHelperFunctions.Local:RessurectCheats()");</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Lässt einen Siedler einem Helden folgen. Gibt die ID des Jobs</p><p>-- zurück, der die Verfolgung steuert.</p><p>-- @param              _Entity Entity das folgt (skriptname oder ID)</p><p>-- @param              _Knight Held (Skriptname oder ID)</p><p>-- @param[type=number] _Distance Entfernung, die uberschritten sein muss</p><p>-- @param[type=number] _Angle Ausrichtung</p><p>-- @return[type=number] Job-ID</p><p>-- @within Internal</p><p>-- @local</p><p>    local EntityID = GetID(_Entity);</p><p>    local KnightID = GetID(_Knight);</p><p>    _Angle = _Angle or 0;</p><p>    local JobID = Trigger.RequestTrigger(Events.LOGIC_EVENT_EVERY_TURN,</p><p>                                         nil,</p><p>                                         "ControlFollowKnightSave",</p><p>                                         1,</p><p>                                         {},</p><p>                                         {EntityID, KnightID, _Distance, _Angle});</p><p>    table.insert(self.Data.FollowKnightSave, JobID);</p><p>    return JobID;</p><p>-- Beendet einen Verfolgungsjob.</p><p>-- @param[type=number] _JobID Job-ID</p><p>-- @within Internal</p><p>-- @local</p><p>    for k,v in pairs(self.Data.FollowKnightSave) do</p><p>        if _JobID == v then</p><p>            self.Data.FollowKnightSave[k] = nil;</p><p>            EndJob(_JobID);</p><p>        end</p><p>    end</p><p>-- Kontrolliert die Verfolgung eines Helden durch einen Siedler.</p><p>-- @param              _Entity Entity das folgt (skriptname oder ID)</p><p>-- @param              _Knight Held (Skriptname oder ID)</p><p>-- @param[type=number] _Distance Entfernung, die uberschritten sein muss</p><p>-- @param[type=number] _Angle Ausrichtung</p><p>-- @within Internal</p><p>-- @local</p><p>    -- Entity oder Held sind hinüber bzw. haben ihre ID verändert</p><p>    if not IsExisting(_KnightID) or not IsExisting(_EntityID) then</p><p>        return true;</p><p>    end</p><p>    -- Wenn Entity ein Held ist, dann nur, wenn Entity nicht komatös ist</p><p>    if Logic.IsKnight(_EntityID) and Logic.KnightGetResurrectionProgress(_EntityID) ~= 1 then</p><p>        return false;</p><p>    end</p><p>    -- Wenn Knight ein Held ist, dann nur, wenn Knight nicht komatös ist</p><p>    if Logic.IsKnight(_KnightID) and Logic.KnightGetResurrectionProgress(_KnightID) ~= 1 then</p><p>        return false;</p><p>    end</p><p>    if  Logic.IsEntityMoving(_EntityID) == false and Logic.IsFighting(_EntityID) == false</p><p>    and IsNear(_EntityID, _KnightID, _Distance+300) == false then</p><p>        -- Relative Position hinter Held bestimmen</p><p>        local x, y, z = Logic.EntityGetPos(_KnightID);</p><p>        local orientation = Logic.GetEntityOrientation(_KnightID)-(180+_Angle);</p><p>        local xBehind = x + _Distance * math.cos(math.rad(orientation));</p><p>        local yBehind = y + _Distance * math.sin(math.rad(orientation));</p><p>        -- Relative Position blockingsicher machen</p><p>        local NoBlocking = Logic.CreateEntityOnUnblockedLand(Entities.XD_ScriptEntity, xBehind, yBehind, 0, 0);</p><p>        local x, y, z = Logic.EntityGetPos(NoBlocking);</p><p>        DestroyEntity(NoBlocking);</p><p>        -- Zur neuen unblockierten Position bewegen</p><p>        Logic.MoveSettler(_EntityID, x, y);</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ändert die Bodentextur innerhalb des Quadrates. Offset bestimmt die</p><p>-- Abstände der Eckpunkte zum Zentralpunkt.</p><p>-- @param              _Center Zentralpunkt (Skriptname oder ID)</p><p>-- @param[type=number] _Offset Entfernung der Ecken zum Zentrum</p><p>-- @param[type=number] _TerrainType Textur ID</p><p>-- @within Internal</p><p>-- @local</p><p>    local Xmin, Ymin, Xmax, Ymax, z = self:GetSquareForWaterAndTerrain(_Center, _Offset);</p><p>    if Xmin == -1 or Xmin == -2 then</p><p>        return Xmin;</p><p>    end</p><p>    if type(_TerrainType) == "number" then</p><p>        for x10 = Xmin, Xmax do</p><p>            for y10 = Ymin, Ymax do</p><p>                Logic.SetTerrainNodeType( x10, y10, _TerrainType );</p><p>            end</p><p>        end</p><p>    end</p><p>    Logic.UpdateBlocking( Xmin, Ymin, Xmax, Ymax);</p><p>-- Ändert die Wasserhöhe in einem Quadrat. Offset bestimmt die Abstände</p><p>-- der Eckpunkte zum Zentralpunkt.</p><p>-- @param               _Center Zentralpunkt (Skriptname oder ID)</p><p>-- @param[type=number]  _Offset Entfernung der Ecken zum Zentrum</p><p>-- @param[type=number]  _Height Neue Höhe</p><p>-- @param[type=boolean] _Relative Relative Höhe benutzen</p><p>-- @within Internal</p><p>-- @local</p><p>    local Xmin, Ymin, Xmax, Ymax, z = self:GetSquareForWaterAndTerrain(_Center, _Offset);</p><p>    if Xmin == -1 or Xmin == -2 then</p><p>        return Xmin;</p><p>    end</p><p>    if not _Relative then</p><p>        if _Height  0 then</p><p>            return -3;</p><p>        end</p><p>        Logic.WaterSetAbsoluteHeight(Xmin, Ymin, Xmax, Ymax, _Height);</p><p>    else</p><p>        if z+_Height  0 then</p><p>            return -3;</p><p>        end</p><p>        Logic.WaterSetAbsoluteHeight(Xmin, Ymin, Xmax, Ymax, z+_Height);</p><p>    end</p><p>    Logic.UpdateBlocking(Xmin, Ymin, Xmax, Ymax);</p><p>    return 0;</p><p>-- Ändert die Landhöhe in einem Quadrat. Offset bestimmt die Abstände</p><p>-- der Eckpunkte zum Zentralpunkt.</p><p>-- @param               _Center Zentralpunkt (Skriptname oder ID)</p><p>-- @param[type=number]  _Offset Entfernung der Ecken zum Zentrum</p><p>-- @param[type=number]  _Height Neue Höhe</p><p>-- @param[type=boolean] _Relative Relative Höhe benutzen</p><p>-- @within Internal</p><p>-- @local</p><p>    local Xmin, Ymin, Xmax, Ymax, z = self:GetSquareForWaterAndTerrain(_Center, _Offset);</p><p>    if Xmin == -1 or Xmin == -2 then</p><p>        return Xmin;</p><p>    end</p><p>    local Height;</p><p>    if not _Relative then</p><p>        if _Height  0 then</p><p>            return -3;</p><p>        end</p><p>        Height = _Height;</p><p>    else</p><p>        if z+_Height  0 then</p><p>            return -3;</p><p>        end</p><p>        Height = z+_Height;</p><p>    end</p><p>    for x10 = Xmin, Xmax do</p><p>        for y10 = Ymin, Ymax do</p><p>            Logic.SetTerrainNodeHeight(x10, y10, Height);</p><p>        end</p><p>    end</p><p>    Logic.UpdateBlocking(Xmin, Ymin, Xmax, Ymax);</p><p>    return 0;</p><p>-- Gibt ein Quadrat für Land- und Wassermanipulation zurück.</p><p>-- Wird verwendet von: WaterHeight, TerrainHeight, TerrainType</p><p>-- @param              _Center Zentralpunkt des Quadrat (Skriptname oder ID)</p><p>-- @param[type=number] _Offset Abstand der Ecken zum Zentrum</p><p>-- @return[type=number] X-Koordinate von Punkt 1</p><p>-- @return[type=number] Y-Koordinate von Punkt 1</p><p>-- @return[type=number] X-Koordinate von Punkt 2</p><p>-- @return[type=number] Y-Koordinate von Punkt 2</p><p>-- @return[type=number] Bodenhöhe</p><p>-- @within Internal</p><p>-- @local</p><p>    local Type = type(_Center);</p><p>    if (Type ~= "string" and Type ~= "number") or not IsExisting(_Center) then</p><p>        return -1;</p><p>    end</p><p>    local Xmin, Ymin, Xmax, Ymax;</p><p>    local eID = GetID(_Center);</p><p>    local x,y,z = Logic.EntityGetPos(eID);</p><p>    Xmin = math.floor((x - _Offset)/100);</p><p>    Ymin = math.floor((y - _Offset)/100);</p><p>    Xmax = math.floor((x + _Offset)/100);</p><p>    Ymax = math.floor((y + _Offset)/100);</p><p>    if IsValidPosition({X= Xmin, Y= Ymin}) == false or IsValidPosition({X= Xmax, Y= Ymax}) == false then</p><p>        return -2;</p><p>    end</p><p>    return Xmin, Ymin, Xmax, Ymax, z;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Stellt nicht-persistente Änderungen nach dem laden wieder her.</p><p>-- @within Internal</p><p>-- @local</p><p>    -- Cheats sperren --</p><p>    if BundleGameHelperFunctions.Global.Data.CheatsForbidden == true then</p><p>        BundleGameHelperFunctions.Global:KillCheats();</p><p>    end</p><p>-- Local Script ----------------------------------------------------------------</p><p>-- Initalisiert das Bundle im lokalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    self:InitForbidSpeedUp()</p><p>    self:InitForbidSaveGame();</p><p>-- Fokusiert die Kamera auf dem Entity.</p><p>-- @param _Entity Entity (Skriptname oder ID)</p><p>-- @param[type=number] _Rotation Kamerawinkel</p><p>-- @param[type=number] _ZoomFactor Zoomfaktor</p><p>-- @within Internal</p><p>-- @local</p><p>    local pos = GetPosition(_Entity);</p><p>    local rotation = (_Rotation or -45);</p><p>    local zoomFactor = (_ZoomFactor or 0.5);</p><p>    Camera.RTS_SetLookAtPosition(pos.X, pos.Y);</p><p>    Camera.RTS_SetRotationAngle(rotation);</p><p>    Camera.RTS_SetZoomFactor(zoomFactor);</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Setzt die Obergrenze für die Spielgeschwindigkeit fest.</p><p>-- @param[type=number] _Limit Obergrenze</p><p>-- @within Internal</p><p>-- @local</p><p>    _Limit = (_Limit  1 and 1) or math.floor(_Limit);</p><p>    self.Data.SpeedLimit = _Limit;</p><p>-- Aktiviert die Speedbremse. Die vorher eingestellte Maximalgeschwindigkeit</p><p>-- kann nicht mehr überschritten werden.</p><p>-- @param[type=boolean] _Flag Speedbremse ist aktiv</p><p>-- @within Internal</p><p>-- @local</p><p>    self.Data.UseSpeedLimit = _Flag == true;</p><p>    if _Flag and Game.GameTimeGetFactor(GUI.GetPlayerID())  self.Data.SpeedLimit then</p><p>        Game.GameTimeSetFactor(GUI.GetPlayerID(), self.Data.SpeedLimit);</p><p>    end</p><p>-- Überschreibt das Callback, das nach dem Ändern der Spielgeschwindigkeit</p><p>-- aufgerufen wird und installiert die Speedbremse.</p><p>-- @within Internal</p><p>-- @local</p><p>    GameCallback_GameSpeedChanged_Orig_Preferences_ForbidSpeedUp = GameCallback_GameSpeedChanged;</p><p>    GameCallback_GameSpeedChanged = function( _Speed )</p><p>        GameCallback_GameSpeedChanged_Orig_Preferences_ForbidSpeedUp( _Speed );</p><p>        if BundleGameHelperFunctions.Local.Data.UseSpeedLimit == true then</p><p>            if _Speed  BundleGameHelperFunctions.Local.Data.SpeedLimit then</p><p>                Game.GameTimeSetFactor(GUI.GetPlayerID(), BundleGameHelperFunctions.Local.Data.SpeedLimit);</p><p>            end</p><p>        end</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Deaktiviert die Tastenkombination zum Einschalten der Cheats.</p><p>-- @within Internal</p><p>-- @local</p><p>    Input.KeyBindDown(</p><p>        Keys.ModifierControl + Keys.ModifierShift + Keys.Divide,</p><p>        "KeyBindings_EnableDebugMode(0)",</p><p>        2,</p><p>        false</p><p>    );</p><p>-- Aktiviert die Tastenkombination zum Einschalten der Cheats.</p><p>-- @within Internal</p><p>-- @local</p><p>    Input.KeyBindDown(</p><p>        Keys.ModifierControl + Keys.ModifierShift + Keys.Divide,</p><p>        "KeyBindings_EnableDebugMode(2)",</p><p>        2,</p><p>        false</p><p>    );</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Überschreibt die Hotkey-Funktion, die das Spiel speichert.</p><p>-- @within Internal</p><p>-- @local</p><p>    KeyBindings_SaveGame_Orig_Preferences_SaveGame = KeyBindings_SaveGame;</p><p>    KeyBindings_SaveGame = function()</p><p>        if BundleGameHelperFunctions.Local.Data.ForbidSave then</p><p>            return;</p><p>        end</p><p>        KeyBindings_SaveGame_Orig_Preferences_SaveGame();</p><p>    end</p><p>-- Zeigt oder versteckt die Speicherbuttons im Spielmenü.</p><p>-- @param[type=boolean] _Flag Speicherbuttons sichtbar</p><p>-- @within Internal</p><p>-- @local</p><p>    XGUIEng.ShowWidget("/InGame/InGame/MainMenu/Container/SaveGame",  (_Flag and 0) or 1);</p><p>    XGUIEng.ShowWidget("/InGame/InGame/MainMenu/Container/QuickSave", (_Flag and 0) or 1);</p><p>-- -------------------------------------------------------------------------- --</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundleinteractiveobjects.lua.html">
            <div class='doclink'>
                <div>BundleInteractiveObjects</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia BundleInteractiveObjects                                     # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Interaktive Objekte sind Gegenstände auf der Karte, mit denen interagiert</p><p>-- werden kann. Diese Interaktion geschieht über einen Button. Ziel dieses</p><p>-- Bundels ist es, die funktionalität von interaktiven Objekten zu erweitern.</p><p>-- Es ist möglich, beliebige Objekte zu interaktiven Objekten zu machen.</p><p>-- Die Einsatzmöglichkeiten sind vielfältig. Wenn ein Gegenstand oder ein</p><p>-- Objekt mit einer Funktion versehen ist, kann dies in verschiedenem Kontext</p><p>-- an die Geschichte angepasst werden: z.B. Helbel öffnen eine Geheimtür,</p><p>-- ein Gegenstand wird vom Helden aufgehoben, ein Marktstand, der etwas</p><p>-- verkauft, ....</p><p>-- Das wichtigste Auf einen Blick:</p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- Ein- und ausschalten von</p><p>-- interaktiven Objekten</p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Erzeugt ein interaktives Objekt.</p><p>-- Die Parameter des interaktiven Objektes werden durch seine Beschreibung</p><p>-- festgelegt. Die Beschreibung ist eine Table, die bestimmte Werte für das</p><p>-- Objekt beinhaltet. Dabei müssen nicht immer alle Werte angegeben werden.</p><p>-- Mögliche Angaben:</p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- Bestimmt die Icongrafik, die angezeigt wird. Dabei kann es sich um</p><p>-- eine Ingame-Grafik oder eine eigene Grafik halten.</p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- Die minimale Entfernung zum Objekt, die ein Held benötigt um das</p><p>-- objekt zu aktivieren.</p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- Die Zeit, die ein Held benötigt, um das Objekt zu aktivieren. Die</p><p>-- Wartezeit ist nur für I_X_ Entities verfügbar.</p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- Eine Nachricht, die angezeigt wird, falls die Bedingung nicht</p><p>-- erfüllt ist.</p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- Nachricht, die angezeigt wird, wenn der falsche Held das Objekt</p><p>-- aktivieren will.</p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- Zusätzlich können beliebige weitere Felder an das Objekt angehangen</p><p>-- werden. Sie sind ausnahmslos im Callback und in der Condition des Objektes</p><p>-- abrufbar.</p><p>-- </p><p>-- @param[type=table] _Description Beschreibung</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- -- Ein einfaches Objekt erstellen:</p><p>-- CreateObject {</p><p>--     Name     = "hut",</p><p>--     Distance = 1500,</p><p>--     Callback = function(_Data)</p><p>--         API.Note("Do something...");</p><p>--     end,</p><p>-- }</p><p>function API.CreateObject(_Description)</p><p>    if GUI then</p><p>        API.Fatal("API.CreateObject: Can not be used from local enviorment!");</p><p>        return;</p><p>    end</p><p>    return BundleInteractiveObjects.Global:CreateObject(_Description);</p><p>-- Löscht ein interaktives Objekt.</p><p>-- Das Entity wird dabei nicht gelöscht. Es wird ausschließlich die</p><p>-- Konfiguration des Objektes entfernt.</p><p>-- </p><p>-- @param[type=string] _EntityName Skriptname des IO</p><p>-- @within Anwenderfunktionen</p><p>function API.RemoveInteractiveObject(_EntityName)</p><p>    if GUI then</p><p>        API.Bridge("API.RemoveInteractiveObject('" .._EntityName.. "')");</p><p>        return;</p><p>    end</p><p>    if not IsExisting(_EntityName) then</p><p>        API.Warn("API.RemoveInteractiveObject: Entity \"" .._EntityName.. "\" is invalid!");</p><p>        return;</p><p>    end</p><p>    return BundleInteractiveObjects.Global:RemoveInteractiveObject(_EntityName);</p><p>-- Aktiviert ein Interaktives Objekt, sodass es vom Spieler</p><p>-- aktiviert werden kann.</p><p>-- Der State bestimmt, ob es immer aktiviert werden kann, oder ob der Spieler</p><p>-- einen Helden benutzen muss. Wird der Parameter weggelassen, muss immer ein</p><p>-- Held das Objekt aktivieren.</p><p>-- </p><p>-- @param[type=string] _EntityName Skriptname des Objektes</p><p>-- @param[type=number] _State  State des Objektes</p><p>-- @within Anwenderfunktionen</p><p>function API.InteractiveObjectActivate(_EntityName, _State)</p><p>    if GUI then</p><p>        API.Bridge("API.InteractiveObjectActivate('" .._EntityName.. "', " ..tostring(_State).. ")");</p><p>        return;</p><p>    end</p><p>    if not IsExisting(_EntityName) then</p><p>        API.Warn("API.InteractiveObjectActivate: Entity \"" .._EntityName.. "\" is invalid!");</p><p>        return;</p><p>    end</p><p>    if not Logic.IsInteractiveObject(GetID(_EntityName)) then</p><p>        if IO[_EntityName] then</p><p>            IO[_EntityName].Inactive = false;</p><p>            IO[_EntityName].Used = false;</p><p>        end</p><p>    else</p><p>        API.ActivateIO(_EntityName, _State);</p><p>    end</p><p>-- Deaktiviert ein interaktives Objekt, sodass es nicht mehr vom Spieler</p><p>-- benutzt werden kann.</p><p>-- </p><p>-- @param[type=string] _EntityName Scriptname des Objektes</p><p>-- @within Anwenderfunktionen</p><p>function API.InteractiveObjectDeactivate(_EntityName)</p><p>    if GUI then</p><p>        API.Bridge("API.InteractiveObjectDeactivate('" .._EntityName.. "')");</p><p>        return;</p><p>    end</p><p>    if not IsExisting(_EntityName) then</p><p>        API.Warn("API.InteractiveObjectDeactivate: Entity \"" .._EntityName.. "\" is invalid!");</p><p>        return;</p><p>    end</p><p>    if not Logic.IsInteractiveObject(GetID(_EntityName)) then</p><p>        if IO[_EntityName] then</p><p>            IO[_EntityName].Inactive = true;</p><p>        end</p><p>    else</p><p>        API.DeactivateIO(_EntityName);</p><p>    end</p><p>-- Erzeugt eine Beschriftung für Custom Objects.</p><p>-- Im Questfenster werden die Namen von Custom Objects als ungesetzt angezeigt.</p><p>-- Mit dieser Funktion kann ein Name angelegt werden.</p><p>-- </p><p>-- @param[type=string] _Key Typname des Entity</p><p>-- @param              _Text Text der Beschriftung</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.AddCustomIOName("D_X_ChestClosed", {de = "Schatztruhe", en = "Treasure");</p><p>-- API.AddCustomIOName("D_X_ChestOpenEmpty", "Leere Schatztruhe");</p><p>function API.AddCustomIOName(_Key, _Text)</p><p>    if type(_Text) == "table" then</p><p>        local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>        _Text = _Text[lang];</p><p>    end</p><p>    if GUI then</p><p>        API.Bridge("API.AddCustomIOName('" .._Key.. "', '" .._Text.. "')");</p><p>        return;</p><p>    end</p><p>    return BundleInteractiveObjects.Global:AddCustomIOName(_Key, _Text);</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {</p><p>        Data = {}</p><p>    },</p><p>    Local = {</p><p>        Data = {</p><p>            IOCustomNames = {},</p><p>            IOCustomNamesByEntityName = {},</p><p>        },</p><p>    },</p><p>-- Global Script ---------------------------------------------------------------</p><p>-- Initalisiert das Bundle im globalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    IO = {};</p><p>    self:OverrideVanillaBehavior();</p><p>-- Überschreibt Reward_ObjectInit, damit IO korrekt funktionieren.</p><p>-- @within Internal</p><p>-- @local</p><p>    if b_Reward_ObjectInit then</p><p>        b_Reward_ObjectInit.CustomFunction = function(_Behavior, _Quest)</p><p>            local eID = GetID(_Behavior.ScriptName);</p><p>            if eID == 0 then</p><p>                return;</p><p>            end</p><p>            QSB.InitalizedObjekts[eID] = _Quest.Identifier;</p><p>            </p><p>            local RewardTable = nil;</p><p>            if _Behavior.RewardType and _Behavior.RewardType ~= "-" then</p><p>                RewardTable = {Goods[_Behavior.RewardType], _Behavior.RewardAmount};</p><p>            end</p><p>            local CostsTable = nil;</p><p>            if _Behavior.FirstCostType and _Behavior.FirstCostType ~= "-" then</p><p>                CostsTable = {Goods[_Behavior.FirstCostType], _Behavior.FirstCostAmount};</p><p>                if _Behavior.SecondCostType and _Behavior.SecondCostType ~= "-" then</p><p>                    table.insert(CostsTable, Goods[_Behavior.SecondCostType]);</p><p>                    table.insert(CostsTable, _Behavior.SecondCostAmount);</p><p>                end</p><p>            end</p><p>            API.CreateObject{</p><p>                Name        = _Behavior.ScriptName,</p><p>                State       = _Behavior.UsingState or 0,</p><p>                Distance    = _Behavior.Distance,</p><p>                Waittime    = _Behavior.Waittime,</p><p>                Reward      = RewardTable,</p><p>                Costs       = CostsTable,</p><p>            };</p><p>        end</p><p>    end</p><p>-- Erzeugt ein interaktives Objekt. Dabei können sowohl interaktive</p><p>-- Objekte (alle mit I_X_), eine Auswahl von normalen Entities und</p><p>-- sogar (sichtbare) XD_ScriptEntities verwendet werden.</p><p>-- Name, Titel und Icon müssen immer angegeben werden. Die restlichen</p><p>-- Angaben hängen teilweise vom Typ der Entity, teilweise vom</p><p>-- Verwendungszweck ab.</p><p>-- @param[type=table] _Description Beschreibung</p><p>-- @within Internal</p><p>-- @local</p><p>    local lang = Network.GetDesiredLanguage();</p><p>    self:HackOnInteractionEvent();</p><p>    self:RemoveInteractiveObject(_Description.Name);</p><p>    if type(_Description.Title) == "table" then</p><p>        _Description.Title = _Description.Title[lang];</p><p>    end</p><p>    if not _Description.Title or _Description.Title == "" then</p><p>        _Description.Title = (lang == "de" and "Interaktion") or "Interaction";</p><p>    end</p><p>    if type(_Description.Text) == "table" then</p><p>        _Description.Text = _Description.Text[lang];</p><p>    end</p><p>    if not _Description.Text then</p><p>        _Description.Text = "";</p><p>    end</p><p>    if type(_Description.WrongKnight) == "table" then</p><p>        _Description.WrongKnight = _Description.WrongKnight[lang];</p><p>    end</p><p>    _Description.WrongKnight = _Description.WrongKnight or "";</p><p>    if type(_Description.ConditionUnfulfilled) == "table" then</p><p>        _Description.ConditionUnfulfilled = _Description.ConditionUnfulfilled[lang];</p><p>    end</p><p>    _Description.ConditionUnfulfilled = _Description.ConditionUnfulfilled or "";</p><p>    _Description.Condition = _Description.Condition or function() return true end</p><p>    _Description.Callback = _Description.Callback or function() end</p><p>    _Description.Distance = _Description.Distance or 1200;</p><p>    _Description.Waittime = _Description.Waittime or 15;</p><p>    _Description.Texture = _Description.Texture or {14,10};</p><p>    _Description.Reward = _Description.Reward or {};</p><p>    _Description.Costs = _Description.Costs or {};</p><p>    _Description.State = _Description.State or 0;</p><p>    Logic.ExecuteInLuaLocalState([[</p><p>        QSB.IOList[#QSB.IOList+1] = "]].._Description.Name..[["</p><p>        if not BundleInteractiveObjects.Local.Data.InteractionHackStarted then</p><p>            BundleInteractiveObjects.Local:ActivateInteractiveObjectControl()</p><p>            BundleInteractiveObjects.Local.Data.InteractionHackStarted = true;</p><p>        end</p><p>    ]]);</p><p>    IO[_Description.Name] = API.InstanceTable(_Description);</p><p>    local eID = GetID(_Description.Name);</p><p>    if Logic.IsInteractiveObject(eID) == true then</p><p>        Logic.InteractiveObjectClearCosts(eID);</p><p>        Logic.InteractiveObjectClearRewards(eID);</p><p>        Logic.InteractiveObjectSetInteractionDistance(eID,_Description.Distance);</p><p>        Logic.InteractiveObjectSetTimeToOpen(eID,_Description.Waittime);</p><p>        Logic.InteractiveObjectAddRewards(eID,_Description.Reward[1],_Description.Reward[2]);</p><p>        Logic.InteractiveObjectSetAvailability(eID, true);</p><p>        Logic.InteractiveObjectSetPlayerState(eID, _Description.PlayerID or 1, _Description.State);</p><p>        Logic.InteractiveObjectSetRewardResourceCartType(eID, Entities.U_ResourceMerchant);</p><p>        Logic.InteractiveObjectSetRewardGoldCartType(eID, Entities.U_GoldCart);</p><p>        table.insert(HiddenTreasures,eID);</p><p>    end</p><p>-- Löscht ein interaktives Objekt.</p><p>-- Das Entity wird dabei nicht gelöscht. Es wird ausschließlich die</p><p>-- Konfiguration des Objektes entfernt.</p><p>-- @param[type=string] _EntityName Skriptname des IO</p><p>-- @within Internal</p><p>-- @local</p><p>    for k,v in pairs(IO) do</p><p>        if k == _EntityName then</p><p>            Logic.ExecuteInLuaLocalState([[</p><p>                IO["]].._EntityName..[["] = nil;</p><p>            ]]);</p><p>            IO[_EntityName] = nil;</p><p>        end</p><p>    end</p><p>-- Erzeugt eine Beschriftung für Custom Objects.</p><p>-- Im Questfenster werden die Namen von Cusrom Objects als ungesetzt angezeigt.</p><p>-- Mit dieser Funktion kann ein Name angelegt werden.</p><p>-- @param[type=string] _Key Identifier der Beschriftung</p><p>-- @param[type=string] _Text Text der Beschriftung</p><p>-- @within Internal</p><p>-- @local</p><p>    if type(_Text) == "table" then</p><p>        local GermanText  = _Text.de;</p><p>        local EnglishText = _Text.en;</p><p>        Logic.ExecuteInLuaLocalState([[</p><p>            BundleInteractiveObjects.Local.Data.IOCustomNames["]].._Key..[["] = {</p><p>                de = "]]..GermanText..[[",</p><p>                en = "]]..EnglishText..[["</p><p>            }</p><p>        ]]);</p><p>    else</p><p>        Logic.ExecuteInLuaLocalState([[</p><p>            BundleInteractiveObjects.Local.Data.IOCustomNames["]].._Key..[["] = "]].._Text..[["</p><p>        ]]);</p><p>    end</p><p>-- Überschreibt die Events, die ausgelöst werden, wenn interaktive Objekte</p><p>-- benutzt werden.</p><p>-- @within Internal</p><p>-- @local</p><p>    if not BundleInteractiveObjects.Global.Data.InteractionEventHacked then</p><p>        StartSimpleJobEx(BundleInteractiveObjects.Global.ControlInteractiveObjects);</p><p>        BundleInteractiveObjects.Global.Data.InteractionEventHacked = true;</p><p>        OnTreasureFound = function(_TreasureID, _PlayerID)</p><p>            for i=1, #HiddenTreasures do</p><p>                local HiddenTreasureID = HiddenTreasures[i]</p><p>                if HiddenTreasureID == _TreasureID then</p><p>                    Logic.InteractiveObjectSetAvailability(_TreasureID,false)</p><p>                    for PlayerID = 1, 8 do</p><p>                        Logic.InteractiveObjectSetPlayerState(_TreasureID,PlayerID, 2)</p><p>                    end</p><p>                    table.remove(HiddenTreasures,i)</p><p>                    HiddenTreasures[0] = #HiddenTreasures</p><p>                    local ActivationSound = "menu_left_prestige";</p><p>                    local eName = Logic.GetEntityName(_TreasureID);</p><p>                    if IO[eName] and IO[eName].ActivationSound then</p><p>                        ActivationSound = IO[eName].ActivationSound;</p><p>                    end</p><p>                    Logic.ExecuteInLuaLocalState("Play2DSound(" .. _PlayerID ..",'" .. ActivationSound .. "')");</p><p>                end</p><p>            end</p><p>        end</p><p>        GameCallback_OnObjectInteraction = function(__entityID_, _PlayerID)</p><p>            OnInteractiveObjectOpened(__entityID_, _PlayerID);</p><p>            OnTreasureFound(__entityID_, _PlayerID);</p><p>            local eName = Logic.GetEntityName(__entityID_);</p><p>            for k,v in pairs(IO)do</p><p>                if k == eName then</p><p>                    if not v.Used then</p><p>                        IO[k].Used = true;</p><p>                        v.Callback(v, _PlayerID);</p><p>                    end</p><p>                end</p><p>            end</p><p>        end</p><p>        GameCallback_ExecuteCustomObjectReward = function(_PlayerID, _SpawnPos, _Type, _Amount)</p><p>            local pos = GetPosition(_SpawnPos);</p><p>            local resCat = Logic.GetGoodCategoryForGoodType(_Type);</p><p>            local ID;</p><p>            if resCat == GoodCategories.GC_Resource then</p><p>                ID = Logic.CreateEntityOnUnblockedLand(Entities.U_ResourceMerchant, pos.X, pos.Y,0,_PlayerID);</p><p>            elseif _Type == Goods.G_Medicine then</p><p>                ID = Logic.CreateEntityOnUnblockedLand(Entities.U_Medicus, pos.X, pos.Y,0,_PlayerID);</p><p>            elseif _Type == Goods.G_Gold then</p><p>                ID = Logic.CreateEntityOnUnblockedLand(Entities.U_GoldCart, pos.X, pos.Y,0,_PlayerID);</p><p>            else</p><p>                ID = Logic.CreateEntityOnUnblockedLand(Entities.U_Marketer, pos.X, pos.Y,0,_PlayerID);</p><p>            end</p><p>            Logic.HireMerchant(ID,_PlayerID,_Type,_Amount,_PlayerID);</p><p>        end</p><p>        function QuestTemplate:AreObjectsActivated(objectList)</p><p>            for i=1, objectList[0] do</p><p>                if not objectList[-i] then</p><p>                    objectList[-i] = GetEntityId(objectList[i]);</p><p>                end</p><p>                local EntityName = Logic.GetEntityName(objectList[-i]);</p><p>                if Logic.IsInteractiveObject(objectList[-i]) then</p><p>                    if not IsInteractiveObjectOpen(objectList[-i]) then</p><p>                        return false;</p><p>                    end</p><p>                else</p><p>                    if not IO[EntityName] then</p><p>                        return;</p><p>                    end</p><p>                    if IO[EntityName].Used ~= true then</p><p>                        return false;</p><p>                    end</p><p>                end</p><p>            end</p><p>            return true;</p><p>        end</p><p>    end</p><p>-- Prüft für alle unbenutzten interaktiven Objekte, ob ihre Bedingung erfüllt</p><p>-- ist und erlaubt die Benutzung.</p><p>-- @within Internal</p><p>-- @local</p><p>    for k,v in pairs(IO) do</p><p>        if not v.Used == true then</p><p>            v.ConditionFullfilled = v.Condition(v);</p><p>        end</p><p>    end</p><p>-- Local Script ----------------------------------------------------------------</p><p>-- Initalisiert das Bundle im lokalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    IO = Logic.CreateReferenceToTableInGlobaLuaState("IO");</p><p>-- Prüft, ob die Kosten für ein interaktives Objekt beglichen werden können.</p><p>-- @param[type=number] _PlayerID Spieler, der zahlt</p><p>-- @param[type=number] _Good Typ der Ware</p><p>-- @param[type=number] _Amount Menge der Ware</p><p>-- @within Internal</p><p>-- @local</p><p>    local AmountOfGoods = GetPlayerGoodsInSettlement(_Good, _PlayerID, true);</p><p>    if AmountOfGoods  _Amount then</p><p>        return false;</p><p>    end</p><p>    return true;</p><p>-- Zieht die Kosten des Objektes aus dem Lagerhaus des Spielers ab.</p><p>-- @param[type=number] _PlayerID Spieler, der zahlt</p><p>-- @param[type=number] _Good Typ der Ware</p><p>-- @param[type=number] _Amount Menge der Ware</p><p>-- @within Internal</p><p>-- @local</p><p>    if Logic.GetGoodCategoryForGoodType(_Good) ~= GoodCategories.GC_Resource and _Good ~= Goods.G_Gold then</p><p>        local buildings = GetPlayerEntities(_PlayerID,0);</p><p>        local goodAmount = _Amount;</p><p>        for i=1,#buildings do</p><p>            if Logic.IsBuilding(buildings[i]) == 1 and goodAmount  0 then</p><p>                if Logic.GetBuildingProduct(buildings[i]) == _Good then</p><p>                    local goodAmountInBuilding = Logic.GetAmountOnOutStockByIndex(buildings[i],0);</p><p>                    for j=1,goodAmountInBuilding do</p><p>                        API.Bridge("Logic.RemoveGoodFromStock("..buildings[i]..",".._Good..",1)");</p><p>                        goodAmount = goodAmount -1;</p><p>                    end</p><p>                end</p><p>            end</p><p>        end</p><p>    else</p><p>        API.Bridge("AddGood(".._Good..","..(_Amount*(-1))..",".._PlayerID..")");</p><p>    end</p><p>-- Überschreibt die Spielfunktione, die interaktive Objekte steuern.</p><p>-- @within Internal</p><p>-- @local</p><p>    g_Interaction.ActiveObjectsOnScreen = g_Interaction.ActiveObjectsOnScreen or {};</p><p>    g_Interaction.ActiveObjects = g_Interaction.ActiveObjects or {};</p><p>    GUI_Interaction.InteractiveObjectUpdate = function()</p><p>        local PlayerID = GUI.GetPlayerID();</p><p>        if g_Interaction.ActiveObjects == nil then</p><p>            return;</p><p>        end</p><p>        for i = 1, #g_Interaction.ActiveObjects do</p><p>            local ObjectID = g_Interaction.ActiveObjects[i];</p><p>            local X, Y = GUI.GetEntityInfoScreenPosition(ObjectID);</p><p>            local ScreenSizeX, ScreenSizeY = GUI.GetScreenSize();</p><p>            if X ~= 0 and Y ~= 0 and X  -50 and Y  -50 and X  (ScreenSizeX + 50) and Y  (ScreenSizeY + 50) then</p><p>                if Inside(ObjectID, g_Interaction.ActiveObjectsOnScreen) == false then</p><p>                    table.insert(g_Interaction.ActiveObjectsOnScreen, ObjectID);</p><p>                end</p><p>            else</p><p>                for i = 1, #g_Interaction.ActiveObjectsOnScreen do</p><p>                    if g_Interaction.ActiveObjectsOnScreen[i] == ObjectID then</p><p>                        table.remove(g_Interaction.ActiveObjectsOnScreen, i);</p><p>                    end</p><p>                end</p><p>            end</p><p>        end</p><p>        for i = 1, #g_Interaction.ActiveObjectsOnScreen do</p><p>            local Widget = "/InGame/Root/Normal/InteractiveObjects/" .. i;</p><p>            if XGUIEng.IsWidgetExisting(Widget) == 1 then</p><p>                local ObjectID = g_Interaction.ActiveObjectsOnScreen[i];</p><p>                local EntityType = Logic.GetEntityType(ObjectID);</p><p>                local X, Y = GUI.GetEntityInfoScreenPosition(ObjectID);</p><p>                local WidgetSize = {XGUIEng.GetWidgetScreenSize(Widget)};</p><p>                local BaseCosts = {Logic.InteractiveObjectGetCosts(ObjectID)};</p><p>                local EffectiveCosts = {Logic.InteractiveObjectGetEffectiveCosts(ObjectID, PlayerID)};</p><p>                local IsAvailable = Logic.InteractiveObjectGetAvailability(ObjectID);</p><p>                local eType = Logic.GetEntityType(ObjectID);</p><p>                local entityName = Logic.GetEntityName(ObjectID);</p><p>                local eTypeName = Logic.GetEntityTypeName(eType);</p><p>                local Disable = false;</p><p>                XGUIEng.SetWidgetScreenPosition(Widget, X - (WidgetSize[1]/2), Y - (WidgetSize[2]/2));</p><p>                if BaseCosts[1] ~= nil and EffectiveCosts[1] == nil and IsAvailable == true then</p><p>                    Disable = true;</p><p>                end</p><p>                local HasSpace = Logic.InteractiveObjectHasPlayerEnoughSpaceForRewards(ObjectID, PlayerID);</p><p>                if HasSpace == false then</p><p>                    Disable = true;</p><p>                end</p><p>                if Disable == true then</p><p>                    XGUIEng.DisableButton(Widget, 1);</p><p>                else</p><p>                    XGUIEng.DisableButton(Widget, 0);</p><p>                end</p><p>                if GUI_Interaction.InteractiveObjectUpdateEx1 ~= nil then</p><p>                    GUI_Interaction.InteractiveObjectUpdateEx1(Widget, EntityType);</p><p>                end</p><p>                if IO[entityName] then</p><p>                    BundleInteractiveObjects.Local:SetIcon(Widget, IO[entityName].Texture);</p><p>                end</p><p>                XGUIEng.ShowWidget(Widget, 1);</p><p>            end</p><p>        end</p><p>        for k,v in pairs(QSB.IOList) do</p><p>            local pID = GUI.GetPlayerID();</p><p>            local eType = Logic.GetEntityType(GetID(v));</p><p>            local eTypeName = Logic.GetEntityTypeName(eType);</p><p>            if eTypeName and v ~= "" then</p><p>                if  not(string.find(eTypeName,"I_X_")) and not(string.find(eTypeName,"Mine"))</p><p>                and not(string.find(eTypeName,"B_Wel")) and not(string.find(eTypeName,"B_Cis")) then</p><p>                    if IO[v].State == 0 and IO[v].Distance ~= nil and IO[v].Distance  0 then</p><p>                        local knights = {};</p><p>                        Logic.GetKnights(pID,knights);</p><p>                        local found = false;</p><p>                        for i=1,#knights do</p><p>                            if IsNear(knights[i], v, IO[v].Distance) then</p><p>                                found = true;</p><p>                                break;</p><p>                            end</p><p>                        end</p><p>                        if not IO[v].Used and not IO[v].Inactive then</p><p>                            if found then</p><p>                                ScriptCallback_ObjectInteraction(pID,GetID(v));</p><p>                            else</p><p>                                ScriptCallback_CloseObjectInteraction(pID,GetID(v));</p><p>                            end</p><p>                        else</p><p>                            ScriptCallback_CloseObjectInteraction(pID,GetID(v));</p><p>                        end</p><p>                    else</p><p>                        if not IO[v].Used and not IO[v].Inactive then</p><p>                            ScriptCallback_ObjectInteraction(pID,GetID(v));</p><p>                        else</p><p>                            ScriptCallback_CloseObjectInteraction(pID,GetID(v));</p><p>                        end</p><p>                    end</p><p>                end</p><p>            end</p><p>        end</p><p>        for i = #g_Interaction.ActiveObjectsOnScreen + 1, 2 do</p><p>            local Widget = "/InGame/Root/Normal/InteractiveObjects/" .. i;</p><p>            XGUIEng.ShowWidget(Widget, 0);</p><p>        end</p><p>    end</p><p>    GUI_Interaction.InteractiveObjectMouseOver_Orig_BundleInteractiveObjects = GUI_Interaction.InteractiveObjectMouseOver;</p><p>    GUI_Interaction.InteractiveObjectMouseOver = function()</p><p>        local PlayerID = GUI.GetPlayerID();</p><p>        local ButtonNumber = tonumber(XGUIEng.GetWidgetNameByID(XGUIEng.GetCurrentWidgetID()));</p><p>        local ObjectID = g_Interaction.ActiveObjectsOnScreen[ButtonNumber];</p><p>        local EntityType = Logic.GetEntityType(ObjectID);</p><p>        -- Führe für Minen und Brunnen Originalfunction aus</p><p>        if g_GameExtraNo  0 then</p><p>            local EntityTypeName = Logic.GetEntityTypeName(EntityType);</p><p>            if Inside (EntityTypeName, {"R_StoneMine", "R_IronMine", "B_Cistern", "I_X_TradePostConstructionSite"}) then</p><p>                GUI_Interaction.InteractiveObjectMouseOver_Orig_BundleInteractiveObjects();</p><p>                return;</p><p>            end</p><p>        end</p><p>        -- Führe für Ruinen Originalfunktion aus, wenn Skriptname Nummer ist</p><p>        local EntityTypeName = Logic.GetEntityTypeName(EntityType);</p><p>        if string.find(EntityTypeName, "^I_X_") and tonumber(Logic.GetEntityName(ObjectID)) ~= nil then</p><p>            GUI_Interaction.InteractiveObjectMouseOver_Orig_BundleInteractiveObjects();</p><p>            return;</p><p>        end</p><p>        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();</p><p>        local Costs = {Logic.InteractiveObjectGetEffectiveCosts(ObjectID, PlayerID)};</p><p>        local IsAvailable = Logic.InteractiveObjectGetAvailability(ObjectID);</p><p>        local TooltipTextKey;</p><p>        local TooltipDisabledTextKey;</p><p>        local eName = Logic.GetEntityName(ObjectID);</p><p>        if IsAvailable == true then</p><p>           TooltipTextKey = "InteractiveObjectAvailable";</p><p>        else</p><p>           TooltipTextKey = "InteractiveObjectNotAvailable";</p><p>        end</p><p>        if Logic.InteractiveObjectHasPlayerEnoughSpaceForRewards(ObjectID, PlayerID) == false then</p><p>           TooltipDisabledTextKey = "InteractiveObjectAvailableReward";</p><p>        end</p><p>        local CheckSettlement;</p><p>        if Costs and Costs[1] and Logic.GetGoodCategoryForGoodType(Costs[1]) ~= GoodCategories.GC_Resource then</p><p>           CheckSettlement = true;</p><p>        end</p><p>        if IO[eName] and IO[eName].Used ~= true then</p><p>            local title;</p><p>            local text;</p><p>            if IO[eName].Title or IO[eName].Text then</p><p>                title = IO[eName].Title or "";</p><p>                text  = IO[eName].Text or "";</p><p>            end</p><p>            Costs = IO[eName].Costs;</p><p>            if Costs and Costs[1] and Logic.GetGoodCategoryForGoodType(Costs[1]) ~= GoodCategories.GC_Resource then</p><p>                CheckSettlement = true;</p><p>            end</p><p>            BundleInteractiveObjects.Local:TextCosts(title, text, nil, {Costs[1], Costs[2], Costs[3], Costs[4]}, CheckSettlement);</p><p>            return;</p><p>        end</p><p>    end</p><p>    GUI_Interaction.InteractiveObjectClicked_Orig_BundleInteractiveObjects = GUI_Interaction.InteractiveObjectClicked</p><p>    GUI_Interaction.InteractiveObjectClicked = function()</p><p>        local i = tonumber(XGUIEng.GetWidgetNameByID(XGUIEng.GetCurrentWidgetID()));</p><p>        local eID = g_Interaction.ActiveObjectsOnScreen[i];</p><p>        local pID = GUI.GetPlayerID();</p><p>        local EntityType = Logic.GetEntityType(eID);</p><p>        local lang = Network.GetDesiredLanguage();</p><p>        lang = (lang == "de" and lang) or "en";</p><p>        -- Führe für Minen und Brunnen Originalfunction aus</p><p>        if g_GameExtraNo  0 then</p><p>            local EntityTypeName = Logic.GetEntityTypeName(EntityType);</p><p>            if Inside (EntityTypeName, {"R_StoneMine", "R_IronMine", "B_Cistern", "I_X_TradePostConstructionSite"}) then</p><p>                GUI_Interaction.InteractiveObjectClicked_Orig_BundleInteractiveObjects();</p><p>                return;</p><p>            end</p><p>        end</p><p>        -- Führe für Ruinen Originalfunktion aus, wenn Skriptname Nummer ist</p><p>        local EntityTypeName = Logic.GetEntityTypeName(EntityType);</p><p>        if string.find(EntityTypeName, "^I_X_") and tonumber(Logic.GetEntityName(eID)) ~= nil then</p><p>            GUI_Interaction.InteractiveObjectClicked_Orig_BundleInteractiveObjects();</p><p>            return;</p><p>        end</p><p>        for k,v in pairs(IO)do</p><p>            if eID == GetID(k)then</p><p>                local ActivationSound = "menu_left_prestige";</p><p>                if v.ActivationSound then</p><p>                    ActivationSound = v.ActivationSound;</p><p>                end</p><p>                local Reward = {};</p><p>                if IO[k].Reward and IO[k].Reward[1] ~= nil then</p><p>                    table.insert(Reward,IO[k].Reward[1]);</p><p>                    table.insert(Reward,IO[k].Reward[2]);</p><p>                end</p><p>                local space = true;</p><p>                if  Reward[2] and type(Reward[2]) == "number" and Reward[1] ~= Goods.G_Gold</p><p>                and Logic.GetGoodCategoryForGoodType(Reward[1]) == GoodCategories.GC_Resource then</p><p>                    local freeSpace = Logic.GetPlayerUnreservedStorehouseSpace(pID);</p><p>                    if freeSpace  Reward[2] then</p><p>                        space = false;</p><p>                    end</p><p>                end</p><p>                local CheckSettlement;</p><p>                if IO[k].Costs and IO[k].Costs[1] then</p><p>                    if Logic.GetGoodCategoryForGoodType(IO[k].Costs[1]) ~= GoodCategories.GC_Resource then</p><p>                        CheckSettlement = true;</p><p>                    end</p><p>                    -- space</p><p>                    if space == false then</p><p>                        local MessageText = XGUIEng.GetStringTableText("Feedback_TextLines/TextLine_MerchantStorehouseSpace")</p><p>                        Message(MessageText);</p><p>                        return;</p><p>                    end</p><p>                    local Costs = IO[k].Costs;</p><p>                    local CanNotBuyString = XGUIEng.GetStringTableText("Feedback_TextLines/TextLine_NotEnough_Resources");</p><p>                    local CanBuyBoolean = true;</p><p>                    -- costs 1</p><p>                    if Costs[1] then</p><p>                        CanBuyBoolean = CanBuyBoolean and BundleInteractiveObjects.Local:CanBeBought(pID, Costs[1], Costs[2]);</p><p>                    end</p><p>                    -- costs 2</p><p>                    if Costs[3] then</p><p>                        CanBuyBoolean = CanBuyBoolean and BundleInteractiveObjects.Local:CanBeBought(pID, Costs[3], Costs[4]);</p><p>                    end</p><p>                    -- check condition</p><p>                    if not IO[k].ConditionFullfilled then</p><p>                        if IO[k].ConditionUnfulfilled then</p><p>                            local MessageText = IO[k].ConditionUnfulfilled;</p><p>                            if type(MessageText) == "table" then</p><p>                                MessageText = MessageText[lang];</p><p>                            end</p><p>                            Message(MessageText);</p><p>                        end</p><p>                        return;</p><p>                    end</p><p>                    -- check opener</p><p>                    if IO[k].Opener then</p><p>                        if Logic.GetDistanceBetweenEntities(GetID(IO[k].Opener),GetID(k))  IO[k].Distance then</p><p>                            if IO[k].WrongKnight and IO[k].WrongKnight ~= "" then</p><p>                                Message(IO[k].WrongKnight);</p><p>                            end</p><p>                            return;</p><p>                        end</p><p>                    end</p><p>                    if CanBuyBoolean == true then</p><p>                        if Costs[1] ~= nil then</p><p>                            BundleInteractiveObjects.Local:BuyObject(pID, Costs[1], Costs[2]);</p><p>                        end</p><p>                        if Costs[3] ~= nil then</p><p>                            BundleInteractiveObjects.Local:BuyObject(pID, Costs[3], Costs[4]);</p><p>                        end</p><p>                        -- reward</p><p>                        if #Reward  0 then</p><p>                            GUI.SendScriptCommand("GameCallback_ExecuteCustomObjectReward("..pID..",'"..k.."',"..Reward[1]..","..Reward[2]..")");</p><p>                        end</p><p>                        Play2DSound(pID, ActivationSound);</p><p>                        GUI.SendScriptCommand("GameCallback_OnObjectInteraction("..eID..","..pID..")");</p><p>                    else</p><p>                        Message(CanNotBuyString)</p><p>                    end</p><p>                else</p><p>                    -- space</p><p>                    if space == false then</p><p>                        local MessageText = XGUIEng.GetStringTableText("Feedback_TextLines/TextLine_MerchantStorehouseSpace")</p><p>                        Message(MessageText);</p><p>                        return;</p><p>                    end</p><p>                    -- check condition</p><p>                    if not IO[k].ConditionFullfilled then</p><p>                        if IO[k].ConditionUnfulfilled and IO[k].ConditionUnfulfilled ~= "" then</p><p>                            Message(IO[k].ConditionUnfulfilled);</p><p>                        end</p><p>                        return;</p><p>                    end</p><p>                    -- check opener</p><p>                    if IO[k].Opener then</p><p>                        if Logic.GetDistanceBetweenEntities(GetID(IO[k].Opener),GetID(k))  IO[k].Distance then</p><p>                            if IO[k].WrongKnight and IO[k].WrongKnight ~= "" then</p><p>                                Message(IO[k].WrongKnight);</p><p>                            end</p><p>                            return;</p><p>                        end</p><p>                    end</p><p>                    -- reward</p><p>                    if #Reward  0 then</p><p>                        GUI.SendScriptCommand("GameCallback_ExecuteCustomObjectReward("..pID..",'"..k.."',"..Reward[1]..","..Reward[2]..")");</p><p>                    end</p><p>                    Play2DSound(pID, ActivationSound);</p><p>                    GUI.SendScriptCommand("GameCallback_OnObjectInteraction("..eID..","..pID..")");</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>    GUI_Interaction.DisplayQuestObjective_Orig_BundleInteractiveObjects = GUI_Interaction.DisplayQuestObjective</p><p>    GUI_Interaction.DisplayQuestObjective = function(_QuestIndex, _MessageKey)</p><p>        local lang = Network.GetDesiredLanguage();</p><p>        if lang ~= "de" then lang = "en" end</p><p>        local QuestIndexTemp = tonumber(_QuestIndex);</p><p>        if QuestIndexTemp then</p><p>            _QuestIndex = QuestIndexTemp;</p><p>        end</p><p>        local Quest, QuestType = GUI_Interaction.GetPotentialSubQuestAndType(_QuestIndex);</p><p>        local QuestObjectivesPath = "/InGame/Root/Normal/AlignBottomLeft/Message/QuestObjectives";</p><p>        XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomLeft/Message/QuestObjectives", 0);</p><p>        local QuestObjectiveContainer;</p><p>        local QuestTypeCaption;</p><p>        local ParentQuest = Quests[_QuestIndex];</p><p>        local ParentQuestIdentifier;</p><p>        if ParentQuest ~= nil</p><p>        and type(ParentQuest) == "table" then</p><p>            ParentQuestIdentifier = ParentQuest.Identifier;</p><p>        end</p><p>        local HookTable = {};</p><p>        g_CurrentDisplayedQuestID = _QuestIndex;</p><p>        if QuestType == Objective.Object then</p><p>            QuestObjectiveContainer = QuestObjectivesPath .. "/List"</p><p>            QuestTypeCaption = Wrapped_GetStringTableText(_QuestIndex, "UI_Texts/QuestInteraction")</p><p>            local ObjectList = {}</p><p>            for i = 1, Quest.Objectives[1].Data[0] do</p><p>                local ObjectType</p><p>                if Logic.IsEntityDestroyed(Quest.Objectives[1].Data[i]) then</p><p>                    ObjectType = g_Interaction.SavedQuestEntityTypes[_QuestIndex][i]</p><p>                else</p><p>                    ObjectType = Logic.GetEntityType(GetEntityId(Quest.Objectives[1].Data[i]))</p><p>                end</p><p>                local ObjectEntityName = Logic.GetEntityName(Quest.Objectives[1].Data[i]);</p><p>                local ObjectName = ""</p><p>                if ObjectType ~= 0 then</p><p>                    local ObjectTypeName = Logic.GetEntityTypeName(ObjectType)</p><p>                    ObjectName = Wrapped_GetStringTableText(_QuestIndex, "Names/" .. ObjectTypeName)</p><p>                    if ObjectName == "" then</p><p>                        ObjectName = Wrapped_GetStringTableText(_QuestIndex, "UI_ObjectNames/" .. ObjectTypeName)</p><p>                    end</p><p>                    if ObjectName == "" then</p><p>                        ObjectName = BundleInteractiveObjects.Local.Data.IOCustomNames[ObjectTypeName];</p><p>                        if type(ObjectName) == "table" then</p><p>                            local lang = Network.GetDesiredLanguage();</p><p>                            lang = (lang == "de" and "de") or "en";</p><p>                            ObjectName = ObjectName[lang];</p><p>                        end</p><p>                    end</p><p>                    if ObjectName == nil then</p><p>                        ObjectName = BundleInteractiveObjects.Local.Data.IOCustomNames[ObjectEntityName];</p><p>                        if type(ObjectName) == "table" then</p><p>                            local lang = Network.GetDesiredLanguage();</p><p>                            lang = (lang == "de" and "de") or "en";</p><p>                            ObjectName = ObjectName[lang];</p><p>                        end</p><p>                    end</p><p>                    if ObjectName == nil then</p><p>                        ObjectName = "Debug: ObjectName missing for " .. ObjectTypeName</p><p>                    end</p><p>                end</p><p>                table.insert(ObjectList, ObjectName)</p><p>            end</p><p>            for i = 1, 4 do</p><p>                local String = ObjectList[i]</p><p>                if String == nil then</p><p>                    String = ""</p><p>                end</p><p>                XGUIEng.SetText(QuestObjectiveContainer .. "/Entry" .. i, "{center}" .. String)</p><p>            end</p><p>            SetIcon(QuestObjectiveContainer .. "/QuestTypeIcon",{14, 10});</p><p>            XGUIEng.SetText(QuestObjectiveContainer.."/Caption","{center}"..QuestTypeCaption);</p><p>            XGUIEng.ShowWidget(QuestObjectiveContainer, 1);</p><p>        else</p><p>            GUI_Interaction.DisplayQuestObjective_Orig_BundleInteractiveObjects(_QuestIndex, _MessageKey);</p><p>        end</p><p>    end</p><p>-- Setzt den Kostentooltip des aktuellen Widgets.</p><p>-- @param[type=string]  _Title Titel des Tooltip</p><p>-- @param[type=string]  _Text Text des Tooltip</p><p>-- @param[type=string]  _DisabledText (optional) Textzusatz wenn inaktiv</p><p>-- @param[type=table]   _Costs Kostentabelle</p><p>-- @param[type=boolean] _InSettlement Kosten in Siedlung suchen</p><p>-- @within Internal</p><p>-- @local</p><p>    local TooltipContainerPath = "/InGame/Root/Normal/TooltipBuy"</p><p>    local TooltipContainer = XGUIEng.GetWidgetID(TooltipContainerPath)</p><p>    local TooltipNameWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Name")</p><p>    local TooltipDescriptionWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Text")</p><p>    local TooltipBGWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/BG")</p><p>    local TooltipFadeInContainer = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn")</p><p>    local TooltipCostsContainer = XGUIEng.GetWidgetID(TooltipContainerPath .. "/Costs")</p><p>    local PositionWidget = XGUIEng.GetCurrentWidgetID()</p><p>    GUI_Tooltip.ResizeBG(TooltipBGWidget, TooltipDescriptionWidget)</p><p>    GUI_Tooltip.SetCosts(TooltipCostsContainer, _Costs, _InSettlement)</p><p>    local TooltipContainerSizeWidgets = {TooltipContainer, TooltipCostsContainer, TooltipBGWidget}</p><p>    GUI_Tooltip.SetPosition(TooltipContainer, TooltipContainerSizeWidgets, PositionWidget, nil, true)</p><p>    GUI_Tooltip.OrderTooltip(TooltipContainerSizeWidgets, TooltipFadeInContainer, TooltipCostsContainer, PositionWidget, TooltipBGWidget)</p><p>    GUI_Tooltip.FadeInTooltip(TooltipFadeInContainer)</p><p>    _DisabledText = _DisabledText or "";</p><p>    local disabled = ""</p><p>    if XGUIEng.IsButtonDisabled(PositionWidget) == 1 and _DisabledText ~= "" and _Text ~= "" then</p><p>        disabled = disabled .. "{cr}{@color:255,32,32,255}" .. _DisabledText</p><p>    end</p><p>    XGUIEng.SetText(TooltipNameWidget, "{center}" .. _Title)</p><p>    XGUIEng.SetText(TooltipDescriptionWidget, _Text .. disabled)</p><p>    local Height = XGUIEng.GetTextHeight(TooltipDescriptionWidget, true)</p><p>    local W, H = XGUIEng.GetWidgetSize(TooltipDescriptionWidget)</p><p>    XGUIEng.SetWidgetSize(TooltipDescriptionWidget, W, Height)</p><p>-- Ändert die Textur eines Icons des aktuellen Widget.</p><p>-- TODO: Eigene Matrizen funktionieren nicht - Grund unbekannt.</p><p>-- @param[type=string] _Widget Icon Widget</p><p>-- @param              _Icon Icon Textur (Dateiname oder Positionsmatrix)</p><p>-- @within Internal</p><p>-- @local</p><p>    if type(_Icon) == "table" then</p><p>        if type(_Icon[3]) == "string" then</p><p>            local ButtonState = 1;</p><p>            if XGUIEng.IsButton(_Widget) == 1 then</p><p>                ButtonState = 7;</p><p>            end</p><p>            local u0, u1, v0, v1;</p><p>            u0 = (_Icon[1] - 1) * 64;</p><p>            v0 = (_Icon[2] - 1) * 64;</p><p>            u1 = (_Icon[1]) * 64;</p><p>            v1 = (_Icon[2]) * 64;</p><p>            XGUIEng.SetMaterialAlpha(_Widget, ButtonState, 255);</p><p>            XGUIEng.SetMaterialTexture(_Widget, ButtonState, _Icon[3].. "big.png");</p><p>            XGUIEng.SetMaterialUV(_Widget, ButtonState, u0, v0, u1, v1);</p><p>        else</p><p>            SetIcon(_Widget, _Icon);</p><p>        end</p><p>    else</p><p>        local screenSize = {GUI.GetScreenSize()};</p><p>        local Scale = 330;</p><p>        if screenSize[2] = 800 then</p><p>            Scale = 260;</p><p>        end</p><p>        if screenSize[2] = 1000 then</p><p>            Scale = 210;</p><p>        end</p><p>        XGUIEng.SetMaterialAlpha(_Widget, 1, 255);</p><p>        XGUIEng.SetMaterialTexture(_Widget, 1, _file);</p><p>        XGUIEng.SetMaterialUV(_Widget, 1, 0, 0, Scale, Scale);</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der Spieler muss bis zu 4 interaktive Objekte benutzen.</p><p>-- @param[type=string] _ScriptName1 Erstes Objekt</p><p>-- @param[type=string] _ScriptName2 (optional) Zweites Objekt</p><p>-- @param[type=string] _ScriptName3 (optional) Drittes Objekt</p><p>-- @param[type=string] _ScriptName4 (optional) Viertes Objekt</p><p>-- @within Goal</p><p>    return b_Goal_ActivateSeveralObjects:new(...);</p><p>Goal_ActivateSeveralObjects</p><p>    Name = "Goal_ActivateSeveralObjects",</p><p>    Description = {</p><p>        en = "Goal: Activate an interactive object",</p><p>        de = "Ziel: Aktiviere ein interaktives Objekt",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Default, en = "Object name 1", de = "Skriptname 1" },</p><p>        { ParameterType.Default, en = "Object name 2", de = "Skriptname 2" },</p><p>        { ParameterType.Default, en = "Object name 3", de = "Skriptname 3" },</p><p>        { ParameterType.Default, en = "Object name 4", de = "Skriptname 4" },</p><p>    },</p><p>    ScriptNames = {};</p><p>    return {Objective.Object, { unpack(self.ScriptNames) } }</p><p>    if _Index == 0 then</p><p>        assert(_Parameter ~= nil and _Parameter ~= "", "Goal_ActivateSeveralObjects: At least one IO needed!");</p><p>    end</p><p>    if _Parameter ~= nil and _Parameter ~= "" then</p><p>        table.insert(self.ScriptNames, _Parameter);</p><p>    end</p><p>    return "Quest_Object_Activate"</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundleinterfaceapperance.lua.html">
            <div class='doclink'>
                <div>BundleInterfaceApperance</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia BundleInterfaceApperance                                     # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Dieses Bundle bietet dem Nutzer Funktionen zur Manipulation der Oberfläche</p><p>-- des Spiels. Der Mapper hat die Möglichkeit, eigene Texte und Grafiken im</p><p>-- Interface anzuzeigen.</p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Setzt eine Grafik als Bild für einen Icon oder einen Button.</p><p>-- Die Größe des Bildes ist auf 200x200 Pixel festgelegt. Es kann an jedem</p><p>-- beliebigen Ort im interen Verzeichnis oder auf der Festplatte liegen. Es</p><p>-- muss jedoch immer der korrekte Pfad angegeben werden.</p><p>--  Es kann vorkommen, dass das Bild nicht genau da ist, wo es</p><p>-- sein soll, sondern seine Position, je nach Auflösung, um ein paar Pixel</p><p>-- unterschiedlich ist.</p><p>-- @param[type=string] _widget Widgetpfad oder ID</p><p>-- @param[type=string] _file Pfad zur Datei</p><p>-- @within Anwenderfunktionen</p><p>function API.InterfaceSetTexture(_widget, _file)</p><p>    if not GUI then</p><p>        return;</p><p>    end</p><p>    BundleInterfaceApperance.Local:SetTexture(_widget, _file)</p><p>-- Setzt einen Icon aus einer benutzerdefinierten Icon Matrix.</p><p>-- Dabei müssen die Quellen nach gui_768, gui_920 und gui_1080 in der</p><p>-- entsprechenden Größe gepackt werden. Die Ordner liegen in graphics/textures.</p><p>-- Jede Map muss einen eigenen eindeutigen Namen für jede Grafik verwenden.</p><p>-- </p><p>-- Die Gesamtgröße ergibt sich aus der Anzahl der Buttons und der Pixelbreite</p><p>-- für die jeweilige Grö0e. z.B. 64 Buttons - Größe * 8 x Größe * 8</p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- Die Namenskonvention wird durch das Spiel vorgegeben. Je nach Größe sind</p><p>-- die Namen der Matrizen erweitert mit .png, big.png und verybig.png. Du</p><p>-- gibst also niemals die Dateiendung mit an!</p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- @param[type=string] _WidgetID Widgetpfad oder ID</p><p>-- @param[type=table]  _Coordinates Koordinaten</p><p>-- @param[type=number] _Size Größe des Icon</p><p>-- @param[type=string] _Name Name der Icon Matrix</p><p>-- @within Anwenderfunktionen</p><p>function API.InterfaceSetIcon(_WidgetID, _Coordinates, _Size, _Name)</p><p>    if not GUI then</p><p>        return;</p><p>    end</p><p>    BundleInterfaceApperance.Local:SetIcon(_WidgetID, _Coordinates, _Size, _Name)</p><p>-- Ändert den aktuellen Tooltip mit der Beschreibung.</p><p>-- </p><p>-- Die Funtion ermittelt das aktuelle GUI Widget und ändert den Text des</p><p>-- Tooltip. Dazu muss die Funktion innerhalb der Mouseover-Funktion eines</p><p>-- Buttons oder Widgets mit Tooltip aufgerufen werden.</p><p>-- Die Funktion kann auch mit deutsch/english lokalisierten Tabellen als</p><p>-- Text gefüttert werden. In diesem Fall wird der deutsche Text genommen,</p><p>-- wenn es sich um eine deutsche Spielversion handelt. Andernfalls wird</p><p>-- immer der englische Text verwendet.</p><p>-- @param[type=string] _title        Titel des Tooltip</p><p>-- @param[type=string] _text         Text des Tooltip</p><p>-- @param[type=string] _disabledText Textzusatz wenn inaktiv</p><p>-- @within Anwenderfunktionen</p><p>function API.InterfaceSetTooltipNormal(_title, _text, _disabledText)</p><p>    if not GUI then</p><p>        return;</p><p>    end</p><p>    BundleInterfaceApperance.Local:TextNormal(_title, _text, _disabledText);</p><p>-- Ändert den aktuellen Tooltip mit der Beschreibung und den Kosten.</p><p>-- </p><p>-- @see API.InterfaceSetTooltipNormal</p><p>-- @param[type=string]  _title        Titel des Tooltip</p><p>-- @param[type=string]  _text         Text des Tooltip</p><p>-- @param[type=string]  _disabledText Textzusatz wenn inaktiv</p><p>-- @param[type=table]   _costs        Kostentabelle</p><p>-- @param[type=boolean] _inSettlement Kosten in Siedlung suchen</p><p>-- @within Anwenderfunktionen</p><p>function API.InterfaceSetTooltipCosts(_title,_text,_disabledText,_costs,_inSettlement)</p><p>    if not GUI then</p><p>        return;</p><p>    end</p><p>    BundleInterfaceApperance.Local:TextCosts(_title,_text,_disabledText,_costs,_inSettlement);</p><p>-- Gibt den Namen des Territoriums zurück.</p><p>-- </p><p>-- @param[type=number] _TerritoryID ID des Territoriums</p><p>-- @return[type=string]  Name des Territorium</p><p>-- @within Anwenderfunktionen</p><p>function API.InterfaceGetTerritoryName(_TerritoryID)</p><p>    local Name = Logic.GetTerritoryName(_TerritoryID);</p><p>    local MapType = Framework.GetCurrentMapTypeAndCampaignName();</p><p>    if MapType == 1 or MapType == 3 then</p><p>        return Name;</p><p>    end</p><p>    local MapName = Framework.GetCurrentMapName();</p><p>    local StringTable = "Map_" .. MapName;</p><p>    local TerritoryName = string.gsub(Name, " ","");</p><p>    TerritoryName = XGUIEng.GetStringTableText(StringTable .. "/Territory_" .. TerritoryName);</p><p>    if TerritoryName == "" then</p><p>        TerritoryName = Name .. "(key?)";</p><p>    end</p><p>    return TerritoryName;</p><p>-- Gibt den Namen des Spielers zurück.</p><p>-- </p><p>-- @param[type=number] _PlayerID ID des Spielers</p><p>-- @return[type=string]  Name des Spielers</p><p>-- @within Anwenderfunktionen</p><p>function API.InterfaceGetPlayerName(_PlayerID)</p><p>    local PlayerName = Logic.GetPlayerName(_PlayerID);</p><p>    local name = QSB.PlayerNames[_PlayerID];</p><p>    if name ~= nil and name ~= "" then</p><p>        PlayerName = name;</p><p>    end</p><p>    local MapType = Framework.GetCurrentMapTypeAndCampaignName();</p><p>    local MutliplayerMode = Framework.GetMultiplayerMapMode(Framework.GetCurrentMapName(), MapType);</p><p>    if MutliplayerMode  0 then</p><p>        return PlayerName;</p><p>    end</p><p>    if MapType == 1 or MapType == 3 then</p><p>        local PlayerNameTmp, PlayerHeadTmp, PlayerAITmp = Framework.GetPlayerInfo(_PlayerID);</p><p>        if PlayerName ~= "" then</p><p>            return PlayerName;</p><p>        end</p><p>        return PlayerNameTmp;</p><p>    end</p><p>-- Gibt dem Spieler einen neuen Namen.</p><p>-- </p><p>-- @param[type=number] _playerID ID des Spielers</p><p>-- @param[type=string] _name Name des Spielers</p><p>-- @within Anwenderfunktionen</p><p>function API.InterfaceSetPlayerName(_playerID,_name)</p><p>    assert(type(_playerID) == "number");</p><p>    assert(type(_name) == "string");</p><p>    if not GUI then</p><p>        Logic.ExecuteInLuaLocalState("SetPlayerName(".._playerID..",'".._name.."')");</p><p>    else</p><p>        GUI_MissionStatistic.PlayerNames[_playerID] = _name;</p><p>        GUI.SendScriptCommand("QSB.PlayerNames[".._playerID.."] = '".._name.."'");</p><p>    end</p><p>    QSB.PlayerNames[_playerID] = _name;</p><p>-- Setzt zu Spielbeginn eine andere Spielerfarbe.</p><p>-- @param[type=number] _PlayerID ID des Spielers</p><p>-- @param[type=number] _Color Spielerfarbe</p><p>-- @param[type=number] _Logo Logo (optional)</p><p>-- @param[type=number] _Pattern Pattern (optional)</p><p>-- @within Anwenderfunktionen</p><p>function API.InterfaceSetPlayerColor(_PlayerID, _Color, _Logo, _Pattern)</p><p>    if GUI then</p><p>        return;</p><p>    end</p><p>    g_ColorIndex["ExtraColor1"] = 16;</p><p>    g_ColorIndex["ExtraColor2"] = 17;</p><p>    local Type    = type(_Color);</p><p>    local Col     = (type(_Color) == "string" and g_ColorIndex[_Color]) or _Color;</p><p>    local Logo    = _Logo or -1;</p><p>    local Pattern = _Pattern or -1;</p><p>    StartSimpleJobEx( function(Col, _PlayerID, _Logo, _Pattern)</p><p>        Logic.PlayerSetPlayerColor(_PlayerID, Col, _Logo, _Pattern);</p><p>        return true;</p><p>    end, Col, _PlayerID, Logo, Pattern);</p><p>-- Setzt das Portrait des Spielers.</p><p>-- Dabei gibt es 3 verschiedene Varianten:</p><p>-- </p><p>-- Wenn _Portrait nicht gesetzt wird, wird das Portrait des Primary</p><p>-- Knight genommen.</p><p>-- Wenn _Portrait ein existierendes Entity ist, wird anhand des Typs</p><p>-- das Portrait bestimmt.</p><p>-- Wenn _Portrait der Modellname eines Portrait ist, wird der Wert</p><p>-- als Portrait gesetzt.</p><p>-- </p><p>-- Wenn kein Portrait bestimmt werden kann, wird H_NPC_Generic_Trader verwendet.</p><p>-- @param[type=number] _PlayerID ID des Spielers</p><p>-- @param[type=string] _Portrait Name des Models</p><p>-- @within Anwenderfunktionen</p><p>-- @usage -- Primary Knight</p><p>-- API.InterfaceSetPlayerPortrait(2);</p><p>-- -- Durch Entity</p><p>-- API.InterfaceSetPlayerPortrait(2, "amma");</p><p>-- -- Durch Modelname</p><p>-- API.InterfaceSetPlayerPortrait(2, "H_NPC_Monk_AS");</p><p>function API.InterfaceSetPlayerPortrait(_PlayerID, _Portrait)</p><p>    if not _PlayerID or type(_PlayerID) ~= "number" or (_PlayerID  8) then</p><p>        API.Fatal("API.InterfaceSetPlayerPortrait: Invalid player ID!");</p><p>        return;</p><p>    end</p><p>    if not GUI then</p><p>        local Portrait = (_Portrait ~= nil and "'" .._Portrait.. "'") or "nil";</p><p>        API.Bridge("API.InterfaceSetPlayerPortrait(" .._PlayerID.. ", " ..Portrait.. ")")</p><p>        return;</p><p>    end</p><p>    </p><p>    if _Portrait == nil then</p><p>        BundleInterfaceApperance.Local:SetPlayerPortraitByPrimaryKnight(_PlayerID);</p><p>        return;</p><p>    end</p><p>    if _Portrait ~= nil and IsExisting(_Portrait) then</p><p>        BundleInterfaceApperance.Local:SetPlayerPortraitBySettler(_PlayerID, _Portrait);</p><p>        return;</p><p>    end</p><p>    BundleInterfaceApperance.Local:SetPlayerPortraitByModelName(_PlayerID, _Portrait);</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {},</p><p>    Local = {}</p><p>-- Local Script ----------------------------------------------------------------</p><p>-- Initialisiert das Bundle im lokalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    StartMissionGoodOrEntityCounter = function(_Icon, _AmountToReach)</p><p>        if type(_Icon) == "string" then</p><p>            BundleInterfaceApperance.Local:SetTexture("/InGame/Root/Normal/MissionGoodOrEntityCounter/Icon", _Icon);</p><p>        else</p><p>            if type(_Icon[3]) == "string" then</p><p>                BundleInterfaceApperance.Local:SetIcon("/InGame/Root/Normal/MissionGoodOrEntityCounter/Icon", _Icon, 64, _Icon[3]);</p><p>            else</p><p>                SetIcon("/InGame/Root/Normal/MissionGoodOrEntityCounter/Icon", _Icon);</p><p>            end</p><p>        end</p><p>        g_MissionGoodOrEntityCounterAmountToReach = _AmountToReach;</p><p>        g_MissionGoodOrEntityCounterIcon = _Icon;</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/MissionGoodOrEntityCounter", 1);</p><p>    end</p><p>-- Setzt das Portrait des Spielers anhand des Primary Knight.</p><p>-- @param[type=number] _PlayerID ID des Spielers</p><p>-- @within Internal</p><p>-- @local</p><p>    local KnightID = Logic.GetKnightID(_PlayerID);</p><p>    if KnightID == 0 then</p><p>        return;</p><p>    end</p><p>    local KnightType = Logic.GetEntityType(KnightID);</p><p>    local KnightTypeName = Logic.GetEntityTypeName(KnightType);</p><p>    local HeadModelName = "H" .. string.sub(KnightTypeName, 2, 8) .. "_" .. string.sub(KnightTypeName, 9);</p><p>    if not Models["Heads_" .. HeadModelName] then</p><p>        HeadModelName = "H_NPC_Generic_Trader";</p><p>    end</p><p>    g_PlayerPortrait[_PlayerID] = HeadModelName;</p><p>-- Setzt das Portrait des Spielers anhand der übergebenen Script Entity.</p><p>-- @param[type=number] _PlayerID ID des Spielers</p><p>-- @param[type=string] _Portrait Skriptname des Entity</p><p>-- @within Internal</p><p>-- @local</p><p>    local PortraitMap = {</p><p>        ["U_KnightChivalry"]           = "H_Knight_Chivalry",</p><p>        ["U_KnightHealing"]            = "H_Knight_Healing",</p><p>        ["U_KnightPlunder"]            = "H_Knight_Plunder",</p><p>        ["U_KnightRedPrince"]          = "H_Knight_RedPrince",</p><p>        ["U_KnightSabatta"]            = "H_Knight_Sabatt",</p><p>        ["U_KnightSong"]               = "H_Knight_Song",</p><p>        ["U_KnightTrading"]            = "H_Knight_Trading",</p><p>        ["U_KnightWisdom"]             = "H_Knight_Wisdom",</p><p>        ["U_NPC_Amma_NE"]              = "H_NPC_Amma",</p><p>        ["U_NPC_Castellan_ME"]         = "H_NPC_Castellan_ME",</p><p>        ["U_NPC_Castellan_NA"]         = "H_NPC_Castellan_NA",</p><p>        ["U_NPC_Castellan_NE"]         = "H_NPC_Castellan_NE",</p><p>        ["U_NPC_Castellan_SE"]         = "H_NPC_Castellan_SE",</p><p>        ["U_MilitaryBandit_Ranged_ME"] = "H_NPC_Mercenary_ME",</p><p>        ["U_MilitaryBandit_Melee_NA"]  = "H_NPC_Mercenary_NA",</p><p>        ["U_MilitaryBandit_Melee_NE"]  = "H_NPC_Mercenary_NE",</p><p>        ["U_MilitaryBandit_Melee_SE"]  = "H_NPC_Mercenary_SE",</p><p>        ["U_NPC_Monk_ME"]              = "H_NPC_Monk_ME",</p><p>        ["U_NPC_Monk_NA"]              = "H_NPC_Monk_NA",</p><p>        ["U_NPC_Monk_NE"]              = "H_NPC_Monk_NE",</p><p>        ["U_NPC_Monk_SE"]              = "H_NPC_Monk_SE",</p><p>        ["U_NPC_Villager01_ME"]        = "H_NPC_Villager01_ME",</p><p>        ["U_NPC_Villager01_NA"]        = "H_NPC_Villager01_NA",</p><p>        ["U_NPC_Villager01_NE"]        = "H_NPC_Villager01_NE",</p><p>        ["U_NPC_Villager01_SE"]        = "H_NPC_Villager01_SE",</p><p>    }</p><p>    if g_GameExtraNo  0 then</p><p>        PortraitMap["U_KnightPraphat"]           = "H_Knight_Praphat";</p><p>        PortraitMap["U_KnightSaraya"]            = "H_Knight_Saraya";</p><p>        PortraitMap["U_KnightKhana"]             = "H_Knight_Khana";</p><p>        PortraitMap["U_MilitaryBandit_Melee_AS"] = "H_NPC_Mercenary_AS";</p><p>        PortraitMap["U_NPC_Castellan_AS"]        = "H_NPC_Castellan_AS";</p><p>        PortraitMap["U_NPC_Villager_AS"]         = "H_NPC_Villager_AS";</p><p>        PortraitMap["U_NPC_Monk_AS"]             = "H_NPC_Monk_AS";</p><p>        PortraitMap["U_NPC_Monk_Khana"]          = "H_NPC_Monk_Khana";</p><p>    end</p><p>    local HeadModelName = "H_NPC_Generic_Trader";</p><p>    local EntityID = GetID(_Portrait);</p><p>    if EntityID ~= 0 then</p><p>        local EntityType = Logic.GetEntityType(EntityID);</p><p>        local EntityTypeName = Logic.GetEntityTypeName(EntityType);</p><p>        HeadModelName = PortraitMap[EntityTypeName] or "H_NPC_Generic_Trader";</p><p>        if not HeadModelName then</p><p>            HeadModelName = "H_NPC_Generic_Trader";</p><p>        end</p><p>    end</p><p>    g_PlayerPortrait[_PlayerID] = HeadModelName;</p><p>-- Setzt das Portrait des Spielers anhand des angegebenen Models.</p><p>-- @param[type=number] _PlayerID ID des Spielers</p><p>-- @param[type=string] _Portrait Name des Models</p><p>-- @within Internal</p><p>-- @local</p><p>    if not Models["Heads_" .. tostring(_Portrait)] then</p><p>        _Portrait = "H_NPC_Generic_Trader";</p><p>    end</p><p>    g_PlayerPortrait[_PlayerID] = _Portrait;</p><p>-- Setzt einen Icon aus einer benutzerdefinerten Datei.</p><p>-- @param[type=string] _widget Widgetpfad oder ID</p><p>-- @param[type=string] _file Pfad zur Datei</p><p>-- @within Internal</p><p>-- @local</p><p>    assert((type(_widget) == "string" or type(_widget) == "number"));</p><p>    local wID = (type(_widget) == "string" and XGUIEng.GetWidgetID(_widget)) or _widget;</p><p>    local screenSize = {GUI.GetScreenSize()};</p><p>    local state = 1;</p><p>    if XGUIEng.IsButton(wID) == 1 then</p><p>        state = 7;</p><p>    end</p><p>    local Scale = 330;</p><p>    if screenSize[2] = 800 then</p><p>        Scale = 260;</p><p>    end</p><p>    if screenSize[2] = 1000 then</p><p>        Scale = 210;</p><p>    end</p><p>    XGUIEng.SetMaterialAlpha(wID, state, 255);</p><p>    XGUIEng.SetMaterialTexture(wID, state, _file);</p><p>    XGUIEng.SetMaterialUV(wID, state, 0, 0, Scale, Scale);</p><p>-- Setzt einen Icon aus einer benutzerdefinierten Matrix.</p><p>-- @param[type=string] _WidgetID Widgetpfad oder ID</p><p>-- @param[type=table]  _Coordinates Koordinaten</p><p>-- @param[type=number] _Size Größe des Icon</p><p>-- @param[type=string] _Name Name der Icon Matrix</p><p>-- @within Internal</p><p>-- @local</p><p>    if _Name == nil then</p><p>        _Name = "usericons";</p><p>    end</p><p>    if _Size == nil then</p><p>        _Size = 64;</p><p>    end</p><p>    if _Size == 44 then</p><p>        _Name = _Name .. ".png"</p><p>    end</p><p>    if _Size == 64 then</p><p>        _Name = _Name .. "big.png"</p><p>    end</p><p>    if _Size == 128 then</p><p>        _Name = _Name .. "verybig.png"</p><p>    end</p><p>    local u0, u1, v0, v1;</p><p>    u0 = (_Coordinates[1] - 1) * _Size;</p><p>    v0 = (_Coordinates[2] - 1) * _Size;</p><p>    u1 = (_Coordinates[1]) * _Size;</p><p>    v1 = (_Coordinates[2]) * _Size;</p><p>    State = 1;</p><p>    if XGUIEng.IsButton(_WidgetID) == 1 then</p><p>        State = 7;</p><p>    end</p><p>    XGUIEng.SetMaterialAlpha(_WidgetID, State, 255);</p><p>    XGUIEng.SetMaterialTexture(_WidgetID, State, _Name);</p><p>    XGUIEng.SetMaterialUV(_WidgetID, State, u0, v0, u1, v1);</p><p>-- Setzt einen Beschreibungstooltip.</p><p>-- @param[type=string] _title        Titel des Tooltip</p><p>-- @param[type=string] _text         Text des Tooltip</p><p>-- @param[type=string] _disabledText Textzusatz wenn inaktiv</p><p>-- @within Internal</p><p>-- @local</p><p>    local lang = Network.GetDesiredLanguage()</p><p>    if lang ~= "de" then lang = "en" end</p><p>    if type(_title) == "table" then</p><p>        _title = _title[lang];</p><p>    end</p><p>    if type(_text) == "table" then</p><p>        _text = _text[lang];</p><p>    end</p><p>    _text = _text or "";</p><p>    if type(_disabledText) == "table" then</p><p>        _disabledText = _disabledText[lang];</p><p>    end</p><p>    local TooltipContainerPath = "/InGame/Root/Normal/TooltipNormal"</p><p>    local TooltipContainer = XGUIEng.GetWidgetID(TooltipContainerPath)</p><p>    local TooltipNameWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Name")</p><p>    local TooltipDescriptionWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Text")</p><p>    local TooltipBGWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/BG")</p><p>    local TooltipFadeInContainer = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn")</p><p>    local PositionWidget = XGUIEng.GetCurrentWidgetID()</p><p>    GUI_Tooltip.ResizeBG(TooltipBGWidget, TooltipDescriptionWidget)</p><p>    local TooltipContainerSizeWidgets = {TooltipBGWidget}</p><p>    GUI_Tooltip.SetPosition(TooltipContainer, TooltipContainerSizeWidgets, PositionWidget)</p><p>    GUI_Tooltip.FadeInTooltip(TooltipFadeInContainer)</p><p>    _disabledText = _disabledText or "";</p><p>    local disabled = "";</p><p>    if XGUIEng.IsButtonDisabled(PositionWidget) == 1 and _disabledText ~= "" and _text ~= "" then</p><p>        disabled = disabled .. "{cr}{@color:255,32,32,255}" .. _disabledText</p><p>    end</p><p>    XGUIEng.SetText(TooltipNameWidget, "{center}" .. _title)</p><p>    XGUIEng.SetText(TooltipDescriptionWidget, _text .. disabled)</p><p>    local Height = XGUIEng.GetTextHeight(TooltipDescriptionWidget, true)</p><p>    local W, H = XGUIEng.GetWidgetSize(TooltipDescriptionWidget)</p><p>    XGUIEng.SetWidgetSize(TooltipDescriptionWidget, W, Height)</p><p>-- Setzt den Kostentooltip.</p><p>-- @param[type=string]  _title        Titel des Tooltip</p><p>-- @param[type=string]  _text         Text des Tooltip</p><p>-- @param[type=string]  _disabledText Textzusatz wenn inaktiv</p><p>-- @param[type=table]   _costs        Kostentabelle</p><p>-- @param[type=boolean] _inSettlement Kosten in Siedlung suchen</p><p>-- @within Internal</p><p>-- @local</p><p>    local lang = Network.GetDesiredLanguage()</p><p>    if lang ~= "de" then lang = "en" end</p><p>    _costs = _costs or {};</p><p>    if type(_title) == "table" then</p><p>        _title = _title[lang];</p><p>    end</p><p>    if type(_text) == "table" then</p><p>        _text = _text[lang];</p><p>    end</p><p>    _text = _text or "";</p><p>    if type(_disabledText) == "table" then</p><p>        _disabledText = _disabledText[lang];</p><p>    end</p><p>    local TooltipContainerPath = "/InGame/Root/Normal/TooltipBuy"</p><p>    local TooltipContainer = XGUIEng.GetWidgetID(TooltipContainerPath)</p><p>    local TooltipNameWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Name")</p><p>    local TooltipDescriptionWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Text")</p><p>    local TooltipBGWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/BG")</p><p>    local TooltipFadeInContainer = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn")</p><p>    local TooltipCostsContainer = XGUIEng.GetWidgetID(TooltipContainerPath .. "/Costs")</p><p>    local PositionWidget = XGUIEng.GetCurrentWidgetID()</p><p>    GUI_Tooltip.ResizeBG(TooltipBGWidget, TooltipDescriptionWidget)</p><p>    GUI_Tooltip.SetCosts(TooltipCostsContainer, _costs, _inSettlement)</p><p>    local TooltipContainerSizeWidgets = {TooltipContainer, TooltipCostsContainer, TooltipBGWidget}</p><p>    GUI_Tooltip.SetPosition(TooltipContainer, TooltipContainerSizeWidgets, PositionWidget, nil, true)</p><p>    GUI_Tooltip.OrderTooltip(TooltipContainerSizeWidgets, TooltipFadeInContainer, TooltipCostsContainer, PositionWidget, TooltipBGWidget)</p><p>    GUI_Tooltip.FadeInTooltip(TooltipFadeInContainer)</p><p>    _disabledText = _disabledText or "";</p><p>    local disabled = ""</p><p>    if XGUIEng.IsButtonDisabled(PositionWidget) == 1 and _disabledText ~= "" and _text ~= "" then</p><p>        disabled = disabled .. "{cr}{@color:255,32,32,255}" .. _disabledText</p><p>    end</p><p>    XGUIEng.SetText(TooltipNameWidget, "{center}" .. _title)</p><p>    XGUIEng.SetText(TooltipDescriptionWidget, _text .. disabled)</p><p>    local Height = XGUIEng.GetTextHeight(TooltipDescriptionWidget, true)</p><p>    local W, H = XGUIEng.GetWidgetSize(TooltipDescriptionWidget)</p><p>    XGUIEng.SetWidgetSize(TooltipDescriptionWidget, W, Height)</p><p>-- -------------------------------------------------------------------------- --</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundleinterfacefeaturevisibility.lua.html">
            <div class='doclink'>
                <div>BundleInterfaceFeatureVisibility</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia BundleInterfaceFeatureVisibility                             # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Dieses Bundle bietet dem Nutzer Funktionen um ausgewählte Buttons und</p><p>-- Widgets auszublenden oder einzublenden. Auf diese Weise können dem Spieler</p><p>-- Funktionalitäten vorenthalten werden.</p><p>-- </p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Graut die Minimap aus oder macht sie wieder verwendbar.</p><p>--  Diese Änderung bleibt auch nach dem Laden eines Spielstandes</p><p>-- aktiv und muss explizit zurückgenommen werden!</p><p>-- @param[type=boolean] _Flag Widget versteckt</p><p>-- @within Anwenderfunktionen</p><p>function API.InterfaceHideMinimap(_Flag)</p><p>    if not GUI then</p><p>        Logic.ExecuteInLuaLocalState("API.InterfaceHideMinimap(" ..tostring(_Flag).. ")");</p><p>        return;</p><p>    end</p><p>    BundleInterfaceFeatureVisibility.Local:HideInterfaceButton(</p><p>        "/InGame/Root/Normal/AlignBottomRight/MapFrame/Minimap/MinimapOverlay",</p><p>        _Flag</p><p>    );</p><p>    BundleInterfaceFeatureVisibility.Local:HideInterfaceButton(</p><p>        "/InGame/Root/Normal/AlignBottomRight/MapFrame/Minimap/MinimapTerrain",</p><p>        _Flag</p><p>    );</p><p>-- Versteckt den Umschaltknopf der Minimap oder blendet ihn ein.</p><p>--  Diese Änderung bleibt auch nach dem Laden eines Spielstandes</p><p>-- aktiv und muss explizit zurückgenommen werden!</p><p>-- @param[type=boolean] _Flag Widget versteckt</p><p>-- @within Anwenderfunktionen</p><p>function API.InterfaceHideToggleMinimap(_Flag)</p><p>    if not GUI then</p><p>        Logic.ExecuteInLuaLocalState("API.InterfaceHideToggleMinimap(" ..tostring(_Flag).. ")");</p><p>        return;</p><p>    end</p><p>    BundleInterfaceFeatureVisibility.Local:HideInterfaceButton(</p><p>        "/InGame/Root/Normal/AlignBottomRight/MapFrame/MinimapButton",</p><p>        _Flag</p><p>    );</p><p>-- Versteckt den Button des Diplomatiemenü oder blendet ihn ein.</p><p>--  Diese Änderung bleibt auch nach dem Laden eines Spielstandes</p><p>-- aktiv und muss explizit zurückgenommen werden!</p><p>-- @param[type=boolean] _Flag Widget versteckt</p><p>-- @within Anwenderfunktionen</p><p>function API.InterfaceHideDiplomacyMenu(_Flag)</p><p>    if not GUI then</p><p>        Logic.ExecuteInLuaLocalState("API.InterfaceHideDiplomacyMenu(" ..tostring(_Flag).. ")");</p><p>        return;</p><p>    end</p><p>    BundleInterfaceFeatureVisibility.Local:HideInterfaceButton(</p><p>        "/InGame/Root/Normal/AlignBottomRight/MapFrame/DiplomacyMenuButton",</p><p>        _Flag</p><p>    );</p><p>-- Versteckt den Button des Produktionsmenü oder blendet ihn ein.</p><p>--  Diese Änderung bleibt auch nach dem Laden eines Spielstandes</p><p>-- aktiv und muss explizit zurückgenommen werden!</p><p>-- @param[type=boolean] _Flag Widget versteckt</p><p>-- @within Anwenderfunktionen</p><p>function API.InterfaceHideProductionMenu(_Flag)</p><p>    if not GUI then</p><p>        Logic.ExecuteInLuaLocalState("API.InterfaceHideProductionMenu(" ..tostring(_Flag).. ")");</p><p>        return;</p><p>    end</p><p>    BundleInterfaceFeatureVisibility.Local:HideInterfaceButton(</p><p>        "/InGame/Root/Normal/AlignBottomRight/MapFrame/ProductionMenuButton",</p><p>        _Flag</p><p>    );</p><p>-- Versteckt den Button des Wettermenüs oder blendet ihn ein.</p><p>--  Diese Änderung bleibt auch nach dem Laden eines Spielstandes</p><p>-- aktiv und muss explizit zurückgenommen werden!</p><p>-- @param[type=boolean] _Flag Widget versteckt</p><p>-- @within Anwenderfunktionen</p><p>function API.InterfaceHideWeatherMenu(_Flag)</p><p>    if not GUI then</p><p>        Logic.ExecuteInLuaLocalState("API.InterfaceHideWeatherMenu(" ..tostring(_Flag).. ")");</p><p>        return;</p><p>    end</p><p>    BundleInterfaceFeatureVisibility.Local:HideInterfaceButton(</p><p>        "/InGame/Root/Normal/AlignBottomRight/MapFrame/WeatherMenuButton",</p><p>        _Flag</p><p>    );</p><p>-- Versteckt den Button zum Territorienkauf oder blendet ihn ein.</p><p>--  Diese Änderung bleibt auch nach dem Laden eines Spielstandes</p><p>-- aktiv und muss explizit zurückgenommen werden!</p><p>-- @param[type=boolean] _Flag Widget versteckt</p><p>-- @within Anwenderfunktionen</p><p>function API.InterfaceHideBuyTerritory(_Flag)</p><p>    if not GUI then</p><p>        Logic.ExecuteInLuaLocalState("API.InterfaceHideBuyTerritory(" ..tostring(_Flag).. ")");</p><p>        return;</p><p>    end</p><p>    BundleInterfaceFeatureVisibility.Local:HideInterfaceButton(</p><p>        "/InGame/Root/Normal/AlignBottomRight/DialogButtons/Knight/ClaimTerritory",</p><p>        _Flag</p><p>    );</p><p>-- Versteckt den Button der Heldenfähigkeit oder blendet ihn ein.</p><p>--  Diese Änderung bleibt auch nach dem Laden eines Spielstandes</p><p>-- aktiv und muss explizit zurückgenommen werden!</p><p>-- @param[type=boolean] _Flag Widget versteckt</p><p>-- @within Anwenderfunktionen</p><p>function API.InterfaceHideKnightAbility(_Flag)</p><p>    if not GUI then</p><p>        Logic.ExecuteInLuaLocalState("API.InterfaceHideKnightAbility(" ..tostring(_Flag).. ")");</p><p>        return;</p><p>    end</p><p>    BundleInterfaceFeatureVisibility.Local:HideInterfaceButton(</p><p>        "/InGame/Root/Normal/AlignBottomRight/DialogButtons/Knight/StartAbilityProgress",</p><p>        _Flag</p><p>    );</p><p>    BundleInterfaceFeatureVisibility.Local:HideInterfaceButton(</p><p>        "/InGame/Root/Normal/AlignBottomRight/DialogButtons/Knight/StartAbility",</p><p>        _Flag</p><p>    );</p><p>-- Versteckt den Button zur Heldenselektion oder blendet ihn ein.</p><p>--  Diese Änderung bleibt auch nach dem Laden eines Spielstandes</p><p>-- aktiv und muss explizit zurückgenommen werden!</p><p>-- @param[type=boolean] _Flag Widget versteckt</p><p>-- @within Anwenderfunktionen</p><p>function API.InterfaceHideKnightButton(_Flag)</p><p>    if not GUI then</p><p>        Logic.ExecuteInLuaLocalState("API.InterfaceHideKnightButton(" ..tostring(_Flag).. ")");</p><p>        return;</p><p>    end</p><p>    local KnightID = Logic.GetKnightID(GUI.GetPlayerID());</p><p>    if _Flag == true then</p><p>        GUI.SendScriptCommand("Logic.SetEntitySelectableFlag("..KnightID..", 0)");</p><p>        GUI.DeselectEntity(KnightID);</p><p>    else</p><p>        GUI.SendScriptCommand("Logic.SetEntitySelectableFlag("..KnightID..", 1)");</p><p>    end</p><p>    BundleInterfaceFeatureVisibility.Local:HideInterfaceButton(</p><p>        "/InGame/Root/Normal/AlignBottomRight/MapFrame/KnightButtonProgress",</p><p>        _Flag</p><p>    );</p><p>    BundleInterfaceFeatureVisibility.Local:HideInterfaceButton(</p><p>        "/InGame/Root/Normal/AlignBottomRight/MapFrame/KnightButton",</p><p>        _Flag</p><p>    );</p><p>-- Versteckt den Button zur Selektion des Militärs oder blendet ihn ein.</p><p>--  Diese Änderung bleibt auch nach dem Laden eines Spielstandes</p><p>-- aktiv und muss explizit zurückgenommen werden!</p><p>-- @param[type=boolean] _Flag Widget versteckt</p><p>-- @within Anwenderfunktionen</p><p>function API.InterfaceHideSelectionButton(_Flag)</p><p>    if not GUI then</p><p>        Logic.ExecuteInLuaLocalState("API.InterfaceHideSelectionButton(" ..tostring(_Flag).. ")");</p><p>        return;</p><p>    end</p><p>    API.InterfaceHideKnightButton(_Flag);</p><p>    GUI.ClearSelection();</p><p>    BundleInterfaceFeatureVisibility.Local:HideInterfaceButton(</p><p>        "/InGame/Root/Normal/AlignBottomRight/MapFrame/BattalionButton",</p><p>        _Flag</p><p>    );</p><p>-- Versteckt das Baumenü oder blendet es ein.</p><p>--  Diese Änderung bleibt auch nach dem Laden eines Spielstandes</p><p>-- aktiv und muss explizit zurückgenommen werden!</p><p>-- @param[type=boolean] _Flag Widget versteckt</p><p>-- @within Anwenderfunktionen</p><p>function API.InterfaceHideBuildMenu(_Flag)</p><p>    if not GUI then</p><p>        Logic.ExecuteInLuaLocalState("API.InterfaceHideBuildMenu(" ..tostring(_Flag).. ")");</p><p>        return;</p><p>    end</p><p>    BundleInterfaceFeatureVisibility.Local:HideInterfaceButton(</p><p>        "/InGame/Root/Normal/AlignBottomRight/BuildMenu",</p><p>        _Flag</p><p>    );</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {},</p><p>    Local = {</p><p>        Data = {</p><p>            HiddenWidgets = {},</p><p>        },</p><p>    }</p><p>-- Global Script ---------------------------------------------------------------</p><p>-- Initialisiert das Bundle im globalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    API.AddSaveGameAction(BundleInterfaceFeatureVisibility.Global.RestoreAfterLoad);</p><p>-- Stellt alle versteckten Buttons nach dem Laden eines Spielstandes wieder her.</p><p>-- @within Internal</p><p>-- @local</p><p>    Logic.ExecuteInLuaLocalState([[</p><p>        BundleInterfaceFeatureVisibility.Local:RestoreAfterLoad();</p><p>    ]]);</p><p>-- Local Script ----------------------------------------------------------------</p><p>-- Initialisiert das Bundle im lokalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    Core:StackFunction("GUI_Knight.ClaimTerritoryUpdate", self.UpdateClaimTerritory);</p><p>-- Versteht ein Widget oder blendet es ein.</p><p>-- @param _Widget [string|number] Widgetpfad oder ID</p><p>-- @param _Hide [boolean] Hidden Flag</p><p>-- @within Internal</p><p>-- @local</p><p>    self.Data.HiddenWidgets[_Widget] = _Hide == true;</p><p>    XGUIEng.ShowWidget(_Widget, (_Hide == true and 0) or 1);</p><p>-- Stellt alle versteckten Buttons nach dem Laden eines Spielstandes wieder her.</p><p>-- @within Internal</p><p>-- @local</p><p>    for k, v in pairs(self.Data.HiddenWidgets) do</p><p>        if v then</p><p>            XGUIEng.ShowWidget(k, 0);</p><p>        end</p><p>    end</p><p>-- Versteckt den Claim-Territory-Button.</p><p>-- @within Internal</p><p>-- @local</p><p>    local Key = "/InGame/Root/Normal/AlignBottomRight/DialogButtons/Knight/ClaimTerritory";</p><p>    if BundleInterfaceFeatureVisibility.Local.Data.HiddenWidgets[Key] == true then</p><p>        XGUIEng.ShowWidget(Key, 0);</p><p>        return true;</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundleknighttitlerequirements.lua.html">
            <div class='doclink'>
                <div>BundleKnightTitleRequirements</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia BundleKnightTitleRequirements                                # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Erlaubt es dem Mapper die vorgegebenen Aufstiegsbedingungen idividuell</p><p>-- an die eigenen Vorstellungen anzupassen.</p><p>-- Die Aufstiegsbedingungen werden in der Funktion InitKnightTitleTables</p><p>-- angegeben und bearbeitet.</p><p>-- </p><p>-- Mögliche Aufstiegsbedingungen:</p><p>-- </p><p>-- </p><p>-- Der Spieler muss eine bestimmte Anzahl von Entities eines Typs besitzen.</p><p>-- </p><p>-- KnightTitleRequirements[KnightTitles.Mayor].Entities = {</p><p>--     {Entities.B_Bakery, 2},</p><p>--     ...</p><p>-- }</p><p>-- </p><p>-- </p><p>-- </p><p>-- Der Spieler muss eine bestimmte Anzahl von Entities einer Kategorie besitzen.</p><p>-- </p><p>-- KnightTitleRequirements[KnightTitles.Mayor].Category = {</p><p>--     {EntitiyCategories.CattlePasture, 10},</p><p>--     ...</p><p>-- }</p><p>-- </p><p>-- </p><p>-- </p><p>-- Der Spieler muss Rohstoffe oder Güter eines Typs besitzen.</p><p>-- </p><p>-- KnightTitleRequirements[KnightTitles.Mayor].Goods = {</p><p>--     {Goods.G_RawFish, 35},</p><p>--     ...</p><p>-- }</p><p>-- </p><p>-- </p><p>-- </p><p>-- Der Spieler muss Gebrauchsgegenstände für ein Bedürfnis bereitstellen.</p><p>-- </p><p>-- KnightTitleRequirements[KnightTitles.Mayor].Products = {</p><p>--     {GoodCategories.GC_Clothes, 6},</p><p>--     ...</p><p>-- }</p><p>-- </p><p>-- </p><p>-- </p><p>-- Die Siedler müssen eine Menge einer bestimmten Waren konsumieren.</p><p>-- </p><p>-- KnightTitleRequirements[KnightTitles.Mayor].Consume = {</p><p>--     {Goods.G_Bread, 30},</p><p>--     ...</p><p>-- }</p><p>-- </p><p>-- </p><p>-- </p><p>-- Der Spieler muss einen Vielfältigkeits-Buff aktivieren.</p><p>-- </p><p>-- KnightTitleRequirements[KnightTitles.Mayor].Buff = {</p><p>--     Buffs.Buff_FoodDiversity,</p><p>--     ...</p><p>-- }</p><p>-- </p><p>-- </p><p>-- </p><p>-- Der Ruf der Stadt muss einen bestimmten Wert erreichen oder überschreiten.</p><p>-- </p><p>-- KnightTitleRequirements[KnightTitles.Mayor].Reputation = 20</p><p>-- </p><p>-- </p><p>-- Der Spieler muss mindestens die Anzahl der angegebenen Dekoration besitzen.</p><p>-- </p><p>-- KnightTitleRequirements[KnightTitles.Mayor].DecoratedBuildings = {</p><p>--     {Goods.G_Banner, 9 },</p><p>-- }</p><p>-- </p><p>-- </p><p>-- </p><p>-- Anzahl an Gebäuden, an die alle vier Dekorationen angebracht sein müssen.</p><p>-- </p><p>-- KnightTitleRequirements[KnightTitles.Mayor].FullDecoratedBuildings = 12</p><p>-- </p><p>-- </p><p>-- </p><p>-- Ein Spezielgebäude muss ausgebaut werden.</p><p>-- </p><p>-- KnightTitleRequirements[KnightTitles.Mayor].Headquarters = 1</p><p>-- KnightTitleRequirements[KnightTitles.Mayor].Storehouse = 1</p><p>-- KnightTitleRequirements[KnightTitles.Mayor].Cathedrals = 1</p><p>-- </p><p>-- </p><p>-- </p><p>-- Der Spieler benötigt eine Gesamtzahl an Siedlern.</p><p>-- </p><p>-- KnightTitleRequirements[KnightTitles.Mayor].Settlers = 40</p><p>-- </p><p>-- </p><p>-- </p><p>-- Eine Anzahl an Gebäuden muss durch Einnahmen Reichtum erlangen.</p><p>-- </p><p>-- KnightTitleRequirements[KnightTitles.Mayor].RichBuildings = 30</p><p>-- </p><p>-- </p><p>-- </p><p>-- Eine benutzerdefinierte Funktion, die entweder als Schalter oder als Zähler</p><p>-- fungieren kann und true oder false zurückgeben muss.</p><p>-- </p><p>-- KnightTitleRequirements[KnightTitles.Mayor].Custom = {</p><p>--     {SomeFunction, {1, 1}, "Überschrift", "Beschreibung"}</p><p>-- }</p><p>-- </p><p>-- </p><p>-- </p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {},</p><p>    Local = {</p><p>        Data = {},</p><p>    }</p><p>-- Global Script ---------------------------------------------------------------</p><p>-- Installiert das Bundle im globalen Skript.</p><p>-- @within BundleKnightTitleRequirements</p><p>-- @local</p><p>    self:OverwriteConsumedGoods();</p><p>-- Zählt den Konsumzähler rauf, sobald eine Ware konsumiert wird.</p><p>-- @param[type=number] _PlayerID ID des Spielers</p><p>-- @param[type=number] _Good Warentyp</p><p>-- @within BundleKnightTitleRequirements</p><p>-- @local</p><p>    QSB.ConsumedGoodsCounter[_PlayerID]        = QSB.ConsumedGoodsCounter[_PlayerID] or {};</p><p>    QSB.ConsumedGoodsCounter[_PlayerID][_Good] = QSB.ConsumedGoodsCounter[_PlayerID][_Good] or 0;</p><p>    QSB.ConsumedGoodsCounter[_PlayerID][_Good] = QSB.ConsumedGoodsCounter[_PlayerID][_Good] +1;</p><p>-- Überschreibt GameCallback_ConsumeGood, sodass konsumierte Waren gezählt</p><p>-- werden können.</p><p>-- @within BundleKnightTitleRequirements</p><p>-- @local</p><p>    GameCallback_ConsumeGood_Orig_QSB_Requirements = GameCallback_ConsumeGood</p><p>    GameCallback_ConsumeGood = function(_Consumer, _Good, _Building)</p><p>        GameCallback_ConsumeGood_Orig_QSB_Requirements(_Consumer, _Good, _Building)</p><p>        local PlayerID = Logic.EntityGetPlayer(_Consumer);</p><p>        BundleKnightTitleRequirements.Global:RegisterConsumedGoods(PlayerID, _Good);</p><p>        Logic.ExecuteInLuaLocalState([[</p><p>            BundleKnightTitleRequirements.Local:RegisterConsumedGoods(</p><p>                ]] ..PlayerID.. [[, ]] .._Good.. [[</p><p>            );</p><p>        ]]);</p><p>    end</p><p>-- Local Script ----------------------------------------------------------------</p><p>-- Installiert das Bundle im lokalen Skript.</p><p>-- @within BundleKnightTitleRequirements</p><p>-- @local</p><p>    self:OverwriteTooltips();</p><p>    self:InitTexturePositions();</p><p>    self:OverwriteUpdateRequirements();</p><p>    self:OverwritePromotionCelebration();</p><p>-- Zählt den Konsumzähler rauf, sobald eine Ware konsumiert wird.</p><p>-- @param[type=number] _PlayerID ID des Spielers</p><p>-- @param[type=number] _Good Warentyp</p><p>-- @within BundleKnightTitleRequirements</p><p>-- @local</p><p>    QSB.ConsumedGoodsCounter[_PlayerID]        = QSB.ConsumedGoodsCounter[_PlayerID] or {};</p><p>    QSB.ConsumedGoodsCounter[_PlayerID][_Good] = QSB.ConsumedGoodsCounter[_PlayerID][_Good] or 0;</p><p>    QSB.ConsumedGoodsCounter[_PlayerID][_Good] = QSB.ConsumedGoodsCounter[_PlayerID][_Good] +1;</p><p>-- Fügt einige weitere Einträge zu den Texturpositionen hinzu.</p><p>-- @within BundleKnightTitleRequirements</p><p>-- @local</p><p>    g_TexturePositions.EntityCategories[EntityCategories.GC_Food_Supplier]          = { 1, 1};</p><p>    g_TexturePositions.EntityCategories[EntityCategories.GC_Clothes_Supplier]       = { 1, 2};</p><p>    g_TexturePositions.EntityCategories[EntityCategories.GC_Hygiene_Supplier]       = {16, 1};</p><p>    g_TexturePositions.EntityCategories[EntityCategories.GC_Entertainment_Supplier] = { 1, 4};</p><p>    g_TexturePositions.EntityCategories[EntityCategories.GC_Luxury_Supplier]        = {16, 3};</p><p>    g_TexturePositions.EntityCategories[EntityCategories.GC_Weapon_Supplier]        = { 1, 7};</p><p>    g_TexturePositions.EntityCategories[EntityCategories.GC_Medicine_Supplier]      = { 2,10};</p><p>    g_TexturePositions.EntityCategories[EntityCategories.Outpost]                   = {12, 3};</p><p>    g_TexturePositions.EntityCategories[EntityCategories.Spouse]                    = { 5,15};</p><p>    g_TexturePositions.EntityCategories[EntityCategories.CattlePasture]             = { 3,16};</p><p>    g_TexturePositions.EntityCategories[EntityCategories.SheepPasture]              = { 4, 1};</p><p>    g_TexturePositions.EntityCategories[EntityCategories.Soldier]                   = { 7,12};</p><p>    g_TexturePositions.EntityCategories[EntityCategories.GrainField]                = {14, 2};</p><p>    g_TexturePositions.EntityCategories[EntityCategories.OuterRimBuilding]          = { 3, 4};</p><p>    g_TexturePositions.EntityCategories[EntityCategories.CityBuilding]              = { 8, 1};</p><p>    g_TexturePositions.EntityCategories[EntityCategories.Leader]                    = { 7, 11};</p><p>    g_TexturePositions.EntityCategories[EntityCategories.Range]                     = { 9, 8};</p><p>    g_TexturePositions.EntityCategories[EntityCategories.Melee]                     = { 9, 7};</p><p>    g_TexturePositions.EntityCategories[EntityCategories.SiegeEngine]               = { 2,15};</p><p>    g_TexturePositions.Entities[Entities.B_Outpost]                                 = {12, 3};</p><p>    g_TexturePositions.Entities[Entities.B_Outpost_AS]                              = {12, 3};</p><p>    g_TexturePositions.Entities[Entities.B_Outpost_ME]                              = {12, 3};</p><p>    g_TexturePositions.Entities[Entities.B_Outpost_NA]                              = {12, 3};</p><p>    g_TexturePositions.Entities[Entities.B_Outpost_NE]                              = {12, 3};</p><p>    g_TexturePositions.Entities[Entities.B_Outpost_SE]                              = {12, 3};</p><p>    g_TexturePositions.Entities[Entities.B_Cathedral_Big]                           = { 3,12};</p><p>    g_TexturePositions.Entities[Entities.U_MilitaryBallista]                        = {10, 5};</p><p>    g_TexturePositions.Entities[Entities.U_Trebuchet]                               = { 9, 1};</p><p>    g_TexturePositions.Entities[Entities.U_SiegeEngineCart]                         = { 9, 4};</p><p>    g_TexturePositions.Needs[Needs.Medicine]                                        = { 2,10};</p><p>    g_TexturePositions.Technologies[Technologies.R_Castle_Upgrade_1]                = { 4, 7};</p><p>    g_TexturePositions.Technologies[Technologies.R_Castle_Upgrade_2]                = { 4, 7};</p><p>    g_TexturePositions.Technologies[Technologies.R_Castle_Upgrade_3]                = { 4, 7};</p><p>    g_TexturePositions.Technologies[Technologies.R_Cathedral_Upgrade_1]             = { 4, 5};</p><p>    g_TexturePositions.Technologies[Technologies.R_Cathedral_Upgrade_2]             = { 4, 5};</p><p>    g_TexturePositions.Technologies[Technologies.R_Cathedral_Upgrade_3]             = { 4, 5};</p><p>    g_TexturePositions.Technologies[Technologies.R_Storehouse_Upgrade_1]            = { 4, 6};</p><p>    g_TexturePositions.Technologies[Technologies.R_Storehouse_Upgrade_2]            = { 4, 6};</p><p>    g_TexturePositions.Technologies[Technologies.R_Storehouse_Upgrade_3]            = { 4, 6};</p><p>    g_TexturePositions.Buffs = g_TexturePositions.Buffs or {};</p><p>    g_TexturePositions.Buffs[Buffs.Buff_ClothesDiversity]                           = { 1, 2};</p><p>    g_TexturePositions.Buffs[Buffs.Buff_EntertainmentDiversity]                     = { 1, 4};</p><p>    g_TexturePositions.Buffs[Buffs.Buff_FoodDiversity]                              = { 1, 1};</p><p>    g_TexturePositions.Buffs[Buffs.Buff_HygieneDiversity]                           = { 1, 3};</p><p>    g_TexturePositions.Buffs[Buffs.Buff_Colour]                                     = { 5,11};</p><p>    g_TexturePositions.Buffs[Buffs.Buff_Entertainers]                               = { 5,12};</p><p>    g_TexturePositions.Buffs[Buffs.Buff_ExtraPayment]                               = { 1, 8};</p><p>    g_TexturePositions.Buffs[Buffs.Buff_Sermon]                                     = { 4,14};</p><p>    g_TexturePositions.Buffs[Buffs.Buff_Spice]                                      = { 5,10};</p><p>    g_TexturePositions.Buffs[Buffs.Buff_NoTaxes]                                    = { 1, 6};</p><p>    if Framework.GetGameExtraNo() ~= 0 then</p><p>        g_TexturePositions.Buffs[Buffs.Buff_Gems]                                   = { 1, 1, 1};</p><p>        g_TexturePositions.Buffs[Buffs.Buff_MusicalInstrument]                      = { 1, 3, 1};</p><p>        g_TexturePositions.Buffs[Buffs.Buff_Olibanum]                               = { 1, 2, 1};</p><p>    end</p><p>    g_TexturePositions.GoodCategories = g_TexturePositions.GoodCategories or {};</p><p>    g_TexturePositions.GoodCategories[GoodCategories.GC_Ammunition]                 = {10, 6};</p><p>    g_TexturePositions.GoodCategories[GoodCategories.GC_Animal]                     = { 4,16};</p><p>    g_TexturePositions.GoodCategories[GoodCategories.GC_Clothes]                    = { 1, 2};</p><p>    g_TexturePositions.GoodCategories[GoodCategories.GC_Document]                   = { 5, 6};</p><p>    g_TexturePositions.GoodCategories[GoodCategories.GC_Entertainment]              = { 1, 4};</p><p>    g_TexturePositions.GoodCategories[GoodCategories.GC_Food]                       = { 1, 1};</p><p>    g_TexturePositions.GoodCategories[GoodCategories.GC_Gold]                       = { 1, 8};</p><p>    g_TexturePositions.GoodCategories[GoodCategories.GC_Hygiene]                    = {16, 1};</p><p>    g_TexturePositions.GoodCategories[GoodCategories.GC_Luxury]                     = {16, 3};</p><p>    g_TexturePositions.GoodCategories[GoodCategories.GC_Medicine]                   = { 2,10};</p><p>    g_TexturePositions.GoodCategories[GoodCategories.GC_None]                       = {15,16};</p><p>    g_TexturePositions.GoodCategories[GoodCategories.GC_RawFood]                    = { 3, 4};</p><p>    g_TexturePositions.GoodCategories[GoodCategories.GC_RawMedicine]                = { 2, 2};</p><p>    g_TexturePositions.GoodCategories[GoodCategories.GC_Research]                   = { 5, 6};</p><p>    g_TexturePositions.GoodCategories[GoodCategories.GC_Resource]                   = { 3, 4};</p><p>    g_TexturePositions.GoodCategories[GoodCategories.GC_Tools]                      = { 4,12};</p><p>    g_TexturePositions.GoodCategories[GoodCategories.GC_Water]                      = { 1,16};</p><p>    g_TexturePositions.GoodCategories[GoodCategories.GC_Weapon]                     = { 8, 5};</p><p>-- Überschreibt die Aktualisierungsfunktion der Aufstiegsbedingungen.</p><p>-- @within BundleKnightTitleRequirements</p><p>-- @local</p><p>    GUI_Knight.UpdateRequirements = function()</p><p>        local WidgetPos = BundleKnightTitleRequirements.Local.Data.RequirementWidgets;</p><p>        local RequirementsIndex = 1;</p><p>        local PlayerID = GUI.GetPlayerID();</p><p>        local CurrentTitle = Logic.GetKnightTitle(PlayerID);</p><p>        local NextTitle = CurrentTitle + 1;</p><p>        --Headline</p><p>        local KnightID = Logic.GetKnightID(PlayerID);</p><p>        local KnightType = Logic.GetEntityType(KnightID);</p><p>        XGUIEng.SetText("/InGame/Root/Normal/AlignBottomRight/KnightTitleMenu/NextKnightTitle", "{center}" .. GUI_Knight.GetTitleNameByTitleID(KnightType, NextTitle));</p><p>        XGUIEng.SetText("/InGame/Root/Normal/AlignBottomRight/KnightTitleMenu/NextKnightTitleWhite", "{center}" .. GUI_Knight.GetTitleNameByTitleID(KnightType, NextTitle));</p><p>        -- show Settlers</p><p>        if KnightTitleRequirements[NextTitle].Settlers ~= nil then</p><p>            SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", {5,16})</p><p>            local IsFulfilled, CurrentAmount, NeededAmount = DoesNeededNumberOfSettlersForKnightTitleExist(PlayerID, NextTitle)</p><p>            XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount)</p><p>            if IsFulfilled then</p><p>                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1)</p><p>            else</p><p>                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0)</p><p>            end</p><p>            XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1)</p><p>            QSB.RequirementTooltipTypes[RequirementsIndex] = "Settlers";</p><p>            RequirementsIndex = RequirementsIndex +1;</p><p>        end</p><p>        -- show rich buildings</p><p>        if KnightTitleRequirements[NextTitle].RichBuildings ~= nil then</p><p>            SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", {8,4});</p><p>            local IsFulfilled, CurrentAmount, NeededAmount = DoNeededNumberOfRichBuildingsForKnightTitleExist(PlayerID, NextTitle);</p><p>            if NeededAmount == -1 then</p><p>                NeededAmount = Logic.GetNumberOfPlayerEntitiesInCategory(PlayerID, EntityCategories.CityBuilding);</p><p>            end</p><p>            XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);</p><p>            if IsFulfilled then</p><p>                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);</p><p>            else</p><p>                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);</p><p>            end</p><p>            XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);</p><p>            QSB.RequirementTooltipTypes[RequirementsIndex] = "RichBuildings";</p><p>            RequirementsIndex = RequirementsIndex +1;</p><p>        end</p><p>        -- Castle</p><p>        if KnightTitleRequirements[NextTitle].Headquarters ~= nil then</p><p>            SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", {4,7});</p><p>            local IsFulfilled, CurrentAmount, NeededAmount = DoNeededSpecialBuildingUpgradeForKnightTitleExist(PlayerID, NextTitle, EntityCategories.Headquarters);</p><p>            XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount + 1 .. "/" .. NeededAmount + 1);</p><p>            if IsFulfilled then</p><p>                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);</p><p>            else</p><p>                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);</p><p>            end</p><p>            XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);</p><p>            QSB.RequirementTooltipTypes[RequirementsIndex] = "Headquarters";</p><p>            RequirementsIndex = RequirementsIndex +1;</p><p>        end</p><p>        -- Storehouse</p><p>        if KnightTitleRequirements[NextTitle].Storehouse ~= nil then</p><p>            SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", {4,6});</p><p>            local IsFulfilled, CurrentAmount, NeededAmount = DoNeededSpecialBuildingUpgradeForKnightTitleExist(PlayerID, NextTitle, EntityCategories.Storehouse);</p><p>            XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount + 1 .. "/" .. NeededAmount + 1);</p><p>            if IsFulfilled then</p><p>                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);</p><p>            else</p><p>                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);</p><p>            end</p><p>            XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);</p><p>            QSB.RequirementTooltipTypes[RequirementsIndex] = "Storehouse";</p><p>            RequirementsIndex = RequirementsIndex +1;</p><p>        end</p><p>        -- Cathedral</p><p>        if KnightTitleRequirements[NextTitle].Cathedrals ~= nil then</p><p>            SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", {4,5});</p><p>            local IsFulfilled, CurrentAmount, NeededAmount = DoNeededSpecialBuildingUpgradeForKnightTitleExist(PlayerID, NextTitle, EntityCategories.Cathedrals);</p><p>            XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount + 1 .. "/" .. NeededAmount + 1);</p><p>            if IsFulfilled then</p><p>                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);</p><p>            else</p><p>                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);</p><p>            end</p><p>            XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);</p><p>            QSB.RequirementTooltipTypes[RequirementsIndex] = "Cathedrals";</p><p>            RequirementsIndex = RequirementsIndex +1;</p><p>        end</p><p>        -- Neue Bedingungen --------------------------------------------</p><p>        -- Volldekorierte Gebäude</p><p>        if KnightTitleRequirements[NextTitle].FullDecoratedBuildings ~= nil then</p><p>            local IsFulfilled, CurrentAmount, NeededAmount = DoNeededNumberOfFullDecoratedBuildingsForKnightTitleExist(PlayerID, NextTitle);</p><p>            local EntityCategory = KnightTitleRequirements[NextTitle].FullDecoratedBuildings;</p><p>            SetIcon(WidgetPos[RequirementsIndex].."/Icon"  , g_TexturePositions.Needs[Needs.Wealth]);</p><p>            XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);</p><p>            if IsFulfilled then</p><p>                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);</p><p>            else</p><p>                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);</p><p>            end</p><p>            XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] , 1);</p><p>            QSB.RequirementTooltipTypes[RequirementsIndex] = "FullDecoratedBuildings";</p><p>            RequirementsIndex = RequirementsIndex +1;</p><p>        end</p><p>        -- Stadtruf</p><p>        if KnightTitleRequirements[NextTitle].Reputation ~= nil then</p><p>            SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", {5,14});</p><p>            local IsFulfilled, CurrentAmount, NeededAmount = DoesNeededCityReputationForKnightTitleExist(PlayerID, NextTitle);</p><p>            XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);</p><p>            if IsFulfilled then</p><p>                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);</p><p>            else</p><p>                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);</p><p>            end</p><p>            XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);</p><p>            QSB.RequirementTooltipTypes[RequirementsIndex] = "Reputation";</p><p>            RequirementsIndex = RequirementsIndex +1;</p><p>        end</p><p>        -- Güter sammeln</p><p>        if KnightTitleRequirements[NextTitle].Goods ~= nil then</p><p>            for i=1, #KnightTitleRequirements[NextTitle].Goods do</p><p>                local GoodType = KnightTitleRequirements[NextTitle].Goods[i][1];</p><p>                SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", g_TexturePositions.Goods[GoodType]);</p><p>                local IsFulfilled, CurrentAmount, NeededAmount = DoesNeededNumberOfGoodTypesForKnightTitleExist(PlayerID, NextTitle, i);</p><p>                XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);</p><p>                if IsFulfilled then</p><p>                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);</p><p>                else</p><p>                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);</p><p>                end</p><p>                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);</p><p>                QSB.RequirementTooltipTypes[RequirementsIndex] = "Goods" .. i;</p><p>                RequirementsIndex = RequirementsIndex +1;</p><p>            end</p><p>        end</p><p>        -- Kategorien</p><p>        if KnightTitleRequirements[NextTitle].Category ~= nil then</p><p>            for i=1, #KnightTitleRequirements[NextTitle].Category do</p><p>                local Category = KnightTitleRequirements[NextTitle].Category[i][1];</p><p>                SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", g_TexturePositions.EntityCategories[Category]);</p><p>                local IsFulfilled, CurrentAmount, NeededAmount = DoesNeededNumberOfEntitiesInCategoryForKnightTitleExist(PlayerID, NextTitle, i);</p><p>                XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);</p><p>                if IsFulfilled then</p><p>                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);</p><p>                else</p><p>                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);</p><p>                end</p><p>                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);</p><p>                local EntitiesInCategory = {Logic.GetEntityTypesInCategory(Category)};</p><p>                if Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.GC_Weapon_Supplier) == 1 then</p><p>                    QSB.RequirementTooltipTypes[RequirementsIndex] = "Weapons" .. i;</p><p>                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.SiegeEngine) == 1 then</p><p>                    QSB.RequirementTooltipTypes[RequirementsIndex] = "HeavyWeapons" .. i;</p><p>                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.Spouse) == 1 then</p><p>                    QSB.RequirementTooltipTypes[RequirementsIndex] = "Spouse" .. i;</p><p>                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.Worker) == 1 then</p><p>                    QSB.RequirementTooltipTypes[RequirementsIndex] = "Worker" .. i;</p><p>                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.Soldier) == 1 then</p><p>                    QSB.RequirementTooltipTypes[RequirementsIndex] = "Soldiers" .. i;</p><p>                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.Leader) == 1 then</p><p>                    QSB.RequirementTooltipTypes[RequirementsIndex] = "Leader" .. i;</p><p>                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.Outpost) == 1 then</p><p>                    QSB.RequirementTooltipTypes[RequirementsIndex] = "Outposts" .. i;</p><p>                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.CattlePasture) == 1 then</p><p>                    QSB.RequirementTooltipTypes[RequirementsIndex] = "Cattle" .. i;</p><p>                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.SheepPasture) == 1 then</p><p>                    QSB.RequirementTooltipTypes[RequirementsIndex] = "Sheep" .. i;</p><p>                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.CityBuilding) == 1 then</p><p>                    QSB.RequirementTooltipTypes[RequirementsIndex] = "CityBuilding" .. i;</p><p>                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.OuterRimBuilding) == 1 then</p><p>                    QSB.RequirementTooltipTypes[RequirementsIndex] = "OuterRimBuilding" .. i;</p><p>                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.AttackableBuilding) == 1 then</p><p>                    QSB.RequirementTooltipTypes[RequirementsIndex] = "Buildings" .. i;</p><p>                else</p><p>                    QSB.RequirementTooltipTypes[RequirementsIndex] = "EntityCategoryDefault" .. i;</p><p>                end</p><p>                RequirementsIndex = RequirementsIndex +1;</p><p>            end</p><p>        end</p><p>        -- Entities</p><p>        if KnightTitleRequirements[NextTitle].Entities ~= nil then</p><p>            for i=1, #KnightTitleRequirements[NextTitle].Entities do</p><p>                local EntityType = KnightTitleRequirements[NextTitle].Entities[i][1];</p><p>                SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", g_TexturePositions.Entities[EntityType]);</p><p>                local IsFulfilled, CurrentAmount, NeededAmount = DoesNeededNumberOfEntitiesOfTypeForKnightTitleExist(PlayerID, NextTitle, i);</p><p>                XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);</p><p>                if IsFulfilled then</p><p>                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);</p><p>                else</p><p>                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);</p><p>                end</p><p>                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);</p><p>                QSB.RequirementTooltipTypes[RequirementsIndex] = "Entities" .. i;</p><p>                RequirementsIndex = RequirementsIndex +1;</p><p>            end</p><p>        end</p><p>        -- Güter konsumieren</p><p>        if KnightTitleRequirements[NextTitle].Consume ~= nil then</p><p>            for i=1, #KnightTitleRequirements[NextTitle].Consume do</p><p>                local GoodType = KnightTitleRequirements[NextTitle].Consume[i][1];</p><p>                SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", g_TexturePositions.Goods[GoodType]);</p><p>                local IsFulfilled, CurrentAmount, NeededAmount = DoNeededNumberOfConsumedGoodsForKnightTitleExist(PlayerID, NextTitle, i);</p><p>                XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);</p><p>                if IsFulfilled then</p><p>                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);</p><p>                else</p><p>                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);</p><p>                end</p><p>                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);</p><p>                QSB.RequirementTooltipTypes[RequirementsIndex] = "Consume" .. i;</p><p>                RequirementsIndex = RequirementsIndex +1;</p><p>            end</p><p>        end</p><p>        -- Güter aus Gruppe produzieren</p><p>        if KnightTitleRequirements[NextTitle].Products ~= nil then</p><p>            for i=1, #KnightTitleRequirements[NextTitle].Products do</p><p>                local Product = KnightTitleRequirements[NextTitle].Products[i][1];</p><p>                SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", g_TexturePositions.GoodCategories[Product]);</p><p>                local IsFulfilled, CurrentAmount, NeededAmount = DoNumberOfProductsInCategoryExist(PlayerID, NextTitle, i);</p><p>                XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);</p><p>                if IsFulfilled then</p><p>                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);</p><p>                else</p><p>                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);</p><p>                end</p><p>                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);</p><p>                QSB.RequirementTooltipTypes[RequirementsIndex] = "Products" .. i;</p><p>                RequirementsIndex = RequirementsIndex +1;</p><p>            end</p><p>        end</p><p>        -- Bonus aktivieren</p><p>        if KnightTitleRequirements[NextTitle].Buff ~= nil then</p><p>            for i=1, #KnightTitleRequirements[NextTitle].Buff do</p><p>                local Buff = KnightTitleRequirements[NextTitle].Buff[i];</p><p>                SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", g_TexturePositions.Buffs[Buff]);</p><p>                local IsFulfilled = DoNeededDiversityBuffForKnightTitleExist(PlayerID, NextTitle, i);</p><p>                XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "");</p><p>                if IsFulfilled then</p><p>                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);</p><p>                else</p><p>                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);</p><p>                end</p><p>                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);</p><p>                QSB.RequirementTooltipTypes[RequirementsIndex] = "Buff" .. i;</p><p>                RequirementsIndex = RequirementsIndex +1;</p><p>            end</p><p>        end</p><p>        -- Selbstdefinierte Bedingung</p><p>        if KnightTitleRequirements[NextTitle].Custom ~= nil then</p><p>            for i=1, #KnightTitleRequirements[NextTitle].Custom do</p><p>                local Icon = KnightTitleRequirements[NextTitle].Custom[i][2];</p><p>                BundleKnightTitleRequirements.Local:RequirementIcon(WidgetPos[RequirementsIndex] .. "/Icon", Icon);</p><p>                local IsFulfilled, CurrentAmount, NeededAmount = DoCustomFunctionForKnightTitleSucceed(PlayerID, NextTitle, i);</p><p>                if CurrentAmount and NeededAmount then</p><p>                    XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);</p><p>                else</p><p>                    XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "");</p><p>                end</p><p>                if IsFulfilled then</p><p>                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);</p><p>                else</p><p>                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);</p><p>                end</p><p>                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);</p><p>                QSB.RequirementTooltipTypes[RequirementsIndex] = "Custom" .. i;</p><p>                RequirementsIndex = RequirementsIndex +1;</p><p>            end</p><p>        end</p><p>        -- Dekorationselemente</p><p>        if KnightTitleRequirements[NextTitle].DecoratedBuildings ~= nil then</p><p>            for i=1, #KnightTitleRequirements[NextTitle].DecoratedBuildings do</p><p>                local GoodType = KnightTitleRequirements[NextTitle].DecoratedBuildings[i][1];</p><p>                SetIcon(WidgetPos[RequirementsIndex].."/Icon", g_TexturePositions.Goods[GoodType]);</p><p>                local IsFulfilled, CurrentAmount, NeededAmount = DoNeededNumberOfDecoratedBuildingsForKnightTitleExist(PlayerID, NextTitle, i);</p><p>                XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);</p><p>                if IsFulfilled then</p><p>                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);</p><p>                else</p><p>                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);</p><p>                end</p><p>                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);</p><p>                QSB.RequirementTooltipTypes[RequirementsIndex] = "DecoratedBuildings" ..i;</p><p>                RequirementsIndex = RequirementsIndex +1;</p><p>            end</p><p>        end</p><p>        -- Übrige ausblenden</p><p>        for i=RequirementsIndex, 6 do</p><p>            XGUIEng.ShowWidget(WidgetPos[i], 0);</p><p>        end</p><p>    end</p><p>-- Überschreibt die Beförderung des Primary Knight.</p><p>-- @within BundleKnightTitleRequirements</p><p>-- @local</p><p>    StartKnightsPromotionCelebration = function( _PlayerID , _OldTitle, _FirstTime)</p><p>        if _PlayerID ~= GUI.GetPlayerID() or Logic.GetTime()  5 then</p><p>            return;</p><p>        end</p><p>        local MarketplaceID = Logic.GetMarketplace(_PlayerID);</p><p>        if _FirstTime == 1 then</p><p>            local KnightID = Logic.GetKnightID(_PlayerID);</p><p>            local Random</p><p>            repeat</p><p>                Random = 1 + XGUIEng.GetRandom(3)</p><p>            until Random ~= g_LastGotPromotionMessageRandom</p><p>            g_LastGotPromotionMessageRandom = Random;</p><p>            local TextKey = "Title_GotPromotion" .. Random;</p><p>            LocalScriptCallback_QueueVoiceMessage(_PlayerID, TextKey, false, _PlayerID);</p><p>            GUI.StartFestival(_PlayerID, 1);</p><p>        end</p><p>        -- reset local</p><p>        local Consume = QSB.ConsumedGoodsCounter[_PlayerID];</p><p>        QSB.ConsumedGoodsCounter[_PlayerID] = Consume or {};</p><p>        for k,v in pairs(QSB.ConsumedGoodsCounter[_PlayerID]) do</p><p>            QSB.ConsumedGoodsCounter[_PlayerID][k] = 0;</p><p>        end</p><p>        -- reset global</p><p>        GUI.SendScriptCommand([[</p><p>            local Consume = QSB.ConsumedGoodsCounter[]].._PlayerID..[[];</p><p>            QSB.ConsumedGoodsCounter[]].._PlayerID..[[] = Consume or {};</p><p>            for k,v in pairs(QSB.ConsumedGoodsCounter[]].._PlayerID..[[]) do</p><p>                QSB.ConsumedGoodsCounter[]].._PlayerID..[[][k] = 0;</p><p>            end</p><p>        ]]);</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/KnightTitleMenu", 0);</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopCenter/KnightTitleMenuBig", 0);</p><p>        g_WantsPromotionMessageInterval = 30;</p><p>        g_TimeOfPromotionPossible = nil;</p><p>    end</p><p>-- Überschreibt die Tooltips im Aufstiegsmenü.</p><p>-- @within BundleKnightTitleRequirements</p><p>-- @local</p><p>    GUI_Tooltip.SetNameAndDescription_Orig_QSB_Requirements = GUI_Tooltip.SetNameAndDescription;</p><p>    GUI_Tooltip.SetNameAndDescription = function(_TooltipNameWidget, _TooltipDescriptionWidget, _OptionalTextKeyName, _OptionalDisabledTextKeyName, _OptionalMissionTextFileBoolean)</p><p>        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();</p><p>        local Selected = GUI.GetSelectedEntity();</p><p>        local PlayerID = GUI.GetPlayerID();</p><p>        for k,v in pairs(BundleKnightTitleRequirements.Local.Data.RequirementWidgets) do</p><p>            if v .. "/Icon" == XGUIEng.GetWidgetPathByID(CurrentWidgetID) then</p><p>                local key = QSB.RequirementTooltipTypes[k];</p><p>                local num = tonumber(string.sub(key, string.len(key)));</p><p>                if num ~= nil then</p><p>                    key = string.sub(key, 1, string.len(key)-1);</p><p>                end</p><p>                BundleKnightTitleRequirements.Local:RequirementTooltipWrapped(key, num);</p><p>                return;</p><p>            end</p><p>        end</p><p>        GUI_Tooltip.SetNameAndDescription_Orig_QSB_Requirements(_TooltipNameWidget, _TooltipDescriptionWidget, _OptionalTextKeyName, _OptionalDisabledTextKeyName, _OptionalMissionTextFileBoolean);</p><p>    end</p><p>    GUI_Knight.RequiredGoodTooltip = function()</p><p>        local key = QSB.RequirementTooltipTypes[2];</p><p>        local num = tonumber(string.sub(key, string.len(key)));</p><p>        if num ~= nil then</p><p>            key = string.sub(key, 1, string.len(key)-1);</p><p>        end</p><p>        BundleKnightTitleRequirements.Local:RequirementTooltipWrapped(key, num);</p><p>    end</p><p>    if Framework.GetGameExtraNo() ~= 0 then</p><p>        BundleKnightTitleRequirements.Local.Data.BuffTypeNames[Buffs.Buff_Gems] = {</p><p>            de = "Edelsteine beschaffen", en = "Obtain gems"</p><p>        }</p><p>        BundleKnightTitleRequirements.Local.Data.BuffTypeNames[Buffs.Buff_Olibanum] = {</p><p>            de = "Weihrauch beschaffen", en = "Obtain olibanum"</p><p>        }</p><p>        BundleKnightTitleRequirements.Local.Data.BuffTypeNames[Buffs.Buff_MusicalInstrument] = {</p><p>            de = "Muskinstrumente beschaffen", en = "Obtain instruments"</p><p>        }</p><p>    end</p><p>-- Ändert die Textur eines Icons in den Aufstiegsbedingungen.</p><p>-- Icons für Aufstiegsbedingungen können sein:</p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- @param[type=string] _Widget Icon Widget</p><p>-- @param              _Icon Icon Textur (Dateiname oder Matrix)</p><p>-- @within BundleKnightTitleRequirements</p><p>-- @local</p><p>    if type(_Icon) == "table" then</p><p>        if type(_Icon[3]) == "string" then</p><p>            local ButtonState = 1;</p><p>            if XGUIEng.IsButton(_Widget) == 1 then</p><p>                ButtonState = 7;</p><p>            end</p><p>            local u0, u1, v0, v1;</p><p>            u0 = (_Icon[1] - 1) * 64;</p><p>            v0 = (_Icon[2] - 1) * 64;</p><p>            u1 = (_Icon[1]) * 64;</p><p>            v1 = (_Icon[2]) * 64;</p><p>            XGUIEng.SetMaterialAlpha(_Widget, ButtonState, 255);</p><p>            XGUIEng.SetMaterialTexture(_Widget, ButtonState, _Icon[3].. "big.png");</p><p>            XGUIEng.SetMaterialUV(_Widget, ButtonState, u0, v0, u1, v1);</p><p>        else</p><p>            SetIcon(_Widget, _Icon);</p><p>        end</p><p>    else</p><p>        local screenSize = {GUI.GetScreenSize()};</p><p>        local Scale = 330;</p><p>        if screenSize[2] = 800 then</p><p>            Scale = 260;</p><p>        end</p><p>        if screenSize[2] = 1000 then</p><p>            Scale = 210;</p><p>        end</p><p>        XGUIEng.SetMaterialAlpha(_Widget, 1, 255);</p><p>        XGUIEng.SetMaterialTexture(_Widget, 1, _file);</p><p>        XGUIEng.SetMaterialUV(_Widget, 1, 0, 0, Scale, Scale);</p><p>    end</p><p>-- Setzt einen für den Tooltip des aktuellen Widget einen neuen Text.</p><p>-- @param[type=string] _Title Titel des Tooltip</p><p>-- @param[type=string] _Text  Text des Tooltip</p><p>-- @within BundleKnightTitleRequirements</p><p>-- @local</p><p>    local TooltipContainerPath = "/InGame/Root/Normal/TooltipNormal";</p><p>    local TooltipContainer = XGUIEng.GetWidgetID(TooltipContainerPath);</p><p>    local TooltipNameWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Name");</p><p>    local TooltipDescriptionWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Text");</p><p>    local TooltipBGWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/BG");</p><p>    local TooltipFadeInContainer = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn");</p><p>    local PositionWidget = XGUIEng.GetCurrentWidgetID();</p><p>    GUI_Tooltip.ResizeBG(TooltipBGWidget, TooltipDescriptionWidget);</p><p>    local TooltipContainerSizeWidgets = {TooltipBGWidget};</p><p>    GUI_Tooltip.SetPosition(TooltipContainer, TooltipContainerSizeWidgets, PositionWidget);</p><p>    GUI_Tooltip.FadeInTooltip(TooltipFadeInContainer);</p><p>    XGUIEng.SetText(TooltipNameWidget, "{center}" .. _Title);</p><p>    XGUIEng.SetText(TooltipDescriptionWidget, _Text);</p><p>    local Height = XGUIEng.GetTextHeight(TooltipDescriptionWidget, true);</p><p>    local W, H = XGUIEng.GetWidgetSize(TooltipDescriptionWidget);</p><p>    XGUIEng.SetWidgetSize(TooltipDescriptionWidget, W, Height);</p><p>-- Ermittelt die veränderten Texte für den Tooltip hinter dem angegebenen Key.</p><p>-- @param[type=string] _key Index in Description</p><p>-- @param[type=number] _i   Buttonindex</p><p>-- @within BundleKnightTitleRequirements</p><p>-- @local</p><p>    local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>    local PlayerID = GUI.GetPlayerID();</p><p>    local KnightTitle = Logic.GetKnightTitle(PlayerID);</p><p>    local Title = ""</p><p>    local Text = "";</p><p>    if _key == "Consume" or _key == "Goods" or _key == "DecoratedBuildings" then</p><p>        local GoodType     = KnightTitleRequirements[KnightTitle+1][_key][_i][1];</p><p>        local GoodTypeName = Logic.GetGoodTypeName(GoodType);</p><p>        local GoodName     = XGUIEng.GetStringTableText("UI_ObjectNames/" .. GoodTypeName);</p><p>        if GoodName == nil then</p><p>            GoodName = "Goods." .. GoodTypeName;</p><p>        end</p><p>        Title = GoodName;</p><p>        Text  = BundleKnightTitleRequirements.Local.Data.Description[_key].Text;</p><p>    elseif _key == "Products" then</p><p>        local GoodCategoryNames = BundleKnightTitleRequirements.Local.Data.GoodCategoryNames;</p><p>        local Category = KnightTitleRequirements[KnightTitle+1][_key][_i][1];</p><p>        local CategoryName = GoodCategoryNames[Category][lang];</p><p>        if CategoryName == nil then</p><p>            CategoryName = "ERROR: Name missng!";</p><p>        end</p><p>        Title = CategoryName;</p><p>        Text  = BundleKnightTitleRequirements.Local.Data.Description[_key].Text;</p><p>    elseif _key == "Entities" then</p><p>        local EntityType     = KnightTitleRequirements[KnightTitle+1][_key][_i][1];</p><p>        local EntityTypeName = Logic.GetEntityTypeName(EntityType);</p><p>        local EntityName = XGUIEng.GetStringTableText("Names/" .. EntityTypeName);</p><p>        if EntityName == nil then</p><p>            EntityName = "Entities." .. EntityTypeName;</p><p>        end</p><p>        Title = EntityName;</p><p>        Text  = BundleKnightTitleRequirements.Local.Data.Description[_key].Text;</p><p>    elseif _key == "Custom" then</p><p>        local Custom = KnightTitleRequirements[KnightTitle+1].Custom[_i];</p><p>        Title = Custom[3];</p><p>        Text  = Custom[4];</p><p>    elseif _key == "Buff" then</p><p>        local BuffTypeNames = BundleKnightTitleRequirements.Local.Data.BuffTypeNames;</p><p>        local BuffType = KnightTitleRequirements[KnightTitle+1][_key][_i];</p><p>        local BuffTitle = BuffTypeNames[BuffType][lang];</p><p>        if BuffTitle == nil then</p><p>            BuffTitle = "ERROR: Name missng!";</p><p>        end</p><p>        Title = BuffTitle;</p><p>        Text  = BundleKnightTitleRequirements.Local.Data.Description[_key].Text;</p><p>    else</p><p>        Title = BundleKnightTitleRequirements.Local.Data.Description[_key].Title;</p><p>        Text  = BundleKnightTitleRequirements.Local.Data.Description[_key].Text;</p><p>    end</p><p>    Title = (type(Title) == "table" and Title[lang]) or Title;</p><p>    Text  = (type(Text) == "table" and Text[lang]) or Text;</p><p>    self:RequirementTooltip(Title, Text);</p><p>    [1] = "/InGame/Root/Normal/AlignBottomRight/KnightTitleMenu/Requirements/Settlers",</p><p>    [2] = "/InGame/Root/Normal/AlignBottomRight/KnightTitleMenu/Requirements/Goods",</p><p>    [3] = "/InGame/Root/Normal/AlignBottomRight/KnightTitleMenu/Requirements/RichBuildings",</p><p>    [4] = "/InGame/Root/Normal/AlignBottomRight/KnightTitleMenu/Requirements/Castle",</p><p>    [5] = "/InGame/Root/Normal/AlignBottomRight/KnightTitleMenu/Requirements/Storehouse",</p><p>    [6] = "/InGame/Root/Normal/AlignBottomRight/KnightTitleMenu/Requirements/Cathedral",</p><p>    [GoodCategories.GC_Ammunition]      = {de = "Munition", en = "Ammunition"},</p><p>    [GoodCategories.GC_Animal]          = {de = "Nutztiere", en = "Livestock"},</p><p>    [GoodCategories.GC_Clothes]         = {de = "Kleidung", en = "Clothes"},</p><p>    [GoodCategories.GC_Document]        = {de = "Dokumente", en = "Documents"},</p><p>    [GoodCategories.GC_Entertainment]   = {de = "Unterhaltung", en = "Entertainment"},</p><p>    [GoodCategories.GC_Food]            = {de = "Nahrungsmittel", en = "Food"},</p><p>    [GoodCategories.GC_Gold]            = {de = "Gold", en = "Gold"},</p><p>    [GoodCategories.GC_Hygiene]         = {de = "Hygieneartikel", en = "Hygiene"},</p><p>    [GoodCategories.GC_Luxury]          = {de = "Dekoration", en = "Decoration"},</p><p>    [GoodCategories.GC_Medicine]        = {de = "Medizin", en = "Medicine"},</p><p>    [GoodCategories.GC_None]            = {de = "Nichts", en = "None"},</p><p>    [GoodCategories.GC_RawFood]         = {de = "Nahrungsmittel", en = "Food"},</p><p>    [GoodCategories.GC_RawMedicine]     = {de = "Medizin", en = "Medicine"},</p><p>    [GoodCategories.GC_Research]        = {de = "Forschung", en = "Research"},</p><p>    [GoodCategories.GC_Resource]        = {de = "Rohstoffe", en = "Resource"},</p><p>    [GoodCategories.GC_Tools]           = {de = "Werkzeug", en = "Tools"},</p><p>    [GoodCategories.GC_Water]           = {de = "Wasser", en = "Water"},</p><p>    [GoodCategories.GC_Weapon]          = {de = "Waffen", en = "Weapon"},</p><p>    [Buffs.Buff_ClothesDiversity]        = {de = "Abwechslungsreiche Kleidung", en = "Clothes diversity"},</p><p>    [Buffs.Buff_Colour]                  = {de = "Farben beschaffen", en = "Obtain color"},</p><p>    -- Funktioniert nicht, belegt MP</p><p>    [Buffs.Buff_Entertainers]            = {de = "Gaukler anheuern", en = "Hire entertainer"},</p><p>    [Buffs.Buff_EntertainmentDiversity]  = {de = "Abwechslungsreiche Unterhaltung", en = "Entertainment diversity"},</p><p>    [Buffs.Buff_ExtraPayment]            = {de = "Sonderzahlung", en = "Extra payment"},</p><p>    -- Funktioniert nicht, belegt MP</p><p>    [Buffs.Buff_Festival]                = {de = "Fest veranstalten", en = "Hold Festival"},</p><p>    [Buffs.Buff_FoodDiversity]           = {de = "Abwechslungsreiche Nahrung", en = "Food diversity"},</p><p>    [Buffs.Buff_HygieneDiversity]        = {de = "Abwechslungsreiche Hygiene", en = "Hygiene diversity"},</p><p>    [Buffs.Buff_NoTaxes]                 = {de = "Steuerbefreiung", en = "No taxes"},</p><p>    [Buffs.Buff_Sermon]                  = {de = "Pregigt abhalten", en = "Hold sermon"},</p><p>    [Buffs.Buff_Spice]                   = {de = "Salz beschaffen", en = "Obtain salt"},</p><p>    Settlers = {</p><p>        Title = {</p><p>            de = "Benötigte Siedler",</p><p>            en = "Needed settlers",</p><p>        },</p><p>        Text = {</p><p>            de = "- Benötigte Menge an Siedlern",</p><p>            en = "- Needed number of settlers",</p><p>        },</p><p>    },</p><p>    RichBuildings = {</p><p>        Title = {</p><p>            de = "Reiche Stadtgebäude",</p><p>            en = "Rich city buildings",</p><p>        },</p><p>        Text = {</p><p>            de = "- Menge an reichen Stadtgebäuden",</p><p>            en = "- Needed amount of rich city buildings",</p><p>        },</p><p>    },</p><p>    Goods = {</p><p>        Title = {</p><p>            de = "Waren lagern",</p><p>            en = "Store Goods",</p><p>        },</p><p>        Text = {</p><p>            de = "- Benötigte Menge",</p><p>            en = "- Needed amount",</p><p>        },</p><p>    },</p><p>    FullDecoratedBuildings = {</p><p>        Title = {</p><p>            de = "Dekorierte Stadtgebäude",</p><p>            en = "Decorated City buildings",</p><p>        },</p><p>        Text = {</p><p>            de = "- Menge an voll dekorierten Gebäuden",</p><p>            en = "- Amount of full decoraded city buildings",</p><p>        },</p><p>    },</p><p>    DecoratedBuildings = {</p><p>        Title = {</p><p>            de = "Dekoration",</p><p>            en = "Decoration",</p><p>        },</p><p>        Text = {</p><p>            de = "- Menge an Dekorationsgütern in der Siedlung",</p><p>            en = "- Amount of decoration goods in settlement",</p><p>        },</p><p>    },</p><p>    Headquarters = {</p><p>        Title = {</p><p>            de = "Burgstufe",</p><p>            en = "Castle level",</p><p>        },</p><p>        Text = {</p><p>            de = "- Benötigte Ausbauten der Burg",</p><p>            en = "- Needed castle upgrades",</p><p>        },</p><p>    },</p><p>    Storehouse = {</p><p>        Title = {</p><p>            de = "Lagerhausstufe",</p><p>            en = "Storehouse level",</p><p>        },</p><p>        Text = {</p><p>            de = "- Benötigte Ausbauten des Lagerhauses",</p><p>            en = "- Needed storehouse upgrades",</p><p>        },</p><p>    },</p><p>    Cathedrals = {</p><p>        Title = {</p><p>            de = "Kirchenstufe",</p><p>            en = "Cathedral level",</p><p>        },</p><p>        Text = {</p><p>            de = "- Benötigte Ausbauten der Kirche",</p><p>            en = "- Needed cathedral upgrades",</p><p>        },</p><p>    },</p><p>    Reputation = {</p><p>        Title = {</p><p>            de = "Ruf der Stadt",</p><p>            en = "City reputation",</p><p>        },</p><p>        Text = {</p><p>            de = "- Benötigter Ruf der Stadt",</p><p>            en = "- Needed city reputation",</p><p>        },</p><p>    },</p><p>    EntityCategoryDefault = {</p><p>        Title = {</p><p>            de = "",</p><p>            en = "",</p><p>        },</p><p>        Text = {</p><p>            de = "- Benötigte Anzahl",</p><p>            en = "- Needed amount",</p><p>        },</p><p>    },</p><p>    Cattle = {</p><p>        Title = {</p><p>            de = "Kühe",</p><p>            en = "Cattle",</p><p>        },</p><p>        Text = {</p><p>            de = "- Benötigte Menge an Kühen",</p><p>            en = "- Needed amount of cattle",</p><p>        },</p><p>    },</p><p>    Sheep = {</p><p>        Title = {</p><p>            de = "Schafe",</p><p>            en = "Sheeps",</p><p>        },</p><p>        Text = {</p><p>            de = "- Benötigte Menge an Schafen",</p><p>            en = "- Needed amount of sheeps",</p><p>        },</p><p>    },</p><p>    Outposts = {</p><p>        Title = {</p><p>            de = "Territorien",</p><p>            en = "Territories",</p><p>        },</p><p>        Text = {</p><p>            de = "- Zu erobernde Territorien",</p><p>            en = "- Territories to claim",</p><p>        },</p><p>    },</p><p>    CityBuilding = {</p><p>        Title = {</p><p>            de = "Stadtgebäude",</p><p>            en = "City buildings",</p><p>        },</p><p>        Text = {</p><p>            de = "- Menge benötigter Stadtgebäude",</p><p>            en = "- Needed amount of city buildings",</p><p>        },</p><p>    },</p><p>    OuterRimBuilding = {</p><p>        Title = {</p><p>            de = "Rohstoffgebäude",</p><p>            en = "Gatherer",</p><p>        },</p><p>        Text = {</p><p>            de = "- Menge benötigter Rohstoffgebäude",</p><p>            en = "- Needed amount of gatherer",</p><p>        },</p><p>    },</p><p>    Consume = {</p><p>        Title = {</p><p>            de = "",</p><p>            en = "",</p><p>        },</p><p>        Text = {</p><p>            de = "- Durch Siedler zu konsumierende Menge",</p><p>            en = "- Amount to be consumed by the settlers",</p><p>        },</p><p>    },</p><p>    Products = {</p><p>        Title = {</p><p>            de = "",</p><p>            en = "",</p><p>        },</p><p>        Text = {</p><p>            de = "- Benötigte Menge",</p><p>            en = "- Needed amount",</p><p>        },</p><p>    },</p><p>    Buff = {</p><p>        Title = {</p><p>            de = "Bonus aktivieren",</p><p>            en = "Activate Buff",</p><p>        },</p><p>        Text = {</p><p>            de = "- Aktiviere diesen Bonus auf den Ruf der Stadt",</p><p>            en = "- Raise the city reputatition with this buff",</p><p>        },</p><p>    },</p><p>    Leader = {</p><p>        Title = {</p><p>            de = "Batalione",</p><p>            en = "Battalions",</p><p>        },</p><p>        Text = {</p><p>            de = "- Menge an Batalionen unterhalten",</p><p>            en = "- Battalions you need under your command",</p><p>        },</p><p>    },</p><p>    Soldiers = {</p><p>        Title = {</p><p>            de = "Soldaten",</p><p>            en = "Soldiers",</p><p>        },</p><p>        Text = {</p><p>            de = "- Menge an Streitkräften unterhalten",</p><p>            en = "- Soldiers you need under your command",</p><p>        },</p><p>    },</p><p>    Worker = {</p><p>        Title = {</p><p>            de = "Arbeiter",</p><p>            en = "Workers",</p><p>        },</p><p>        Text = {</p><p>            de = "- Menge an arbeitender Bevölkerung",</p><p>            en = "- Workers you need under your reign",</p><p>        },</p><p>    },</p><p>    Entities = {</p><p>        Title = {</p><p>            de = "",</p><p>            en = "",</p><p>        },</p><p>        Text = {</p><p>            de = "- Benötigte Menge",</p><p>            en = "- Needed Amount",</p><p>        },</p><p>    },</p><p>    Buildings = {</p><p>        Title = {</p><p>            de = "Gebäude",</p><p>            en = "Buildings",</p><p>        },</p><p>        Text = {</p><p>            de = "- Gesamtmenge an Gebäuden",</p><p>            en = "- Amount of buildings",</p><p>        },</p><p>    },</p><p>    Weapons = {</p><p>        Title = {</p><p>            de = "Waffen",</p><p>            en = "Weapons",</p><p>        },</p><p>        Text = {</p><p>            de = "- Benötigte Menge an Waffen",</p><p>            en = "- Needed amount of weapons",</p><p>        },</p><p>    },</p><p>    HeavyWeapons = {</p><p>        Title = {</p><p>            de = "Belagerungsgeräte",</p><p>            en = "Siege Engines",</p><p>        },</p><p>        Text = {</p><p>            de = "- Benötigte Menge an Belagerungsgeräten",</p><p>            en = "- Needed amount of siege engine",</p><p>        },</p><p>    },</p><p>    Spouse = {</p><p>        Title = {</p><p>            de = "Ehefrauen",</p><p>            en = "Spouses",</p><p>        },</p><p>        Text = {</p><p>            de = "- Benötigte Anzahl Ehefrauen in der Stadt",</p><p>            en = "- Needed amount of spouses in your city",</p><p>        },</p><p>    },</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Spielfunktionen                                                            --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Prüft, ob genug Entities in einer bestimmten Kategorie existieren.</p><p>-- @param[type=number] _PlayerID ID des Spielers</p><p>-- @param[type=number] _KnightTitle Nächster Titel</p><p>-- @param[type=number] _i Button Index</p><p>-- @within Originalfunktionen</p><p>-- @local</p><p>    if KnightTitleRequirements[_KnightTitle].Category == nil then</p><p>        return;</p><p>    end</p><p>    if _i then</p><p>        local EntityCategory = KnightTitleRequirements[_KnightTitle].Category[_i][1];</p><p>        local NeededAmount = KnightTitleRequirements[_KnightTitle].Category[_i][2];</p><p>        local ReachedAmount = 0;</p><p>        if EntityCategory == EntityCategories.Spouse then</p><p>            ReachedAmount = Logic.GetNumberOfSpouses(_PlayerID);</p><p>        else</p><p>            local Buildings = {Logic.GetPlayerEntitiesInCategory(_PlayerID, EntityCategory)};</p><p>            for i=1, #Buildings do</p><p>                if Logic.IsBuilding(Buildings[i]) == 1 then</p><p>                    if Logic.IsConstructionComplete(Buildings[i]) == 1 then</p><p>                        ReachedAmount = ReachedAmount +1;</p><p>                    end</p><p>                else</p><p>                    ReachedAmount = ReachedAmount +1;</p><p>                end</p><p>            end</p><p>        end</p><p>        if ReachedAmount = NeededAmount then</p><p>            return true, ReachedAmount, NeededAmount;</p><p>        end</p><p>        return false, ReachedAmount, NeededAmount;</p><p>    else</p><p>        local bool, reach, need;</p><p>        for i=1,#KnightTitleRequirements[_KnightTitle].Category do</p><p>            bool, reach, need = DoesNeededNumberOfEntitiesInCategoryForKnightTitleExist(_PlayerID, _KnightTitle, i);</p><p>            if bool == false then</p><p>                return bool, reach, need</p><p>            end</p><p>        end</p><p>        return bool;</p><p>    end</p><p>-- Prüft, ob genug Entities eines bestimmten Typs existieren.</p><p>-- @param[type=number] _PlayerID ID des Spielers</p><p>-- @param[type=number] _KnightTitle Nächster Titel</p><p>-- @param[type=number] _i Button Index</p><p>-- @within Originalfunktionen</p><p>-- @local</p><p>    if KnightTitleRequirements[_KnightTitle].Entities == nil then</p><p>        return;</p><p>    end</p><p>    if _i then</p><p>        local EntityType = KnightTitleRequirements[_KnightTitle].Entities[_i][1];</p><p>        local NeededAmount = KnightTitleRequirements[_KnightTitle].Entities[_i][2];</p><p>        local Buildings = GetPlayerEntities(_PlayerID, EntityType);</p><p>        local ReachedAmount = 0;</p><p>        for i=1, #Buildings do</p><p>            if Logic.IsBuilding(Buildings[i]) == 1 then</p><p>                if Logic.IsConstructionComplete(Buildings[i]) == 1 then</p><p>                    ReachedAmount = ReachedAmount +1;</p><p>                end</p><p>            else</p><p>                ReachedAmount = ReachedAmount +1;</p><p>            end</p><p>        end</p><p>        if ReachedAmount = NeededAmount then</p><p>            return true, ReachedAmount, NeededAmount;</p><p>        end</p><p>        return false, ReachedAmount, NeededAmount;</p><p>    else</p><p>        local bool, reach, need;</p><p>        for i=1,#KnightTitleRequirements[_KnightTitle].Entities do</p><p>            bool, reach, need = DoesNeededNumberOfEntitiesOfTypeForKnightTitleExist(_PlayerID, _KnightTitle, i);</p><p>            if bool == false then</p><p>                return bool, reach, need</p><p>            end</p><p>        end</p><p>        return bool;</p><p>    end</p><p>-- Prüft, ob es genug Einheiten eines Warentyps gibt.</p><p>-- @param[type=number] _PlayerID ID des Spielers</p><p>-- @param[type=number] _KnightTitle Nächster Titel</p><p>-- @param[type=number] _i Button Index</p><p>-- @within Originalfunktionen</p><p>-- @local</p><p>    if KnightTitleRequirements[_KnightTitle].Goods == nil then</p><p>        return;</p><p>    end</p><p>    if _i then</p><p>        local GoodType = KnightTitleRequirements[_KnightTitle].Goods[_i][1];</p><p>        local NeededAmount = KnightTitleRequirements[_KnightTitle].Goods[_i][2];</p><p>        local ReachedAmount = GetPlayerGoodsInSettlement(GoodType, _PlayerID, true);</p><p>        if ReachedAmount = NeededAmount then</p><p>            return true, ReachedAmount, NeededAmount;</p><p>        end</p><p>        return false, ReachedAmount, NeededAmount;</p><p>    else</p><p>        local bool, reach, need;</p><p>        for i=1,#KnightTitleRequirements[_KnightTitle].Goods do</p><p>            bool, reach, need = DoesNeededNumberOfGoodTypesForKnightTitleExist(_PlayerID, _KnightTitle, i);</p><p>            if bool == false then</p><p>                return bool, reach, need</p><p>            end</p><p>        end</p><p>        return bool;</p><p>    end</p><p>-- Prüft, ob die Siedler genug Einheiten einer Ware konsumiert haben.</p><p>-- @param[type=number] _PlayerID ID des Spielers</p><p>-- @param[type=number] _KnightTitle Nächster Titel</p><p>-- @param[type=number] _i Button Index</p><p>-- @within Originalfunktionen</p><p>-- @local</p><p>    if KnightTitleRequirements[_KnightTitle].Consume == nil then</p><p>        return;</p><p>    end</p><p>    if _i then</p><p>        QSB.ConsumedGoodsCounter[_PlayerID] = QSB.ConsumedGoodsCounter[_PlayerID] or {};</p><p>        local GoodType = KnightTitleRequirements[_KnightTitle].Consume[_i][1];</p><p>        local GoodAmount = QSB.ConsumedGoodsCounter[_PlayerID][GoodType] or 0;</p><p>        local NeededGoodAmount = KnightTitleRequirements[_KnightTitle].Consume[_i][2];</p><p>        if GoodAmount = NeededGoodAmount then</p><p>            return true, GoodAmount, NeededGoodAmount;</p><p>        else</p><p>            return false, GoodAmount, NeededGoodAmount;</p><p>        end</p><p>    else</p><p>        local bool, reach, need;</p><p>        for i=1,#KnightTitleRequirements[_KnightTitle].Consume do</p><p>            bool, reach, need = DoNeededNumberOfConsumedGoodsForKnightTitleExist(_PlayerID, _KnightTitle, i);</p><p>            if bool == false then</p><p>                return false, reach, need</p><p>            end</p><p>        end</p><p>        return true, reach, need;</p><p>    end</p><p>-- Prüft, ob genug Waren der Kategorie hergestellt wurde.</p><p>-- @param[type=number] _PlayerID ID des Spielers</p><p>-- @param[type=number] _KnightTitle Nächster Titel</p><p>-- @param[type=number] _i Button Index</p><p>-- @within Originalfunktionen</p><p>-- @local</p><p>    if KnightTitleRequirements[_KnightTitle].Products == nil then</p><p>        return;</p><p>    end</p><p>    if _i then</p><p>        local GoodAmount = 0;</p><p>        local NeedAmount = KnightTitleRequirements[_KnightTitle].Products[_i][2];</p><p>        local GoodCategory = KnightTitleRequirements[_KnightTitle].Products[_i][1];</p><p>        local GoodsInCategory = {Logic.GetGoodTypesInGoodCategory(GoodCategory)};</p><p>        for i=1, #GoodsInCategory do</p><p>            GoodAmount = GoodAmount + GetPlayerGoodsInSettlement(GoodsInCategory[i], _PlayerID, true);</p><p>        end</p><p>        return (GoodAmount = NeedAmount), GoodAmount, NeedAmount;</p><p>    else</p><p>        local bool, reach, need;</p><p>        for i=1,#KnightTitleRequirements[_KnightTitle].Products do</p><p>            bool, reach, need = DoNumberOfProductsInCategoryExist(_PlayerID, _KnightTitle, i);</p><p>            if bool == false then</p><p>                return bool, reach, need</p><p>            end</p><p>        end</p><p>        return bool;</p><p>    end</p><p>-- Prüft, ob ein bestimmter Buff für den Spieler aktiv ist.</p><p>-- @param[type=number] _PlayerID ID des Spielers</p><p>-- @param[type=number] _KnightTitle Nächster Titel</p><p>-- @param[type=number] _i Button Index</p><p>-- @within Originalfunktionen</p><p>-- @local</p><p>    if KnightTitleRequirements[_KnightTitle].Buff == nil then</p><p>        return;</p><p>    end</p><p>    if _i then</p><p>        local buff = KnightTitleRequirements[_KnightTitle].Buff[_i];</p><p>        if Logic.GetBuff(_PlayerID,buff) and Logic.GetBuff(_PlayerID,buff) ~= 0 then</p><p>            return true;</p><p>        end</p><p>        return false;</p><p>    else</p><p>        local bool, reach, need;</p><p>        for i=1,#KnightTitleRequirements[_KnightTitle].Buff do</p><p>            bool, reach, need = DoNeededDiversityBuffForKnightTitleExist(_PlayerID, _KnightTitle, i);</p><p>            if bool == false then</p><p>                return bool, reach, need</p><p>            end</p><p>        end</p><p>        return bool;</p><p>    end</p><p>-- Prüft, ob die Custom Function true vermeldet.</p><p>-- @param[type=number] _PlayerID ID des Spielers</p><p>-- @param[type=number] _KnightTitle Nächster Titel</p><p>-- @param[type=number] _i Button Index</p><p>-- @within Originalfunktionen</p><p>-- @local</p><p>    if KnightTitleRequirements[_KnightTitle].Custom == nil then</p><p>        return;</p><p>    end</p><p>    if _i then</p><p>        return KnightTitleRequirements[_KnightTitle].Custom[_i][1]();</p><p>    else</p><p>        local bool, reach, need;</p><p>        for i=1,#KnightTitleRequirements[_KnightTitle].Custom do</p><p>            bool, reach, need = DoCustomFunctionForKnightTitleSucceed(_PlayerID, _KnightTitle, i);</p><p>            if bool == false then</p><p>                return bool, reach, need</p><p>            end</p><p>        end</p><p>        return bool;</p><p>    end</p><p>-- Prüft, ob genug Dekoration eines Typs angebracht wurde.</p><p>-- @param[type=number] _PlayerID ID des Spielers</p><p>-- @param[type=number] _KnightTitle Nächster Titel</p><p>-- @param[type=number] _i Button Index</p><p>-- @within Originalfunktionen</p><p>-- @local</p><p>    if KnightTitleRequirements[_KnightTitle].DecoratedBuildings == nil then</p><p>        return</p><p>    end</p><p>    if _i then</p><p>        local CityBuildings = {Logic.GetPlayerEntitiesInCategory(_PlayerID, EntityCategories.CityBuilding)}</p><p>        local DecorationGoodType = KnightTitleRequirements[_KnightTitle].DecoratedBuildings[_i][1]</p><p>        local NeededBuildingsWithDecoration = KnightTitleRequirements[_KnightTitle].DecoratedBuildings[_i][2]</p><p>        local BuildingsWithDecoration = 0</p><p>        for i=1, #CityBuildings do</p><p>            local BuildingID = CityBuildings[i]</p><p>            local GoodState = Logic.GetBuildingWealthGoodState(BuildingID, DecorationGoodType)</p><p>            if GoodState  0 then</p><p>                BuildingsWithDecoration = BuildingsWithDecoration + 1</p><p>            end</p><p>        end</p><p>        if BuildingsWithDecoration = NeededBuildingsWithDecoration then</p><p>            return true, BuildingsWithDecoration, NeededBuildingsWithDecoration</p><p>        else</p><p>            return false, BuildingsWithDecoration, NeededBuildingsWithDecoration</p><p>        end</p><p>    else</p><p>        local bool, reach, need;</p><p>        for i=1,#KnightTitleRequirements[_KnightTitle].DecoratedBuildings do</p><p>            bool, reach, need = DoNeededNumberOfDecoratedBuildingsForKnightTitleExist(_PlayerID, _KnightTitle, i);</p><p>            if bool == false then</p><p>                return bool, reach, need</p><p>            end</p><p>        end</p><p>        return bool;</p><p>    end</p><p>-- Prüft, ob die Spezialgebäude weit genug ausgebaut sind.</p><p>-- @param[type=number] _PlayerID ID des Spielers</p><p>-- @param[type=number] _KnightTitle Nächster Titel</p><p>-- @param[type=number] _EntityCategory Entity Category</p><p>-- @within Originalfunktionen</p><p>-- @local</p><p>    local SpecialBuilding</p><p>    local SpecialBuildingName</p><p>    if _EntityCategory == EntityCategories.Headquarters then</p><p>        SpecialBuilding = Logic.GetHeadquarters(_PlayerID)</p><p>        SpecialBuildingName = "Headquarters"</p><p>    elseif _EntityCategory == EntityCategories.Storehouse then</p><p>        SpecialBuilding = Logic.GetStoreHouse(_PlayerID)</p><p>        SpecialBuildingName = "Storehouse"</p><p>    elseif _EntityCategory == EntityCategories.Cathedrals then</p><p>        SpecialBuilding = Logic.GetCathedral(_PlayerID)</p><p>        SpecialBuildingName = "Cathedrals"</p><p>    else</p><p>        return</p><p>    end</p><p>    if KnightTitleRequirements[_KnightTitle][SpecialBuildingName] == nil then</p><p>        return</p><p>    end</p><p>    local NeededUpgradeLevel = KnightTitleRequirements[_KnightTitle][SpecialBuildingName]</p><p>    if SpecialBuilding ~= nil then</p><p>        local SpecialBuildingUpgradeLevel = Logic.GetUpgradeLevel(SpecialBuilding)</p><p>        if SpecialBuildingUpgradeLevel = NeededUpgradeLevel then</p><p>            return true, SpecialBuildingUpgradeLevel, NeededUpgradeLevel</p><p>        else</p><p>            return false, SpecialBuildingUpgradeLevel, NeededUpgradeLevel</p><p>        end</p><p>    else</p><p>        return false, 0, NeededUpgradeLevel</p><p>    end</p><p>-- Prüft, ob der Ruf der Stadt hoch genug ist.</p><p>-- @param[type=number] _PlayerID ID des Spielers</p><p>-- @param[type=number] _KnightTitle Nächster Titel</p><p>-- @within Originalfunktionen</p><p>-- @local</p><p>    if KnightTitleRequirements[_KnightTitle].Reputation == nil then</p><p>        return;</p><p>    end</p><p>    local NeededAmount = KnightTitleRequirements[_KnightTitle].Reputation;</p><p>    if not NeededAmount then</p><p>        return;</p><p>    end</p><p>    local ReachedAmount = math.floor((Logic.GetCityReputation(_PlayerID) * 100) + 0.5);</p><p>    if ReachedAmount = NeededAmount then</p><p>        return true, ReachedAmount, NeededAmount;</p><p>    end</p><p>    return false, ReachedAmount, NeededAmount;</p><p>-- Prüft, ob genug Gebäude vollständig dekoriert sind.</p><p>-- @param[type=number] _PlayerID ID des Spielers</p><p>-- @param[type=number] _KnightTitle Nächster Titel</p><p>-- @within Originalfunktionen</p><p>-- @local</p><p>    if KnightTitleRequirements[_KnightTitle].FullDecoratedBuildings == nil then</p><p>        return</p><p>    end</p><p>    local CityBuildings = {Logic.GetPlayerEntitiesInCategory(_PlayerID, EntityCategories.CityBuilding)}</p><p>    local NeededBuildingsWithDecoration = KnightTitleRequirements[_KnightTitle].FullDecoratedBuildings</p><p>    local BuildingsWithDecoration = 0</p><p>    for i=1, #CityBuildings do</p><p>        local BuildingID = CityBuildings[i]</p><p>        local AmountOfWealthGoodsAtBuilding = 0</p><p>        if Logic.GetBuildingWealthGoodState(BuildingID, Goods.G_Banner )  0 then</p><p>            AmountOfWealthGoodsAtBuilding = AmountOfWealthGoodsAtBuilding  + 1</p><p>        end</p><p>        if Logic.GetBuildingWealthGoodState(BuildingID, Goods.G_Sign  )  0 then</p><p>            AmountOfWealthGoodsAtBuilding = AmountOfWealthGoodsAtBuilding  + 1</p><p>        end</p><p>        if Logic.GetBuildingWealthGoodState(BuildingID, Goods.G_Candle)  0 then</p><p>            AmountOfWealthGoodsAtBuilding = AmountOfWealthGoodsAtBuilding  + 1</p><p>        end</p><p>        if Logic.GetBuildingWealthGoodState(BuildingID, Goods.G_Ornament  )  0 then</p><p>            AmountOfWealthGoodsAtBuilding = AmountOfWealthGoodsAtBuilding  + 1</p><p>        end</p><p>        if AmountOfWealthGoodsAtBuilding = 4 then</p><p>            BuildingsWithDecoration = BuildingsWithDecoration + 1</p><p>        end</p><p>    end</p><p>    if BuildingsWithDecoration = NeededBuildingsWithDecoration then</p><p>        return true, BuildingsWithDecoration, NeededBuildingsWithDecoration</p><p>    else</p><p>        return false, BuildingsWithDecoration, NeededBuildingsWithDecoration</p><p>    end</p><p>-- Prüft, ob der Spieler befördert werden kann.</p><p>-- @param[type=number] _PlayerID ID des Spielers</p><p>-- @param[type=number] _KnightTitle Nächster Titel</p><p>-- @within Originalfunktionen</p><p>-- @local</p><p>    if _KnightTitle == nil then</p><p>        _KnightTitle = Logic.GetKnightTitle(_PlayerID) + 1;</p><p>    end</p><p>    if Logic.CanStartFestival(_PlayerID, 1) == true then</p><p>        if  KnightTitleRequirements[_KnightTitle] ~= nil</p><p>        and DoesNeededNumberOfSettlersForKnightTitleExist(_PlayerID, _KnightTitle) ~= false</p><p>        and DoNeededNumberOfGoodsForKnightTitleExist( _PlayerID, _KnightTitle)  ~= false</p><p>        and DoNeededSpecialBuildingUpgradeForKnightTitleExist( _PlayerID, _KnightTitle, EntityCategories.Headquarters) ~= false</p><p>        and DoNeededSpecialBuildingUpgradeForKnightTitleExist( _PlayerID, _KnightTitle, EntityCategories.Storehouse) ~= false</p><p>        and DoNeededSpecialBuildingUpgradeForKnightTitleExist( _PlayerID, _KnightTitle, EntityCategories.Cathedrals)  ~= false</p><p>        and DoNeededNumberOfRichBuildingsForKnightTitleExist( _PlayerID, _KnightTitle)  ~= false</p><p>        and DoNeededNumberOfFullDecoratedBuildingsForKnightTitleExist( _PlayerID, _KnightTitle) ~= false</p><p>        and DoNeededNumberOfDecoratedBuildingsForKnightTitleExist( _PlayerID, _KnightTitle) ~= false</p><p>        and DoesNeededCityReputationForKnightTitleExist( _PlayerID, _KnightTitle) ~= false</p><p>        and DoesNeededNumberOfEntitiesInCategoryForKnightTitleExist( _PlayerID, _KnightTitle) ~= false</p><p>        and DoesNeededNumberOfEntitiesOfTypeForKnightTitleExist( _PlayerID, _KnightTitle) ~= false</p><p>        and DoesNeededNumberOfGoodTypesForKnightTitleExist( _PlayerID, _KnightTitle) ~= false</p><p>        and DoNeededDiversityBuffForKnightTitleExist( _PlayerID, _KnightTitle) ~= false</p><p>        and DoCustomFunctionForKnightTitleSucceed( _PlayerID, _KnightTitle) ~= false</p><p>        and DoNeededNumberOfConsumedGoodsForKnightTitleExist( _PlayerID, _KnightTitle) ~= false</p><p>        and DoNumberOfProductsInCategoryExist( _PlayerID, _KnightTitle) ~= false then</p><p>            return true;</p><p>        end</p><p>    end</p><p>    return false;</p><p>-- Der Spieler gewinnt das Spiel</p><p>-- @within Originalfunktionen</p><p>-- @local</p><p>    QuestTemplate:TerminateEventsAndStuff();</p><p>    Victory(g_VictoryAndDefeatType.VictoryMissionComplete);</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Aufstiegsbedingungen                                                       --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Definiert andere Aufstiegsbedingungen für den Spieler. Muss stets nach dem</p><p>-- Laden der QSB im globalen und lokalen Skript aufgerufen werden!</p><p>-- Diese Funktion muss entweder in der QSB modifiziert oder sowohl im globalen</p><p>-- als auch im lokalen Skript überschrieben werden. Bei Modifikationen muss</p><p>-- das Schema für Aufstiegsbedingungen und Rechtevergabe immer beibehalten</p><p>-- werden.</p><p>-- @within Originalfunktionen</p><p>    KnightTitles = {}</p><p>    KnightTitles.Knight     = 0</p><p>    KnightTitles.Mayor      = 1</p><p>    KnightTitles.Baron      = 2</p><p>    KnightTitles.Earl       = 3</p><p>    KnightTitles.Marquees   = 4</p><p>    KnightTitles.Duke       = 5</p><p>    KnightTitles.Archduke   = 6</p><p>    -- ---------------------------------------------------------------------- --</p><p>    -- Rechte und Pflichten                                                   --</p><p>    -- ---------------------------------------------------------------------- --</p><p>    NeedsAndRightsByKnightTitle = {}</p><p>    -- Ritter ------------------------------------------------------------------</p><p>    NeedsAndRightsByKnightTitle[KnightTitles.Knight] = {</p><p>        ActivateNeedForPlayer,</p><p>        {</p><p>            Needs.Nutrition,                                    -- Bedürfnis: Nahrung</p><p>            Needs.Medicine,                                     -- Bedürfnis: Medizin</p><p>        },</p><p>        ActivateRightForPlayer,</p><p>        {</p><p>            Technologies.R_Gathering,                           -- Recht: Rohstoffsammler</p><p>            Technologies.R_Woodcutter,                          -- Recht: Holzfäller</p><p>            Technologies.R_StoneQuarry,                         -- Recht: Steinbruch</p><p>            Technologies.R_HuntersHut,                          -- Recht: Jägerhütte</p><p>            Technologies.R_FishingHut,                          -- Recht: Fischerhütte</p><p>            Technologies.R_CattleFarm,                          -- Recht: Kuhfarm</p><p>            Technologies.R_GrainFarm,                           -- Recht: Getreidefarm</p><p>            Technologies.R_SheepFarm,                           -- Recht: Schaffarm</p><p>            Technologies.R_IronMine,                            -- Recht: Eisenmine</p><p>            Technologies.R_Beekeeper,                           -- Recht: Imkerei</p><p>            Technologies.R_HerbGatherer,                        -- Recht: Kräutersammler</p><p>            Technologies.R_Nutrition,                           -- Recht: Nahrung</p><p>            Technologies.R_Bakery,                              -- Recht: Bäckerei</p><p>            Technologies.R_Dairy,                               -- Recht: Käserei</p><p>            Technologies.R_Butcher,                             -- Recht: Metzger</p><p>            Technologies.R_SmokeHouse,                          -- Recht: Räucherhaus</p><p>            Technologies.R_Clothes,                             -- Recht: Kleidung</p><p>            Technologies.R_Tanner,                              -- Recht: Ledergerber</p><p>            Technologies.R_Weaver,                              -- Recht: Weber</p><p>            Technologies.R_Construction,                        -- Recht: Konstruktion</p><p>            Technologies.R_Wall,                                -- Recht: Mauer</p><p>            Technologies.R_Pallisade,                           -- Recht: Palisade</p><p>            Technologies.R_Trail,                               -- Recht: Pfad</p><p>            Technologies.R_KnockDown,                           -- Recht: Abriss</p><p>            Technologies.R_Sermon,                              -- Recht: Predigt</p><p>            Technologies.R_SpecialEdition,                      -- Recht: Special Edition</p><p>            Technologies.R_SpecialEdition_Pavilion,             -- Recht: Pavilion AeK SE</p><p>        }</p><p>    }</p><p>    -- Landvogt ----------------------------------------------------------------</p><p>    NeedsAndRightsByKnightTitle[KnightTitles.Mayor] = {</p><p>        ActivateNeedForPlayer,</p><p>        {</p><p>            Needs.Clothes,                                      -- Bedürfnis: KLeidung</p><p>        },</p><p>        ActivateRightForPlayer, {</p><p>            Technologies.R_Hygiene,                             -- Recht: Hygiene</p><p>            Technologies.R_Soapmaker,                           -- Recht: Seifenmacher</p><p>            Technologies.R_BroomMaker,                          -- Recht: Besenmacher</p><p>            Technologies.R_Military,                            -- Recht: Militär</p><p>            Technologies.R_SwordSmith,                          -- Recht: Schwertschmied</p><p>            Technologies.R_Barracks,                            -- Recht: Schwertkämpferkaserne</p><p>            Technologies.R_Thieves,                             -- Recht: Diebe</p><p>            Technologies.R_SpecialEdition_StatueFamily,         -- Recht: Familienstatue Aek SE</p><p>        },</p><p>        StartKnightsPromotionCelebration                        -- Beförderungsfest aktivieren</p><p>    }</p><p>    -- Baron -------------------------------------------------------------------</p><p>    NeedsAndRightsByKnightTitle[KnightTitles.Baron] = {</p><p>        ActivateNeedForPlayer,</p><p>        {</p><p>            Needs.Hygiene,                                      -- Bedürfnis: Hygiene</p><p>        },</p><p>        ActivateRightForPlayer, {</p><p>            Technologies.R_Medicine,                            -- Recht: Medizin</p><p>            Technologies.R_BowMaker,                            -- Recht: Bogenmacher</p><p>            Technologies.R_BarracksArchers,                     -- Recht: Bogenschützenkaserne</p><p>            Technologies.R_Entertainment,                       -- Recht: Unterhaltung</p><p>            Technologies.R_Tavern,                              -- Recht: Taverne</p><p>            Technologies.R_Festival,                            -- Recht: Fest</p><p>            Technologies.R_Street,                              -- Recht: Straße</p><p>            Technologies.R_SpecialEdition_Column,               -- Recht: Säule AeK SE</p><p>        },</p><p>        StartKnightsPromotionCelebration                        -- Beförderungsfest aktivieren</p><p>    }</p><p>    -- Graf --------------------------------------------------------------------</p><p>    NeedsAndRightsByKnightTitle[KnightTitles.Earl] = {</p><p>        ActivateNeedForPlayer,</p><p>        {</p><p>            Needs.Entertainment,                                -- Bedürfnis: Unterhaltung</p><p>            Needs.Prosperity,                                   -- Bedürfnis: Reichtum</p><p>        },</p><p>        ActivateRightForPlayer, {</p><p>            Technologies.R_SiegeEngineWorkshop,                 -- Recht: Belagerungswaffenschmied</p><p>            Technologies.R_BatteringRam,                        -- Recht: Ramme</p><p>            Technologies.R_Baths,                               -- Recht: Badehaus</p><p>            Technologies.R_AmmunitionCart,                      -- Recht: Munitionswagen</p><p>            Technologies.R_Prosperity,                          -- Recht: Reichtum</p><p>            Technologies.R_Taxes,                               -- Recht: Steuern einstellen</p><p>            Technologies.R_Ballista,                            -- Recht: Mauerkatapult</p><p>            Technologies.R_SpecialEdition_StatueSettler,        -- Recht: Siedlerstatue AeK SE</p><p>        },</p><p>        StartKnightsPromotionCelebration                        -- Beförderungsfest aktivieren</p><p>    }</p><p>    -- Marquees ----------------------------------------------------------------</p><p>    NeedsAndRightsByKnightTitle[KnightTitles.Marquees] = {</p><p>        ActivateNeedForPlayer,</p><p>        {</p><p>            Needs.Wealth,                                       -- Bedürfnis: Verschönerung</p><p>        },</p><p>        ActivateRightForPlayer, {</p><p>            Technologies.R_Theater,                             -- Recht: Theater</p><p>            Technologies.R_Wealth,                              -- Recht: Schmuckgebäude</p><p>            Technologies.R_BannerMaker,                         -- Recht: Bannermacher</p><p>            Technologies.R_SiegeTower,                          -- Recht: Belagerungsturm</p><p>            Technologies.R_SpecialEdition_StatueProduction,     -- Recht: Produktionsstatue AeK SE</p><p>        },</p><p>        StartKnightsPromotionCelebration                        -- Beförderungsfest aktivieren</p><p>    }</p><p>    -- Herzog ------------------------------------------------------------------</p><p>    NeedsAndRightsByKnightTitle[KnightTitles.Duke] = {</p><p>        ActivateNeedForPlayer, nil,</p><p>        ActivateRightForPlayer, {</p><p>            Technologies.R_Catapult,                            -- Recht: Katapult</p><p>            Technologies.R_Carpenter,                           -- Recht: Tischler</p><p>            Technologies.R_CandleMaker,                         -- Recht: Kerzenmacher</p><p>            Technologies.R_Blacksmith,                          -- Recht: Schmied</p><p>            Technologies.R_SpecialEdition_StatueDario,          -- Recht: Dariostatue AeK SE</p><p>        },</p><p>        StartKnightsPromotionCelebration                        -- Beförderungsfest aktivieren</p><p>    }</p><p>    -- Erzherzog ---------------------------------------------------------------</p><p>    NeedsAndRightsByKnightTitle[KnightTitles.Archduke] = {</p><p>        ActivateNeedForPlayer,nil,</p><p>        ActivateRightForPlayer, {</p><p>            Technologies.R_Victory                              -- Sieg</p><p>        },</p><p>        -- VictroryBecauseOfTitle,                              -- Sieg wegen Titel</p><p>        StartKnightsPromotionCelebration                        -- Beförderungsfest aktivieren</p><p>    }</p><p>    -- Reich des Ostens --------------------------------------------------------</p><p>    if g_GameExtraNo = 1 then</p><p>        local TechnologiesTableIndex = 4;</p><p>        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Mayor][TechnologiesTableIndex],Technologies.R_Cistern);</p><p>        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Mayor][TechnologiesTableIndex],Technologies.R_Beautification_Brazier);</p><p>        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Mayor][TechnologiesTableIndex],Technologies.R_Beautification_Shrine);</p><p>        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Baron][TechnologiesTableIndex],Technologies.R_Beautification_Pillar);</p><p>        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Earl][TechnologiesTableIndex],Technologies.R_Beautification_StoneBench);</p><p>        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Earl][TechnologiesTableIndex],Technologies.R_Beautification_Vase);</p><p>        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Marquees][TechnologiesTableIndex],Technologies.R_Beautification_Sundial);</p><p>        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Archduke][TechnologiesTableIndex],Technologies.R_Beautification_TriumphalArch);</p><p>        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Duke][TechnologiesTableIndex],Technologies.R_Beautification_VictoryColumn);</p><p>    end</p><p>    -- ---------------------------------------------------------------------- --</p><p>    -- Bedingungen                                                            --</p><p>    -- ---------------------------------------------------------------------- --</p><p>    KnightTitleRequirements = {}</p><p>    -- Ritter ------------------------------------------------------------------</p><p>    KnightTitleRequirements[KnightTitles.Mayor] = {}</p><p>    KnightTitleRequirements[KnightTitles.Mayor].Headquarters = 1</p><p>    KnightTitleRequirements[KnightTitles.Mayor].Settlers = 10</p><p>    KnightTitleRequirements[KnightTitles.Mayor].Products = {</p><p>        {GoodCategories.GC_Clothes, 6},</p><p>    }</p><p>    -- Baron -------------------------------------------------------------------</p><p>    KnightTitleRequirements[KnightTitles.Baron] = {}</p><p>    KnightTitleRequirements[KnightTitles.Baron].Settlers = 30</p><p>    KnightTitleRequirements[KnightTitles.Baron].Headquarters = 1</p><p>    KnightTitleRequirements[KnightTitles.Baron].Storehouse = 1</p><p>    KnightTitleRequirements[KnightTitles.Baron].Cathedrals = 1</p><p>    KnightTitleRequirements[KnightTitles.Baron].Products = {</p><p>        {GoodCategories.GC_Hygiene, 12},</p><p>    }</p><p>    -- Graf --------------------------------------------------------------------</p><p>    KnightTitleRequirements[KnightTitles.Earl] = {}</p><p>    KnightTitleRequirements[KnightTitles.Earl].Settlers = 50</p><p>    KnightTitleRequirements[KnightTitles.Earl].Headquarters = 2</p><p>    KnightTitleRequirements[KnightTitles.Earl].Products = {</p><p>        {GoodCategories.GC_Entertainment, 18},</p><p>    }</p><p>    -- Marquess ----------------------------------------------------------------</p><p>    KnightTitleRequirements[KnightTitles.Marquees] = {}</p><p>    KnightTitleRequirements[KnightTitles.Marquees].Settlers = 70</p><p>    KnightTitleRequirements[KnightTitles.Marquees].Headquarters = 2</p><p>    KnightTitleRequirements[KnightTitles.Marquees].Storehouse = 2</p><p>    KnightTitleRequirements[KnightTitles.Marquees].Cathedrals = 2</p><p>    KnightTitleRequirements[KnightTitles.Marquees].RichBuildings = 20</p><p>    -- Herzog ------------------------------------------------------------------</p><p>    KnightTitleRequirements[KnightTitles.Duke] = {}</p><p>    KnightTitleRequirements[KnightTitles.Duke].Settlers = 90</p><p>    KnightTitleRequirements[KnightTitles.Duke].Storehouse = 2</p><p>    KnightTitleRequirements[KnightTitles.Duke].Cathedrals = 2</p><p>    KnightTitleRequirements[KnightTitles.Duke].Headquarters = 3</p><p>    KnightTitleRequirements[KnightTitles.Duke].DecoratedBuildings = {</p><p>        {Goods.G_Banner, 9 },</p><p>    }</p><p>    -- Erzherzog ---------------------------------------------------------------</p><p>    KnightTitleRequirements[KnightTitles.Archduke] = {}</p><p>    KnightTitleRequirements[KnightTitles.Archduke].Settlers = 150</p><p>    KnightTitleRequirements[KnightTitles.Archduke].Storehouse = 3</p><p>    KnightTitleRequirements[KnightTitles.Archduke].Cathedrals = 3</p><p>    KnightTitleRequirements[KnightTitles.Archduke].Headquarters = 3</p><p>    KnightTitleRequirements[KnightTitles.Archduke].RichBuildings = 30</p><p>    KnightTitleRequirements[KnightTitles.Archduke].FullDecoratedBuildings = 30</p><p>    -- Einstellungen Aktivieren</p><p>    CreateTechnologyKnightTitleTable()</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundleminimapmarker.lua.html">
            <div class='doclink'>
                <div>BundleMinimapMarker</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia BundleMinimapMarker                                          # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ermöglocht das Anlegen von Markierungen auf der Minimap.</p><p>-- Mögliche Typen von Markierungen:</p><p>-- </p><p>-- Signal: Eine flüchtige Markierung, die nach wenigen Sekunden wieder</p><p>-- verschwindet.</p><p>-- </p><p>-- </p><p>-- </p><p>-- Die Farbe eines Markers kann auf 2 verschiedene Weisen bestimmt werden.</p><p>-- </p><p>-- Durch die Spielerfarbe des "Besitzers" der Markierung.</p><p>-- </p><p>-- </p><p>-- Durch Übergabe einer vordefinierten Farbe oder einer Farbtabelle</p><p>-- </p><p>-- API.CreateMinimapSignal(MarkerColor.Red, GetPosition("pos"));</p><p>-- API.CreateMinimapSignal({180, 180, 180}, GetPosition("pos"));</p><p>-- </p><p>-- </p><p>-- Durchsichtige Marker sind nicht vorgesehen!</p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>-- Vordefinierte Farben für Minimap Marker.</p><p>-- @field Blue Königsblau</p><p>-- @field Red Blutrot</p><p>-- @field Yellow Sonnengelb</p><p>-- @field Green Blattgrün</p><p>-- @usage API.CreateMinimapSignal(MarkerColor.Red, GetPosition("pos"));</p><p>    Blue    = { 17,   7, 216},</p><p>    Red     = {216,   7,   7},</p><p>    Yellow  = { 25, 185,   8},</p><p>    Green   = { 16, 194, 220},</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Erstellt eine flüchtige Markierung auf der Minimap.</p><p>-- : Die Farbe richtet sich nach der Spielerfarbe!</p><p>-- : CreateMinimapSignal</p><p>-- @param _PlayerID PlayerID oder Farbtabelle (Spielernummer oder Farbtabelle)</p><p>-- @param _Position Position des Markers (Skriptname, ID oder Position)</p><p>-- @return[type=number] ID des Markers</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.CreateMinimapSignal(1, GetPosition("pos"));</p><p>function API.CreateMinimapSignal(_PlayerID, _Position)</p><p>    if GUI then</p><p>        fatal("API.CreateMinimapSignal: Can not be used in local script!");</p><p>        return;</p><p>    end</p><p>    local Position = _Position;</p><p>    if type(_Position) ~= "table" then</p><p>        Position = GetPosition(_Position);</p><p>    end</p><p>    if type(Position) ~= "table" or (not Position.X or not Position.X) then</p><p>        fatal("API.CreateMinimapSignal: Position is invalid!");</p><p>        return;</p><p>    end</p><p>    return BundleMinimapMarker.Global:CreateMinimapMarker(_PlayerID, Position.X, Position.Y, 7);</p><p>-- Erstellt eine statische Markierung auf der Minimap.</p><p>-- : Die Farbe richtet sich nach der Spielerfarbe!</p><p>-- : CreateMinimapMarker</p><p>-- @param _PlayerID PlayerID oder Farbtabelle (Spielernummer oder Farbtabelle)</p><p>-- @param _Position Position des Markers (Skriptname, ID oder Position)</p><p>-- @return[type=number] ID des Markers</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.CreateMinimapMarker(1, GetPosition("pos"));</p><p>function API.CreateMinimapMarker(_PlayerID, _Position)</p><p>    if GUI then</p><p>        fatal("API.CreateMinimapMarker: Can not be used in local script!");</p><p>        return;</p><p>    end</p><p>    local Position = _Position;</p><p>    if type(_Position) ~= "table" then</p><p>        Position = GetPosition(_Position);</p><p>    end</p><p>    if type(Position) ~= "table" or (not Position.X or not Position.X) then</p><p>        fatal("API.CreateMinimapMarker: Position is invalid!");</p><p>        return;</p><p>    end</p><p>    return BundleMinimapMarker.Global:CreateMinimapMarker(_PlayerID, Position.X, Position.Y, 6);</p><p>-- Erstellt eine pulsierende Markierung auf der Minimap.</p><p>-- : Die Farbe richtet sich nach der Spielerfarbe!</p><p>-- : CreateMinimapPulse</p><p>-- @param _PlayerID PlayerID oder Farbtabelle (Spielernummer oder Farbtabelle)</p><p>-- @param _Position Position des Markers (Skriptname, ID oder Position)</p><p>-- @return[type=number] ID des Markers</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.CreateMinimapPulse(1, GetPosition("pos"));</p><p>function API.CreateMinimapPulse(_PlayerID, _Position)</p><p>    if GUI then</p><p>        fatal("API.CreateMinimapPulse: Can not be used in local script!");</p><p>        return;</p><p>    end</p><p>    local Position = _Position;</p><p>    if type(_Position) ~= "table" then</p><p>        Position = GetPosition(_Position);</p><p>    end</p><p>    </p><p>    if type(Position) ~= "table" or (not Position.X or not Position.X) then</p><p>        fatal("API.CreateMinimapPulse: Position is invalid!");</p><p>        return;</p><p>    end</p><p>    return BundleMinimapMarker.Global:CreateMinimapMarker(_PlayerID, Position.X, Position.Y, 1);</p><p>-- Zerstört eine Markierung auf der Minimap.</p><p>-- : DestroyMinimapSignal</p><p>-- @param[type=number] _ID ID des Markers</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.DestroyMinimapSignal(SomeMarkerID);</p><p>function API.DestroyMinimapSignal(_ID)</p><p>    if GUI then</p><p>        fatal("API.DestroyMinimapSignal: Can not be used in local script!");</p><p>        return;</p><p>    end</p><p>    if type(_ID) ~= "number" then</p><p>        fatal("API.DestroyMinimapSignal: _ID must be a number!");</p><p>        return;</p><p>    end</p><p>    BundleMinimapMarker.Global:DestroyMinimapMarker(_ID);</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {</p><p>        Data = {</p><p>            MarkerCounter = 1000000,</p><p>            CreatedMinimapMarkers = {},</p><p>        },</p><p>    },</p><p>    Local = {</p><p>        Data = {},</p><p>    }</p><p>-- Global Script ---------------------------------------------------------------</p><p>-- Initialisiert das Bundle im globalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    API.AddSaveGameAction(self.OnSaveGameLoaded);</p><p>-- Erstellt eine neue Markierung auf der Minimap.</p><p>-- </p><p>-- @param[type=number] _PlayerID ID des Besitzers</p><p>-- @param[type=number] _X X-Koordinate des Markers</p><p>-- @param[type=number] _Y Y-Koordinate des Makers</p><p>-- @param[type=number] _Type Typ des Markers</p><p>-- @return[type=number] ID des Markers</p><p>-- @within Internal</p><p>-- @local</p><p>    self.Data.MarkerCounter = self.Data.MarkerCounter +1;</p><p>    -- Flüchtige Markierungen werden nicht gespeichert!</p><p>    self.Data.CreatedMinimapMarkers[self.Data.MarkerCounter] = {</p><p>        _PlayerID, _X, _Y, _Type</p><p>    };</p><p>    self:ShowMinimapMarker(self.Data.MarkerCounter);</p><p>    return self.Data.MarkerCounter;</p><p>-- Zerstort eine Markierung auf der Minimap.</p><p>-- </p><p>-- @param[type=number] _ID ID des Markers</p><p>-- @within Internal</p><p>-- @local</p><p>    self.Data.CreatedMinimapMarkers[_ID] = nil;</p><p>    API.Bridge([[GUI.DestroyMinimapSignal(]] .._ID.. [[)]]);</p><p>-- Zeigt eine erstellte Markierung auf der Minimap an.</p><p>-- </p><p>-- @param[type=number] _ID ID des Markers</p><p>-- @within Internal</p><p>-- @local</p><p>    if not self.Data.CreatedMinimapMarkers[_ID] then</p><p>        return;</p><p>    end</p><p>    local Marker = self.Data.CreatedMinimapMarkers[_ID];</p><p>    local ColorOrPlayerID = Marker[1];</p><p>    if type(ColorOrPlayerID) == "table" then</p><p>        ColorOrPlayerID = API.ConvertTableToString(ColorOrPlayerID);</p><p>    end</p><p>    API.Bridge([[</p><p>        BundleMinimapMarker.Local:ShowMinimapMarker(</p><p>            ]] .._ID.. [[,]] ..ColorOrPlayerID.. [[,]] ..Marker[2].. [[,]] ..Marker[3].. [[, ]] ..Marker[4].. [[</p><p>        )</p><p>    ]]);</p><p>-- Stellt Markierungen auf der Minimap wieder her, wenn ein Spielstand</p><p>-- geladen wird.</p><p>-- </p><p>-- @within Internal</p><p>-- @local</p><p>    for k, v in pairs(BundleMinimapMarker.Global.Data.CreatedMinimapMarkers) do</p><p>        if v and v[4] ~= 7 then</p><p>            BundleMinimapMarker.Global:ShowMinimapMarker(k);</p><p>        end</p><p>    end</p><p>-- Local Script ------------------------------------------------------------- --</p><p>-- Initialisiert das Bundle im globalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>-- Initialisiert das Bundle im globalen Skript.</p><p>-- @param[type=number] _PlayerID ID des Besitzers</p><p>-- @param[type=number] _X X-Koordinate des Markers</p><p>-- @param[type=number] _Y Y-Koordinate des Makers</p><p>-- @param[type=number] _Type Typ des Markers</p><p>-- @return[type=number] ID des Markers</p><p>-- @within Internal</p><p>-- @local</p><p>    local R, G, B;</p><p>    if type(_PlayerID) == "number" then</p><p>        R, G, B = GUI.GetPlayerColor(_PlayerID);</p><p>    else</p><p>        R = _PlayerID[1];</p><p>        G = _PlayerID[2];</p><p>        B = _PlayerID[3];</p><p>    end</p><p>    GUI.CreateMinimapSignalRGBA(_ID, _X, _Y, R, G, B, 255, _Type);</p><p>-- -------------------------------------------------------------------------- --</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundlemusictools.lua.html">
            <div class='doclink'>
                <div>BundleMusicTools</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia BundleMusicTools                                             # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Dieses Bundle bietet die Möglichkeit Musikstücke abzuspielen. Die</p><p>-- Musik kann als einzelne Titel oder als Playlist wiedergegeben werden.</p><p>-- </p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet ein Musikstück als Stimme.</p><p>-- </p><p>-- Es wird nicht als Musik behandelt, sondern als Sprache! Die Lautstäkre</p><p>-- sämtlicher Sprache wird beeinflusst, weshalb immer nur 1 Song gleichzeitig</p><p>-- gespielt werden kann! Alle als Sprache abgespielten Sounds werden die</p><p>-- gleiche Lautstärke haben, wie die Musik.</p><p>-- _Description hat folgendes Format:</p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- @param[type=table] _Description Definition des Musikstück</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.StartMusic({</p><p>--     File     = "music/s6_10_antagonist.mp3",</p><p>--     Volume   = 70,</p><p>--     Length   = 49,</p><p>--     Fadeout  = 20,</p><p>--     MuteAtmo = true;</p><p>--     MuteUI   = true,</p><p>-- });</p><p>function API.StartMusic(_Description)</p><p>    if GUI then</p><p>        API.Fatal("Could not execute API.StartMusic in local script!");</p><p>        return;</p><p>    end</p><p>    BundleMusicTools.Global:StartSong(_Description);</p><p>-- Vereinfachter einzeiliger Aufruf für StartSong.</p><p>-- </p><p>-- @param[type=string] _File Pfad zur Datei</p><p>-- @param[type=number] _Volume Lautstärke</p><p>-- @param[type=number] _Length Abspieldauer (= Dauer Musikstück)</p><p>-- @param[type=number] _FadeOut Ausblenden in Sekunden</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.StartMusicSimple("music/s6_10_antagonist.mp3", 70, 49, 1)</p><p>function API.StartMusicSimple(_File, _Volume, _Length, _FadeOut)</p><p>    if GUI then</p><p>        API.Bridge("API.StartMusicSimple('" .._File.. "', " .._Volume.. ", " .._Length.. ", " .._FadeOut.. ")");</p><p>        return;</p><p>    end</p><p>    local Data = {</p><p>        File     = _File,</p><p>        Volume   = _Volume,</p><p>        Length   = _Length,</p><p>        Fadeout  = _FadeOut * 10,</p><p>        MuteAtmo = true;</p><p>        MuteUI   = true,</p><p>    };</p><p>    BundleMusicTools.Global:StartSong(Data);</p><p>-- Spielt eine Playlist ab.</p><p>-- </p><p>-- Eine im Skript definierte Playlist, nicht</p><p>-- eine XML! Die Playlist kann einmal abgearbeitet oder auf Wiederholung</p><p>-- gestellt werden. Alle Einträge haben das Format von StartSong!</p><p>-- Zusätzlich kann der Wahrheitswert Repeat gesetzt werden, damit</p><p>-- sich die Playlist endlos wiederholt.</p><p>-- @param[type=table] _Playlist Definition der Playlist</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- local Playlist = {</p><p>--     {</p><p>--         File     = "music/s6_10_antagonist.mp3",</p><p>--         Volume   = 70,</p><p>--         Length   = 49,</p><p>--         Fadeout  = 20,</p><p>--         MuteAtmo = true;</p><p>--         MuteUI   = true,</p><p>--     },</p><p>--     {</p><p>--         File     = "music/s6_04_blaze.mp3",</p><p>--         Volume   = 70,</p><p>--         Length   = 65,</p><p>--         Fadeout  = 20,</p><p>--         MuteAtmo = false;</p><p>--         MuteUI   = true,</p><p>--     },</p><p>-- }</p><p>-- API.StartPlaylist(Playlist);</p><p>function API.StartPlaylist(_Playlist)</p><p>    if GUI then</p><p>        API.Fatal("Could not execute API.StartPlaylist in local script!");</p><p>        return;</p><p>    end</p><p>    BundleMusicTools.Global:StartPlaylist(_Playlist);</p><p>-- Stoppt gerade gespielte Musik und startet die Playlist mit dem</p><p>-- angegebenen Titel. Es muss eine Playlist existieren! Nachdem der</p><p>-- Titel abgespielt ist, wird die Playlist normal weiter gespielt.</p><p>-- </p><p>-- @param[type=number] _Title Index des Titels</p><p>-- @within Anwenderfunktionen</p><p>function API.StartPlaylistTitle(_Title)</p><p>    if GUI then</p><p>        API.Fatal("Could not execute API.StartPlaylistTitle in local script!");</p><p>        return;</p><p>    end</p><p>    BundleMusicTools.Global:StartPlaylistTitle(_Title);</p><p>-- Stopt Musik und stellt die alte Soundkonfiguration wieder her.</p><p>-- </p><p>-- @within Anwenderfunktionen</p><p>function API.StopSong()</p><p>    if GUI then</p><p>        API.Bridge("API.StopSong()");</p><p>        return;</p><p>    end</p><p>    BundleMusicTools.Global:StopSong();</p><p>-- Stopt den gerade laufenden Song und leert sowohl die Songdaten</p><p>-- als auch die Playlist.</p><p>-- </p><p>-- @within Anwenderfunktionen</p><p>function API.AbortMusic()</p><p>    if GUI then</p><p>        API.Bridge("API.AbortMusic()");</p><p>        return;</p><p>    end</p><p>    BundleMusicTools.Global:AbortMusic();</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {</p><p>        Data = {</p><p>            StartSongData = {},</p><p>            StartSongPlaylist = {},</p><p>            StartSongQueue = {},</p><p>        }</p><p>    },</p><p>    Local = {</p><p>        Data = {</p><p>            SoundBackup = {},</p><p>        }</p><p>    },</p><p>-- Global Script ---------------------------------------------------------------</p><p>-- Initalisiert das Bundle im globalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>-- Startet ein Musikstück als Stimme.</p><p>-- @param[type=table] _Description Beschreibung des Musikstücks</p><p>-- @within Internal</p><p>-- @local</p><p>    if self.Data.StartSongData.Running then</p><p>        table.insert(self.Data.StartSongQueue, _Description);</p><p>    else</p><p>        assert(type(_Description.File) == "string");</p><p>        assert(type(_Description.Volume) == "number");</p><p>        assert(type(_Description.Length) == "number");</p><p>        _Description.Length = _Description.Length * 10;</p><p>        assert(type(_Description.Fadeout) == "number");</p><p>        _Description.MuteAtmo = _Description.MuteAtmo == true;</p><p>        _Description.MuteUI = _Description.MuteUI == true;</p><p>        _Description.CurrentVolume = _Description.Volume;</p><p>        _Description.Time = 0;</p><p>        self.Data.StartSongData = _Description;</p><p>        self.Data.StartSongData.Running = true;</p><p>        Logic.ExecuteInLuaLocalState([[</p><p>            BundleMusicTools.Local:BackupSound(</p><p>                ]].. _Description.Volume ..[[,</p><p>                "]].. _Description.File ..[[",</p><p>                ]].. tostring(_Description.MuteAtmo) ..[[,</p><p>                ]].. tostring(_Description.MuteUI) ..[[</p><p>            )</p><p>        ]])</p><p>        if not self.Data.StartSongJob then</p><p>            self.Data.StartSongJob = StartSimpleHiResJob("StartSongControl");</p><p>        end</p><p>    end</p><p>-- Spielt eine Playlist ab.</p><p>-- @param[type=table] _Playlist Playlist</p><p>-- @within Internal</p><p>-- @local</p><p>    for i=1, #_Playlist, 1 do</p><p>        table.insert(self.Data.StartSongPlaylist, _Playlist[i]);</p><p>        self:StartSong(_Playlist[i]);</p><p>    end</p><p>    self.Data.StartSongPlaylist.Repeat = _Playlist.Repeat == true;</p><p>-- Stoppt gerade gespielte Musik und startet die Playlist mit dem</p><p>-- angegebenen Titel. Es muss eine Playlist existieren! Nachdem der</p><p>-- Titel abgespielt ist, wird die Playlist normal weiter gespielt.</p><p>-- @param[type=number] _Title Index des Titels</p><p>-- @within Internal</p><p>-- @local</p><p>    local playlist = self.Data.StartSongPlaylist;</p><p>    local length = #length;</p><p>    if (length = _Title) then</p><p>        self.Data.StartSongData.Running = false;</p><p>        self.Data.StartSongQueue = {};</p><p>        self.Data.StartSongData = {};</p><p>        self:StopSong();</p><p>        EndJob(self.Data.StartSongJob);</p><p>        self.Data.StartSongJob = nil;</p><p>        for i=_Title, length, 1 do</p><p>            self:StartSong(playlist);</p><p>        end</p><p>    end</p><p>-- Stopt Musik und stellt die alte Soundkonfiguration wieder her.</p><p>-- @within Internal</p><p>-- @local</p><p>    local Queue = #self.Data.StartSongQueue;</p><p>    local Data = self.Data.StartSongData;</p><p>    Logic.ExecuteInLuaLocalState([[</p><p>        BundleMusicTools.Local:ResetSound(</p><p>            "]].. ((Data.File ~= nil and Data.File) or "") ..[[",</p><p>            ]].. Queue ..[[</p><p>        )</p><p>    ]]);</p><p>-- Stopt den gerade laufenden Song und leert sowohl die Songdaten</p><p>-- als auch die Playlist.</p><p>-- @within Internal</p><p>-- @local</p><p>    self.Data.StartSongPlaylist = {};</p><p>    self.Data.StartSongQueue = {};</p><p>    self:StopSong();</p><p>    self.Data.StartSongData = {};</p><p>    EndJob(self.Data.StartSongJob);</p><p>    self.Data.StartSongJob = nil;</p><p>-- Kontrolliert den Song / die Playlist. Wenn ein Song durch ist, wird</p><p>-- der nächste Song in der Warteschlange gestartet, sofern vorhanden.</p><p>-- Ist die Warteschlange leer, endet der Job. Existiert eine Playlist,</p><p>-- für die Repeat = true ist, dann wird die Playlist neu gestartet.</p><p>-- @within Internal</p><p>-- @local</p><p>    if not BundleMusicTools.Global.Data.StartSongData.Running then</p><p>        BundleMusicTools.Global.Data.StartSongData = {};</p><p>        BundleMusicTools.Global.Data.StartSongJob = nil;</p><p>        if #BundleMusicTools.Global.Data.StartSongQueue  0 then</p><p>            local Description = table.remove(BundleMusicTools.Global.Data.StartSongQueue, 1);</p><p>            BundleMusicTools.Global:StartSong(Description);</p><p>        else</p><p>            if BundleMusicTools.Global.Data.StartSongPlaylist.Repeat then</p><p>                BundleMusicTools.Global:StartPlaylist(BundleMusicTools.Global.Data.StartSongPlaylist);</p><p>            end</p><p>        end</p><p>        return true;</p><p>    end</p><p>    local Data = BundleMusicTools.Global.Data.StartSongData;</p><p>    -- Zeit zählen</p><p>    BundleMusicTools.Global.Data.StartSongData.Time = Data.Time +1;</p><p>    if Data.Fadeout  5 then</p><p>        if Data.Time = Data.Length then</p><p>            BundleMusicTools.Global.Data.StartSongData.Running = false;</p><p>            BundleMusicTools.Global:StopSong();</p><p>        end</p><p>    else</p><p>        local FadeoutTime = Data.Length - Data.Fadeout+1;</p><p>        if Data.Time = FadeoutTime then</p><p>            if Data.Time = Data.Length then</p><p>                BundleMusicTools.Global.Data.StartSongData.Running = false;</p><p>                BundleMusicTools.Global:StopSong();</p><p>            else</p><p>                local VolumeStep = Data.Volume / Data.Fadeout;</p><p>                BundleMusicTools.Global.Data.StartSongData.CurrentVolume = Data.CurrentVolume - VolumeStep;</p><p>                Logic.ExecuteInLuaLocalState([[</p><p>                    Sound.SetSpeechVolume(]]..Data.CurrentVolume..[[)</p><p>                ]]);</p><p>            end</p><p>        end</p><p>    end</p><p>-- Local Script ----------------------------------------------------------------</p><p>-- Initalisiert das Bundle im lokalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>-- Speichert die Soundeinstellungen.</p><p>-- @param[type=number]  _Volume Lautstärke</p><p>-- @param[type=string]  _Song Pfad zum Titel</p><p>-- @param[type=boolean] _MuteAtmo Atmosphäre stumm schalten</p><p>-- @param[type=boolean] _MuteUI UI stumm schalten</p><p>-- @within Internal</p><p>-- @local</p><p>    if self.Data.SoundBackup.FXSP == nil then</p><p>        self.Data.SoundBackup.FXSP = Sound.GetFXSoundpointVolume();</p><p>        self.Data.SoundBackup.FXAtmo = Sound.GetFXAtmoVolume();</p><p>        self.Data.SoundBackup.FXVol = Sound.GetFXVolume();</p><p>        self.Data.SoundBackup.Sound = Sound.GetGlobalVolume();</p><p>        self.Data.SoundBackup.Music = Sound.GetMusicVolume();</p><p>        self.Data.SoundBackup.Voice = Sound.GetSpeechVolume();</p><p>        self.Data.SoundBackup.UI = Sound.Get2DFXVolume();</p><p>    end</p><p>    Sound.SetFXVolume(100);</p><p>    Sound.SetSpeechVolume(_Volume);</p><p>    if _MuteAtmo == true then</p><p>        Sound.SetFXSoundpointVolume(0);</p><p>        Sound.SetFXAtmoVolume(0);</p><p>    end</p><p>    if _MuteUI == true then</p><p>        Sound.Set2DFXVolume(0);</p><p>        Sound.SetFXVolume(0);</p><p>    end</p><p>    Sound.SetMusicVolume(0);</p><p>    Sound.PlayVoice("ImportantStuff", _Song);</p><p>-- Stellt die Soundeinstellungen wieder her.</p><p>-- @param[type=string] _File Pfad zur Datei</p><p>-- @param[type=number] _QueueLength Länge der Warteschlange</p><p>-- @within Internal</p><p>-- @local</p><p>    if _File ~= nil then</p><p>        Sound.StopVoice("ImportantStuff", _File)</p><p>    end</p><p>    if _QueueLength = 0 then</p><p>        if self.Data.SoundBackup.FXSP ~= nil then</p><p>            Sound.SetFXSoundpointVolume(self.Data.SoundBackup.FXSP)</p><p>            Sound.SetFXAtmoVolume(self.Data.SoundBackup.FXAtmo)</p><p>            Sound.SetFXVolume(self.Data.SoundBackup.FXVol)</p><p>            Sound.SetGlobalVolume(self.Data.SoundBackup.Sound)</p><p>            Sound.SetMusicVolume(self.Data.SoundBackup.Music)</p><p>            Sound.SetSpeechVolume(self.Data.SoundBackup.Voice)</p><p>            Sound.Set2DFXVolume(self.Data.SoundBackup.UI)</p><p>            self.Data.SoundBackup = {}</p><p>        end</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundlenonplayercharacter.lua.html">
            <div class='doclink'>
                <div>BundleNonPlayerCharacter</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia BundleNonPlayerCharacter                                     # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Mit diesem Bundle wird ein spezieller Modus für Nichtspieler-Charaktere</p><p>-- bereitgestellt. Die Helden eines Spielers können mit diesen NPCs sprechen.</p><p>-- Dazu muss der Held selektiert sein. Dann kann der Spieler ihm mit einem</p><p>-- Rechtsklick befehlen, den NPC anzusprechen. Dabei wird der Mauszeiger zu</p><p>-- einer Hand.</p><p>-- Ein NPC wird durch ein leichtes Glitzern auf der Spielwelt hervorgehoben.</p><p>-- </p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Erstellt einen neuen NPC für den angegebenen Siedler.</p><p>-- Der NPC wird sofort aktiviert und kann angesprochen werden. Er wird durch</p><p>-- eine glitzernde Aura hervorgehoben.</p><p>-- Mögliche Einstellungen für den NPC:</p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- @param[type=table] _Data Nichtspieler-Charakter</p><p>-- @return[type=table] NonPlayerCharacter Objekt</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.NpcCompose {</p><p>--     Name     = "horst",</p><p>--     Callback = function(_Npc, _Hero)</p><p>--        -- Hier kann was passieren</p><p>--     end,</p><p>-- }</p><p>function API.NpcCompose(_Data)</p><p>    local WronHeroCallback = function(_Npc)</p><p>        if _Npc.WrongHeroMessage then</p><p>            API.Note(_Npc.WrongHeroMessage);</p><p>        end</p><p>    end</p><p>    local NPC = QSB.NonPlayerCharacter:New(_Data.Name);</p><p>    NPC:SetDialogPartner(_Data.Hero);</p><p>    NPC:SetWrongPartnerCallback(WronHeroCallback);</p><p>    NPC:SetCallback(_Data.Callback);</p><p>    return NPC:Activate();</p><p>-- Entfernt den NPC komplett vom Entity. Das Entity bleibt dabei erhalten.</p><p>-- </p><p>-- @param _Entity Nichtspieler-Charakter (Skriptname oder ID)</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.NpcDispose("horst")</p><p>function API.NpcDispose(_Entity)</p><p>    local ScriptName = Logic.GetEntityName(GetID(_Entity));</p><p>    local NPC = QSB.NonPlayerCharacter:GetInstance(ScriptName);</p><p>    if not NPC then</p><p>        return;</p><p>    end</p><p>    NPC:Dispose();</p><p>-- Aktiviert einen inaktiven NPC. Wenn ein NPC bereits gesprochen hat, muss</p><p>-- er zuvor zurückgesetzt werden.</p><p>-- </p><p>-- @param _Entity Nichtspieler-Charakter (Skriptname oder ID)</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.NpcActivate("horst")</p><p>function API.NpcActivate(_Entity)</p><p>    local ScriptName = Logic.GetEntityName(GetID(_Entity));</p><p>    local NPC = QSB.NonPlayerCharacter:GetInstance(ScriptName);</p><p>    if not NPC then</p><p>        return;</p><p>    end</p><p>    NPC:Activate();</p><p>-- Deaktiviert einen NPC, sodass dieser nicht angesprochen werden kann.</p><p>-- </p><p>-- @param _Entity Nichtspieler-Charakter (Skriptname oder ID)</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.NpcDeactivate("horst")</p><p>function API.NpcDeactivate(_Entity)</p><p>    local ScriptName = Logic.GetEntityName(GetID(_Entity));</p><p>    local NPC = QSB.NonPlayerCharacter:GetInstance(ScriptName);</p><p>    if not NPC then</p><p>        return;</p><p>    end</p><p>    NPC:Deactivate();</p><p>-- Setzt einen NPC zurück, sodass er nicht mehr als angesprochen gilt.</p><p>-- </p><p>-- @param _Entity Nichtspieler-Charakter (Skriptname oder ID)</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.NpcReset("horst")</p><p>function API.NpcReset(_Entity)</p><p>    local ScriptName = Logic.GetEntityName(GetID(_Entity));</p><p>    local NPC = QSB.NonPlayerCharacter:GetInstance(ScriptName);</p><p>    if not NPC then</p><p>        return;</p><p>    end</p><p>    NPC:Reset();</p><p>-- Prüft, ob der NPC bereits angesprochen wurde. Wenn ein Ansprechpartner</p><p>-- vorgegeben ist, muss dieser den NPC ansprechen.</p><p>-- </p><p>-- @param _Entity Nichtspieler-Charakter (Skriptname oder ID)</p><p>-- @return[type=boolean] NPC wurde angesprochen</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.NpcHasSpoken("horst")</p><p>function API.NpcHasSpoken(_Entity)</p><p>    local ScriptName = Logic.GetEntityName(GetID(_Entity));</p><p>    local NPC = QSB.NonPlayerCharacter:GetInstance(ScriptName);</p><p>    if not NPC then</p><p>        return;</p><p>    end</p><p>    return NPC:HasTalkedTo();</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Klassen                                                                    --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Konstruktor</p><p>-- @param[type=string] _ScriptName Skriptname des NPC</p><p>-- @within QSB.NonPlayerCharacter</p><p>-- @usage</p><p>-- -- Einen normalen NPC erzeugen:</p><p>-- QSB.NonPlayerCharacter:New("npc")</p><p>--     :SetDialogPartner("hero")                 -- Optional</p><p>--     :SetCallback(Briefing1)                   -- Optional</p><p>--     :Activate();</p><p>    assert(self == QSB.NonPlayerCharacter, 'Can not be used from instance!');</p><p>    local npc = API.InstanceTable(self);</p><p>    npc.m_NpcName  = _ScriptName;</p><p>    npc.m_NpcType  = BundleNonPlayerCharacter.Global.DefaultNpcType</p><p>    npc.m_Distance = 350;</p><p>    if Logic.IsKnight(GetID(_ScriptName)) then</p><p>        npc.m_Distance = 400;</p><p>    end</p><p>    QSB.NonPlayerCharacterObjects[_ScriptName] = npc;</p><p>    npc:CreateMarker();</p><p>    return npc;</p><p>-- Gibt das Objekt des NPC zurück, wenn denn eins für dieses Entity existiert.</p><p>-- Wurde noch kein NPC für diesen Skriptnamen erzeugt, wird nil zurückgegeben.</p><p>-- @param[type=string] _ScriptName Skriptname des NPC</p><p>-- @return[type=table] Interaktives Objekt</p><p>-- @within QSB.NonPlayerCharacter</p><p>-- @usage -- NPC ermitteln</p><p>-- local NPC = QSB.NonPlayerCharacter:GetInstance("horst");</p><p>-- -- Etwas mit dem NPC tun</p><p>-- NPC:SetDialogPartner("hilda");</p><p>    assert(self == QSB.NonPlayerCharacter, 'Can not be used from instance!');</p><p>    local EntityID = GetID(_ScriptName)</p><p>    local ScriptName = Logic.GetEntityName(EntityID);</p><p>    if Logic.IsEntityInCategory(EntityID, EntityCategories.Soldier) == 1 then</p><p>        local LeaderID = Logic.SoldierGetLeaderEntityID(EntityID);</p><p>        if IsExisting(LeaderID) then</p><p>            ScriptName = Logic.GetEntityName(LeaderID);</p><p>        end</p><p>    end</p><p>    return QSB.NonPlayerCharacterObjects[ScriptName];</p><p>-- Gibt die Entity ID des letzten angesprochenen NPC zurück.</p><p>-- @return[type=number] ID des letzten NPC</p><p>-- @within QSB.NonPlayerCharacter</p><p>    assert(self == QSB.NonPlayerCharacter, 'Can not be used from instance!');</p><p>    return BundleNonPlayerCharacter.Global.LastNpcEntityID;</p><p>-- Gibt die Entity ID des letzten Helden zurück, der einen NPC</p><p>-- angesprochen hat.</p><p>-- @return[type=number] ID des letzten Heden</p><p>-- @within QSB.NonPlayerCharacter</p><p>    assert(self == QSB.NonPlayerCharacter, 'Can not be used from instance!');</p><p>    return BundleNonPlayerCharacter.Global.LastHeroEntityID;</p><p>-- Gibt die Entity ID des NPC zurück. Ist der NPC ein Leader, wird</p><p>-- der erste Soldat zurückgegeben, wenn es einen gibt.</p><p>-- @return[type=number] ID des NPC</p><p>-- @within QSB.NonPlayerCharacter</p><p>    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');</p><p>    local EntityID = GetID(self.m_NpcName);</p><p>    if Logic.IsEntityInCategory(EntityID, EntityCategories.Leader) == 1 then</p><p>        local Soldiers = {Logic.GetSoldiersAttachedToLeader(EntityID)};</p><p>        if Soldiers[1]  0 then</p><p>            return Soldiers[2];</p><p>        end</p><p>    end</p><p>    return EntityID</p><p>-- Löscht einen NPC.</p><p>-- @within QSB.NonPlayerCharacter</p><p>-- @usage -- NPC löschen</p><p>-- NPC:Dispose();</p><p>    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');</p><p>    self:Deactivate();</p><p>    self:DestroyMarker();</p><p>    QSB.NonPlayerCharacterObjects[self.m_NpcName] = nil;</p><p>-- Aktiviert einen inaktiven NPC, sodass er wieder angesprochen werden kann.</p><p>-- @param[type=number] _Type NPC-Typ [1-4]</p><p>-- @return[type=table] self</p><p>-- @within QSB.NonPlayerCharacter</p><p>-- @usage -- NPC aktivieren:</p><p>-- NPC:Activate();</p><p>    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');</p><p>    if IsExisting(self.m_NpcName) then</p><p>        Logic.SetOnScreenInformation(self:GetID(), _Type or self.m_NpcType);</p><p>        self:ShowMarker();</p><p>    end</p><p>    return self;</p><p>-- Deaktiviert einen aktiven NPC, sodass er nicht angesprochen werden kann.</p><p>-- @return[type=table] self</p><p>-- @within QSB.NonPlayerCharacter</p><p>-- @usage -- NPC deaktivieren:</p><p>-- NPC:Deactivate();</p><p>    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');</p><p>    if IsExisting(self.m_NpcName) then</p><p>        Logic.SetOnScreenInformation(self:GetID(), 0);</p><p>        self:HideMarker();</p><p>    end</p><p>    return self;</p><p>-- </p><p>-- @return[type=boolean] NPC ist aktiv</p><p>-- @within QSB.NonPlayerCharacter</p><p>    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');</p><p>    return Logic.GetEntityScriptingValue(self:GetID(), 6)  0;</p><p>-- Setzt den NPC zurück, sodass er erneut aktiviert werden kann.</p><p>-- @return[type=table] self</p><p>-- @within QSB.NonPlayerCharacter</p><p>    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');</p><p>    if IsExisting(self.m_NpcName) then</p><p>        Logic.SetOnScreenInformation(self:GetID(), 0);</p><p>        self.m_TalkedTo = nil;</p><p>        self:HideMarker();</p><p>    end</p><p>    return self;</p><p>-- Gibt true zurück, wenn der NPC angesprochen wurde. Ist ein</p><p>-- spezieller Ansprechpartner definiert, wird nur dann true</p><p>-- zurückgegeben, wenn dieser Held mit dem NPC spricht.</p><p>-- @return[type=boolean] NPC wurde angesprochen</p><p>-- @within QSB.NonPlayerCharacter</p><p>    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');</p><p>    if self.m_HeroName then</p><p>        return self.m_TalkedTo == GetID(self.m_HeroName);</p><p>    end</p><p>    return self.m_TalkedTo ~= nil;</p><p>-- Gibt die Entity ID des letzten angesprochenen NPC zurück.</p><p>-- @param[type=number] _Type Typ des Npc</p><p>-- @return[type=number] ID des letzten NPC</p><p>-- @within QSB.NonPlayerCharacter</p><p>    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');</p><p>    self.m_NpcType = _Type;</p><p>    if _Type  1 then</p><p>        self:HideMarker();</p><p>    end</p><p>    return self;</p><p>-- Setzt die Entfernung, die unterschritten werden muss, damit</p><p>-- ein NPC als angesprochen gilt.</p><p>-- @param[type=number] _Distance Aktivierungsdistanz</p><p>-- @within QSB.NonPlayerCharacter</p><p>    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');</p><p>    self.m_Distance = _Distance or 350;</p><p>    return self;</p><p>-- Setzt den Ansprechpartner für diesen NPC.</p><p>-- @param[type=string] _HeroName Skriptname des Helden</p><p>-- @return[type=table] self</p><p>-- @within QSB.NonPlayerCharacter</p><p>    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');</p><p>    self.m_HeroName = _HeroName;</p><p>    return self;</p><p>-- Setzt das Callback für den Fall, dass ein falscher Held den</p><p>-- NPC anspricht.</p><p>-- @param[type=function] _Callback Callback</p><p>-- @return[type=table] self</p><p>-- @within QSB.NonPlayerCharacter</p><p>    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');</p><p>    self.m_WrongHeroCallback = _Callback;</p><p>    return self;</p><p>-- Setzt das Callback des NPC, dass beim Ansprechen ausgeführt wird.</p><p>-- @param[type=function] _Callback Callback</p><p>-- @return[type=table] self</p><p>-- @within QSB.NonPlayerCharacter</p><p>    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');</p><p>    assert(type(_Callback) == "function", 'callback must be a function!');</p><p>    self.m_Callback = _Callback;</p><p>    return self;</p><p>-- Rotiert alle nahen Helden zum NPC und den NPC zu dem Helden,</p><p>-- der ihn angesprochen hat.</p><p>-- @within QSB.NonPlayerCharacter</p><p>-- @local</p><p>    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');</p><p>    local PlayerID = Logic.EntityGetPlayer(BundleNonPlayerCharacter.Global.LastHeroEntityID);</p><p>    local PlayerKnights = {};</p><p>    Logic.GetKnights(PlayerID, PlayerKnights);</p><p>    for k, v in pairs(PlayerKnights) do</p><p>        -- Alle Helden stoppen, die sich zu NPC bewegen</p><p>        local x1 = math.floor(BundleNonPlayerCharacter.Global:IntegerToFloat(Logic.GetEntityScriptingValue(v, 19)));</p><p>        local y1 = math.floor(BundleNonPlayerCharacter.Global:IntegerToFloat(Logic.GetEntityScriptingValue(v, 20)));</p><p>        local x2, y2 = Logic.EntityGetPos(GetID(self.m_NpcName));</p><p>        if x1 == math.floor(x2) and y1 == math.floor(y2) then</p><p>            local x, y, z = Logic.EntityGetPos(v);</p><p>            Logic.MoveEntity(v, x, y);</p><p>            LookAt(v, self.m_NpcName);</p><p>        end</p><p>    end</p><p>    API.Confront(self.m_NpcName, BundleNonPlayerCharacter.Global.LastHeroEntityID)</p><p>-- Erzeugt das Entity des NPC-Markers.</p><p>-- @within QSB.NonPlayerCharacter</p><p>-- @local</p><p>    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');</p><p>    local x,y,z = Logic.EntityGetPos(self:GetID());</p><p>    local MarkerID = Logic.CreateEntity(Entities.XD_ScriptEntity, x, y, 0, 0);</p><p>    DestroyEntity(self.m_MarkerID);</p><p>    self.m_MarkerID = MarkerID;</p><p>    self:HideMarker();</p><p>    return self;</p><p>-- Entfernt das Entity des NPC-Markers.</p><p>-- @within QSB.NonPlayerCharacter</p><p>-- @local</p><p>    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');</p><p>    if self.m_MarkerID then</p><p>        DestroyEntity(self.m_MarkerID);</p><p>        self.m_MarkerID = nil;</p><p>    end</p><p>    return self;</p><p>-- Zeigt den NPC-Marker des NPC an.</p><p>-- @within QSB.NonPlayerCharacter</p><p>-- @local</p><p>    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');</p><p>    if self.m_NpcType == 1 and IsExisting(self.m_MarkerID) then</p><p>        local EntityScale = Logic.GetEntityScriptingValue(self:GetID(), -45);</p><p>        Logic.SetEntityScriptingValue(self.m_MarkerID, -45, EntityScale);</p><p>        Logic.SetModel(self.m_MarkerID, Models.Effects_E_Wealth);</p><p>        Logic.SetVisible(self.m_MarkerID, true);</p><p>    end</p><p>    self.m_MarkerVisibility = true;</p><p>    return self;</p><p>-- Versteckt den NPC-Marker des NPC.</p><p>-- @within QSB.NonPlayerCharacter</p><p>-- @local</p><p>    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');</p><p>    if IsExisting(self.m_MarkerID) then</p><p>        Logic.SetModel(self.m_MarkerID, Models.Effects_E_NullFX);</p><p>        Logic.SetVisible(self.m_MarkerID, false);</p><p>    end</p><p>    self.m_MarkerVisibility = false;</p><p>    return self;</p><p>-- Gibt true zurück, wenn der Marker des NPC sichtbar ist.</p><p>-- @return[type=boolen] Sichtbarkeit</p><p>-- @within QSB.NonPlayerCharacter</p><p>-- @local</p><p>    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');</p><p>    return IsExisting(self.m_MarkerID) and self.m_MarkerVisibility == true;</p><p>-- Kontrolliert die Sichtbarkeit und die Position des NPC-Markers.</p><p>-- @within QSB.NonPlayerCharacter</p><p>-- @local</p><p>    -- Nur, wenn Standard-NPC</p><p>    if self.m_NpcType == 1 then</p><p>        if self:IsActive() and not self:HasTalkedTo() then</p><p>            -- Blinken</p><p>            if self:IsMarkerVisible() then</p><p>                self:HideMarker();</p><p>            else</p><p>                self:ShowMarker();</p><p>            end</p><p>            -- Repositionierung</p><p>            local x1,y1,z1 = Logic.EntityGetPos(self.m_MarkerID);</p><p>            local x2,y2,z2 = Logic.EntityGetPos(self:GetID());</p><p>            if math.abs(x1-x2)  20 or math.abs(y1-y2)  20 then</p><p>                Logic.DEBUG_SetPosition(self.m_MarkerID, x2, y2);</p><p>            end</p><p>        end</p><p>        -- Während Briefings immer verstecken</p><p>        if IsBriefingActive and IsBriefingActive() then</p><p>            self:HideMarker();</p><p>        end</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {</p><p>        LastNpcEntityID = 0,</p><p>        LastHeroEntityID = 0,</p><p>        DefaultNpcType = 1,</p><p>    },</p><p>    Local = {}</p><p>-- Global Script ---------------------------------------------------------------</p><p>-- Initialisiert das Bundle im globalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    -- NPC stuff --</p><p>    StartSimpleJob("BundleNonPlayerCharacter_ControlMarkerJob");</p><p>    StartSimpleHiResJob("BundleNonPlayerCharacter_DialogTriggerJob");</p><p>    GameCallback_OnNPCInteraction_Orig_QSB_NPC_Rewrite = GameCallback_OnNPCInteraction</p><p>    GameCallback_OnNPCInteraction = function(_EntityID, _PlayerID)</p><p>        GameCallback_OnNPCInteraction_Orig_QSB_NPC_Rewrite(_EntityID, _PlayerID)</p><p>        Quest_OnNPCInteraction(_EntityID, _PlayerID)</p><p>    end</p><p>    Quest_OnNPCInteraction = function(_EntityID, _PlayerID)</p><p>        local KnightIDs = {};</p><p>        Logic.GetKnights(_PlayerID, KnightIDs);</p><p>        local ClosestKnightID = 0;</p><p>        local ClosestKnightDistance = Logic.WorldGetSize();</p><p>        for i= 1, #KnightIDs, 1 do</p><p>            local DistanceBetween = Logic.GetDistanceBetweenEntities(KnightIDs[i], _EntityID);</p><p>            if DistanceBetween  ClosestKnightDistance then</p><p>                ClosestKnightDistance = DistanceBetween;</p><p>                ClosestKnightID = KnightIDs[i];</p><p>            end</p><p>        end</p><p>        BundleNonPlayerCharacter.Global.LastHeroEntityID = ClosestKnightID;</p><p>        local NPC = QSB.NonPlayerCharacter:GetInstance(_EntityID);</p><p>        BundleNonPlayerCharacter.Global.LastNpcEntityID = NPC:GetID();</p><p>        if NPC then</p><p>            NPC:RotateActors();</p><p>            NPC.m_TalkedTo = ClosestKnightID;</p><p>            if NPC:HasTalkedTo() then</p><p>                NPC:Deactivate();</p><p>                if NPC.m_Callback then</p><p>                    NPC.m_Callback(NPC, ClosestKnightID);</p><p>                end</p><p>            else</p><p>                if NPC.m_WrongHeroCallback then</p><p>                    NPC.m_WrongHeroCallback(NPC, ClosestKnightID);</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>    -- Quest stuff --</p><p>    function QuestTemplate:RemoveQuestMarkers()</p><p>        for i=1, self.Objectives[0] do</p><p>            if self.Objectives[i].Type == Objective.Distance then</p><p>                if ((type(self.Objectives[i].Data[1]) == "number" and self.Objectives[i].Data[1]  0)</p><p>                or (type(self.Objectives[i].Data[1]) ~= "number")) and self.Objectives[i].Data[4] then</p><p>                    DestroyQuestMarker(self.Objectives[i].Data[2]);</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>    function QuestTemplate:ShowQuestMarkers()</p><p>        for i=1, self.Objectives[0] do</p><p>            if self.Objectives[i].Type == Objective.Distance then</p><p>                if ((type(self.Objectives[i].Data[1]) == "number" and self.Objectives[i].Data[1]  0)</p><p>                or (type(self.Objectives[i].Data[1]) ~= "number")) and self.Objectives[i].Data[4] then</p><p>                    ShowQuestMarker(self.Objectives[i].Data[2]);</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>    function QuestTemplate:RemoveNPCMarkers()</p><p>        for i=1, self.Objectives[0] do</p><p>            if type(self.Objectives[i].Data) == "table" then</p><p>                if self.Objectives[i].Data[1] == -65565 then</p><p>                    if type(self.Objectives[i].Data[4]) == "table" then</p><p>                        if self.Objectives[i].Data[4].NpcInstance then</p><p>                            self.Objectives[i].Data[4].NpcInstance:Dispose();</p><p>                            self.Objectives[i].Data[4].NpcInstance = nil;</p><p>                        end</p><p>                    end</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>    QuestTemplate.Interrupt_Orig_BundleNonPlayerCharacter = QuestTemplate.Interrupt;</p><p>    QuestTemplate.Interrupt = function(_quest, i)</p><p>        QuestTemplate.Interrupt_Orig_BundleNonPlayerCharacter(_quest, i);</p><p>        _quest:RemoveNPCMarkers();</p><p>    end</p><p>    QuestTemplate.IsObjectiveCompleted_Orig_BundleNonPlayerCharacter = QuestTemplate.IsObjectiveCompleted;</p><p>    QuestTemplate.IsObjectiveCompleted = function(self, objective)</p><p>        local objectiveType = objective.Type;</p><p>        local data = objective.Data;</p><p>        if objective.Completed ~= nil then</p><p>            return objective.Completed;</p><p>        end</p><p>        if objectiveType ~= Objective.Distance then</p><p>            return self:IsObjectiveCompleted_Orig_BundleNonPlayerCharacter(objective);</p><p>        else</p><p>            if data[1] == -65565 then</p><p>                if not IsExisting(data[3]) then</p><p>                    API.Fatal(data[3].. " is dead! :(");</p><p>                    objective.Completed = false;</p><p>                else</p><p>                    if not data[4].NpcInstance then</p><p>                        local NPC = QSB.NonPlayerCharacter:New(data[3]);</p><p>                        NPC:SetDialogPartner(data[2]);</p><p>                        data[4].NpcInstance = NPC;</p><p>                    end</p><p>                    if data[4].NpcInstance:HasTalkedTo(data[2]) then</p><p>                        objective.Completed = true;</p><p>                    end</p><p>                    if not objective.Completed then</p><p>                        if not data[4].NpcInstance:IsActive() then</p><p>                            data[4].NpcInstance:Activate();</p><p>                        end</p><p>                    end</p><p>                end</p><p>            else</p><p>                return self:IsObjectiveCompleted_Orig_BundleNonPlayerCharacter(objective);</p><p>            end</p><p>        end</p><p>    end</p><p>-- Setzt den Standardtypen des NPC. Der Typ gibt an, ob Glitter verwendet wird</p><p>-- oder auf die NPC-Marker zurückgegriffen wird.</p><p>-- @param[type=number] _Type Typ des NPC [1-4]</p><p>-- @within Internal</p><p>-- @local</p><p>    self.DefaultNpcType = _Type;</p><p>-- Gibt die ID des kontrollierenden Spielers zurück.</p><p>-- </p><p>-- @return[type=number] Kontrollierender Spieler</p><p>-- @within Internal</p><p>-- @local</p><p>    for i= 1, 8, 1 do</p><p>        if Logic.PlayerGetIsHumanFlag(i) == true then</p><p>            return i;</p><p>        end</p><p>    end</p><p>    return 0;</p><p>-- Konvertiert eine Ganzzahl in eine Gleitkommazahl.</p><p>-- @param[type=number] num Zahl zum Konvertieren</p><p>-- @return[type=number] Ganzzahl</p><p>-- @within Internal</p><p>-- @local</p><p>    if(num == 0) then </p><p>        return 0;</p><p>    end</p><p>    local sign = 1</p><p>    if(num  0) then </p><p>        num = 2147483648 + num; sign = -1;</p><p>    end</p><p>    local frac = (num - math.floor(num/8388608)*8388608);</p><p>    local headPart = (num-frac)/8388608</p><p>    local expNoSign = (headPart - math.floor(headPart/256)*256);</p><p>    local exp = expNoSign-127</p><p>    local fraction = 1</p><p>    local fp = 0.5</p><p>    local check = 4194304</p><p>    for i = 23, 0, -1 do</p><p>        if(frac - check)  0 then</p><p>            fraction = fraction + fp; frac = frac - check;</p><p>        end</p><p>        check = check / 2; fp = fp / 2</p><p>    end</p><p>    return fraction * math.pow(2, exp) * sign</p><p>-- Kontrolliert die "Glitter Marker" der NPCs.</p><p>-- @within Internal</p><p>-- @local</p><p>    for k, v in pairs(QSB.NonPlayerCharacterObjects) do</p><p>        if IsExisting(v:GetID()) then</p><p>            v:ControlMarker();</p><p>        end</p><p>    end</p><p>-- Prüft, ob ein NPC durch die emulierte Aktivierungsdistanz angesprochen</p><p>-- wird. Die Bedingung wird für alle NPCs geprüft. Der erste NPC, der</p><p>-- die Bedingung erfüllt, wird aktiviert.</p><p>-- Der Job prüft nur NPCs, deren Aktivierungsdistanz 350 oder höher ist.</p><p>-- @within Internal</p><p>-- @local</p><p>    local PlayerID = BundleNonPlayerCharacter.Global:GetControllingPlayer();</p><p>    local PlayersKnights = {};</p><p>    Logic.GetKnights(PlayerID, PlayersKnights);</p><p>    for i= 1, #PlayersKnights, 1 do</p><p>        if Logic.GetCurrentTaskList(PlayersKnights[i]) == "TL_NPC_INTERACTION" then</p><p>            for k, v in pairs(QSB.NonPlayerCharacterObjects) do</p><p>                if v and v.m_TalkedTo == nil and v.m_Distance = 350 then</p><p>                    local x1 = math.floor(BundleNonPlayerCharacter.Global:IntegerToFloat(Logic.GetEntityScriptingValue(PlayersKnights[i], 19)));</p><p>                    local y1 = math.floor(BundleNonPlayerCharacter.Global:IntegerToFloat(Logic.GetEntityScriptingValue(PlayersKnights[i], 20)));</p><p>                    local x2, y2 = Logic.EntityGetPos(GetID(k));</p><p>                    if x1 == math.floor(x2) and y1 == math.floor(y2) then</p><p>                        if IsExisting(k) and IsNear(PlayersKnights[i], k, v.m_Distance) then</p><p>                            GameCallback_OnNPCInteraction(GetID(k), PlayerID);</p><p>                            return;</p><p>                        end</p><p>                    end</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>-- Local Script ----------------------------------------------------------------</p><p>-- Initialisiert das Bundle im lokalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    g_CurrentDisplayedQuestID = 0;</p><p>    GUI_Interaction.DisplayQuestObjective_Orig_BundleNonPlayerCharacter = GUI_Interaction.DisplayQuestObjective</p><p>    GUI_Interaction.DisplayQuestObjective = function(_QuestIndex, _MessageKey)</p><p>        local lang = Network.GetDesiredLanguage();</p><p>        if lang ~= "de" then lang = "en" end</p><p>        local QuestIndexTemp = tonumber(_QuestIndex);</p><p>        if QuestIndexTemp then</p><p>            _QuestIndex = QuestIndexTemp;</p><p>        end</p><p>        local Quest, QuestType = GUI_Interaction.GetPotentialSubQuestAndType(_QuestIndex);</p><p>        local QuestObjectivesPath = "/InGame/Root/Normal/AlignBottomLeft/Message/QuestObjectives";</p><p>        XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomLeft/Message/QuestObjectives", 0);</p><p>        local QuestObjectiveContainer;</p><p>        local QuestTypeCaption;</p><p>        local ParentQuest = Quests[_QuestIndex];</p><p>        local ParentQuestIdentifier;</p><p>        if ParentQuest ~= nil</p><p>        and type(ParentQuest) == "table" then</p><p>            ParentQuestIdentifier = ParentQuest.Identifier;</p><p>        end</p><p>        local HookTable = {};</p><p>        g_CurrentDisplayedQuestID = _QuestIndex;</p><p>        if QuestType == Objective.Distance then</p><p>            QuestObjectiveContainer = QuestObjectivesPath .. "/List";</p><p>            QuestTypeCaption = Wrapped_GetStringTableText(_QuestIndex, "UI_Texts/QuestInteraction");</p><p>            local ObjectList = {};</p><p>            if Quest.Objectives[1].Data[1] == -65565 then</p><p>                QuestObjectiveContainer = QuestObjectivesPath .. "/Distance";</p><p>                QuestTypeCaption = Wrapped_GetStringTableText(_QuestIndex, "UI_Texts/QuestMoveHere");</p><p>                SetIcon(QuestObjectiveContainer .. "/QuestTypeIcon",{7,10});</p><p>                local MoverEntityID = GetEntityId(Quest.Objectives[1].Data[2]);</p><p>                local MoverEntityType = Logic.GetEntityType(MoverEntityID);</p><p>                local MoverIcon = g_TexturePositions.Entities[MoverEntityType];</p><p>                if not MoverIcon then</p><p>                    MoverIcon = {7, 9};</p><p>                end</p><p>                SetIcon(QuestObjectiveContainer .. "/IconMover", MoverIcon);</p><p>                local TargetEntityID = GetEntityId(Quest.Objectives[1].Data[3]);</p><p>                local TargetEntityType = Logic.GetEntityType(TargetEntityID);</p><p>                local TargetIcon = g_TexturePositions.Entities[TargetEntityType];</p><p>                if not TargetIcon then</p><p>                    TargetIcon = {14, 10};</p><p>                end</p><p>                local IconWidget = QuestObjectiveContainer .. "/IconTarget";</p><p>                local ColorWidget = QuestObjectiveContainer .. "/TargetPlayerColor";</p><p>                SetIcon(IconWidget, TargetIcon);</p><p>                XGUIEng.SetMaterialColor(ColorWidget, 0, 255, 255, 255, 0);</p><p>                SetIcon(QuestObjectiveContainer .. "/QuestTypeIcon",{16,12});</p><p>                local caption = {de = "Gespräch beginnen", en = "Start conversation"};</p><p>                QuestTypeCaption = caption[lang];</p><p>                XGUIEng.SetText(QuestObjectiveContainer.."/Caption","{center}"..QuestTypeCaption);</p><p>                XGUIEng.ShowWidget(QuestObjectiveContainer, 1);</p><p>            else</p><p>                GUI_Interaction.DisplayQuestObjective_Orig_BundleNonPlayerCharacter(_QuestIndex, _MessageKey);</p><p>            end</p><p>        else</p><p>            GUI_Interaction.DisplayQuestObjective_Orig_BundleNonPlayerCharacter(_QuestIndex, _MessageKey);</p><p>        end</p><p>    end</p><p>    GUI_Interaction.GetEntitiesOrTerritoryListForQuest_Orig_BundleNonPlayerCharacter = GUI_Interaction.GetEntitiesOrTerritoryListForQuest</p><p>    GUI_Interaction.GetEntitiesOrTerritoryListForQuest = function( _Quest, _QuestType )</p><p>        local EntityOrTerritoryList = {}</p><p>        local IsEntity = true</p><p>        if _QuestType == Objective.Distance then</p><p>            if _Quest.Objectives[1].Data[1] == -65565 then</p><p>                local Entity = GetEntityId(_Quest.Objectives[1].Data[3]);</p><p>                table.insert(EntityOrTerritoryList, Entity);</p><p>            else</p><p>                return GUI_Interaction.GetEntitiesOrTerritoryListForQuest_Orig_BundleNonPlayerCharacter( _Quest, _QuestType );</p><p>            end</p><p>        else</p><p>            return GUI_Interaction.GetEntitiesOrTerritoryListForQuest_Orig_BundleNonPlayerCharacter( _Quest, _QuestType );</p><p>        end</p><p>        return EntityOrTerritoryList, IsEntity</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Behavior                                                                   --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der Held muss einen Nichtspielercharakter ansprechen.</p><p>-- Es wird automatisch ein NPC erzeugt und überwacht, sobald der Quest</p><p>-- aktiviert wurde. Ein NPC darf nicht auf geblocktem Gebiet stehen oder</p><p>-- seine Enity-ID verändern.</p><p>--  NPC </p><p>-- haben. Wird ein weiterer NPC zugewiesen, wird der alte überschrieben und</p><p>-- der verknüpfte Quest funktioniert nicht mehr!</p><p>-- @param[type=string] _NpcName  Skriptname des NPC</p><p>-- @param[type=string] _HeroName (optional) Skriptname des Helden</p><p>-- @within Goal</p><p>    return b_Goal_NPC:new(...);</p><p>Goal_NPC</p><p>    Name             = "Goal_NPC",</p><p>    Description     = {</p><p>        en = "Goal: The hero has to talk to a non-player character.",</p><p>        de = "Ziel: Der Held muss einen Nichtspielercharakter ansprechen.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "NPC",  de = "NPC" },</p><p>        { ParameterType.ScriptName, en = "Hero", de = "Held" },</p><p>    },</p><p>    return {Objective.Distance, -65565, self.Hero, self.NPC, self}</p><p>    if (_Index == 0) then</p><p>        self.NPC = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.Hero = _Parameter</p><p>        if self.Hero == "-" then</p><p>            self.Hero = nil</p><p>        end</p><p>   end</p><p>    return {14,10}</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundleplayerhelperfunctions.lua.html">
            <div class='doclink'>
                <div>BundlePlayerHelperFunctions</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia BundlePlayerHelperFunctions                                   # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Mit diesem Bundle kommen einige Funktionalitäten zur Steuerung von</p><p>-- spielerbezogenen Features.</p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Entfernt ein Territorium für den angegebenen Spieler aus der Liste</p><p>-- der entdeckten Territorien.</p><p>-- </p><p>-- @param[type=number] _PlayerID    Spieler-ID</p><p>-- @param[type=number] _TerritoryID Territorium-ID</p><p>-- @within Anwenderfunktionen</p><p>function API.UndiscoverTerritory(_PlayerID, _TerritoryID)</p><p>    if GUI then</p><p>        API.Bridge("API.UndiscoverTerritory(" .._PlayerID.. ", ".._TerritoryID.. ")")</p><p>        return;</p><p>    end</p><p>    return BundlePlayerHelperFunctions.Global:UndiscoverTerritory(_PlayerID, _TerritoryID);</p><p>-- Entfernt alle Territorien einer Partei aus der Liste der entdeckten</p><p>-- Territorien. Als Nebeneffekt gild die Partei als unentdeckt.</p><p>-- </p><p>-- @param[type=number] _PlayerID    Spieler-ID</p><p>-- @param[type=number] _TargetPlayerID Anderer Spieler</p><p>-- @within Anwenderfunktionen</p><p>function API.UndiscoverTerritories(_PlayerID, _TargetPlayerID)</p><p>    if GUI then</p><p>        API.Bridge("API.UndiscoverTerritories(" .._PlayerID.. ", ".._TargetPlayerID.. ")")</p><p>        return;</p><p>    end</p><p>    return BundlePlayerHelperFunctions.Global:UndiscoverTerritories(_PlayerID, _TargetPlayerID);</p><p>-- Setzt die Einnahmen für alle Stadtgebäude eines Spielers. Stadtgebäude</p><p>-- können nur Einnahmen zwischen 0 und 100 Talern haben.</p><p>-- </p><p>-- @param[type=number] _PlayerID Partei oder nil für alle</p><p>-- @param[type=number] _Earnings Einnahmen [0 | 100]</p><p>-- @within Anwenderfunktionen</p><p>function API.SetEarningsOfPlayerCity(_PlayerID, _Earnings)</p><p>    if GUI then</p><p>        API.Bridge("API.SetEarningsOfPlayerCity(" .._PlayerID.. ", " .._Earnings.. ")");</p><p>        return;</p><p>    end</p><p>    if _PlayerID ~= -1 and Logic.GetStoreHouse(_PlayerID) == 0 then</p><p>        API.Fatal("API.SetEarningsOfPlayerCity: Player " .._PlayerID.. " is dead! :(");</p><p>        return;</p><p>    end</p><p>    if _Earnings == nil or (_Earnings  100) then</p><p>        API.Fatal("API.SetEarningsOfPlayerCity: _Earnings must be between 0 and 100!");</p><p>        return;</p><p>    end</p><p>    return BundlePlayerHelperFunctions.Global:SetEarningsOfPlayerCity(_PlayerID, _Earnings);</p><p>-- Setzt den Befriedigungsstatus eines Bedürfnisses für alle Gebäude</p><p>-- des angegebenen Spielers. Der Befriedigungsstatus ist eine Zahl</p><p>-- zwischen 0.0 und 1.0.</p><p>-- </p><p>-- @param[type=number] _Need Bedürfnis</p><p>-- @param[type=number] _State Erfüllung des Bedürfnisses</p><p>-- @param[type=number] _PlayerID Partei oder -1 für alle</p><p>-- @within Anwenderfunktionen</p><p>function API.SetNeedSatisfaction(_Need, _State, _PlayerID)</p><p>    if GUI then</p><p>        API.Bridge("API.SetNeedSatisfaction(" .._Need.. ", " .._State.. ", " .._PlayerID.. ")")</p><p>        return;</p><p>    end</p><p>    if _PlayerID ~= -1 and Logic.GetStoreHouse(_PlayerID) == 0 then</p><p>        API.Fatal("API.SetNeedSatisfaction: Player " .._PlayerID.. " is dead! :(");</p><p>        return;</p><p>    end</p><p>    if _State  1 then</p><p>        API.Fatal("API.SetNeedSatisfaction: _State must be between 0 and 1!");</p><p>        return;</p><p>    end</p><p>    return BundlePlayerHelperFunctions.Global:SetNeedSatisfactionLevel(_Need, _State, _PlayerID);</p><p>-- Diese Funktion ermöglicht das sichere Entsperren eines gesperrten Titels.</p><p>-- </p><p>-- @param[type=number] _PlayerID Zielpartei</p><p>-- @param[type=number] _KnightTitle Titel zum Entsperren</p><p>-- @within Anwenderfunktionen</p><p>function API.UnlockTitleForPlayer(_PlayerID, _KnightTitle)</p><p>    if GUI then</p><p>        API.Bridge("API.UnlockTitleForPlayer(" .._PlayerID.. ", " .._KnightTitle.. ")")</p><p>        return;</p><p>    end</p><p>    return BundlePlayerHelperFunctions.Global:UnlockTitleForPlayer(_PlayerID, _KnightTitle);</p><p>-- Startet ein Fest für den Spieler. Ist dieser Typ von Fest für</p><p>-- den Spieler verboten, wird er automatisch erlaubt.</p><p>-- </p><p>-- @param[type=number] _PlayerID Spieler</p><p>-- @within Anwenderfunktionen</p><p>function API.StartNormalFestival(_PlayerID)</p><p>    if GUI then</p><p>        API.Bridge("API.StartNormalFestival(".. _PlayerID ..")");</p><p>        return;</p><p>    end</p><p>    BundlePlayerHelperFunctions.Global:RestrictFestivalForPlayer(_PlayerID, 0, false);</p><p>    Logic.StartFestival(_PlayerID, 0);</p><p>-- Startet ein Beförderungsfest für den Spieler. Ist dieser Typ</p><p>-- von Fest für den Spieler verboten, wird er automatisch erlaubt.</p><p>-- </p><p>-- @param[type=number] _PlayerID Spieler</p><p>-- @within Anwenderfunktionen</p><p>function API.StartCityUpgradeFestival(_PlayerID)</p><p>    if GUI then</p><p>        API.Bridge("API.StartCityUpgradeFestival(".. _PlayerID ..")");</p><p>        return;</p><p>    end</p><p>    BundlePlayerHelperFunctions.Global:RestrictFestivalForPlayer(_PlayerID, 1, false);</p><p>    Logic.StartFestival(_PlayerID, 1);</p><p>-- Verbietet ein normales Fest und sperrt die Technologie.</p><p>-- </p><p>-- @param[type=number] _PlayerID Spieler</p><p>-- @within Anwenderfunktionen</p><p>function API.ForbidFestival(_PlayerID)</p><p>    if GUI then</p><p>        API.Bridge("API.ForbidFestival(".. _PlayerID ..")");</p><p>        return;</p><p>    end</p><p>    local KnightTitle = Logic.GetKnightTitle(_PlayerID)</p><p>    local Technology = Technologies.R_Festival;</p><p>    local State = TechnologyStates.Locked;</p><p>    if KnightTitleNeededForTechnology[Technology] == nil or KnightTitle = KnightTitleNeededForTechnology[Technology] then</p><p>        State = TechnologyStates.Prohibited;</p><p>    end</p><p>    Logic.TechnologySetState(_PlayerID, Technology, State);</p><p>    BundlePlayerHelperFunctions.Global:RestrictFestivalForPlayer(_PlayerID, 0, true);</p><p>    API.Bridge("BundlePlayerHelperFunctions.Local.Data.NormalFestivalLockedForPlayer[" .._PlayerID.. "] = true");</p><p>-- Erlaubt ein normales Fest und gibt die Technologie frei.</p><p>-- </p><p>-- @param[type=number] _PlayerID Spieler</p><p>-- @within Anwenderfunktionen</p><p>function API.AllowFestival(_PlayerID)</p><p>    if GUI then</p><p>        API.Bridge("API.AllowFestival(".. _PlayerID ..")");</p><p>        return;</p><p>    end</p><p>    BundlePlayerHelperFunctions.Global:RestrictFestivalForPlayer(_PlayerID, 0, false);</p><p>    local KnightTitle = Logic.GetKnightTitle(_PlayerID)</p><p>    local Technology = Technologies.R_Festival;</p><p>    local State = TechnologyStates.Unlocked;</p><p>    if KnightTitleNeededForTechnology[Technology] == nil or KnightTitle = KnightTitleNeededForTechnology[Technology] then</p><p>        State = TechnologyStates.Researched;</p><p>    end</p><p>    Logic.TechnologySetState(_PlayerID, Technology, State);</p><p>    API.Bridge("BundlePlayerHelperFunctions.Local.Data.NormalFestivalLockedForPlayer[" .._PlayerID.. "] = false");</p><p>-- Wechselt die Spieler ID des menschlichen Spielers. Die neue ID muss</p><p>-- einen Primärritter haben. Diese Funktion kann nicht im Multiplayer</p><p>-- Mode verwendet werden.</p><p>-- </p><p>-- @param[type=number]  _OldID Alte ID des menschlichen Spielers</p><p>-- @param[type=number]  _NewID Neue ID des menschlichen Spielers</p><p>-- @param[type=string]  _NewName Name in der Statistik</p><p>-- @param[type=boolean] _RetainKnight Ritter mitnehmen</p><p>-- @within Anwenderfunktionen</p><p>function API.SetControllingPlayer(_OldID, _NewID, _NewName, _RetainKnight)</p><p>    if GUI then</p><p>        API.Bridge("API.SetControllingPlayer(".. _OldID ..", ".. _NewID ..", '".. _NewName .."', ".. tostring(_RetainKnight) ..")");</p><p>        return;</p><p>    end</p><p>    return BundlePlayerHelperFunctions.Global:SetControllingPlayer(_OldID, _NewID, _NewName, _RetainKnight);</p><p>-- Gibt die ID des kontrollierenden Spielers zurück. Der erste als menschlich</p><p>-- definierte Spieler wird als kontrollierender Spieler angenommen.</p><p>-- </p><p>-- @return[type=number] PlayerID</p><p>-- @within Anwenderfunktionen</p><p>function API.GetControllingPlayer()</p><p>    if not GUI then</p><p>        return BundlePlayerHelperFunctions.Global:GetControllingPlayer();</p><p>    else</p><p>        return GUI.GetPlayerID();</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {</p><p>        Data = {</p><p>            FestivalBlacklist = {},</p><p>            DiscoveredTerritories = {};</p><p>        }</p><p>    },</p><p>    Local = {</p><p>        Data = {</p><p>            NormalFestivalLockedForPlayer = {},</p><p>        }</p><p>    },</p><p>-- Global Script ---------------------------------------------------------------</p><p>-- Initalisiert das Bundle im globalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    self:InitFestival();</p><p>    API.AddSaveGameAction(BundlePlayerHelperFunctions.Global.OnSaveGameLoaded);</p><p>-- Überschreibt Logic.StartFestival, sodass das Feierverhalten der KI gesteuert</p><p>-- werden kann.</p><p>-- @within Internal</p><p>-- @local</p><p>    Logic.StartFestival_Orig_NothingToCelebrate = Logic.StartFestival;</p><p>    Logic.StartFestival = function(_PlayerID, _Index)</p><p>        if BundlePlayerHelperFunctions.Global.Data.FestivalBlacklist[_PlayerID] then</p><p>            if BundlePlayerHelperFunctions.Global.Data.FestivalBlacklist[_PlayerID][_Index] then</p><p>                return;</p><p>            end</p><p>        end</p><p>        Logic.StartFestival_Orig_NothingToCelebrate(_PlayerID, _Index);</p><p>    end</p><p>-- Entfernt ein Territorium für den angegebenen Spieler aus der Liste</p><p>-- der entdeckten Territorien.</p><p>-- @param[type=number] _PlayerID    Spieler-ID</p><p>-- @param[type=number] _TerritoryID Territorium-ID</p><p>-- @within Internal</p><p>-- @local</p><p>    if self.Data.DiscoveredTerritories[_PlayerID] == nil then</p><p>        self.Data.DiscoveredTerritories[_PlayerID] = {};</p><p>    end</p><p>    for i=1, #self.Data.DiscoveredTerritories[_PlayerID], 1 do</p><p>        if self.Data.DiscoveredTerritories[_PlayerID][i] == _TerritoryID then</p><p>            table.remove(self.Data.DiscoveredTerritories[_PlayerID], i);</p><p>            break;</p><p>        end</p><p>    end</p><p>-- Entfernt alle Territorien einer Partei aus der Liste der entdeckten</p><p>-- Territorien. Als Nebeneffekt gild die Partei als unentdeckt-</p><p>-- @param[type=number] _PlayerID    Spieler-ID</p><p>-- @param[type=number] _TargetPlayerID Anderer Spieler</p><p>-- @within Internal</p><p>-- @local</p><p>    if self.Data.DiscoveredTerritories[_PlayerID] == nil then</p><p>        self.Data.DiscoveredTerritories[_PlayerID] = {};</p><p>    end</p><p>    local Discovered = {};</p><p>    for k, v in pairs(self.Data.DiscoveredTerritories[_PlayerID]) do</p><p>        local OwnerPlayerID = Logic.GetTerritoryPlayerID(v);</p><p>        if OwnerPlayerID ~= _TargetPlayerID then</p><p>            table.insert(Discovered, v);</p><p>            break;</p><p>        end</p><p>    end</p><p>    self.Data.DiscoveredTerritories[_PlayerID][i] = Discovered;</p><p>-- Setzt die Einnahmen für alle Stadtgebäude eines Spielers. Stadtgebäude</p><p>-- können nur Einnahmen zwischen 0 und 100 Talern haben.</p><p>--  SetPlayerEarnings</p><p>-- @param[type=number] _PlayerID Partei oder nil für alle</p><p>-- @param[type=number] _Earnings Einnahmen [0 | 100]</p><p>-- @within Internal</p><p>-- @local</p><p>    if _PlayerID == -1 then</p><p>        for i=1, 8, 1 do</p><p>            self:SetEarningsOfPlayerCity(i, _Earnings);</p><p>        end</p><p>    else</p><p>        local City = {Logic.GetPlayerEntitiesInCategory(_PlayerID, EntityCategories.CityBuilding)};</p><p>        for i=1, #City, 1 do</p><p>            Logic.SetBuildingEarnings(City[i], _Earnings);</p><p>        end</p><p>    end</p><p>-- Setzt den Befriedigungsstatus eines Bedürfnisses für alle Gebäude</p><p>-- des angegebenen Spielers. Der Befriedigungsstatus ist eine Zahl</p><p>-- zwischen 0.0 und 1.0.</p><p>-- @param[type=number] _Need Bedürfnis</p><p>-- @param[type=number] _State Erfüllung des Bedürfnisses</p><p>-- @param[type=number] _PlayerID Partei oder -1 für alle</p><p>-- @within Internal</p><p>-- @local</p><p>    if _PlayerID == -1 then</p><p>        for i=1, 8, 1 do</p><p>            self:SetNeedSatisfactionLevel(_Need, _State, i);</p><p>        end</p><p>    else</p><p>        local City = {Logic.GetPlayerEntitiesInCategory(_PlayerID, EntityCategories.CityBuilding)};</p><p>        if _Need == Needs.Nutrition or _Need == Needs.Medicine then</p><p>            local Rim = {Logic.GetPlayerEntitiesInCategory(_PlayerID, EntityCategories.OuterRimBuilding)};</p><p>            City = Array_Append(City, Rim);</p><p>        end</p><p>        for j=1, #City, 1 do</p><p>            if Logic.IsNeedActive(City[j], _Need) then</p><p>                Logic.SetNeedState(City[j], _Need, _State);</p><p>            end</p><p>        end</p><p>    end</p><p>-- Entsperrt einen gesperrten Titel für den Spieler.</p><p>-- @param[type=number] _PlayerID Zielpartei</p><p>-- @param[type=number] _KnightTitle Titel zum Entsperren</p><p>-- @within Internal</p><p>-- @local</p><p>    if LockedKnightTitles[_PlayerID] == _KnightTitle</p><p>    then</p><p>        LockedKnightTitles[_PlayerID] = nil;</p><p>        for KnightTitle= _KnightTitle, #NeedsAndRightsByKnightTitle</p><p>        do</p><p>            local TechnologyTable = NeedsAndRightsByKnightTitle[KnightTitle][4];</p><p>            if TechnologyTable ~= nil</p><p>            then</p><p>                for i=1, #TechnologyTable</p><p>                do</p><p>                    local TechnologyType = TechnologyTable[i];</p><p>                    Logic.TechnologySetState(_PlayerID, TechnologyType, TechnologyStates.Unlocked);</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>-- Erlaubt oder verbietet ein Fest für den angegebenen Spieler.</p><p>-- @param[type=number]  _PlayerID ID des Spielers</p><p>-- @param[type=number]  _Index    Index des Fest</p><p>-- @param[type=boolean] _Flag     Erlauben/verbieten</p><p>-- @within Internal</p><p>-- @local</p><p>    self.Data.FestivalBlacklist[_PlayerID] = self.Data.FestivalBlacklist[_PlayerID] or {};</p><p>    self.Data.FestivalBlacklist[_PlayerID][_Index] = _Flag == true;</p><p>-- Wechselt die Spieler ID des menschlichen Spielers. Die neue ID muss</p><p>-- einen Primärritter haben. Diese Funktion kann nicht im Multiplayer</p><p>-- Mode verwendet werden.</p><p>-- @param[type=number] _oldPlayerID Alte ID des menschlichen Spielers</p><p>-- @param[type=number] _newPlayerID Neue ID des menschlichen Spielers</p><p>-- @param[type=string] _newNameForStatistics Name in der Statistik</p><p>-- @param[type=boolean] _retainPrimaryKnight Ritter mitnehmen</p><p>-- @within Internal</p><p>-- @local</p><p>    assert(type(_oldPlayerID) == "number");</p><p>    assert(type(_newPlayerID) == "number");</p><p>    _newNameForStatistics = _newNameForStatistics or "";</p><p>    _retainPrimaryKnight = (_retainPrimaryKnight and true) or false;</p><p>    local eID,eName,eType;</p><p>    if _retainPrimaryKnight then</p><p>        eID   = Logic.GetKnightID(_oldPlayerID);</p><p>        eName = Logic.GetEntityName(eID);</p><p>        eType = Logic.GetEntityType(eID);</p><p>        Logic.ChangeEntityPlayerID(eID,_newPlayerID);</p><p>        Logic.SetPrimaryKnightID(_newPlayerID,GetID(eName));</p><p>    else</p><p>        eID   = Logic.GetKnightID(_newPlayerID);</p><p>        eName = Logic.GetEntityName(eID);</p><p>        eType = Logic.GetEntityType(eID);</p><p>    end</p><p>    Logic.PlayerSetIsHumanFlag(_oldPlayerID, 0);</p><p>    Logic.PlayerSetIsHumanFlag(_newPlayerID, 1);</p><p>    Logic.PlayerSetGameStateToPlaying(_newPlayerID);</p><p>    self.Data.HumanKnightType = eType;</p><p>    self.Data.HumanPlayerID = _newPlayerID;</p><p>    GameCallback_PlayerLost = function( _PlayerID )</p><p>        if _PlayerID == self:GetControllingPlayer() then</p><p>            QuestTemplate:TerminateEventsAndStuff()</p><p>            if MissionCallback_Player1Lost then</p><p>                MissionCallback_Player1Lost()</p><p>            end</p><p>        end</p><p>    end</p><p>    Logic.ExecuteInLuaLocalState([[</p><p>        GUI.ClearSelection()</p><p>        GUI.SetControlledPlayer(]].._newPlayerID..[[)</p><p>        for k,v in pairs(Buffs)do</p><p>            GUI_Buffs.UpdateBuffsInInterface(]].._newPlayerID..[[,v)</p><p>            GUI.ResetMiniMap()</p><p>        end</p><p>        if IsExisting(Logic.GetKnightID(GUI.GetPlayerID())) then</p><p>            local portrait = GetKnightActor(]]..eType..[[)</p><p>            g_PlayerPortrait[GUI.GetPlayerID()] = portrait</p><p>            LocalSetKnightPicture()</p><p>        end</p><p>        local newName = "]].._newNameForStatistics..[["</p><p>        if newName ~= "" then</p><p>            GUI_MissionStatistic.PlayerNames[GUI.GetPlayerID()] = newName</p><p>        end</p><p>        HideOtherMenus()</p><p>        function GUI_Knight.GetTitleNameByTitleID(_KnightType, _TitleIndex)</p><p>            local KeyName = "Title_" .. GetNameOfKeyInTable(KnightTitles, _TitleIndex) .. "_" .. KnightGender[]]..eType..[[]</p><p>            local String = XGUIEng.GetStringTableText("UI_ObjectNames/" .. KeyName)</p><p>            if String == nil or String == "" then</p><p>                String = "Knight not in Gender Table? (localscript.lua)"</p><p>            end</p><p>            return String</p><p>        end</p><p>    ]]);</p><p>    self.Data.HumanPlayerChangedOnce = true;</p><p>-- Gibt die ID des kontrollierenden Spielers zurück. Der erste als menschlich</p><p>-- definierte Spieler wird als kontrollierender Spieler angenommen.</p><p>-- @return[type=number] PlayerID</p><p>-- @within Internal</p><p>-- @local</p><p>    local pID = 1;</p><p>    for i=1,8 do</p><p>        if Logic.PlayerGetIsHumanFlag(i) == true then</p><p>            pID = i;</p><p>            break;</p><p>        end</p><p>    end</p><p>    return pID;</p><p>-- Stellt nicht-persistente Änderungen nach dem laden wieder her.</p><p>-- @within Internal</p><p>-- @local</p><p>    -- Feste sperren --</p><p>    Logic.StartFestival_Orig_NothingToCelebrate = nil;</p><p>    BundlePlayerHelperFunctions.Global:InitFestival();</p><p>    -- Menschlichen Spieler ändern --</p><p>    if BundlePlayerHelperFunctions.Global.Data.HumanPlayerChangedOnce then</p><p>        Logic.ExecuteInLuaLocalState([[</p><p>            GUI.SetControlledPlayer(]]..BundlePlayerHelperFunctions.Global.Data.HumanPlayerID..[[)</p><p>            for k,v in pairs(Buffs)do</p><p>                GUI_Buffs.UpdateBuffsInInterface(]]..BundlePlayerHelperFunctions.Global.Data.HumanPlayerID..[[,v)</p><p>                GUI.ResetMiniMap()</p><p>            end</p><p>            if IsExisting(Logic.GetKnightID(GUI.GetPlayerID())) then</p><p>                local portrait = GetKnightActor(]]..BundlePlayerHelperFunctions.Global.Data.HumanKnightType..[[)</p><p>                g_PlayerPortrait[]]..BundlePlayerHelperFunctions.Global.Data.HumanPlayerID..[[] = portrait</p><p>                LocalSetKnightPicture()</p><p>            end</p><p>        ]]);</p><p>    end</p><p>-- Local Script ------------------------------------------------------------- --</p><p>    self:InitForbidFestival();</p><p>    self:OverrideQuestLogPlayerIcon();</p><p>    self:OverrideQuestPlayerIcon();</p><p>-- Überschreibt den Button zum Start eines Festes, sodass er nicht angezeigt</p><p>-- wird, wenn Feste verboten sind.</p><p>-- @within Internal</p><p>-- @local</p><p>    NewStartFestivalUpdate = function()</p><p>        local WidgetID = XGUIEng.GetCurrentWidgetID();</p><p>        local PlayerID = GUI.GetPlayerID();</p><p>        if BundlePlayerHelperFunctions.Local.Data.NormalFestivalLockedForPlayer[PlayerID] then</p><p>            XGUIEng.ShowWidget(WidgetID, 0);</p><p>            return true;</p><p>        end</p><p>    end</p><p>    Core:StackFunction("GUI_BuildingButtons.StartFestivalUpdate", NewStartFestivalUpdate);</p><p>-- Überschreibt das Quest Icon für Spieler, die keinem Typen zugeordnet sind.</p><p>-- @within Internal</p><p>-- @local</p><p>    GUI_Interaction.SetPlayerIcon_Orig_BundlePlayerHelperFunctions = GUI_Interaction.SetPlayerIcon;</p><p>    GUI_Interaction.SetPlayerIcon = function(_PlayerIconContainer, _PlayerID)</p><p>        if _PlayerID == GUI.GetPlayerID() then</p><p>            GUI_Interaction.SetPlayerIcon_Orig_BundlePlayerHelperFunctions(_PlayerIconContainer, _PlayerID);</p><p>            return;</p><p>        end</p><p>        -- Icon</p><p>        local PlayerIcon;</p><p>        local LogoWidget = _PlayerIconContainer .. "/Logo";</p><p>        local PatternWidget = _PlayerIconContainer .. "/Pattern";</p><p>        local PlayerCategory = GetPlayerCategoryType(_PlayerID);</p><p>        local PlayerIcon = g_TexturePositions.PlayerCategories[PlayerCategory];</p><p>        if Mission_Callback_OverridePlayerIconForQuest then</p><p>            PlayerIcon = Mission_Callback_OverridePlayerIconForQuest(_PlayerID) or PlayerIcon;</p><p>        end</p><p>        if PlayerIcon == nil then</p><p>            PlayerIcon = {13, 7};</p><p>        end</p><p>        SetIcon(LogoWidget, PlayerIcon);</p><p>        -- Background</p><p>        SetIcon(PatternWidget, {14, 1});</p><p>        local R, G, B = GUI.GetPlayerColor(_PlayerID);</p><p>        if PlayerCategory == PlayerCategories.Harbour then</p><p>            R, G, B = 255, 255, 255;</p><p>        end</p><p>        XGUIEng.SetMaterialColor(PatternWidget, 0, R, G, B, 255);</p><p>    end</p><p>-- Überschreibt das Quest log Icon für Spieler, die keinem Typen zugeordnet sind.</p><p>-- @within Internal</p><p>-- @local</p><p>    QuestLog.PushQuestGiverLogo_Orig_BundlePlayerHelperFunctions = QuestLog.PushQuestGiverLogo;</p><p>    QuestLog.PushQuestGiverLogo = function(_widgetlist, _PlayerID)</p><p>        local Frame = "Icons.png";</p><p>        local IconSize = 44;</p><p>        local PlayerCategory = GetPlayerCategoryType(_PlayerID);</p><p>        local Coordinates = g_TexturePositions.PlayerCategories[PlayerCategory];</p><p>        </p><p>        if Coordinates ~= nil or Mission_Callback_OverridePlayerIconForQuest then</p><p>            QuestLog.PushQuestGiverLogo_Orig_BundlePlayerHelperFunctions(_widgetlist, _PlayerID);</p><p>            return;</p><p>        end</p><p>        Coordinates = {13, 7};</p><p>        local u0 = (Coordinates[1] - 1) * IconSize;</p><p>        local v0 = (Coordinates[2] - 1) * IconSize;</p><p>        local u1 = Coordinates[1] * IconSize;</p><p>        local v1 = Coordinates[2] * IconSize;</p><p>        if Coordinates[3] and Coordinates[3] == 1 then</p><p>            Frame = "Icons2.png";</p><p>        end</p><p>        XGUIEng.ListBoxPushItemEx(_widgetlist, "", Frame, nil, u0, v0, u1, v1);</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundlequestgeneration.lua.html">
            <div class='doclink'>
                <div>BundleQuestGeneration</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia BundleQuestGeneration                                        # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Mit diesem Bundle können Aufträge per Skript erstellt werden.</p><p>-- Normaler Weise werden Aufträge im Questassistenten erzeugt. Dies ist aber</p><p>-- statisch und das Kopieren von Aufträgen ist nicht möglich. Wenn Aufträge</p><p>-- im Skript erzeugt werden, verschwinden alle diese Nachteile. Aufträge</p><p>-- können im Skript kopiert und angepasst werden. Es ist ebenfalls machbar,</p><p>-- die Aufträge in Sequenzen zu erzeugen.</p><p>-- </p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Erstellt einen Quest.</p><p>-- Ein Quest braucht immer wenigstens ein Goal und einen Trigger. Hat ein Quest</p><p>-- keinen Namen, erhält er automatisch einen mit fortlaufender Nummerierung.</p><p>-- Ein Quest besteht aus verschiedenen Eigenschaften und Behavior, die nicht</p><p>-- alle zwingend gesetzt werden müssen. Behavior werden einfach nach den</p><p>-- Eigenschaften nacheinander angegeben.</p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- @param[type=table] _Data Questdefinition</p><p>-- @return[type=string] Name des Quests</p><p>-- @return[type=number] Gesamtzahl Quests</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- AddQuest {</p><p>--     Name        = "ExampleQuest",</p><p>--     Suggestion  = "Wir müssen das Kloster finden.",</p><p>--     Success     = "Dies sind die berümten Heilermönche.",</p><p>--     Goal_DiscoverPlayer(4),</p><p>--     Reward_Diplomacy(1, 4, "EstablishedContact"),</p><p>--     Trigger_Time(0),</p><p>-- }</p><p>function API.CreateQuest(_Data)</p><p>    if GUI then</p><p>        API.Fatal("API.CreateQuest: Could not execute in local script!");</p><p>        return;</p><p>    end</p><p>    return BundleQuestGeneration.Global:QuestCreateNewQuest(_Data);</p><p>-- Erzeugt eine Nachricht im Questfenster.</p><p>-- Der Quest wird immer nach Ablauf der Wartezeit nach</p><p>-- Abschluss des Ancestor Quest gestartet bzw. unmittelbar, wenn es keinen</p><p>-- Ancestor Quest gibt. Das Callback ist eine Funktion, die zur Anzeigezeit</p><p>-- des Quests ausgeführt wird.</p><p>-- Alle Paramater sind optional und können von rechts nach links weggelassen</p><p>-- oder mit nil aufgefüllt werden.</p><p>-- : QuestMessage</p><p>-- @param[type=string]   _Text        Anzeigetext der Nachricht</p><p>-- @param[type=number]   _Sender      Sender der Nachricht</p><p>-- @param[type=number]   _Receiver    Receiver der Nachricht</p><p>-- @param[type=number]   _AncestorWt  Wartezeit</p><p>-- @param[type=function] _Callback    Callback</p><p>-- @param[type=string]   _Ancestor    Vorgänger-Quest</p><p>-- @return[type=string] QuestName</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.CreateQuestMessage("Das ist ein Text", 4, 1);</p><p>function API.CreateQuestMessage(_Text, _Sender, _Receiver, _AncestorWt, _Callback, _Ancestor)</p><p>    if GUI then</p><p>        API.Fatal("API.CreateQuestMessage: Could not execute in local script!");</p><p>        return;</p><p>    end</p><p>    return BundleQuestGeneration.Global:QuestMessage(_Text, _Sender, _Receiver, _AncestorWt, _Callback, _Ancestor);</p><p>-- Erzeugt aus einer Table mit Daten eine Reihe von Nachrichten, die nach</p><p>-- einander angezeigt werden.</p><p>-- Dabei sind die eingestellten Wartezeiten in Echtzeit gemessen. Somit ist es</p><p>-- egal, wie hoch die Spielgeschwindigkeit ist. Die Dialoge warten alle</p><p>-- automatisch 12 Sekunden, wenn nichts anderes eingestellt wird.</p><p>-- Ein Dialog kann als Nachfolge auf einen Quest oder einen anderen Dialog</p><p>-- erzeugt werden, indem Ancestor gleich dem Questnamen gesetzt wird. Die</p><p>-- Wartezeit ist automatisch 0 Sekunden. Will man eine andere Wartezeit,</p><p>-- so muss Delay gesetzt werden.</p><p>-- Diese Funktion ist geeignet um längere Quest-Dialoge zu konfigurieren!</p><p>-- : QuestDialog</p><p>-- Einzelne Parameter pro Eintrag:</p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- @param[type=table] _Messages Liste der anzuzeigenden Nachrichten</p><p>-- @return[type=string] Name des letzten Quest</p><p>-- @return[type=table] Namensliste der Quests</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.CreateQuestDialog{</p><p>--     Name = "DialogName",</p><p>--     Ancestor = "SomeQuestName",</p><p>--     Delay = 12,</p><p>--     {"Hallo, wie geht es dir?", 4, 1, 8},</p><p>--     {"Mir geht es gut, wie immer!", 1, 1, 8, SomeCallbackFunction},</p><p>--     {"Das ist doch schön.", 4, 1, 8},</p><p>-- };</p><p>function API.CreateQuestDialog(_Messages)</p><p>    if GUI then</p><p>        API.Fatal("API.CreateQuestDialog: Could not execute in local script!");</p><p>        return;</p><p>    end</p><p>    table.insert(_Messages, {"KEY(NO_MESSAGE)", 1, 1});</p><p>    local QuestName;</p><p>    local GeneratedQuests = {};</p><p>    for i= 1, #_Messages, 1 do</p><p>        _Messages[i][4] = _Messages[i][4] or 12;</p><p>        if i  1 then</p><p>            _Messages[i][6] = _Messages[i][6] or QuestName;</p><p>        else</p><p>            _Messages[i][6] = _Messages[i][6] or _Messages.Ancestor;</p><p>            _Messages[i][4] = _Messages.Delay or 0;</p><p>        end</p><p>        if i == #_Messages and #_Messages[i-1] then</p><p>            _Messages[i][7] = _Messages.Name;</p><p>            _Messages[i][4] = _Messages[i-1][4];</p><p>        end</p><p>        QuestName = BundleQuestGeneration.Global:QuestMessage(unpack(_Messages[i]));</p><p>        table.insert(GeneratedQuests, QuestName);</p><p>    end</p><p>    -- Benannte Dialoge für spätere Zugriffe speichern.</p><p>    if _Messages.Name then</p><p>        QSB.GeneratedQuestDialogs[_Messages.Name] = GeneratedQuests;</p><p>    end</p><p>    return GeneratedQuests[#GeneratedQuests], GeneratedQuests;</p><p>-- Unterbricht einen laufenden oder noch nicht gestarteten Quest-Dialog.</p><p>-- Die Funktion kann entweder anhand eines Dialognamen den Dialog zurücksetzen</p><p>-- oder direkt die Table der erzeugten Quests annehmen.</p><p>-- : QuestDialogInterrupt</p><p>-- @param[type=string] _Dialog Dialog der abgebrochen wird</p><p>-- @within Anwenderfunktionen</p><p>function API.InterruptQuestDialog(_Dialog)</p><p>    if GUI then</p><p>        API.Fatal("API.InterruptQuestDialog: Could not execute in local script!");</p><p>        return;</p><p>    end</p><p>    local QuestDialog = _Dialog;</p><p>    if type(QuestDialog) == "string" then</p><p>        QuestDialog = QSB.GeneratedQuestDialogs[QuestDialog];</p><p>    end</p><p>    if QuestDialog == nil then</p><p>        API.Fatal("API.InterruptQuestDialog: Dialog is invalid!");</p><p>        return;</p><p>    end</p><p>    for i= 1, #QuestDialog-1, 1 do</p><p>        API.StopQuest(QuestDialog[i], true);</p><p>    end</p><p>    API.WinQuest(QuestDialog[#QuestDialog], true);</p><p>-- Setzt einen Quest-Dialog zurück sodass er erneut gestartet werden kann.</p><p>-- Die Funktion kann entweder anhand eines Dialognamen den Dialog zurücksetzen</p><p>-- oder direkt die Table der erzeugten Quests annehmen.</p><p>-- : QuestDialogRestart</p><p>-- @param[type=string] _Dialog Dialog der neu gestartet wird</p><p>-- @within Anwenderfunktionen</p><p>function API.RestartQuestDialog(_Dialog)</p><p>    if GUI then</p><p>        API.Fatal("API.ResetQuestDialog: Could not execute in local script!");</p><p>        return;</p><p>    end</p><p>    local QuestDialog = _Dialog;</p><p>    if type(QuestDialog) == "string" then</p><p>        QuestDialog = QSB.GeneratedQuestDialogs[QuestDialog];</p><p>    end</p><p>    if QuestDialog == nil then</p><p>        API.Fatal("API.ResetQuestDialog: Dialog is invalid!");</p><p>        return;</p><p>    end</p><p>    for i= 1, #QuestDialog, 1 do</p><p>        Quests[GetQuestID(QuestDialog[i])].Triggers[1][2][1].WaitTimeTimer = nil;</p><p>        API.RestartQuest(QuestDialog[i], true);</p><p>    end</p><p>    Quests[GetQuestID(QuestDialog[1])]:Trigger();</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {</p><p>        Data = {</p><p>            QuestMessageID = 0,</p><p>        }</p><p>    },</p><p>-- Global Script ---------------------------------------------------------------</p><p>-- Initalisiert das Bundle im globalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>-- Erzeugt eine Nachricht im Questfenster.</p><p>-- Der erzeugte Quest wird immer fehlschlagen. Der angezeigte Test ist die</p><p>-- Failure Message. Der Quest wird immer nach Ablauf der Wartezeit nach</p><p>-- Abschluss des Ancestor Quest gestartet bzw. unmittelbar, wenn es keinen</p><p>-- Ancestor Quest gibt. Das Callback ist eine Funktion, die zur Anzeigezeit</p><p>-- des Quests ausgeführt wird.</p><p>-- Alle Paramater sind optional und können von rechts nach links weggelassen</p><p>-- oder mit nil aufgefüllt werden.</p><p>-- @param[type=string]   _Text        Anzeigetext der Nachricht</p><p>-- @param[type=number]   _Sender      Sender der Nachricht</p><p>-- @param[type=number]   _Receiver    Receiver der Nachricht</p><p>-- @param[type=number]   _AncestorWt  Wartezeit</p><p>-- @param[type=function] _Callback    Callback</p><p>-- @param[type=string]   _Ancestor    Vorgänger-Quest</p><p>-- @param[type=string]   _QuestName   Questname überschreiben</p><p>-- @return[type=string] QuestName</p><p>-- @within Internal</p><p>-- @local</p><p>    self.Data.QuestMessageID = self.Data.QuestMessageID +1;</p><p>    -- Trigger-Nachbau</p><p>    local OnQuestOver = {</p><p>        Triggers.Custom2, {</p><p>            {QuestName = _Ancestor, WaitTime = _AncestorWt or 1,},</p><p>                function(_Data)</p><p>                local QuestID = GetQuestID(_Data.QuestName);</p><p>                if not _Data.QuestName then</p><p>                    return true;</p><p>                end</p><p>                if (Quests[QuestID] and Quests[QuestID].State == QuestState.Over and Quests[QuestID].Result ~= QuestResult.Interrupted) then</p><p>                    _Data.WaitTimeTimer = _Data.WaitTimeTimer or API.RealTimeGetSecondsPassedSinceGameStart();</p><p>                    if API.RealTimeGetSecondsPassedSinceGameStart() = _Data.WaitTimeTimer + _Data.WaitTime then</p><p>                        return true;</p><p>                    end</p><p>                end</p><p>                return false;</p><p>            end</p><p>        }</p><p>    };</p><p>    -- Lokalisierung</p><p>    local Language = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>    if type(_Text) == "table" then</p><p>        _Text = _Text[Language];</p><p>    end</p><p>    -- Quest erzeugen</p><p>    local _, CreatedQuest = QuestTemplate:New(</p><p>        (_QuestName ~= nil and _QuestName) or "QSB_QuestMessage_" ..self.Data.QuestMessageID,</p><p>        (_Sender or 1),</p><p>        (_Receiver or 1),</p><p>        { {Objective.Dummy} },</p><p>        { OnQuestOver },</p><p>        0, nil, nil, _Callback, nil, false, (_Text ~= nil), nil, nil, _Text, nil</p><p>    );</p><p>    return CreatedQuest.Identifier;</p><p>-- Erzeugt einen Quest.</p><p>-- @param[type=table] _Data Daten des Quest.</p><p>-- @return[type=string] Name des erzeugten Quests</p><p>-- @within Internal</p><p>-- @local</p><p>    if not _Data.Name then</p><p>        QSB.AutomaticQuestNameCounter = (QSB.AutomaticQuestNameCounter or 0) +1;</p><p>        _Data.Name = string.format("AutoNamed_Quest_d", QSB.AutomaticQuestNameCounter);</p><p>    end</p><p>    if not Core:CheckQuestName(_Data.Name) then</p><p>        fatal("Quest '"..tostring(_Data.Name).."': invalid questname! Contains forbidden characters!");</p><p>        return;</p><p>    end</p><p>    local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>    -- Questdaten erzeugen</p><p>    local QuestData = {</p><p>        _Data.Name,</p><p>        (_Data.Sender ~= nil and _Data.Sender) or 1,</p><p>        (_Data.Receiver ~= nil and _Data.Receiver) or 1,</p><p>        {},</p><p>        {},</p><p>        (_Data.Time ~= nil and _Data.Time) or 0,</p><p>        {},</p><p>        {},</p><p>        _Data.Callback,</p><p>        _Data.Loop,</p><p>        _Data.Visible == true or _Data.Suggestion ~= nil,</p><p>        _Data.EndMessage == true or (_Data.Failure ~= nil or _Data.Success ~= nil),</p><p>        (type(_Data.Description) == "table" and _Data.Description[lang]) or _Data.Description,</p><p>        (type(_Data.Suggestion) == "table" and _Data.Suggestion[lang]) or _Data.Suggestion,</p><p>        (type(_Data.Success) == "table" and _Data.Success[lang]) or _Data.Success,</p><p>        (type(_Data.Failure) == "table" and _Data.Failure[lang]) or _Data.Failure</p><p>    };</p><p>    -- Daten validieren</p><p>    if not self:QuestValidateQuestData(QuestData) then</p><p>        API.Fatal("AddQuest: Error while creating quest. Table has been copied to log.");</p><p>        API.DumpTable(QuestData, "Quest");</p><p>        return;</p><p>    end</p><p>    -- Behaviour</p><p>    for k,v in pairs(_Data) do</p><p>        if tonumber(k) ~= nil then</p><p>            if type(v) == "table" then</p><p>                if v.GetGoalTable then</p><p>                    table.insert(QuestData[4], v:GetGoalTable());</p><p>                    local Idx = #QuestData[4];</p><p>                    QuestData[4][Idx].Context            = v;</p><p>                    QuestData[4][Idx].FuncOverrideIcon   = QuestData[4][Idx].Context.GetIcon;</p><p>                    QuestData[4][Idx].FuncOverrideMsgKey = QuestData[4][Idx].Context.GetMsgKey;</p><p>                elseif v.GetReprisalTable then</p><p>                    table.insert(QuestData[8], v:GetReprisalTable());</p><p>                elseif v.GetRewardTable then</p><p>                    table.insert(QuestData[7], v:GetRewardTable());</p><p>                else</p><p>                    table.insert(QuestData[5], v:GetTriggerTable());</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>    -- Quest erzeugen</p><p>    local QuestID, Quest = QuestTemplate:New(unpack(QuestData, 1, 16));</p><p>    Quest.MsgTableOverride = _Data.MSGKeyOverwrite;</p><p>    Quest.IconOverride = _Data.IconOverwrite;</p><p>    return _Data.Name, Quests[0];</p><p>-- Validiert die Felder eines Quests.</p><p>-- @param[type=table] _Data Daten des Quest.</p><p>-- @return[type=boolean] Quest OK</p><p>-- @within Internal</p><p>-- @local</p><p>    return (</p><p>        (type(_Data[1]) == "string" and self:QuestValidateQuestName(_Data[1])) and</p><p>        (type(_Data[2]) == "number" and _Data[2] = 1 and _Data[2] = 8) and</p><p>        (type(_Data[3]) == "number" and _Data[3] = 1 and _Data[3] = 8) and</p><p>        (type(_Data[6]) == "number" and _Data[6] = 0) and</p><p>        ((_Data[9] ~= nil and type(_Data[9]) == "function") or (_Data[9] == nil)) and</p><p>        ((_Data[10] ~= nil and type(_Data[10]) == "function") or (_Data[10] == nil)) and</p><p>        (type(_Data[11]) == "boolean") and</p><p>        (type(_Data[12]) == "boolean") and</p><p>        ((_Data[13] ~= nil and type(_Data[13]) == "string") or (_Data[13] == nil)) and</p><p>        ((_Data[14] ~= nil and type(_Data[14]) == "string") or (_Data[14] == nil)) and</p><p>        ((_Data[15] ~= nil and type(_Data[15]) == "string") or (_Data[15] == nil)) and</p><p>        ((_Data[16] ~= nil and type(_Data[16]) == "string") or (_Data[16] == nil))</p><p>    );</p><p>-- Validiert den Namen eines Quests.</p><p>-- @param[type=string] _Name Name des Quest.</p><p>-- @return[type=boolean] Name OK</p><p>-- @within Internal</p><p>-- @local</p><p>    return string.find(_Name, "^[A-Za-z0-9_]+$") ~= nil;</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundlesymfoniabehaviors.lua.html">
            <div class='doclink'>
                <div>BundleSymfoniaBehaviors</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia BundleSymfoniaBehaviors                                      # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Dieses Bundle enthält einige weitere nützliche Behavior, welche es so nicht</p><p>-- in der ursprünglichen QSB gab.</p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Hier gibt es keine Funktionen!</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Goals                                                                      --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ein Entity muss sich zu einem Ziel bewegen und eine Distanz unterschreiten.</p><p>-- Optional kann das Ziel mit einem Marker markiert werden.</p><p>-- @param _ScriptName Skriptname des Entity</p><p>-- @param _Target     Skriptname des Ziels</p><p>-- @param _Distance   Entfernung</p><p>-- @param _UseMarker  Ziel markieren</p><p>-- @within Goal</p><p>    return b_Goal_MoveToPosition:new(...);</p><p>Goal_MoveToPosition</p><p>    Name = "Goal_MoveToPosition",</p><p>    Description = {</p><p>        en = "Goal: A entity have to moved as close as the distance to another entity. The target can be marked with a static marker.",</p><p>        de = "Ziel: Eine Entity muss sich einer anderen bis auf eine bestimmte Distanz nähern. Die Lupe wird angezeigt, das Ziel kann markiert werden.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Entity",   de = "Entity" },</p><p>        { ParameterType.ScriptName, en = "Target",   de = "Ziel" },</p><p>        { ParameterType.Number,     en = "Distance", de = "Entfernung" },</p><p>        { ParameterType.Custom,     en = "Marker",   de = "Ziel markieren" },</p><p>    },</p><p>    return {Objective.Distance, self.Entity, self.Target, self.Distance, self.Marker}</p><p>    if (_Index == 0) then</p><p>        self.Entity = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.Target = _Parameter</p><p>    elseif (_Index == 2) then</p><p>        self.Distance = _Parameter * 1</p><p>    elseif (_Index == 3) then</p><p>        self.Marker = AcceptAlternativeBoolean(_Parameter)</p><p>    end</p><p>    local Data = {};</p><p>    if _Index == 3 then</p><p>        Data = {"true", "false"}</p><p>    end</p><p>    return Data</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der Spieler muss einen bestimmten Quest abschließen.</p><p>-- @param _QuestName Name des Quest</p><p>-- @within Goal</p><p>    return b_Goal_WinQuest:new(...);</p><p>Goal_WinQuest</p><p>    Name = "Goal_WinQuest",</p><p>    Description = {</p><p>        en = "Goal: The player has to win a given quest",</p><p>        de = "Ziel: Der Spieler muss eine angegebene Quest erfolgreich abschliessen.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.QuestName, en = "Quest Name",      de = "Questname" },</p><p>    },</p><p>    return {Objective.Custom2, {self, self.CustomFunction}};</p><p>    if (_Index == 0) then</p><p>        self.Quest = _Parameter;</p><p>    end</p><p>    local quest = Quests[GetQuestID(self.Quest)];</p><p>    if quest then</p><p>        if quest.Result == QuestResult.Failure then</p><p>            return false;</p><p>        end</p><p>        if quest.Result == QuestResult.Success then</p><p>            return true;</p><p>        end</p><p>    end</p><p>    return nil;</p><p>    if Quests[GetQuestID(self.Quest)] == nil then</p><p>        fatal(_Quest.Identifier .. ": " .. self.Name .. ": Quest '"..self.Quest.."' does not exist!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der Spieler muss eine bestimmte Menge Gold mit Dieben stehlen.</p><p>-- Dabei ist es egal von welchem Spieler. Diebe können Gold nur aus</p><p>-- Stadtgebäude stehlen und nur von feindlichen Spielern.</p><p>-- :Das Behavior cheatet allen Zielspielern Einnahmen in den</p><p>-- Gebäuden, damit der Quest stets erfüllbar bleibt. Dies gilt auch, wenn</p><p>-- der menschliche Spieler das Ziel ist!</p><p>-- @param _Amount       Menge an Gold</p><p>-- @param _ShowProgress Fortschritt ausgeben</p><p>-- @within Goal</p><p>    return b_Goal_StealGold:new(...)</p><p>Goal_StealGold</p><p>    Name = "Goal_StealGold",</p><p>    Description = {</p><p>        en = "Goal: Steal an explicit amount of gold from a players or any players city buildings.",</p><p>        de = "Ziel: Diebe sollen eine bestimmte Menge Gold aus feindlichen Stadtgebäuden stehlen.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Number,   en = "Amount on Gold", de = "Zu stehlende Menge" },</p><p>        { ParameterType.Custom,   en = "Target player",  de = "Spieler von dem gestohlen wird" },</p><p>        { ParameterType.Custom,   en = "Print progress", de = "Fortschritt ausgeben" },</p><p>    },</p><p>    return {Objective.Custom2, {self, self.CustomFunction}};</p><p>    if (_Index == 0) then</p><p>        self.Amount = _Parameter * 1;</p><p>    elseif (_Index == 1) then</p><p>        local PlayerID = tonumber(_Paramater) or -1;</p><p>        self.Target = PlayerID * 1;</p><p>    elseif (_Index == 2) then</p><p>        _Parameter = _Parameter or "true"</p><p>        self.Printout = AcceptAlternativeBoolean(_Parameter);</p><p>    end</p><p>    self.StohlenGold = 0;</p><p>    if _Index == 1 then</p><p>        return { "-", 1, 2, 3, 4, 5, 6, 7, 8 };</p><p>    elseif _Index == 2 then</p><p>        return { "true", "false" };</p><p>    end</p><p>    local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>    local TargetPlayerName = (lang == "de" and " anderen Spielern ") or " different parties";</p><p>    if self.Target ~= -1 then</p><p>        TargetPlayerName = GetPlayerName(self.Target);</p><p>        if TargetPlayerName == nil or TargetPlayerName == "" then</p><p>            TargetPlayerName = " PLAYER_NAME_MISSING ";</p><p>        end</p><p>    end</p><p>    -- Cheat earnings</p><p>    local PlayerIDs = {self.Target};</p><p>    if self.Target == -1 then</p><p>        PlayerIDs = {1, 2, 3, 4, 5, 6, 7, 8};</p><p>    end</p><p>    for i= 1, #PlayerIDs, 1 do</p><p>        if i ~= _Quest.ReceivingPlayer and Logic.GetStoreHouse(i) ~= 0 then</p><p>            local CityBuildings = {Logic.GetPlayerEntitiesInCategory(i, EntityCategories.CityBuilding)};</p><p>            for j= 1, #CityBuildings, 1 do</p><p>                local CurrentEarnings = Logic.GetBuildingProductEarnings(CityBuildings[j]);</p><p>                if CurrentEarnings  45 and Logic.GetTime()  5 == 0 then</p><p>                    Logic.SetBuildingEarnings(CityBuildings[j], CurrentEarnings +1);</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>    local amount = self.Amount-self.StohlenGold;</p><p>    amount = (amount  0 and amount) or 0;</p><p>    local text = {</p><p>        de = "Gold von s stehlen {cr}{cr}Aus Stadtgebäuden zu stehlende Goldmenge: d",</p><p>        en = "Steal gold from s {cr}{cr}Amount on gold to steal from city buildings: d",</p><p>    };</p><p>    return "{center}" ..string.format(text[lang], TargetPlayerName, amount);</p><p>    Core:ChangeCustomQuestCaptionText(self:SetDescriptionOverwrite(_Quest), _Quest);</p><p>    if self.StohlenGold = self.Amount then</p><p>        return true;</p><p>    end</p><p>    return nil;</p><p>    return {5,13};</p><p>    if tonumber(self.Amount) == nil and self.Amount  0 then</p><p>        fatal(_Quest.Identifier .. ": " .. self.Name .. ": amount can not be negative!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>    self.StohlenGold = 0;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der Spieler muss ein bestimmtes Stadtgebäude bestehlen.</p><p>-- Eine Kirche wird immer Sabotiert. Ein Lagerhaus verhält sich ähnlich zu</p><p>-- einer Burg.</p><p>-- : Das Behavior cheatet in dem Zielgebäude Einnahmen, damit</p><p>-- ein Dieb entsandt werden kann.</p><p>-- @param _ScriptName Skriptname des Gebäudes</p><p>-- @within Goal</p><p>    return b_Goal_StealBuilding:new(...)</p><p>Goal_StealBuilding</p><p>    Name = "Goal_StealBuilding",</p><p>    Description = {</p><p>        en = "Goal: The player has to steal from a building. Not a castle and not a village storehouse!",</p><p>        de = "Ziel: Der Spieler muss ein bestimmtes Gebäude bestehlen. Dies darf keine Burg und kein Dorflagerhaus sein!",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Building", de = "Gebäude" },</p><p>    },</p><p>    return {Objective.Custom2, {self, self.CustomFunction}};</p><p>    if (_Index == 0) then</p><p>        self.Building = _Parameter</p><p>    end</p><p>    self.RobberList = {};</p><p>    if _Index == 1 then</p><p>        return { "true", "false" };</p><p>    end</p><p>    local isCathedral = Logic.IsEntityInCategory(GetID(self.Building), EntityCategories.Cathedrals) == 1;</p><p>    local isWarehouse = Logic.GetEntityType(GetID(self.Building)) == Entities.B_StoreHouse;</p><p>    local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>    local text;</p><p>    if isCathedral then</p><p>        text = {</p><p>            de = "Sabotage {cr}{cr} Sabotiert die mit Pfeil markierte Kirche.",</p><p>            en = "Sabotage {cr}{cr} Sabotage the Church of the opponent.",</p><p>        };</p><p>    elseif isWarehouse then</p><p>        text = {</p><p>            de = "Lagerhaus bestehlen {cr}{cr} Sendet einen Dieb in das markierte Lagerhaus.",</p><p>            en = "Steal from storehouse {cr}{cr} Steal from the marked storehouse.",</p><p>        };</p><p>    else</p><p>        text = {</p><p>            de = "Gebäude bestehlen {cr}{cr} Bestehlt das durch einen Pfeil markierte Gebäude.",</p><p>            en = "Steal from building {cr}{cr} Steal from the building marked by an arrow.",</p><p>        };</p><p>    end</p><p>    return "{center}" .. text[lang];</p><p>    if not IsExisting(self.Building) then</p><p>        if self.Marker then</p><p>            Logic.DestroyEffect(self.Marker);</p><p>        end</p><p>        return false;</p><p>    end</p><p>    if not self.Marker then</p><p>        local pos = GetPosition(self.Building);</p><p>        self.Marker = Logic.CreateEffect(EGL_Effects.E_Questmarker, pos.X, pos.Y, 0);</p><p>    end</p><p>    -- Cheat earnings</p><p>    local BuildingID = GetID(self.Building);</p><p>    if  Logic.IsEntityInCategory(BuildingID, EntityCategories.CityBuilding) == 1</p><p>    and Logic.GetBuildingEarnings(BuildingID)  10 then</p><p>        Logic.SetBuildingEarnings(BuildingID, 10);</p><p>    end</p><p>    if self.SuccessfullyStohlen then</p><p>        Logic.DestroyEffect(self.Marker);</p><p>        return true;</p><p>    end</p><p>    return nil;</p><p>    return {5,13};</p><p>    local eTypeName = Logic.GetEntityTypeName(Logic.GetEntityType(GetID(self.Building)));</p><p>    local IsHeadquarter = Logic.IsEntityInCategory(GetID(self.Building), EntityCategories.Headquarters) == 1;</p><p>    if Logic.IsBuilding(GetID(self.Building)) == 0 then</p><p>        fatal(_Quest.Identifier .. ": " .. self.Name .. ": target is not a building");</p><p>        return true;</p><p>    elseif not IsExisting(self.Building) then</p><p>        fatal(_Quest.Identifier .. ": " .. self.Name .. ": target is destroyed :(");</p><p>        return true;</p><p>    elseif string.find(eTypeName, "B_NPC_BanditsHQ") or string.find(eTypeName, "B_NPC_Cloister") or string.find(eTypeName, "B_NPC_StoreHouse") then</p><p>        fatal(_Quest.Identifier .. ": " .. self.Name .. ": village storehouses are not allowed!");</p><p>        return true;</p><p>    elseif IsHeadquarter then</p><p>        fatal(_Quest.Identifier .. ": " .. self.Name .. ": use Goal_StealInformation for headquarters!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>    self.SuccessfullyStohlen = false;</p><p>    self.RobberList = {};</p><p>    self.Marker = nil;</p><p>    Logic.DestroyEffect(self.Marker);</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der Spieler muss ein Gebäude mit einem Dieb ausspoinieren.</p><p>-- Der Quest ist erfolgreich, sobald der Dieb in das Gebäude eindringt. Es</p><p>-- muss sich um ein Gebäude handeln, das bestohlen werden kann (Burg, Lager,</p><p>-- Kirche, Stadtgebäude mit Einnahmen)!</p><p>-- Optional kann der Dieb nach Abschluss gelöscht werden. Diese Option macht</p><p>-- es einfacher ihn durch z.B. einen Abfahrenden U_ThiefCart zu "ersetzen".</p><p>-- :Das Behavior cheatet in dem Zielgebäude Einnahmen, damit</p><p>-- ein Dieb entsandt werden kann.</p><p>-- @param _ScriptName  Skriptname des Gebäudes</p><p>-- @param _DeleteThief Dieb nach Abschluss löschen</p><p>-- @within Goal</p><p>    return b_Goal_SpyBuilding:new(...)</p><p>Goal_SpyBuilding</p><p>    Name = "Goal_SpyBuilding",</p><p>    IconOverwrite = {5,13},</p><p>    Description = {</p><p>        en = "Goal: Infiltrate a building with a thief. A thief must be able to steal from the target building.",</p><p>        de = "Ziel: Infiltriere ein Gebäude mit einem Dieb. Nur mit Gebaueden möglich, die bestohlen werden koennen.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Target Building", de = "Zielgebäude" },</p><p>        { ParameterType.Custom,     en = "Destroy Thief", de = "Dieb löschen" },</p><p>    },</p><p>    return {Objective.Custom2, {self, self.CustomFunction}};</p><p>    if (_Index == 0) then</p><p>        self.Building = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        _Parameter = _Parameter or "true"</p><p>        self.Delete = AcceptAlternativeBoolean(_Parameter)</p><p>    end</p><p>    if _Index == 1 then</p><p>        return { "true", "false" };</p><p>    end</p><p>    if not _Quest.QuestDescription then</p><p>        local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>        local text = {</p><p>            de = "Gebäude infriltrieren {cr}{cr}Spioniere das markierte Gebäude mit einem Dieb aus!",</p><p>            en = "Infiltrate building {cr}{cr}Spy on the highlighted buildings with a thief!",</p><p>        };</p><p>        return text[lang];</p><p>    else</p><p>        return _Quest.QuestDescription;</p><p>    end</p><p>    if not IsExisting(self.Building) then</p><p>        if self.Marker then</p><p>            Logic.DestroyEffect(self.Marker);</p><p>        end</p><p>        return false;</p><p>    end</p><p>    if not self.Marker then</p><p>        local pos = GetPosition(self.Building);</p><p>        self.Marker = Logic.CreateEffect(EGL_Effects.E_Questmarker, pos.X, pos.Y, 0);</p><p>    end</p><p>    -- Cheat earnings</p><p>    local BuildingID = GetID(self.Building);</p><p>    if  Logic.IsEntityInCategory(BuildingID, EntityCategories.CityBuilding) == 1</p><p>    and Logic.GetBuildingEarnings(BuildingID)  10 then</p><p>        Logic.SetBuildingEarnings(BuildingID, 10);</p><p>    end</p><p>    if self.Infiltrated then</p><p>        Logic.DestroyEffect(self.Marker);</p><p>        return true;</p><p>    end</p><p>    return nil;</p><p>    return self.IconOverwrite;</p><p>    if Logic.IsBuilding(GetID(self.Building)) == 0 then</p><p>        fatal(_Quest.Identifier .. ": " .. self.Name .. ": target is not a building");</p><p>        return true;</p><p>    elseif not IsExisting(self.Building) then</p><p>        fatal(_Quest.Identifier .. ": " .. self.Name .. ": target is destroyed :(");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>    self.Infiltrated = false;</p><p>    self.Marker = nil;</p><p>    Logic.DestroyEffect(self.Marker);</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Es muss eine Menge an Munition in der Kriegsmaschine erreicht werden.</p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- @param _ScriptName  Name des Kriegsgerät</p><p>-- @param _Relation    Mengenrelation</p><p>-- @param _Amount      Menge an Munition</p><p>-- @within Goal</p><p>    return b_Goal_AmmunitionAmount:new(...);</p><p>Goal_AmmunitionAmount</p><p>    Name = "Goal_AmmunitionAmount",</p><p>    Description = {</p><p>        en = "Goal: Reach a smaller or bigger value than the given amount of ammunition in a war machine.",</p><p>        de = "Ziel: Ueber- oder unterschreite die angegebene Anzahl Munition in einem Kriegsgerät.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Script name", de = "Skriptname" },</p><p>        { ParameterType.Custom, en = "Relation", de = "Relation" },</p><p>        { ParameterType.Number, en = "Amount", de = "Menge" },</p><p>    },</p><p>    return { Objective.Custom2, {self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.Scriptname = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.bRelSmallerThan = tostring(_Parameter) == "true" or _Parameter == ""</p><p>    elseif (_Index == 2) then</p><p>        self.Amount = _Parameter * 1</p><p>    end</p><p>    local EntityID = GetID(self.Scriptname);</p><p>    if not IsExisting(EntityID) then</p><p>        return false;</p><p>    end</p><p>    local HaveAmount = Logic.GetAmmunitionAmount(EntityID);</p><p>    if ( self.bRelSmallerThan and HaveAmount = self.Amount ) then</p><p>        return true;</p><p>    end</p><p>    return nil;</p><p>    if self.Amount  0 then</p><p>        fatal(_Quest.Identifier .. ": Error in " .. self.Name .. ": Amount is negative");</p><p>        return true</p><p>    end</p><p>    if _Index == 1 then</p><p>        return {"="};</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Eine Menge an Entities des angegebenen Spawnpoint muss zerstört werden.</p><p>-- Wenn die angegebene Anzahl zu Beginn des Quest nicht mit der Anzahl an</p><p>-- bereits gespawnten Entities übereinstimmt, wird dies automatisch korrigiert.</p><p>-- (Neue Entities gespawnt bzw. überschüssige gelöscht)</p><p>-- @param              _SpawnPoint Spawnpoint oder Liste von Spawnpoints</p><p>-- @param[type=number] _Amount     Menge zu zerstörender Entities</p><p>-- @within Goal</p><p>    return b_Goal_DestroySpawnedEntities:new(...);</p><p>Goal_DestroySpawnedEntities</p><p>    Name = "Goal_DestroySpawnedEntities",</p><p>    Description = {</p><p>        en = "Goal: Destroy all entities spawned at the spawnpoint.",</p><p>        de = "Ziel: Zerstöre alle Entitäten, die bei dem Spawnpoint erzeugt wurde.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Spawnpoint", de = "Spawnpoint" },</p><p>        { ParameterType.Number,     en = "Amount",     de = "Menge" },</p><p>    },</p><p>    return {Objective.DestroyEntities, 3, self.SpawnPoint, self.Amount};</p><p>    if (_Index == 0) then</p><p>        if type(_Parameter) ~= "table" then</p><p>            _Parameter = {_Parameter};</p><p>        end</p><p>        self.SpawnPoint = _Parameter;</p><p>    elseif (_Index == 1) then</p><p>        self.Amount = _Parameter * 1;</p><p>    end</p><p>    return "Quest_DestroyEntities";</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der Spieler muss mindestens den angegebenen Ruf erreichen. Der Ruf muss</p><p>-- in Prozent angegeben werden (ohne -Zeichen).</p><p>-- @param[type=number] _Reputation Benötigter Ruf</p><p>-- @within Goal</p><p>    return b_Goal_CityReputation:new(...);</p><p>Goal_CityReputation</p><p>    Name = "Goal_CityReputation",</p><p>    Description = {</p><p>        en = "Goal: Der Ruf der Stadt des Empfängers muss mindestens so hoch sein, wie angegeben.",</p><p>        de = "Ziel: The reputation of the quest receivers city must at least reach the desired hight.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Number, en = "City reputation", de = "Ruf der Stadt" },</p><p>    },</p><p>    Text = {</p><p>        de = "RUF DER STADT{cr}{cr}Hebe den Ruf der Stadt durch weise Herrschaft an!{cr}Benötigter Ruf: d",</p><p>        en = "CITY REPUTATION{cr}{cr}Raise your reputation by fair rulership!{cr}Needed reputation: d",</p><p>    }</p><p>    return {Objective.Custom2, {self, self.CustomFunction}};</p><p>    if (_Index == 0) then</p><p>        self.Reputation = _Parameter * 1;</p><p>    end</p><p>    self:SetCaption(_Quest);</p><p>    local CityReputation = Logic.GetCityReputation(_Quest.ReceivingPlayer) * 100;</p><p>    if CityReputation = self.Reputation then</p><p>        return true;</p><p>    end</p><p>    if not _Quest.QuestDescription or _Quest.QuestDescription == "" then</p><p>    local Language = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>        local Text = string.format(self.Text[Language], self.Reputation);</p><p>        Core:ChangeCustomQuestCaptionText(Text, _Quest);</p><p>    end</p><p>    if type(self.Reputation) ~= "number" or self.Reputation  100 then</p><p>        API.Fatal(_Quest.Identifier.. " " ..self.Name.. ": Reputation must be between 0 and 100!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Reprisals                                                                  --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ändert die Position eines Siedlers oder eines Gebäudes.</p><p>-- Optional kann das Entity in einem bestimmten Abstand zum Ziel platziert</p><p>-- werden und das Ziel anschauen. Die Entfernung darf nicht kleiner sein</p><p>-- als 50!</p><p>-- @param _ScriptName Skriptname des Entity</p><p>-- @param _Target     Skriptname des Ziels</p><p>-- @param _LookAt     Gegenüberstellen</p><p>-- @param _Distance   Relative Entfernung (nur mit _LookAt)</p><p>-- @within Reprisal</p><p>    return b_Reprisal_SetPosition:new(...);</p><p>Reprisal_SetPosition</p><p>    Name = "Reprisal_SetPosition",</p><p>    Description = {</p><p>        en = "Reprisal: Places an entity relative to the position of another. The entity can look the target.",</p><p>        de = "Vergeltung: Setzt eine Entity relativ zur Position einer anderen. Die Entity kann zum Ziel ausgerichtet werden.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Entity",             de = "Entity", },</p><p>        { ParameterType.ScriptName, en = "Target position", de = "Zielposition", },</p><p>        { ParameterType.Custom,     en = "Face to face",     de = "Ziel ansehen", },</p><p>        { ParameterType.Number,     en = "Distance",         de = "Zielentfernung", },</p><p>    },</p><p>    return { Reprisal.Custom, { self, self.CustomFunction } }</p><p>    if (_Index == 0) then</p><p>        self.Entity = _Parameter;</p><p>    elseif (_Index == 1) then</p><p>        self.Target = _Parameter;</p><p>    elseif (_Index == 2) then</p><p>        self.FaceToFace = AcceptAlternativeBoolean(_Parameter)</p><p>    elseif (_Index == 3) then</p><p>        self.Distance = (_Parameter ~= nil and tonumber(_Parameter)) or 100;</p><p>    end</p><p>    if not IsExisting(self.Entity) or not IsExisting(self.Target) then</p><p>        return;</p><p>    end</p><p>    local entity = GetID(self.Entity);</p><p>    local target = GetID(self.Target);</p><p>    local x,y,z = Logic.EntityGetPos(target);</p><p>    if Logic.IsBuilding(target) == 1 then</p><p>        x,y = Logic.GetBuildingApproachPosition(target);</p><p>    end</p><p>    local ori = Logic.GetEntityOrientation(target)+90;</p><p>    if self.FaceToFace then</p><p>        x = x + self.Distance * math.cos( math.rad(ori) );</p><p>        y = y + self.Distance * math.sin( math.rad(ori) );</p><p>        Logic.DEBUG_SetSettlerPosition(entity, x, y);</p><p>        LookAt(self.Entity, self.Target);</p><p>    else</p><p>        if Logic.IsBuilding(target) == 1 then</p><p>            x,y = Logic.GetBuildingApproachPosition(target);</p><p>        end</p><p>        Logic.DEBUG_SetSettlerPosition(entity, x, y);</p><p>    end</p><p>    if _Index == 2 then</p><p>        return { "true", "false" }</p><p>    end</p><p>    if self.FaceToFace then</p><p>        if tonumber(self.Distance) == nil or self.Distance  50 then</p><p>            fatal(_Quest.Identifier.. " " ..self.Name.. ": Distance is nil or to short!");</p><p>            return true;</p><p>        end</p><p>    end</p><p>    if not IsExisting(self.Entity) or not IsExisting(self.Target) then</p><p>        fatal(_Quest.Identifier.. " " ..self.Name.. ": Mover entity or target entity does not exist!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ändert den Eigentümer des Entity oder des Battalions.</p><p>-- @param _ScriptName Skriptname des Entity</p><p>-- @param _NewOwner   PlayerID des Eigentümers</p><p>-- @within Reprisal</p><p>    return b_Reprisal_ChangePlayer:new(...)</p><p>Reprisal_ChangePlayer</p><p>    Name = "Reprisal_ChangePlayer",</p><p>    Description = {</p><p>        en = "Reprisal: Changes the owner of the entity or a battalion.",</p><p>        de = "Vergeltung: Aendert den Besitzer einer Entity oder eines Battalions.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Entity",     de = "Entity", },</p><p>        { ParameterType.Custom,     en = "Player",     de = "Spieler", },</p><p>    },</p><p>    return { Reprisal.Custom, { self, self.CustomFunction } }</p><p>    if (_Index == 0) then</p><p>        self.Entity = _Parameter;</p><p>    elseif (_Index == 1) then</p><p>        self.Player = tostring(_Parameter);</p><p>    end</p><p>    if not IsExisting(self.Entity) then</p><p>        return;</p><p>    end</p><p>    local eID = GetID(self.Entity);</p><p>    if Logic.IsLeader(eID) == 1 then</p><p>        Logic.ChangeSettlerPlayerID(eID, self.Player);</p><p>    else</p><p>        Logic.ChangeEntityPlayerID(eID, self.Player);</p><p>    end</p><p>    if _Index == 1 then</p><p>        return {"0", "1", "2", "3", "4", "5", "6", "7", "8"}</p><p>    end</p><p>    if not IsExisting(self.Entity) then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": entity '"..  self.Entity .. "' does not exist!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ändert die Sichtbarkeit eines Entity.</p><p>-- @param _ScriptName Skriptname des Entity</p><p>-- @param _Visible    Sichtbarkeit an/aus</p><p>-- @within Reprisal</p><p>    return b_Reprisal_SetVisible:new(...)</p><p>Reprisal_SetVisible</p><p>    Name = "Reprisal_SetVisible",</p><p>    Description = {</p><p>        en = "Reprisal: Changes the visibility of an entity. If the entity is a spawner the spawned entities will be affected.",</p><p>        de = "Strafe: Setzt die Sichtbarkeit einer Entity. Handelt es sich um einen Spawner werden auch die gespawnten Entities beeinflusst.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Entity",     de = "Entity", },</p><p>        { ParameterType.Custom,     en = "Visible",     de = "Sichtbar", },</p><p>    },</p><p>    return { Reprisal.Custom, { self, self.CustomFunction } }</p><p>    if (_Index == 0) then</p><p>        self.Entity = _Parameter;</p><p>    elseif (_Index == 1) then</p><p>        self.Visible = AcceptAlternativeBoolean(_Parameter)</p><p>    end</p><p>    if not IsExisting(self.Entity) then</p><p>        return;</p><p>    end</p><p>    local eID = GetID(self.Entity);</p><p>    local pID = Logic.EntityGetPlayer(eID);</p><p>    local eType = Logic.GetEntityType(eID);</p><p>    local tName = Logic.GetEntityTypeName(eType);</p><p>    if string.find(tName, "S_") or string.find(tName, "B_NPC_Bandits")</p><p>    or string.find(tName, "B_NPC_Barracks") then</p><p>        local spawned = {Logic.GetSpawnedEntities(eID)};</p><p>        for i=1, #spawned do</p><p>            if Logic.IsLeader(spawned[i]) == 1 then</p><p>                local soldiers = {Logic.GetSoldiersAttachedToLeader(spawned[i])};</p><p>                for j=2, #soldiers do</p><p>                    Logic.SetVisible(soldiers[j], self.Visible);</p><p>                end</p><p>            else</p><p>                Logic.SetVisible(spawned[i], self.Visible);</p><p>            end</p><p>        end</p><p>    else</p><p>        if Logic.IsLeader(eID) == 1 then</p><p>            local soldiers = {Logic.GetSoldiersAttachedToLeader(eID)};</p><p>            for j=2, #soldiers do</p><p>                Logic.SetVisible(soldiers[j], self.Visible);</p><p>            end</p><p>        else</p><p>            Logic.SetVisible(eID, self.Visible);</p><p>        end</p><p>    end</p><p>    if _Index == 1 then</p><p>        return { "true", "false" }</p><p>    end</p><p>    if not IsExisting(self.Entity) then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": entity '"..  self.Entity .. "' does not exist!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Macht das Entity verwundbar oder unverwundbar.</p><p>-- Bei einem Battalion wirkt sich das Behavior auf alle Soldaten und den</p><p>-- (unsichtbaren) Leader aus. Wird das Behavior auf ein Spawner Entity </p><p>-- angewendet, werden die gespawnten Entities genommen.</p><p>-- @param _ScriptName Skriptname des Entity</p><p>-- @param _Vulnerable Verwundbarkeit an/aus</p><p>-- @within Reprisal</p><p>    return b_Reprisal_SetVulnerability:new(...);</p><p>Reprisal_SetVulnerability</p><p>    Name = "Reprisal_SetVulnerability",</p><p>    Description = {</p><p>        en = "Reprisal: Changes the vulnerability of the entity. If the entity is a spawner the spawned entities will be affected.",</p><p>        de = "Vergeltung: Macht eine Entity verwundbar oder unverwundbar. Handelt es sich um einen Spawner, sind die gespawnten Entities betroffen",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Entity",              de = "Entity", },</p><p>        { ParameterType.Custom,     en = "Vulnerability",      de = "Verwundbar", },</p><p>    },</p><p>    return { Reprisal.Custom, { self, self.CustomFunction } }</p><p>    if (_Index == 0) then</p><p>        self.Entity = _Parameter;</p><p>    elseif (_Index == 1) then</p><p>        self.Vulnerability = AcceptAlternativeBoolean(_Parameter)</p><p>    end</p><p>    if not IsExisting(self.Entity) then</p><p>        return;</p><p>    end</p><p>    local eID = GetID(self.Entity);</p><p>    local eType = Logic.GetEntityType(eID);</p><p>    local tName = Logic.GetEntityTypeName(eType);</p><p>    local EntitiesToCheck = {eID};</p><p>    if string.find(tName, "S_") or string.find(tName, "B_NPC_Bandits")</p><p>    or string.find(tName, "B_NPC_Barracks") then</p><p>        EntitiesToCheck = {Logic.GetSpawnedEntities(eID)};</p><p>    end</p><p>    local MethodToUse = "MakeInvulnerable";</p><p>    if self.Vulnerability then</p><p>        MethodToUse = "MakeVulnerable";</p><p>    end</p><p>    for i= 1, #EntitiesToCheck, 1 do</p><p>        if Logic.IsLeader(EntitiesToCheck[i]) == 1 then</p><p>            local Soldiers = {Logic.GetSoldiersAttachedToLeader(EntitiesToCheck[i])};</p><p>            for j=2, #Soldiers, 1 do</p><p>                _G[MethodToUse](Soldiers[j]);</p><p>            end</p><p>        end</p><p>        _G[MethodToUse](EntitiesToCheck[i]);</p><p>    end</p><p>    if _Index == 1 then</p><p>        return { "true", "false" }</p><p>    end</p><p>    if not IsExisting(self.Entity) then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": entity '"..  self.Entity .. "' does not exist!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ändert das Model eines Entity.</p><p>-- In Verbindung mit Reward_SetVisible oder Reprisal_SetVisible können</p><p>-- Script Entites ein neues Model erhalten und sichtbar gemacht werden.</p><p>-- Das hat den Vorteil, das Script Entities nicht überbaut werden können.</p><p>-- @param _ScriptName Skriptname des Entity</p><p>-- @param _Model      Neues Model</p><p>-- @within Reprisal</p><p>    return b_Reprisal_SetModel:new(...);</p><p>Reprisal_SetModel</p><p>    Name = "Reprisal_SetModel",</p><p>    Description = {</p><p>        en = "Reprisal: Changes the model of the entity. Be careful, some models crash the game.",</p><p>        de = "Vergeltung: Aendert das Model einer Entity. Achtung: Einige Modelle fuehren zum Absturz.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Entity",     de = "Entity", },</p><p>        { ParameterType.Custom,     en = "Model",     de = "Model", },</p><p>    },</p><p>    return { Reprisal.Custom, { self, self.CustomFunction } }</p><p>    if (_Index == 0) then</p><p>        self.Entity = _Parameter;</p><p>    elseif (_Index == 1) then</p><p>        self.Model = _Parameter;</p><p>    end</p><p>    if not IsExisting(self.Entity) then</p><p>        return;</p><p>    end</p><p>    local eID = GetID(self.Entity);</p><p>    Logic.SetModel(eID, Models[self.Model]);</p><p>    if _Index == 1 then</p><p>        local Data = {};</p><p>        for k,v in pairs(Models) do</p><p>            if  not string.find(k,"Animals_") and not string.find(k,"Banners_") and not string.find(k,"Goods_") and not string.find(k,"goods_")</p><p>            and not string.find(k,"Heads_") and not string.find(k,"MissionMap_") and not string.find(k,"R_Fish") and not string.find(k,"Units_")</p><p>            and not string.find(k,"XD_") and not string.find(k,"XS_") and not string.find(k,"XT_") and not string.find(k,"Z_") then</p><p>                table.insert(Data,k);</p><p>            end</p><p>        end</p><p>        return Data;</p><p>    end</p><p>    if not IsExisting(self.Entity) then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": entity '"..  self.Entity .. "' does not exist!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Rewards                                                                    --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ändert die Position eines Siedlers oder eines Gebäudes.</p><p>-- Optional kann das Entity in einem bestimmten Abstand zum Ziel platziert</p><p>-- werden und das Ziel anschauen. Die Entfernung darf nicht kleiner sein</p><p>-- als 50!</p><p>-- @param _ScriptName Skriptname des Entity</p><p>-- @param _Target     Skriptname des Ziels</p><p>-- @param _LookAt     Gegenüberstellen</p><p>-- @param _Distance   Relative Entfernung (nur mit _LookAt)</p><p>-- @within Reward</p><p>    return b_Reward_SetPosition:new(...);</p><p>Reward_SetPosition = API.InstanceTable(b_Reprisal_SetPositi</p><p>Reward_SetPosition.Name = "Reward_SetPositi</p><p>Reward_SetPosition.Description.en = "Reward: Places an entity relative to the position of another. The entity can look the targe</p><p>Reward_SetPosition.Description.de = "Lohn: Setzt eine Entity relativ zur Position einer anderen. Die Entity kann zum Ziel ausgerichtet werde</p><p>Reward_SetPosition.GetReprisalTable = </p><p>Reward_SetPosition.GetRewardTable = function(self, _Qu</p><p>    return { Reward.Custom, { self, self.CustomFunction } };</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ändert den Eigentümer des Entity oder des Battalions.</p><p>-- @param _ScriptName Skriptname des Entity</p><p>-- @param _NewOwner   PlayerID des Eigentümers</p><p>-- @within Reward</p><p>    return b_Reward_ChangePlayer:new(...);</p><p>Reward_ChangePlayer = API.InstanceTable(b_Reprisal_ChangePlay</p><p>Reward_ChangePlayer.Name = "Reward_ChangePlay</p><p>Reward_ChangePlayer.Description.en = "Reward: Changes the owner of the entity or a battalio</p><p>Reward_ChangePlayer.Description.de = "Lohn: Aendert den Besitzer einer Entity oder eines Battalion</p><p>Reward_ChangePlayer.GetReprisalTable = </p><p>Reward_ChangePlayer.GetRewardTable = function(self, _Qu</p><p>    return { Reward.Custom, { self, self.CustomFunction } };</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Bewegt einen Siedler relativ zu einem Zielpunkt.</p><p>-- Der Siedler wird sich zum Ziel ausrichten und in der angegeben Distanz</p><p>-- und dem angegebenen Winkel Position beziehen.</p><p>--  Funktioniert ähnlich wie MoveEntityToPositionToAnotherOne.</p><p>-- </p><p>-- @param _ScriptName  Skriptname des Entity</p><p>-- @param _Destination Skriptname des Ziels</p><p>-- @param _Distance    Entfernung</p><p>-- @param _Angle       Winkel</p><p>-- @within Reward</p><p>    return b_Reward_MoveToPosition:new(...);</p><p>Reward_MoveToPosition</p><p>    Name = "Reward_MoveToPosition",</p><p>    Description = {</p><p>        en = "Reward: Moves an entity relative to another entity. If angle is zero the entities will be standing directly face to face.",</p><p>        de = "Lohn: Bewegt eine Entity relativ zur Position einer anderen. Wenn Winkel 0 ist, stehen sich die Entities direkt gegen�ber.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Settler", de = "Siedler" },</p><p>        { ParameterType.ScriptName, en = "Destination", de = "Ziel" },</p><p>        { ParameterType.Number,     en = "Distance", de = "Entfernung" },</p><p>        { ParameterType.Number,     en = "Angle", de = "Winkel" },</p><p>    },</p><p>    return { Reward.Custom, {self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.Entity = _Parameter;</p><p>    elseif (_Index == 1) then</p><p>        self.Target = _Parameter;</p><p>    elseif (_Index == 2) then</p><p>        self.Distance = _Parameter * 1;</p><p>    elseif (_Index == 3) then</p><p>        self.Angle = _Parameter * 1;</p><p>    end</p><p>    if not IsExisting(self.Entity) or not IsExisting(self.Target) then</p><p>        return;</p><p>    end</p><p>    self.Angle = self.Angle or 0;</p><p>    local entity = GetID(self.Entity);</p><p>    local target = GetID(self.Target);</p><p>    local orientation = Logic.GetEntityOrientation(target);</p><p>    local x,y,z = Logic.EntityGetPos(target);</p><p>    if Logic.IsBuilding(target) == 1 then</p><p>        x, y = Logic.GetBuildingApproachPosition(target);</p><p>        orientation = orientation -90;</p><p>    end</p><p>    x = x + self.Distance * math.cos( math.rad(orientation+self.Angle) );</p><p>    y = y + self.Distance * math.sin( math.rad(orientation+self.Angle) );</p><p>    Logic.MoveSettler(entity, x, y);</p><p>    StartSimpleJobEx( function(_entityID, _targetID)</p><p>        if Logic.IsEntityMoving(_entityID) == false then</p><p>            LookAt(_entityID, _targetID);</p><p>            return true;</p><p>        end</p><p>    end, entity, target);</p><p>    if tonumber(self.Distance) == nil or self.Distance  50 then</p><p>        fatal(_Quest.Identifier.. " " ..self.Name.. ": Distance is nil or to short!");</p><p>        return true;</p><p>    elseif not IsExisting(self.Entity) or not IsExisting(self.Target) then</p><p>        fatal(_Quest.Identifier.. " " ..self.Name.. ": Mover entity or target entity does not exist!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der Spieler gewinnt das Spiel mit einem animierten Siegesfest.</p><p>-- Es ist nicht möglich weiterzuspielen!</p><p>-- @within Reward</p><p>    return b_Reward_VictoryWithParty:new();</p><p>Reward_VictoryWithParty</p><p>    Name = "Reward_VictoryWithParty",</p><p>    Description = {</p><p>        en = "Reward: The player wins the game with an animated festival on the market.",</p><p>        de = "Lohn: Der Spieler gewinnt das Spiel mit einer animierten Siegesfeier.",</p><p>    },</p><p>    Parameter =    {}</p><p>    return {Reward.Custom, {self, self.CustomFunction}};</p><p>    Victory(g_VictoryAndDefeatType.VictoryMissionComplete);</p><p>    local pID = _Quest.ReceivingPlayer;</p><p>    local market = Logic.GetMarketplace(pID);</p><p>    if IsExisting(market) then</p><p>        local pos = GetPosition(market)</p><p>        Logic.CreateEffect(EGL_Effects.FXFireworks01,pos.X,pos.Y,0);</p><p>        Logic.CreateEffect(EGL_Effects.FXFireworks02,pos.X,pos.Y,0);</p><p>        local PossibleSettlerTypes = {</p><p>            Entities.U_SmokeHouseWorker,</p><p>            Entities.U_Butcher,</p><p>            Entities.U_Carpenter,</p><p>            Entities.U_Tanner,</p><p>            Entities.U_Blacksmith,</p><p>            Entities.U_CandleMaker,</p><p>            Entities.U_Baker,</p><p>            Entities.U_DairyWorker,</p><p>            Entities.U_SpouseS01,</p><p>            Entities.U_SpouseS02,</p><p>            Entities.U_SpouseS02,</p><p>            Entities.U_SpouseS03,</p><p>            Entities.U_SpouseF01,</p><p>            Entities.U_SpouseF01,</p><p>            Entities.U_SpouseF02,</p><p>            Entities.U_SpouseF03,</p><p>        };</p><p>        VictoryGenerateFestivalAtPlayer(pID, PossibleSettlerTypes);</p><p>        Logic.ExecuteInLuaLocalState([[</p><p>            if IsExisting(]]..market..[[) then</p><p>                CameraAnimation.AllowAbort = false</p><p>                CameraAnimation.QueueAnimation(CameraAnimation.SetCameraToEntity, ]]..market..[[)</p><p>                CameraAnimation.QueueAnimation(CameraAnimation.StartCameraRotation, 5)</p><p>                CameraAnimation.QueueAnimation(CameraAnimation.Stay ,9999)</p><p>            end</p><p>            XGUIEng.ShowWidget("/InGame/InGame/MissionEndScreen/ContinuePlaying", 0);</p><p>        ]]);</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ändert die Sichtbarkeit eines Entity.</p><p>-- @param _ScriptName Skriptname des Entity</p><p>-- @param _Visible    Sichtbarkeit an/aus</p><p>-- @within Reprisal</p><p>    return b_Reward_SetVisible:new(...)</p><p>Reward_SetVisible = API.InstanceTable(b_Reprisal_SetVisib</p><p>Reward_SetVisible.Name = "Reward_SetVisib</p><p>Reward_SetVisible.Description.en = "Reward: Changes the visibility of an entity. If the entity is a spawner the spawned entities will be affecte</p><p>Reward_SetVisible.Description.de = "Lohn: Setzt die Sichtbarkeit einer Entity. Handelt es sich um einen Spawner werden auch die gespawnten Entities beeinfluss</p><p>Reward_SetVisible.GetReprisalTable = </p><p>Reward_SetVisible.GetRewardTable = function(self, _Qu</p><p>    return { Reward.Custom, { self, self.CustomFunction } }</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Gibt oder entzieht einem KI-Spieler die Kontrolle über ein Entity.</p><p>-- @param _ScriptName Skriptname des Entity</p><p>-- @param _Controlled Durch KI kontrollieren an/aus</p><p>-- @within Reward</p><p>    return b_Reward_AI_SetEntityControlled:new(...);</p><p>Reward_AI_SetEntityControlled</p><p>    Name = "Reward_AI_SetEntityControlled",</p><p>    Description = {</p><p>        en = "Reward: Bind or Unbind an entity or a battalion to/from an AI player. The AI player must be activated!",</p><p>        de = "Lohn: Die KI kontrolliert die Entity oder der KI die Kontrolle entziehen. Die KI muss aktiv sein!",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Entity",               de = "Entity", },</p><p>        { ParameterType.Custom,     en = "AI control entity", de = "KI kontrolliert Entity", },</p><p>    },</p><p>    return { Reward.Custom, { self, self.CustomFunction } }</p><p>    if (_Index == 0) then</p><p>        self.Entity = _Parameter;</p><p>    elseif (_Index == 1) then</p><p>        self.Hidden = AcceptAlternativeBoolean(_Parameter)</p><p>    end</p><p>    if not IsExisting(self.Entity) then</p><p>        return;</p><p>    end</p><p>    local eID = GetID(self.Entity);</p><p>    local pID = Logic.EntityGetPlayer(eID);</p><p>    local eType = Logic.GetEntityType(eID);</p><p>    local tName = Logic.GetEntityTypeName(eType);</p><p>    if string.find(tName, "S_") or string.find(tName, "B_NPC_Bandits")</p><p>    or string.find(tName, "B_NPC_Barracks") then</p><p>        local spawned = {Logic.GetSpawnedEntities(eID)};</p><p>        for i=1, #spawned do</p><p>            if Logic.IsLeader(spawned[i]) == 1 then</p><p>                AICore.HideEntityFromAI(pID, spawned[i], not self.Hidden);</p><p>            end</p><p>        end</p><p>    else</p><p>        AICore.HideEntityFromAI(pID, eID, not self.Hidden);</p><p>    end</p><p>    if _Index == 1 then</p><p>        return { "false", "true" }</p><p>    end</p><p>    if not IsExisting(self.Entity) then</p><p>        fatal(_Quest.Identifier .. " " .. self.Name .. ": entity '"..  self.Entity .. "' does not exist!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Macht das Entity verwundbar oder unverwundbar.</p><p>-- Bei einem Battalion wirkt sich das Behavior auf alle Soldaten und den</p><p>-- (unsichtbaren) Leader aus. Wird das Behavior auf ein Spawner Entity </p><p>-- angewendet, werden die gespawnten Entities genommen.</p><p>-- @param _ScriptName Skriptname des Entity</p><p>-- @param _Vulnerable Verwundbarkeit an/aus</p><p>-- @within Reward</p><p>    return b_Reward_SetVulnerability:new(...);</p><p>Reward_SetVulnerability = API.InstanceTable(b_Reprisal_SetVulnerabili</p><p>Reward_SetVulnerability.Name = "Reward_SetVulnerabili</p><p>Reward_SetVulnerability.Description.en = "Reward: Changes the vulnerability of the entity. If the entity is a spawner the spawned entities will be affecte</p><p>Reward_SetVulnerability.Description.de = "Lohn: Macht eine Entity verwundbar oder unverwundbar. Handelt es sich um einen Spawner, sind die gespawnten Entities betroffe</p><p>Reward_SetVulnerability.GetReprisalTable = </p><p>Reward_SetVulnerability.GetRewardTable = function(self, _Qu</p><p>    return { Reward.Custom, { self, self.CustomFunction } }</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ändert das Model eines Entity.</p><p>-- In Verbindung mit Reward_SetVisible oder Reprisal_SetVisible können</p><p>-- Script Entites ein neues Model erhalten und sichtbar gemacht werden.</p><p>-- Das hat den Vorteil, das Script Entities nicht überbaut werden können.</p><p>-- @param _ScriptName Skriptname des Entity</p><p>-- @param _Model      Neues Model</p><p>-- @within Reward</p><p>    return b_Reward_SetModel:new(...);</p><p>Reward_SetModel = API.InstanceTable(b_Reprisal_SetMod</p><p>Reward_SetModel.Name = "Reward_SetMod</p><p>Reward_SetModel.Description.en = "Reward: Changes the model of the entity. Be careful, some models crash the gam</p><p>Reward_SetModel.Description.de = "Lohn: Aendert das Model einer Entity. Achtung: Einige Modelle fuehren zum Abstur</p><p>Reward_SetModel.GetReprisalTable = </p><p>Reward_SetModel.GetRewardTable = function(self, _Qu</p><p>    return { Reward.Custom, { self, self.CustomFunction } }</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Füllt die Munition in der Kriegsmaschine vollständig auf.</p><p>-- @param _ScriptName Skriptname des Entity</p><p>-- @within Reward</p><p>    return b_Reward_RefillAmmunition:new(...);</p><p>Reward_RefillAmmunition</p><p>    Name = "Reward_RefillAmmunition",</p><p>    Description = {</p><p>        en = "Reward: Refills completely the ammunition of the entity.",</p><p>        de = "Lohn: Fuellt die Munition der Entity vollständig auf.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Script name", de = "Skriptname" },</p><p>    },</p><p>    return { Reward.Custom, {self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.Scriptname = _Parameter</p><p>    end</p><p>    local EntityID = GetID(self.Scriptname);</p><p>    if not IsExisting(EntityID) then</p><p>        return;</p><p>    end</p><p>    local Ammunition = Logic.GetAmmunitionAmount(EntityID);</p><p>    while (Ammunition  10)</p><p>    do</p><p>        Logic.RefillAmmunitions(EntityID);</p><p>        Ammunition = Logic.GetAmmunitionAmount(EntityID);</p><p>    end</p><p>    if not IsExisting(self.Scriptname) then</p><p>        fatal(_Quest.Identifier .. ": Error in " .. self.Name .. ": '"..self.Scriptname.."' is destroyed!");</p><p>        return true</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Trigger                                                                    --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet den Quest, sobald mindestens X von Y Quests fehlgeschlagen sind.</p><p>-- @param _MinAmount Mindestens zu verlieren (max. 5)</p><p>-- @param _QuestAmount Anzahl geprüfter Quests (max. 5 und = _MinAmount)</p><p>-- @param _Quest1      Name des 1. Quest</p><p>-- @param _Quest2      Name des 2. Quest</p><p>-- @param _Quest3      Name des 3. Quest</p><p>-- @param _Quest4      Name des 4. Quest</p><p>-- @param _Quest5      Name des 5. Quest</p><p>-- @within Trigger</p><p>    return b_Trigger_OnAtLeastXOfYQuestsFailed:new(...);</p><p>Trigger_OnAtLeastXOfYQuestsFailed</p><p>    Name = "Trigger_OnAtLeastXOfYQuestsFailed",</p><p>    Description = {</p><p>        en = "Trigger: if at least X of Y given quests has been finished successfully.",</p><p>        de = "Ausloeser: wenn X von Y angegebener Quests fehlgeschlagen sind.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Custom, en = "Least Amount", de = "Mindest Anzahl" },</p><p>        { ParameterType.Custom, en = "Quest Amount", de = "Quest Anzahl" },</p><p>        { ParameterType.QuestName, en = "Quest name 1", de = "Questname 1" },</p><p>        { ParameterType.QuestName, en = "Quest name 2", de = "Questname 2" },</p><p>        { ParameterType.QuestName, en = "Quest name 3", de = "Questname 3" },</p><p>        { ParameterType.QuestName, en = "Quest name 4", de = "Questname 4" },</p><p>        { ParameterType.QuestName, en = "Quest name 5", de = "Questname 5" },</p><p>    },</p><p>    return { Triggers.Custom2,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.LeastAmount = tonumber(_Parameter)</p><p>    elseif (_Index == 1) then</p><p>        self.QuestAmount = tonumber(_Parameter)</p><p>    elseif (_Index == 2) then</p><p>        self.QuestName1 = _Parameter</p><p>    elseif (_Index == 3) then</p><p>        self.QuestName2 = _Parameter</p><p>    elseif (_Index == 4) then</p><p>        self.QuestName3 = _Parameter</p><p>    elseif (_Index == 5) then</p><p>        self.QuestName4 = _Parameter</p><p>    elseif (_Index == 6) then</p><p>        self.QuestName5 = _Parameter</p><p>    end</p><p>    local least = 0</p><p>    for i = 1, self.QuestAmount do</p><p>        if IsValidQuest(QuestID) then</p><p>        end</p><p>    end</p><p>    return false</p><p>    local leastAmount = self.LeastAmount</p><p>    local questAmount = self.QuestAmount</p><p>    if leastAmount 5 then</p><p>        fatal(_Quest.Identifier .. ": Error in " .. self.Name .. ": LeastAmount is wrong")</p><p>        return true</p><p>    elseif questAmount  5 then</p><p>        fatal(_Quest.Identifier .. ": Error in " .. self.Name .. ": QuestAmount is wrong")</p><p>        return true</p><p>    elseif leastAmount  questAmount then</p><p>        fatal(_Quest.Identifier .. ": Error in " .. self.Name .. ": LeastAmount is greater than QuestAmount")</p><p>        return true</p><p>    end</p><p>    for i = 1, questAmount do</p><p>        if not IsValidQuest(self["QuestName"..i]) then</p><p>            fatal(_Quest.Identifier .. ": Error in " .. self.Name .. ": Quest ".. self["QuestName"..i] .. " not found")</p><p>            return true</p><p>        end</p><p>    end</p><p>    return false</p><p>    if (_Index == 0) or (_Index == 1) then</p><p>        return {"1", "2", "3", "4", "5"}</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet den Quest, sobald die Munition in der Kriegsmaschine erschöpft ist.</p><p>-- @param _ScriptName Skriptname des Entity</p><p>-- @within Trigger</p><p>    return b_Trigger_AmmunitionDepleted:new(...);</p><p>Trigger_AmmunitionDepleted</p><p>    Name = "Trigger_AmmunitionDepleted",</p><p>    Description = {</p><p>        en = "Trigger: if the ammunition of the entity is depleted.",</p><p>        de = "Ausloeser: wenn die Munition der Entity aufgebraucht ist.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Scriptname, en = "Script name", de = "Skriptname" },</p><p>    },</p><p>    return { Triggers.Custom2,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.Scriptname = _Parameter</p><p>    end</p><p>    if not IsExisting(self.Scriptname) then</p><p>        return false;</p><p>    end</p><p>    local EntityID = GetID(self.Scriptname);</p><p>    if Logic.GetAmmunitionAmount(EntityID)  0 then</p><p>        return false;</p><p>    end</p><p>    return true;</p><p>    if not IsExisting(self.Scriptname) then</p><p>        fatal(_Quest.Identifier .. ": Error in " .. self.Name .. ": '"..self.Scriptname.."' is destroyed!");</p><p>        return true</p><p>    end</p><p>    return false</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet den Quest, wenn exakt einer von beiden Quests erfolgreich ist.</p><p>-- @param _QuestName1 Name des ersten Quest</p><p>-- @param _QuestName2 Name des zweiten Quest</p><p>-- @within Trigger</p><p>    return b_Trigger_OnExactOneQuestIsWon:new(...);</p><p>Trigger_OnExactOneQuestIsWon</p><p>    Name = "Trigger_OnExactOneQuestIsWon",</p><p>    Description = {</p><p>        en = "Trigger: if one of two given quests has been finished successfully, but NOT both.",</p><p>        de = "Ausloeser: wenn eine von zwei angegebenen Quests (aber NICHT beide) erfolgreich abgeschlossen wurde.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.QuestName, en = "Quest Name 1", de = "Questname 1" },</p><p>        { ParameterType.QuestName, en = "Quest Name 2", de = "Questname 2" },</p><p>    },</p><p>    return {Triggers.Custom2, {self, self.CustomFunction}};</p><p>    self.QuestTable = {};</p><p>    if (_Index == 0) then</p><p>        self.Quest1 = _Parameter;</p><p>    elseif (_Index == 1) then</p><p>        self.Quest2 = _Parameter;</p><p>    end</p><p>    local Quest1 = Quests[GetQuestID(self.Quest1)];</p><p>    local Quest2 = Quests[GetQuestID(self.Quest2)];</p><p>    if Quest2 and Quest1 then</p><p>        local Quest1Succeed = (Quest1.State == QuestState.Over and Quest1.Result == QuestResult.Success);</p><p>        local Quest2Succeed = (Quest2.State == QuestState.Over and Quest2.Result == QuestResult.Success);</p><p>        if (Quest1Succeed and not Quest2Succeed) or (not Quest1Succeed and Quest2Succeed) then</p><p>            return true;</p><p>        end</p><p>    end</p><p>    return false;</p><p>    if self.Quest1 == self.Quest2 then</p><p>        fatal(_Quest.Identifier..": "..self.Name..": Both quests are identical!");</p><p>        return true;</p><p>    elseif not IsValidQuest(self.Quest1) then</p><p>        fatal(_Quest.Identifier..": "..self.Name..": Quest '"..self.Quest1.."' does not exist!");</p><p>        return true;</p><p>    elseif not IsValidQuest(self.Quest2) then</p><p>        fatal(_Quest.Identifier..": "..self.Name..": Quest '"..self.Quest2.."' does not exist!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet den Quest, wenn exakt einer von beiden Quests fehlgeschlagen ist.</p><p>-- @param _QuestName1 Name des ersten Quest</p><p>-- @param _QuestName2 Name des zweiten Quest</p><p>-- @within Trigger</p><p>    return b_Trigger_OnExactOneQuestIsLost:new(...);</p><p>Trigger_OnExactOneQuestIsLost</p><p>    Name = "Trigger_OnExactOneQuestIsLost",</p><p>    Description = {</p><p>        en = "Trigger: If one of two given quests has been lost, but NOT both.",</p><p>        de = "Ausloeser: Wenn einer von zwei angegebenen Quests (aber NICHT beide) fehlschlägt.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.QuestName, en = "Quest Name 1", de = "Questname 1" },</p><p>        { ParameterType.QuestName, en = "Quest Name 2", de = "Questname 2" },</p><p>    },</p><p>    return {Triggers.Custom2, {self, self.CustomFunction}};</p><p>    self.QuestTable = {};</p><p>    if (_Index == 0) then</p><p>        self.Quest1 = _Parameter;</p><p>    elseif (_Index == 1) then</p><p>        self.Quest2 = _Parameter;</p><p>    end</p><p>    local Quest1 = Quests[GetQuestID(self.Quest1)];</p><p>    local Quest2 = Quests[GetQuestID(self.Quest2)];</p><p>    if Quest2 and Quest1 then</p><p>        local Quest1Succeed = (Quest1.State == QuestState.Over and Quest1.Result == QuestResult.Failure);</p><p>        local Quest2Succeed = (Quest2.State == QuestState.Over and Quest2.Result == QuestResult.Failure);</p><p>        if (Quest1Succeed and not Quest2Succeed) or (not Quest1Succeed and Quest2Succeed) then</p><p>            return true;</p><p>        end</p><p>    end</p><p>    return false;</p><p>    if self.Quest1 == self.Quest2 then</p><p>        fatal(_Quest.Identifier..": "..self.Name..": Both quests are identical!");</p><p>        return true;</p><p>    elseif not IsValidQuest(self.Quest1) then</p><p>        fatal(_Quest.Identifier..": "..self.Name..": Quest '"..self.Quest1.."' does not exist!");</p><p>        return true;</p><p>    elseif not IsValidQuest(self.Quest2) then</p><p>        fatal(_Quest.Identifier..": "..self.Name..": Quest '"..self.Quest2.."' does not exist!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {},</p><p>    Local = {}</p><p>-- Global Script ---------------------------------------------------------------</p><p>-- Initialisiert das Bundle im globalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p><p>    -- Theif observation</p><p>    --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p><p>    GameCallback_OnThiefDeliverEarnings_Orig_QSB_SymfoniaBehaviors = GameCallback_OnThiefDeliverEarnings;</p><p>    GameCallback_OnThiefDeliverEarnings = function(_ThiefPlayerID, _ThiefID, _BuildingID, _GoodAmount)</p><p>        GameCallback_OnThiefDeliverEarnings_Orig_QSB_SymfoniaBehaviors(_ThiefPlayerID, _ThiefID, _BuildingID, _GoodAmount);</p><p>        for i=1, Quests[0] do</p><p>            if Quests[i] and Quests[i].State == QuestState.Active then</p><p>                for j=1, Quests[i].Objectives[0] do</p><p>                    if Quests[i].Objectives[j].Type == Objective.Custom2 then</p><p>                        if Quests[i].Objectives[j].Data[1].Name == "Goal_StealBuilding" then</p><p>                            local found;</p><p>                            for k=1, #Quests[i].Objectives[j].Data[1].RobberList do</p><p>                                local stohlen = Quests[i].Objectives[j].Data[1].RobberList[k];</p><p>                                if stohlen[1] == GetID(Quests[i].Objectives[j].Data[1].Building) and stohlen[2] == _ThiefID then</p><p>                                    found = true;</p><p>                                    break;</p><p>                                end</p><p>                            end</p><p>                            if found then</p><p>                                Quests[i].Objectives[j].Data[1].SuccessfullyStohlen = true;</p><p>                            end</p><p>                        elseif Quests[i].Objectives[j].Data[1].Name == "Goal_StealGold" then</p><p>                            local CurrentObjective = Quests[i].Objectives[j].Data[1];</p><p>                            local TargetPlayerID = Logic.EntityGetPlayer(_BuildingID);</p><p>                            if CurrentObjective.Target ~= -1 and CurrentObjective.Target ~= TargetPlayerID then</p><p>                                return;</p><p>                            end</p><p>                            Quests[i].Objectives[j].Data[1].StohlenGold = Quests[i].Objectives[j].Data[1].StohlenGold + _GoodAmount;</p><p>                            if CurrentObjective.Printout then</p><p>                                local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>                                local msg  = {de = "Talern gestohlen",en = "gold stolen",};</p><p>                                local curr = CurrentObjective.StohlenGold;</p><p>                                local need = CurrentObjective.Amount;</p><p>                                API.Note(string.format("d/d s", curr, need, msg[lang]));</p><p>                            end</p><p>                        end</p><p>                    end</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>    GameCallback_OnThiefStealBuilding_Orig_QSB_SymfoniaBehaviors = GameCallback_OnThiefStealBuilding;</p><p>    GameCallback_OnThiefStealBuilding = function(_ThiefID, _ThiefPlayerID, _BuildingID, _BuildingPlayerID)</p><p>        GameCallback_OnThiefStealBuilding_Orig_QSB_SymfoniaBehaviors(_ThiefID, _ThiefPlayerID, _BuildingID, _BuildingPlayerID);</p><p>        for i=1, Quests[0] do</p><p>            if Quests[i] and Quests[i].State == QuestState.Active then</p><p>                for j=1, Quests[i].Objectives[0] do</p><p>                    if Quests[i].Objectives[j].Type == Objective.Custom2 then</p><p>                        if Quests[i].Objectives[j].Data[1].Name == "Goal_SpyBuilding" then</p><p>                            if  GetID(Quests[i].Objectives[j].Data[1].Building) == _BuildingID and Quests[i].ReceivingPlayer == _ThiefPlayerID then</p><p>                                Quests[i].Objectives[j].Data[1].Infiltrated = true;</p><p>                                if Quests[i].Objectives[j].Data[1].Delete then</p><p>                                    DestroyEntity(_ThiefID);</p><p>                                end</p><p>                            end</p><p>                        elseif Quests[i].Objectives[j].Data[1].Name == "Goal_StealBuilding" then</p><p>                            local found;</p><p>                            local isCathedral = Logic.IsEntityInCategory(_BuildingID, EntityCategories.Cathedrals) == 1;</p><p>                            local isWarehouse = Logic.GetEntityType(_BuildingID) == Entities.B_StoreHouse;</p><p>                            if isWarehouse or isCathedral then</p><p>                                Quests[i].Objectives[j].Data[1].SuccessfullyStohlen = true;</p><p>                            else</p><p>                                for k=1, #Quests[i].Objectives[j].Data[1].RobberList do</p><p>                                    local stohlen = Quests[i].Objectives[j].Data[1].RobberList[k];</p><p>                                    if stohlen[1] == _BuildingID and stohlen[2] == _ThiefID then</p><p>                                        found = true;</p><p>                                        break;</p><p>                                    end</p><p>                                end</p><p>                            end</p><p>                            if not found then</p><p>                                table.insert(Quests[i].Objectives[j].Data[1].RobberList, {_BuildingID, _ThiefID});</p><p>                            end</p><p>                        end</p><p>                    end</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>    --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p><p>    -- Objectives</p><p>    --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p><p>    QuestTemplate.IsObjectiveCompleted_Orig_QSB_SymfoniaBehaviors = QuestTemplate.IsObjectiveCompleted;</p><p>    QuestTemplate.IsObjectiveCompleted = function(self, objective)</p><p>        local objectiveType = objective.Type;</p><p>        if objective.Completed ~= nil then</p><p>            return objective.Completed;</p><p>        end</p><p>        if objectiveType == Objective.Distance then</p><p>            objective.Completed = BundleSymfoniaBehaviors.Global:IsQuestPositionReached(self, objective);</p><p>        elseif objectiveType == Objective.DestroyEntities then</p><p>            if objective.Data[1] == 3 then</p><p>                objective.Completed = BundleSymfoniaBehaviors.Global:AreQuestEntitiesDestroyed(self, objective);</p><p>            else</p><p>                return self:IsObjectiveCompleted_Orig_QSB_SymfoniaBehaviors(objective);</p><p>            end</p><p>        else</p><p>            return self:IsObjectiveCompleted_Orig_QSB_SymfoniaBehaviors(objective);</p><p>        end</p><p>    end</p><p>    --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p><p>    -- Questmarkers</p><p>    --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p><p>    function QuestTemplate:RemoveQuestMarkers()</p><p>        for i=1, self.Objectives[0] do</p><p>            if self.Objectives[i].Type == Objective.Distance then</p><p>                if self.Objectives[i].Data[4] then</p><p>                    DestroyQuestMarker(self.Objectives[i].Data[2]);</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>    function QuestTemplate:ShowQuestMarkers()</p><p>        for i=1, self.Objectives[0] do</p><p>            if self.Objectives[i].Type == Objective.Distance then</p><p>                if self.Objectives[i].Data[4] then</p><p>                    ShowQuestMarker(self.Objectives[i].Data[2]);</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>    function ShowQuestMarker(_Entity)</p><p>        local eID = GetID(_Entity);</p><p>        local x,y = Logic.GetEntityPosition(eID);</p><p>        local Marker = EGL_Effects.E_Questmarker_low;</p><p>        if Logic.IsBuilding(eID) == 1 then</p><p>            Marker = EGL_Effects.E_Questmarker;</p><p>        end</p><p>        Questmarkers[eID] = Logic.CreateEffect(Marker, x,y,0);</p><p>    end</p><p>    function DestroyQuestMarker(_Entity)</p><p>        local eID = GetID(_Entity);</p><p>        if Questmarkers[eID] ~= nil then</p><p>            Logic.DestroyEffect(Questmarkers[eID]);</p><p>            Questmarkers[eID] = nil;</p><p>        end</p><p>    end</p><p>-- Prüft, ob das Entity das Ziel erreicht hat.</p><p>-- @param[type=table] _Quest     Quest Data</p><p>-- @param[type=table] _Objective Behavior Data</p><p>-- @return[type=boolean] Ziel wurde erreicht</p><p>-- @within Internal</p><p>-- @local</p><p>    local IDdata2 = GetID(_Objective.Data[1]);</p><p>    local IDdata3 = GetID(_Objective.Data[2]);</p><p>    _Objective.Data[3] = _Objective.Data[3] or 2500;</p><p>    if not (Logic.IsEntityDestroyed(IDdata2) or Logic.IsEntityDestroyed(IDdata3)) then</p><p>        if Logic.GetDistanceBetweenEntities(IDdata2,IDdata3) = _Objective.Data[3] then</p><p>            DestroyQuestMarker(IDdata3);</p><p>            return true;</p><p>        end</p><p>    else</p><p>        DestroyQuestMarker(IDdata3);</p><p>        return false;</p><p>    end</p><p>-- Prüft, ob alle gespawnten Entities zerstört wurden.</p><p>-- @param[type=table] _Quest     Quest Data</p><p>-- @param[type=table] _Objective Behavior Data</p><p>-- @return[type=boolean] Resultat des Behavior</p><p>-- @within Internal</p><p>-- @local</p><p>    if _Objective.Data[1] == 3 then</p><p>        -- Initial wird die Anzahl an Entities sichergestellt.</p><p>        if not _Objective.Data[4] then</p><p>            local FirstEntityID;</p><p>            local SpawnAmount = _Objective.Data[3];</p><p>            for k, v in pairs(_Objective.Data[2]) do</p><p>                local EntityID        = GetID(v);</p><p>                local SpawnedEntities = {Logic.GetSpawnedEntities(EntityID)};</p><p>                if #SpawnedEntities  SpawnAmount then</p><p>                    repeat</p><p>                        Logic.RespawnResourceEntity_Spawn(EntityID);</p><p>                        SpawnedEntities = {Logic.GetSpawnedEntities(EntityID)};</p><p>                    until (#SpawnedEntities == SpawnAmount);</p><p>                elseif #SpawnedEntities  SpawnAmount then</p><p>                    repeat</p><p>                        DestroyEntity(SpawnedEntities[1]);</p><p>                        SpawnedEntities = {Logic.GetSpawnedEntities(EntityID)};</p><p>                    until (#SpawnedEntities == SpawnAmount);</p><p>                end</p><p>                if not FirstEntityID then</p><p>                    FirstEntityID = SpawnedEntities[1];</p><p>                end</p><p>            end</p><p>            -- Icon setzen</p><p>            if not _Objective.Data[5] then</p><p>                _Objective.Data[5] = {7, 12};</p><p>                if Logic.IsEntityInCategory(FirstEntityID, EntityCategories.AttackableAnimal) == 1 then</p><p>                    _Objective.Data[5] = {13, 8};</p><p>                end</p><p>            end</p><p>            _Objective.Data[4] = true;</p><p>        end</p><p>        -- Gibt es keine gespawnten Entities mehr, ist das Ziel erreicht.</p><p>        local AllSpawnedEntities = {};</p><p>        for k, v in pairs(_Objective.Data[2]) do</p><p>            AllSpawnedEntities = Array_Append(AllSpawnedEntities, {Logic.GetSpawnedEntities(v)});</p><p>        end</p><p>        if #AllSpawnedEntities == 0 then</p><p>            return true;</p><p>        end</p><p>    end</p><p>-- Local Script ----------------------------------------------------------------</p><p>-- Initialisiert das Bundle im lokalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    Core:StackFunction("GUI_Interaction.GetEntitiesOrTerritoryListForQuest", self.GetEntitiesOrTerritoryList);</p><p>    Core:StackFunction("GUI_Interaction.SaveQuestEntityTypes", self.SaveQuestEntityTypes);</p><p>    Core:StackFunction("GUI_Interaction.DisplayQuestObjective", self.DisplayQuestObjective);</p><p>-- Erweitert die Funktion, welche das Auftragsziel darstellt. Das richtige</p><p>-- Icon für Spawned Entities wird angezeigt.</p><p>-- @within Internal</p><p>-- @local</p><p>    local QuestIndexTemp = tonumber(_QuestIndex);</p><p>    if QuestIndexTemp then</p><p>        _QuestIndex = QuestIndexTemp;</p><p>    end</p><p>    local Quest, QuestType = GUI_Interaction.GetPotentialSubQuestAndType(_QuestIndex);</p><p>    local QuestObjectivesPath = "/InGame/Root/Normal/AlignBottomLeft/Message/QuestObjectives";</p><p>    XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomLeft/Message/QuestObjectives", 0);</p><p>    if QuestType == Objective.DestroyEntities and Quest.Objectives[1].Data[1] == 3 then</p><p>        local QuestObjectiveContainer = QuestObjectivesPath .. "/GroupEntityType";</p><p>        local QuestTypeCaption = Wrapped_GetStringTableText(_QuestIndex, "UI_Texts/QuestDestroy");</p><p>        local EntitiesList = GUI_Interaction.GetEntitiesOrTerritoryListForQuest( Quest, QuestType );</p><p>        local EntitiesAmount = #EntitiesList;</p><p>        if not Quest.Objectives[1].Data[4] and #EntitiesList == 0 then</p><p>            EntitiesAmount = #Quest.Objectives[1].Data[2] * Quest.Objectives[1].Data[3];</p><p>        end</p><p>        XGUIEng.ShowWidget(QuestObjectiveContainer .. "/AdditionalCaption", 0);</p><p>        XGUIEng.ShowWidget(QuestObjectiveContainer .. "/AdditionalCondition", 0);</p><p>        SetIcon(QuestObjectiveContainer .. "/Icon", Quest.Objectives[1].Data[5]);</p><p>        XGUIEng.SetText(QuestObjectiveContainer .. "/Number", "{center}" .. EntitiesAmount);</p><p>        XGUIEng.SetText(QuestObjectiveContainer .. "/Caption", "{center}" .. QuestTypeCaption);</p><p>        XGUIEng.ShowWidget(QuestObjectiveContainer, 1);</p><p>        GUI_Interaction.SetQuestTypeIcon(QuestObjectiveContainer .. "/QuestTypeIcon", _QuestIndex);</p><p>        if Quest.State == QuestState.Over then</p><p>            if Quest.Result == QuestResult.Success then</p><p>                XGUIEng.ShowWidget(QuestObjectivesPath .. "/QuestOverSuccess", 1);</p><p>            elseif Quest.Result == QuestResult.Failure then</p><p>                XGUIEng.ShowWidget(QuestObjectivesPath .. "/QuestOverFailure", 1);</p><p>            end</p><p>        end</p><p>        return true;</p><p>    end</p><p>    --end if dummy quest</p><p>    if QuestObjectiveContainer == nil then</p><p>        return</p><p>    end</p><p>-- Erweitert die Funktion zur Ermittlung der Sprungziele für die Lupe.</p><p>-- Alle gespawnten Entities werden durch die Lupe angezeigt.</p><p>-- @param[type=table]  _Quest     Quest Table</p><p>-- @param[type=number] _QuestType Typ des Quest</p><p>-- @within Internal</p><p>-- @local</p><p>    local IsEntity = true;</p><p>    local EntityOrTerritoryList = {};</p><p>    if _QuestType == Objective.DestroyEntities then</p><p>        if _Quest.Objectives[1].Data and _Quest.Objectives[1].Data[1] == 3 then</p><p>            for k, v in pairs(_Quest.Objectives[1].Data[2]) do</p><p>                EntityOrTerritoryList = Array_Append(EntityOrTerritoryList, {Logic.GetSpawnedEntities(GetID(v))});</p><p>            end</p><p>            return EntityOrTerritoryList, IsEntity;</p><p>        end</p><p>    end</p><p>-- Erweitert die Funktion zur Speicherung der Quest Entities. Es wird der</p><p>-- neue Typ 3 für Objective.DestroyEntities implementiert.</p><p>-- @param[type=number] _QuestIndex Index des Quest</p><p>-- @within Internal</p><p>-- @local</p><p>    if g_Interaction.SavedQuestEntityTypes[_QuestIndex] ~= nil then</p><p>        return;</p><p>    end</p><p>    local Quest, QuestType = GUI_Interaction.GetPotentialSubQuestAndType(_QuestIndex);</p><p>    local EntitiesList;</p><p>    if QuestType ~= Objective.DestroyEntities or Quest.Objectives[1].Data[1] == 2 then</p><p>        return;</p><p>    end</p><p>    EntitiesList = GUI_Interaction.GetEntitiesOrTerritoryListForQuest(Quest, QuestType);</p><p>    EntitiesList[0] = #EntitiesList;</p><p>    if EntitiesList ~= nil then</p><p>        g_Interaction.SavedQuestEntityTypes[_QuestIndex] = {};</p><p>        for i = 1, EntitiesList[0], 1 do</p><p>            if Logic.IsEntityAlive(EntitiesList[i]) then</p><p>                local EntityType = Logic.GetEntityType(GetEntityId(EntitiesList[i]));</p><p>                table.insert(g_Interaction.SavedQuestEntityTypes[_QuestIndex], i, EntityType);</p><p>            end</p><p>        end</p><p>        return true;</p><p>    end</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundlethirdpersoncamera.lua.html">
            <div class='doclink'>
                <div>BundleThirdPersonCamera</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia BundleThirdPersonCamera                                      # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Dieses Bundle bietet einen Kameramodus an, mit dem ein Entity aus der</p><p>-- Schulterperspektive verfolgt werden kann.</p><p>-- </p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Aktiviert die Heldenkamera und setzt den verfolgten Helden. Der</p><p>-- Held kann 0 sein, dann wird entweder der letzte Held verwendet</p><p>-- oder über den GUI-Spieler ermittelt.</p><p>-- </p><p>-- @param _Hero [string|number] Skriptname/Entity-ID des Helden</p><p>-- @param _MaxZoom [number] Maximaler Zoomfaktor</p><p>-- @within Anwenderfunktionen</p><p>function API.ThirdPersonActivate(_Hero, _MaxZoom)</p><p>    if GUI then</p><p>        local Target = (type(_Hero) == "string" and "'".._Hero.."'") or _Hero;</p><p>        API.Bridge("API.ThirdPersonActivate(".. Target ..", ".. _MaxZoom ..")");</p><p>        return;</p><p>    end</p><p>    return BundleThirdPersonCamera.Global:ThirdPersonActivate(_Hero, _MaxZoom);</p><p>-- Deaktiviert die Heldenkamera.</p><p>-- </p><p>-- @within Anwenderfunktionen</p><p>function API.ThirdPersonDeactivate()</p><p>    if GUI then</p><p>        API.Bridge("API.ThirdPersonDeactivate()");</p><p>        return;</p><p>    end</p><p>    return BundleThirdPersonCamera.Global:ThirdPersonDeactivate();</p><p>-- Prüft, ob die Heldenkamera aktiv ist.</p><p>-- </p><p>-- @return [boolean] Kamera aktiv</p><p>-- @within Anwenderfunktionen</p><p>function API.ThirdPersonIsRuning()</p><p>    if not GUI then</p><p>        return BundleThirdPersonCamera.Global:ThirdPersonIsRuning();</p><p>    else</p><p>        return BundleThirdPersonCamera.Local:ThirdPersonIsRuning();</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {</p><p>        Data = {</p><p>            ThirdPersonIsActive = false,</p><p>        }</p><p>    },</p><p>    Local = {</p><p>        Data = {</p><p>            ThirdPersonIsActive = false,</p><p>            ThirdPersonLastHero = nil,</p><p>            ThirdPersonLastZoom = nil,</p><p>        }</p><p>    },</p><p>-- Global Script ---------------------------------------------------------------</p><p>-- Initalisiert das Bundle im globalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    API.AddSaveGameAction(BundleThirdPersonCamera.Global.OnSaveGameLoaded);</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Aktiviert die Heldenkamera und setzt den verfolgten Helden. Der</p><p>-- Held kann 0 sein, dann wird entweder der letzte Held verwendet</p><p>-- oder über den GUI-Spieler ermittelt.</p><p>-- @param _Hero [string|number] Skriptname/Entity-ID des Helden</p><p>-- @param _MaxZoom [number] Maximaler Zoomfaktor</p><p>-- @within Internal</p><p>-- @local</p><p>    if BriefingSystem then</p><p>        BundleThirdPersonCamera.Global:ThirdPersonOverwriteStartAndEndBriefing();</p><p>    end</p><p>    local Hero = GetID(_Hero);</p><p>    BundleThirdPersonCamera.Global.Data.ThirdPersonIsActive = true;</p><p>    Logic.ExecuteInLuaLocalState([[</p><p>        BundleThirdPersonCamera.Local:ThirdPersonActivate(]]..tostring(Hero)..[[, ]].. tostring(_MaxZoom) ..[[);</p><p>    ]]);</p><p>-- Deaktiviert die Heldenkamera.</p><p>-- @within Internal</p><p>-- @local</p><p>    BundleThirdPersonCamera.Global.Data.ThirdPersonIsActive = false;</p><p>    Logic.ExecuteInLuaLocalState([[</p><p>        BundleThirdPersonCamera.Local:ThirdPersonDeactivate();</p><p>    ]]);</p><p>-- Prüft, ob die Heldenkamera aktiv ist.</p><p>-- @return [boolean] Kamera aktiv</p><p>-- @within Internal</p><p>-- @local</p><p>    return self.Data.ThirdPersonIsActive;</p><p>-- Überschreibt StartBriefing und EndBriefing des Briefing System,</p><p>-- wenn es vorhanden ist.</p><p>-- @within Internal</p><p>-- @local</p><p>    if BriefingSystem then</p><p>        if not BriefingSystem.StartBriefing_Orig_HeroCamera then</p><p>            BriefingSystem.StartBriefing_Orig_HeroCamera = BriefingSystem.StartBriefing;</p><p>            BriefingSystem.StartBriefing = function(_Briefing, _CutsceneMode)</p><p>                if BundleThirdPersonCamera.Global:ThirdPersonIsRuning() then</p><p>                    BundleThirdPersonCamera.Global:ThirdPersonDeactivate();</p><p>                    BundleThirdPersonCamera.Global.Data.ThirdPersonStoppedByCode = true;</p><p>                end</p><p>                BriefingSystem.StartBriefing_Orig_HeroCamera(_Briefing, _CutsceneMode);</p><p>            end</p><p>            StartBriefing = BriefingSystem.StartBriefing;</p><p>        end</p><p>        if not BriefingSystem.EndBriefing_Orig_HeroCamera then</p><p>            BriefingSystem.EndBriefing_Orig_HeroCamera = BriefingSystem.EndBriefing;</p><p>            BriefingSystem.EndBriefing = function(_Briefing, _CutsceneMode)</p><p>                BriefingSystem.EndBriefing_Orig_HeroCamera();</p><p>                if BundleThirdPersonCamera.Global.Data.ThirdPersonStoppedByCode then</p><p>                    BundleThirdPersonCamera.Global:ThirdPersonActivate(0);</p><p>                    BundleThirdPersonCamera.Global.Data.ThirdPersonStoppedByCode = false;</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Stellt nicht-persistente Änderungen nach dem laden wieder her.</p><p>-- @within Internal</p><p>-- @local</p><p>    </p><p>-- Local Script ----------------------------------------------------------------</p><p>-- Aktiviert die Heldenkamera und setzt den verfolgten Helden. Der</p><p>-- Held kann 0 sein, dann wird entweder der letzte Held verwendet</p><p>-- oder über den GUI-Spieler ermittelt.</p><p>-- @param _Hero [string|number] Skriptname/Entity-ID des Helden</p><p>-- @param _MaxZoom [number] Maximaler Zoomfaktor</p><p>-- @within Internal</p><p>-- @local</p><p>    _Hero = (_Hero ~= 0 and _Hero) or self.Data.ThirdPersonLastHero or Logic.GetKnightID(GUI.GetPlayerID());</p><p>    _MaxZoom = _MaxZoom or self.Data.ThirdPersonLastZoom or 0.5;</p><p>    if not _Hero then</p><p>        return;</p><p>    end</p><p>    if not GameCallback_Camera_GetBorderscrollFactor_Orig_HeroCamera then</p><p>        self:ThirdPersonOverwriteGetBorderScrollFactor();</p><p>    end</p><p>    self.Data.ThirdPersonLastHero = _Hero;</p><p>    self.Data.ThirdPersonLastZoom = _MaxZoom;</p><p>    self.Data.ThirdPersonIsActive = true;</p><p>    local Orientation = Logic.GetEntityOrientation(_Hero);</p><p>    Camera.RTS_FollowEntity(_Hero);</p><p>    Camera.RTS_SetRotationAngle(Orientation-90);</p><p>    Camera.RTS_SetZoomFactor(_MaxZoom);</p><p>    Camera.RTS_SetZoomFactorMax(_MaxZoom + 0.0001);</p><p>-- Deaktiviert die Heldenkamera.</p><p>-- @within Internal</p><p>-- @local</p><p>    self.Data.ThirdPersonIsActive = false;</p><p>    Camera.RTS_SetZoomFactorMax(0.5);</p><p>    Camera.RTS_SetZoomFactor(0.5);</p><p>    Camera.RTS_FollowEntity(0);</p><p>-- Prüft, ob die Heldenkamera aktiv ist.</p><p>-- @return [boolean] Kamera aktiv</p><p>-- @within Internal</p><p>-- @local</p><p>    return self.Data.ThirdPersonIsActive;</p><p>-- Überschreibt GameCallback_GetBorderScrollFactor und wandelt den</p><p>-- Bildlauf am Bildschirmrand in Bildrotation um. Dabei wird die</p><p>-- Kamera um links oder rechts gedreht, abhänig von der Position</p><p>-- der Mouse.</p><p>-- @within Internal</p><p>-- @local</p><p>    GameCallback_Camera_GetBorderscrollFactor_Orig_HeroCamera = GameCallback_Camera_GetBorderscrollFactor</p><p>    GameCallback_Camera_GetBorderscrollFactor = function()</p><p>        if not BundleThirdPersonCamera.Local.Data.ThirdPersonIsActive then</p><p>            return GameCallback_Camera_GetBorderscrollFactor_Orig_HeroCamera();</p><p>        end</p><p>        local CameraRotation = Camera.RTS_GetRotationAngle();</p><p>        local xS, yS = GUI.GetScreenSize();</p><p>        local xM, yM = GUI.GetMousePosition();</p><p>        local xR = xM / xS;</p><p>        if xR = 0.02 then</p><p>            CameraRotation = CameraRotation + 0.3;</p><p>        elseif xR = 0.98 then</p><p>            CameraRotation = CameraRotation - 0.3;</p><p>        else</p><p>            return 0;</p><p>        end</p><p>        if CameraRotation = 360 then</p><p>            CameraRotation = 0;</p><p>        end</p><p>        Camera.RTS_SetRotationAngle(CameraRotation);</p><p>        return 0;</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundletimeline.lua.html">
            <div class='doclink'>
                <div>BundleTimeLine</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia BundleTimeLine                                               # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Dieses Bundle ermöglicht es Aktionen in einer zeitlichen Abfolge zu</p><p>-- gliedern.</p><p>-- Die Bezeichnung "Time Line" (Zeitstrahl) wird z.B. in der Filmindustrie</p><p>-- verwendet und beschreibt einen Ablauf von aufeinander folgenden Ereignissen.</p><p>-- Diese Ereignisse sind zeitlich gegliedert.</p><p>-- Du kannst mit der Implementation eines solchen Zeitstrahls Lua-Funktionen</p><p>-- im Abstand einer oder mehrerer Sekunden ausführen lassen. Ein solcher</p><p>-- Zeitstrahl verfügt über eine ID, mit der er angesprochen werden kann. So</p><p>-- kann er abgebrochen, pausiert, fortgesetzt und neu gestartet werden.</p><p>-- Eine Abfolge von</p><p>-- Aktionen definieren, die zu gewissen Zeitpunkten ausgelöst werden.</p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>    Data = {</p><p>        TimeLineUniqueJobID = 1,</p><p>        TimeLineJobs = {},</p><p>    }</p><p>-- -------------------------------------------------------------------------- --</p><p>-- TimeLine Klasse                                                            --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet einen Zeitstrahl. Ein Zeitstrahl hat Stationen,</p><p>-- an denen eine Aktion ausgeführt wird. Jede Station muss mindestens eine</p><p>-- Sekunde nach der vorherigen liegen.</p><p>-- Jede Aktion eines Zeitstrahls erhält die Table des aktuellen Ereignisses</p><p>-- als Argument. So können Parameter an die Funktion übergeben werden.</p><p>-- @param[type=table] _Description Beschreibung</p><p>-- @return[type=number] ID des Zeitstrahls</p><p>-- @within Anwenderfunktionen</p><p>-- @usage MyTimeLine = QSB.TimeLine:Start {</p><p>--     {Time = 5, Action = MyFirstAction},</p><p>--     -- MySecondAction erhält "BOCKWURST" als Parameter</p><p>--     {Time = 15, Action = MySecondAction, "BOCKWURST"},</p><p>--     -- Inline-Funktion</p><p>--     {Time = 30, Action = function() end},</p><p>-- }</p><p>    local JobID = QSB.TimeLine.Data.TimeLineUniqueJobID;</p><p>    QSB.TimeLine.Data.TimeLineUniqueJobID = JobID +1;</p><p>    _description.Running = true;</p><p>    _description.StartTime = Logic.GetTime();</p><p>    _description.Iterator = 1;</p><p>    -- Check auf sinnvolle Zeitabstände</p><p>    local Last = 0;</p><p>    for i=1, #_description, 1 do</p><p>        if _description[i].Time  Last then</p><p>            _description[i].Time = Last+1;</p><p>            Last = _description[i].Time;</p><p>        end</p><p>    end</p><p>    QSB.TimeLine.Data.TimeLineJobs[JobID] = _description;</p><p>    if not QSB.TimeLine.Data.ControlerID then</p><p>        local Controler = StartSimpleJobEx(QSB.TimeLine.TimeLineControler);</p><p>        QSB.TimeLine.Data.ControlerID = Controler;</p><p>    end</p><p>    return JobID;</p><p>function API.TimeLineStart(_ID)</p><p>    return QSB.TimeLine:Start(_ID);</p><p>-- Startet einen Zeitstrahl erneut. Ist der Zeitstrahl noch nicht</p><p>-- beendet, beginnt er dennoch von vorn.</p><p>-- @param[type=number] _ID ID des Zeitstrahl</p><p>-- @within Anwenderfunktionen</p><p>-- @usage QSB.TimeLine:Restart(MyTimeLine);</p><p>    if not QSB.TimeLine.Data.TimeLineJobs[_ID] then</p><p>        return;</p><p>    end</p><p>    QSB.TimeLine.Data.TimeLineJobs[_ID].Running = true;</p><p>    QSB.TimeLine.Data.TimeLineJobs[_ID].StartTime = Logic.GetTime();</p><p>    QSB.TimeLine.Data.TimeLineJobs[_ID].Iterator = 1;</p><p>function API.TimeLineRestart(_ID)</p><p>    QSB.TimeLine:Restart(_ID);</p><p>-- Prüft, ob der Zeitstrahl noch nicht durchgelaufen ist.</p><p>-- @param[type=number] _ID ID des Zeitstrahl</p><p>-- @return[type=boolean] Zeitstrahl ist aktiv</p><p>-- @within Anwenderfunktionen</p><p>-- @usage local IsRunning = QSB.TimeLine:IsRunning(MyTimeLine);</p><p>    if QSB.TimeLine.Data.TimeLineJobs[_ID] then</p><p>        return QSB.TimeLine.Data.TimeLineJobs[_ID].Running == true;</p><p>    end</p><p>    return false;</p><p>function API.TimeLineIsRunning(_ID)</p><p>    QSB.TimeLine:IsRunning(_ID);</p><p>-- Hält einen Zeitstrahl an.</p><p>-- @param[type=number] _ID ID des Zeitstrahl</p><p>-- @within Anwenderfunktionen</p><p>-- @usage QSB.TimeLine:Yield(MyTimeLine);</p><p>    if not QSB.TimeLine.Data.TimeLineJobs[_ID] then</p><p>        return;</p><p>    end</p><p>    QSB.TimeLine.Data.TimeLineJobs[_ID].YieldTime = Logic.GetTime();</p><p>    QSB.TimeLine.Data.TimeLineJobs[_ID].Running = false;</p><p>function API.TimeLineYield(_ID)</p><p>    QSB.TimeLine:Yield(_ID);</p><p>-- Stößt einen angehaltenen Zeitstrahl wieder an.</p><p>-- @param[type=number] _ID ID des Zeitstrahl</p><p>-- @within Anwenderfunktionen</p><p>-- @usage QSB.TimeLine:Resume(MyTimeLine);</p><p>    if not QSB.TimeLine.Data.TimeLineJobs[_ID] then</p><p>        return;</p><p>    end</p><p>    if QSB.TimeLine.Data.TimeLineJobs[_ID].YieldTime then</p><p>        local OldStartTime = QSB.TimeLine.Data.TimeLineJobs[_ID].StartTime;</p><p>        local TimeYielded = Logic.GetTime() - QSB.TimeLine.Data.TimeLineJobs[_ID].YieldTime;</p><p>        QSB.TimeLine.Data.TimeLineJobs[_ID].StartTime = OldStartTime + TimeYielded;</p><p>        QSB.TimeLine.Data.TimeLineJobs[_ID].YieldTime = nil;</p><p>    end</p><p>    QSB.TimeLine.Data.TimeLineJobs[_ID].Running = true;</p><p>function API.TimeLineResume(_ID)</p><p>    QSB.TimeLine:Resume(_ID);</p><p>-- Steuert alle Zeitstrahlen.</p><p>-- @within QSB.TimeLine</p><p>-- @local</p><p>    for k,v in pairs(QSB.TimeLine.Data.TimeLineJobs) do</p><p>        if v.Iterator  #v then</p><p>            QSB.TimeLine.Data.TimeLineJobs[k].Running = false;</p><p>        end</p><p>        if v.Running then</p><p>            if (v[v.Iterator].Time + v.StartTime) = Logic.GetTime() then</p><p>                v[v.Iterator].Action(unpack(v[v.Iterator]));</p><p>                QSB.TimeLine.Data.TimeLineJobs[k].Iterator = v.Iterator +1;</p><p>            end</p><p>        end</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {</p><p>        Data = {}</p><p>    },</p><p>    Local = {</p><p>        Data = {}</p><p>    },</p><p>-- Global Script ---------------------------------------------------------------</p><p>-- Initalisiert das Bundle im globalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    TimeLine = QSB.TimeLine;</p><p>-- Local Script ----------------------------------------------------------------</p><p>-- Initalisiert das Bundle im lokalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    TimeLine = QSB.TimeLine;</p><p>-- -------------------------------------------------------------------------- --</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundletradinganalysis.lua.html">
            <div class='doclink'>
                <div>BundleTradingAnalysis</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia BundleTradingAnalysis                                        # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Dieses Bundle bietet einige Funktionen zum untersuchen und</p><p>-- zur Manipulation von Handelsangeboten. Die bekannten Funktionen, wie z.B.</p><p>-- AddOffer, werden erweitert, sodass sie Angebote für einen Spieler mit einer</p><p>-- anderen ID als 1 erstellen können. Ein kann Händler nicht mehr</p><p>-- mehrere Angebote des gleichen Typs anbieten. Außerdem werden einige</p><p>-- Preise und Erneuerungsraten hinzugefügt.</p><p>-- Das wichtigste auf einen Blick:</p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>    GoodTrader        = 0,</p><p>    MercenaryTrader   = 1,</p><p>    EntertainerTrader = 2,</p><p>    Unknown           = 3,</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Gibt die Handelsinformationen des Spielers aus. In dem Objekt stehen</p><p>-- ID des Spielers, ID des Lagerhaus, Menge an Angeboten insgesamt und</p><p>-- alle Angebote der Händlertypen.</p><p>-- @param[type=number] _PlayerID Player ID</p><p>-- @return[type=table] Angebotsinformationen</p><p>-- @within Anwenderfunktionen</p><p>-- @usage local Info = API.GetOfferInformation(2);</p><p>-- -- Info enthält:</p><p>-- -- Info = {</p><p>-- --      Player = 2,</p><p>-- --      Storehouse = 26796.</p><p>-- --      OfferCount = 2,</p><p>-- --      {</p><p>-- --          Händler-ID, Angebots-ID, Angebotstyp, Wagenladung, Angebotsmenge</p><p>-- --          {0, 0, Goods.G_Gems, 9, 2},</p><p>-- --          {0, 1, Goods.G_Milk, 9, 4},</p><p>-- --      },</p><p>-- -- };</p><p>function API.GetOfferInformation(_PlayerID)</p><p>    if GUI then</p><p>        API.Fatal("Can not execute API.GetOfferInformation in local script!");</p><p>        return;</p><p>    end</p><p>    return BundleTradingAnalysis.Global:GetStorehouseInformation(_PlayerID);</p><p>-- Gibt die Menge an Angeboten im Lagerhaus des Spielers zurück. Wenn</p><p>-- der Spieler kein Lagerhaus hat, wird 0 zurückgegeben.</p><p>-- @param[type=number] _PlayerID Player ID</p><p>-- @return[type=number] Anzahl angebote</p><p>-- @within Anwenderfunktionen</p><p>-- @usage -- Angebote von Spieler 5 zählen</p><p>-- local Count = API.GetOfferCount(5);</p><p>function API.GetOfferCount(_PlayerID)</p><p>    if GUI then</p><p>        API.Fatal("Can not execute API.GetOfferCount in local script!");</p><p>        return;</p><p>    end</p><p>    return BundleTradingAnalysis.Global:GetOfferCount(_PlayerID);</p><p>-- Gibt zurück, ob das Angebot vom angegebenen Spieler im Lagerhaus zum</p><p>-- Verkauf angeboten wird.</p><p>-- @param[type=number] _PlayerID Player ID</p><p>-- @param[type=number] _GoodOrEntityType Warentyp oder Entitytyp</p><p>-- @return[type=boolean] Ware wird angeboten</p><p>-- @within Anwenderfunktionen</p><p>-- @usage -- Wird die Ware angeboten?</p><p>-- if API.IsGoodOrUnitOffered(4, Goods.G_Bread) then</p><p>--     API.Note("Brot wird von Spieler 4 angeboten.");</p><p>-- end</p><p>function API.IsGoodOrUnitOffered(_PlayerID, _GoodOrEntityType)</p><p>    if GUI then</p><p>        API.Fatal("Can not execute API.IsGoodOrUnitOffered in local script!");</p><p>        return;</p><p>    end</p><p>    local OfferID, TraderID = BundleTradingAnalysis.Global:GetOfferAndTrader(_PlayerID, _GoodOrEntityType);</p><p>    return OfferID ~= 1 and TraderID ~= 1;</p><p>-- Entfernt das Angebot vom Lagerhaus des Spielers, wenn es vorhanden</p><p>-- ist. Es wird immer nur das erste Angebot des Typs entfernt.</p><p>-- @param[type=number] _PlayerID Player ID</p><p>-- @param[type=number] _GoodOrEntityType Warentyp oder Entitytyp</p><p>-- @within Anwenderfunktionen</p><p>-- @usage -- Keinen Käse mehr verkaufen</p><p>-- API.RemoveTradeOffer(7, Goods.G_Cheese);</p><p>function API.RemoveTradeOffer(_PlayerID, _GoodOrEntityType)</p><p>    if GUI then</p><p>        API.Bridge("API.RemoveTradeOffer(" .._PlayerID.. ", " .._GoodOrEntityType.. ")");</p><p>        return;</p><p>    end</p><p>    return BundleTradingAnalysis.Global:RemoveTradeOffer(_PlayerID, _GoodOrEntityType);</p><p>-- Ändert die aktuelle Menge des Angebots im Händelrgebäude.</p><p>-- Es kann ein beliebiger positiver Wert gesetzt werden. Es gibt keine</p><p>-- Beschränkungen.</p><p>-- : Wird eine höherer Wert gesetzt, als das ursprüngliche</p><p>-- Maximum, regenerieren sich die zusätzlichen Angebote nicht.</p><p>-- @param[type=number] _PlayerID Player ID</p><p>-- @param[type=number] _GoodOrEntityType ID des Händlers im Gebäude</p><p>-- @param[type=number] _NewAmount Neue Menge an Angeboten</p><p>-- @within Anwenderfunktionen</p><p>-- @usage -- Angebote voll auffüllen</p><p>-- API.ModifyTradeOffer(7, Goods.G_Cheese, -1);</p><p>-- API.ModifyTradeOffer(7, Goods.U_MilitarySword);</p><p>-- -- 2 Angebote auffüllen</p><p>-- API.ModifyTradeOffer(7, Goods.G_Dye, 2);</p><p>function API.ModifyTradeOffer(_PlayerID, _GoodOrEntityType, _NewAmount)</p><p>    if GUI then</p><p>        API.Bridge("API.ModifyTradeOffer(" .._PlayerID.. ", " .._GoodOrEntityType.. ", " .._NewAmount.. ")");</p><p>        return;</p><p>    end</p><p>    return BundleTradingAnalysis.Global:ModifyTradeOffer(_PlayerID, _GoodOrEntityType, _NewAmount);</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {</p><p>        Data = {</p><p>            PlayerOffersAmount = {</p><p>                [1] = {}, [2] = {}, [3] = {}, [4] = {}, [5] = {}, [6] = {}, [7] = {}, [8] = {},</p><p>            };</p><p>        },</p><p>    },</p><p>-- Global Script ---------------------------------------------------------------</p><p>-- Initialisiert das Bundle im globalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    self.OverwriteOfferFunctions();</p><p>    self.OverwriteBasePricesAndRefreshRates();</p><p>-- Überschreibt die Funktionen für Standardangebote.</p><p>-- @within Internal</p><p>-- @local</p><p>    ---</p><p>    -- Erzeugt ein Handelsangebot für Waren und gibt die ID zurück.</p><p>    --</p><p>    -- : Jeder Angebotstyp kann nur 1 Mal pro Lagerhaus</p><p>    -- angeboten werden.</p><p>    --</p><p>    -- @param[type=number] _Merchant  Handelsgebäude</p><p>    -- @param[type=number] _NumberOfOffers Anzahl an Angeboten</p><p>    -- @param[type=number] _GoodType Warentyp</p><p>    -- @param[type=number] _RefreshRate Erneuerungsrate</p><p>    -- @param[type=number] _optionalPlayersPlayerID Optionale Spieler-ID</p><p>    -- @return[type=number] Offer ID</p><p>    -- @within Originalfunktionen</p><p>    --</p><p>    AddOffer = function(_Merchant, _NumberOfOffers, _GoodType, _RefreshRate, _optionalPlayersPlayerID)</p><p>        local MerchantID = GetID(_Merchant);</p><p>        if type(_GoodType) == "string" then</p><p>            _GoodType = Goods[_GoodType];</p><p>        else</p><p>            _GoodType = _GoodType;</p><p>        end</p><p>        local PlayerID = Logic.EntityGetPlayer(MerchantID);</p><p>        local OfferID, TraderID = BundleTradingAnalysis.Global:GetOfferAndTrader(PlayerID, _GoodType);</p><p>        if OfferID ~= -1 and TraderID ~= -1 then</p><p>            API.Warn("Good offer for good type " .._GoodType.. " already exists for player " ..PlayerID.. "!");</p><p>            return;</p><p>        end</p><p>        AddGoodToTradeBlackList(PlayerID, _GoodType);</p><p>        local MarketerType = Entities.U_Marketer;</p><p>        if _GoodType == Goods.G_Medicine then</p><p>            MarketerType = Entities.U_Medicus;</p><p>        end</p><p>        if _RefreshRate == nil then</p><p>            _RefreshRate = MerchantSystem.RefreshRates[_GoodType];</p><p>            if _RefreshRate == nil then</p><p>                _RefreshRate = 0;</p><p>            end</p><p>        end</p><p>        if _optionalPlayersPlayerID == nil then</p><p>            _optionalPlayersPlayerID = 1;</p><p>        end</p><p>        local offerAmount = 9;</p><p>        BundleTradingAnalysis.Global.Data.PlayerOffersAmount[PlayerID][_GoodType] = _NumberOfOffers;</p><p>        return Logic.AddGoodTraderOffer(MerchantID,_NumberOfOffers,Goods.G_Gold,0,_GoodType,offerAmount,_optionalPlayersPlayerID,_RefreshRate,MarketerType,Entities.U_ResourceMerchant);</p><p>    end</p><p>    ---</p><p>    -- Erzeugt ein Handelsangebot für Söldner und gibt die ID zurück.</p><p>    --</p><p>    -- : Jeder Angebotstyp kann nur 1 Mal pro Lagerhaus</p><p>    -- angeboten werden.</p><p>    --</p><p>    -- @param[type=number] _Mercenary Handelsgebäude</p><p>    -- @param[type=number] _Amount Anzahl an Angeboten</p><p>    -- @param[type=number] _Type Soldatentyp</p><p>    -- @param[type=number] _RefreshRate Erneuerungsrate</p><p>    -- @param[type=number] _optionalPlayersPlayerID Optionale Spieler-ID</p><p>    -- @return[type=number] Offer ID</p><p>    -- @within Originalfunktionen</p><p>    --</p><p>    AddMercenaryOffer = function(_Mercenary, _Amount, _Type, _RefreshRate, _optionalPlayersPlayerID)</p><p>        local MercenaryID = GetID(_Mercenary);</p><p>        if _Type == nil then</p><p>            _Type = Entities.U_MilitaryBandit_Melee_ME;</p><p>        end</p><p>        if _RefreshRate == nil then</p><p>            _RefreshRate = MerchantSystem.RefreshRates[_Type];</p><p>            if _RefreshRate == nil then</p><p>                _RefreshRate = 0;</p><p>            end</p><p>        end</p><p>        local PlayerID = Logic.EntityGetPlayer(MercenaryID);</p><p>        local OfferID, TraderID = BundleTradingAnalysis.Global:GetOfferAndTrader(PlayerID, _Type);</p><p>        if OfferID ~= -1 and TraderID ~= -1 then</p><p>            API.Warn("Mercenary offer for type " .._Type.. " already exists for player " ..PlayerID.. "!");</p><p>            return;</p><p>        end</p><p>        local amount = 3;</p><p>        local typeName = Logic.GetEntityTypeName(_Type);</p><p>        if string.find(typeName,"MilitaryBow") or string.find(typeName,"MilitarySword") then</p><p>            amount = 6;</p><p>        elseif string.find(typeName,"Cart") then</p><p>            amount = 0;</p><p>        end</p><p>        if _optionalPlayersPlayerID == nil then</p><p>            _optionalPlayersPlayerID = 1;</p><p>        end</p><p>        BundleTradingAnalysis.Global.Data.PlayerOffersAmount[PlayerID][_Type] = _Amount;</p><p>        return Logic.AddMercenaryTraderOffer(MercenaryID, _Amount, Goods.G_Gold, 3, _Type ,amount,_optionalPlayersPlayerID,_RefreshRate);</p><p>    end</p><p>    ---</p><p>    -- Erzeugt ein Handelsangebot für Entertainer und gibt die</p><p>    -- ID zurück.</p><p>    --</p><p>    -- : Jeder Angebotstyp kann nur 1 Mal pro Lagerhaus</p><p>    -- angeboten werden.</p><p>    --</p><p>    -- @param[type=number] _Merchant Handelsgebäude</p><p>    -- @param[type=number] _EntertainerType Typ des Entertainer</p><p>    -- @param[type=number] _optionalPlayersPlayerID Optionale Spieler-ID</p><p>    -- @return[type=number] Offer ID</p><p>    -- @within Originalfunktionen</p><p>    --</p><p>    AddEntertainerOffer = function(_Merchant, _EntertainerType, _optionalPlayersPlayerID)</p><p>        local MerchantID = GetID(_Merchant);</p><p>        local NumberOfOffers = 1;</p><p>        local PlayerID = Logic.EntityGetPlayer(MerchantID);</p><p>        local OfferID, TraderID = BundleTradingAnalysis.Global:GetOfferAndTrader(PlayerID, _EntertainerType);</p><p>        if OfferID ~= -1 and TraderID ~= -1 then</p><p>            API.Warn("Entertainer offer for type " .._EntertainerType.. " already exists for player " ..PlayerID.. "!");</p><p>            return;</p><p>        end</p><p>        if _EntertainerType == nil then</p><p>            _EntertainerType = Entities.U_Entertainer_NA_FireEater;</p><p>        end</p><p>        if _optionalPlayersPlayerID == nil then</p><p>            _optionalPlayersPlayerID = 1;</p><p>        end</p><p>        BundleTradingAnalysis.Global.Data.PlayerOffersAmount[PlayerID][_EntertainerType] = 1;</p><p>        return Logic.AddEntertainerTraderOffer(MerchantID,NumberOfOffers,Goods.G_Gold,0,_EntertainerType, _optionalPlayersPlayerID,0);</p><p>    end</p><p>-- Fügt fehlende Einträge für Militäreinheiten bei den Basispreisen</p><p>-- und Erneuerungsraten hinzu, damit diese gehandelt werden können.</p><p>-- @within Internal</p><p>-- @local</p><p>    MerchantSystem.BasePrices[Entities.U_CatapultCart] = MerchantSystem.BasePrices[Entities.U_CatapultCart] or 1000;</p><p>    MerchantSystem.BasePrices[Entities.U_BatteringRamCart] = MerchantSystem.BasePrices[Entities.U_BatteringRamCart] or 450;</p><p>    MerchantSystem.BasePrices[Entities.U_SiegeTowerCart] = MerchantSystem.BasePrices[Entities.U_SiegeTowerCart] or 600;</p><p>    MerchantSystem.BasePrices[Entities.U_AmmunitionCart] = MerchantSystem.BasePrices[Entities.U_AmmunitionCart] or 180;</p><p>    MerchantSystem.BasePrices[Entities.U_MilitarySword_RedPrince] = MerchantSystem.BasePrices[Entities.U_MilitarySword_RedPrince] or 150;</p><p>    MerchantSystem.BasePrices[Entities.U_MilitarySword] = MerchantSystem.BasePrices[Entities.U_MilitarySword] or 150;</p><p>    MerchantSystem.BasePrices[Entities.U_MilitaryBow_RedPrince] = MerchantSystem.BasePrices[Entities.U_MilitaryBow_RedPrince] or 220;</p><p>    MerchantSystem.BasePrices[Entities.U_MilitaryBow] = MerchantSystem.BasePrices[Entities.U_MilitaryBow] or 220;</p><p>    MerchantSystem.RefreshRates[Entities.U_CatapultCart] = MerchantSystem.RefreshRates[Entities.U_CatapultCart] or 270;</p><p>    MerchantSystem.RefreshRates[Entities.U_BatteringRamCart] = MerchantSystem.RefreshRates[Entities.U_BatteringRamCart] or 190;</p><p>    MerchantSystem.RefreshRates[Entities.U_SiegeTowerCart] = MerchantSystem.RefreshRates[Entities.U_SiegeTowerCart] or 220;</p><p>    MerchantSystem.RefreshRates[Entities.U_AmmunitionCart] = MerchantSystem.RefreshRates[Entities.U_AmmunitionCart] or 150;</p><p>    MerchantSystem.RefreshRates[Entities.U_MilitaryBow_RedPrince] = MerchantSystem.RefreshRates[Entities.U_MilitarySword_RedPrince] or 150;</p><p>    MerchantSystem.RefreshRates[Entities.U_MilitarySword] = MerchantSystem.RefreshRates[Entities.U_MilitarySword] or 150;</p><p>    MerchantSystem.RefreshRates[Entities.U_MilitaryBow_RedPrince] = MerchantSystem.RefreshRates[Entities.U_MilitaryBow_RedPrince] or 150;</p><p>    MerchantSystem.RefreshRates[Entities.U_MilitaryBow] = MerchantSystem.RefreshRates[Entities.U_MilitaryBow] or 150;</p><p>    if g_GameExtraNo = 1 then</p><p>        MerchantSystem.BasePrices[Entities.U_MilitaryBow_Khana] = MerchantSystem.BasePrices[Entities.U_MilitaryBow_Khana] or 220;</p><p>        MerchantSystem.RefreshRates[Entities.U_MilitaryBow_Khana] = MerchantSystem.RefreshRates[Entities.U_MilitaryBow_Khana] or 150;</p><p>        MerchantSystem.BasePrices[Entities.U_MilitarySword_Khana] = MerchantSystem.BasePrices[Entities.U_MilitarySword_Khana] or 150;</p><p>        MerchantSystem.RefreshRates[Entities.U_MilitaryBow_Khana] = MerchantSystem.RefreshRates[Entities.U_MilitarySword_Khana] or 150;</p><p>    end</p><p>-- Gibt die Handelsinformationen des Spielers aus. In dem Objekt stehen</p><p>-- ID des Spielers, ID des Lagerhaus, Menge an Angeboten insgesamt und</p><p>-- alle Angebote der Händlertypen.</p><p>-- @param[type=number] _PlayerID Player ID</p><p>-- @return[type=table] Angebotsinformationen</p><p>-- @within Internal</p><p>-- @local</p><p>-- @usage BundleTradingAnalysis.Global:GetStorehouseInformation(2);</p><p>-- -- Ausgabe:</p><p>-- -- Info = {</p><p>-- --      Player = 2,</p><p>-- --      Storehouse = 26796.</p><p>-- --      OfferCount = 2,</p><p>-- --      {</p><p>-- --          Händler-ID, Angebots-ID, Angebotstyp, Wagenladung, Angebotsmenge</p><p>-- --          {0, 0, Goods.G_Gems, 9, 2},</p><p>-- --          {0, 1, Goods.G_Milk, 9, 4},</p><p>-- --      },</p><p>-- -- }</p><p>    local BuildingID = Logic.GetStoreHouse(_PlayerID);</p><p>    local StorehouseData = {</p><p>        Player      = _PlayerID,</p><p>        Storehouse  = BuildingID,</p><p>        OfferCount  = 0,</p><p>        {},</p><p>    };</p><p>    local NumberOfMerchants = Logic.GetNumberOfMerchants(Logic.GetStoreHouse(2));</p><p>    local AmountOfOffers = 0;</p><p>    if BuildingID ~= 0 then</p><p>        for Index = 0, NumberOfMerchants, 1 do</p><p>            local Offers = {Logic.GetMerchantOfferIDs(BuildingID, Index, _PlayerID)};</p><p>            for i= 1, #Offers, 1 do</p><p>                local type, goodAmount, offerAmount, prices = 0, 0, 0, 0;</p><p>                if Logic.IsGoodTrader(BuildingID, Index) then</p><p>                    type, goodAmount, offerAmount, prices = Logic.GetGoodTraderOffer(BuildingID, Offers[i], _PlayerID);</p><p>                    if type == Goods.G_Sheep or type == Goods.G_Cow then</p><p>                        goodAmount = 5;</p><p>                    end</p><p>                elseif Logic.IsMercenaryTrader(BuildingID, Index) then</p><p>                    type, goodAmount, offerAmount, prices = Logic.GetMercenaryOffer(BuildingID, Offers[i], _PlayerID);</p><p>                elseif Logic.IsEntertainerTrader(BuildingID, Index) then</p><p>                    type, goodAmount, offerAmount, prices = Logic.GetEntertainerTraderOffer(BuildingID, Offers[i], _PlayerID);</p><p>                end</p><p>                AmountOfOffers = AmountOfOffers +1;</p><p>                local OfferData = {Index, Offers[i], type, goodAmount, offerAmount};</p><p>                table.insert(StorehouseData[1], OfferData);</p><p>            end</p><p>        end</p><p>    end</p><p>    StorehouseData.OfferCount = AmountOfOffers;</p><p>    return StorehouseData;</p><p>-- Gibt die Menge an Angeboten im Lagerhaus des Spielers zurück. Wenn</p><p>-- der Spieler kein Lagerhaus hat, wird 0 zurückgegeben.</p><p>-- @param[type=number] _PlayerID ID des Spielers</p><p>-- @return[type=number] Menge an Angeboten</p><p>-- @within Internal</p><p>-- @local</p><p>    local Offers = self:GetStorehouseInformation(_PlayerID);</p><p>    if Info then</p><p>        return Offers.OfferCount;</p><p>    end</p><p>    return 0;</p><p>-- Gibt Offer ID und Trader ID und ID des Lagerhaus des Angebots für</p><p>-- den Spieler zurück. Es wird immer das erste Angebot zurückgegeben.</p><p>-- @param[type=number] _PlayerID Player ID</p><p>-- @param[type=number] _GoodOrEntityType Warentyp oder Entitytyp</p><p>-- @return[type=number] Offer ID</p><p>-- @return[type=number] Trader ID</p><p>-- @return[type=number] Storehouse ID</p><p>-- @within Internal</p><p>-- @local</p><p>    local Info = self:GetStorehouseInformation(_PlayerID);</p><p>    if Info then</p><p>        for j=1, #Info[1], 1 do</p><p>            if Info[1][j][3] == _GoodOrEntityType then</p><p>                return Info[1][j][2], Info[1][j][1], Info.Storehouse;</p><p>            end</p><p>        end</p><p>    end</p><p>    return -1, -1, -1;</p><p>-- Gibt den Typ des Händlers mit der ID im Gebäude zurück.</p><p>-- @param[type=number] _BuildingID Building ID</p><p>-- @param[type=number] _TraderID Trader ID</p><p>-- @return[type=number] Händlertyp</p><p>-- @within Internal</p><p>-- @local</p><p>    if Logic.IsGoodTrader(BuildingID, _TraderID) == true then</p><p>        return QSB.TraderTypes.GoodTrader;</p><p>    elseif Logic.IsMercenaryTrader(BuildingID, _TraderID) == true then</p><p>        return QSB.TraderTypes.MercenaryTrader;</p><p>    elseif Logic.IsEntertainerTrader(BuildingID, _TraderID) == true then</p><p>        return QSB.TraderTypes.EntertainerTrader;</p><p>    else</p><p>        return QSB.TraderTypes.Unknown;</p><p>    end</p><p>-- Entfernt das Angebot vom Lagerhaus des Spielers, wenn es vorhanden ist.</p><p>-- Es wird immer nur das erste Angebot des Typs entfernt.</p><p>-- @param[type=number] _PlayerID Player ID</p><p>-- @param[type=number] _GoodOrEntityType Warentyp oder Entitytyp</p><p>-- @within Internal</p><p>-- @local</p><p>    local OfferID, TraderID, BuildingID = self:GetOfferAndTrader(_PlayerID, _GoodOrEntityType);</p><p>    if not IsExisting(BuildingID) then</p><p>        return;</p><p>    end</p><p>    -- Wird benötigt, weil bei RemoveOffer die Trader-IDs vertauscht sind.</p><p>    local MappedTraderID = (TraderID == 1 and 2) or (TraderID == 2 and 1) or 0;</p><p>    Logic.RemoveOffer(BuildingID, MappedTraderID, OfferID);</p><p>-- Ändert die aktuelle Menge des Angebots im Händelrgebäude.</p><p>-- Der eingetragene Wert darf die maximale Menge an Angeboten des Typs im</p><p>-- Lagerhaus nicht überschreiten.</p><p>-- : Wird eine höherer Wert gesetzt, als das ursprüngliche</p><p>-- Maximum, regenerieren sich die zusätzlichen Angebote nicht.</p><p>-- @param[type=number] _PlayerID	     Händlergebäude</p><p>-- @param[type=number] _GoodOrEntityType ID des Händlers im Gebäude</p><p>-- @param[type=number] _NewAmount        Neue Menge an Angeboten</p><p>-- @within Internal</p><p>-- @local</p><p>    local OfferID, TraderID, BuildingID = self:GetOfferAndTrader(_PlayerID, _GoodOrEntityType);</p><p>    if not IsExisting(BuildingID) then</p><p>        return;</p><p>    end</p><p>    -- Menge == -1 oder Menge == nil bedeutet Maximum</p><p>    if _NewAmount == nil or _NewAmount == -1 then</p><p>        _NewAmount = self.Data.PlayerOffersAmount[_PlayerID][_GoodOrEntityType];</p><p>    end</p><p>    -- Werte größer als das Maximum werden nicht erneuert!</p><p>    if self.Data.PlayerOffersAmount[_PlayerID][_GoodOrEntityType] and self.Data.PlayerOffersAmount[_PlayerID][_GoodOrEntityType]  _NewAmount then</p><p>        _NewAmount = self.Data.PlayerOffersAmount[_PlayerID][_GoodOrEntityType];</p><p>    end</p><p>    Logic.ModifyTraderOffer(BuildingID, OfferID, _NewAmount, TraderID);</p><p>-- -------------------------------------------------------------------------- --</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundletravelingsalesman.lua.html">
            <div class='doclink'>
                <div>BundleTravelingSalesman</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia BundleTravelingSalesman                                       # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Mit diesem Bundle wird ein Fahrender Händler angeboten der periodisch den</p><p>-- Hafen mit einem Schiff anfährt. Dabei kann der Fahrtweg frei mit Wegpunkten</p><p>-- bestimmt werden. Es können auch mehrere Spieler zu Händlern gemacht werden.</p><p>-- </p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Erstellt einen fahrender Händler mit zufälligen Angeboten.</p><p>-- Soll immer das selbe angeboten werden, darf nur ein Angebotsblock</p><p>-- definiert werden.</p><p>-- Es kann mehr als einen fahrender Händler auf der Map geben.</p><p>-- : ActivateTravelingSalesman</p><p>-- @param[type=number]  _PlayerID Spieler-ID des Händlers</p><p>-- @param[type=table]   _Offers Liste an Angeboten</p><p>-- @param[type=table]   _Waypoints Wegpunktliste Anfahrt</p><p>-- @param[type=table]   _Reversed (optional) Wegpunktliste Abfahrt</p><p>-- @param[type=table]   _Appearance (optional) Ankunft und Abfahrt</p><p>-- @param[type=boolean] _RotationMode (optional) Angebote werden der Reihe nach durchgegangen</p><p>-- @within Anwenderfunktionen</p><p>-- @usage -- Angebote deklarieren</p><p>-- local Offers = {</p><p>--     {</p><p>--         {"G_Gems", 5,},</p><p>--         {"G_Iron", 5,},</p><p>--         {"G_Beer", 2,},</p><p>--     },</p><p>--     {</p><p>--         {"G_Stone", 5,},</p><p>--         {"G_Sheep", 1,},</p><p>--         {"G_Cheese", 2,},</p><p>--         {"G_Milk", 5,},</p><p>--     },</p><p>--     {</p><p>--         {"G_Grain", 5,},</p><p>--         {"G_Broom", 2,},</p><p>--         {"G_Sheep", 1,},</p><p>--     },</p><p>--     {</p><p>--         {"U_CatapultCart", 1,},</p><p>--         {"U_MilitarySword", 3,},</p><p>--         {"U_MilitaryBow", 3,},</p><p>--     },</p><p>-- };</p><p>-- -- Es sind maximal 4 Angebote pro Block erlaubt. Es können Waren, Soldaten</p><p>-- -- oder Entertainer angeboten werden. Es wird immer automatisch 1 Block</p><p>-- -- selektiert und die Angebote gesetzt.</p><p>-- -- Wegpunkte deklarieren</p><p>-- local Waypoints = {"WP1", "WP2", "WP3", "WP4"};</p><p>-- -- Es gibt nun zwei Möglichkeiten:</p><p>-- -- 1. Durch weglassen des Reversed Path werden die Wegpunkte durch das</p><p>-- -- Schiff bei der Abfahrt automatisch rückwärts abgefahren.</p><p>-- -- 2. Es wird ein anderer Pfad für die Abfahrt deklariert.</p><p>-- -- An- und Abfanrtsmonate deklarieren</p><p>-- local Appearance = {{4, 6}, {8, 10}};</p><p>-- -- Auch hier gibt es 2 Möglichkeiten:</p><p>-- -- 1. Neue Anfahrts- und Abfahrtszeiten setzen.</p><p>-- -- 2. _Apperance weglassen / nil setzen und den Standard verwenden</p><p>-- -- (März bis Mai und August bis Oktober)</p><p>-- -- Jetzt kann ein fahrender Händler erzeugt werden</p><p>-- API.TravelingSalesmanActivate(2, Offers, Waypoints, nil, Appearance);</p><p>-- -- Hier ist der Rückweg automatisch die Umkehr des Hinwegs (_Reversed = nil).</p><p>-- -- _Reversed und _Apperance können in den meisten Fällen immer weggelassen</p><p>-- -- bzw. nil sein!</p><p>-- API.TravelingSalesmanActivate(2, Offers, Waypoints);</p><p>function API.TravelingSalesmanActivate(_PlayerID, _Offers, _Waypoints, _Reversed, _Appearance, _RotationMode)</p><p>    if GUI then</p><p>        API.Fatal("Can not execute API.TravelingSalesmanActivate in local script!");</p><p>        return;</p><p>    end</p><p>    return QSB.TravelingSalesman:New(_PlayerID)</p><p>        :SetOffers(_Offers)</p><p>        :SetApproachRoute(_Waypoints)</p><p>        :SetReturnRouteRoute(_Reversed)</p><p>        :SetApperance(_Appearance)</p><p>        :UseOfferRotation(_Flag);</p><p>-- Entfernt den fahrenden Händler von dem Spieler. Der Spieler bleibt</p><p>-- erhalten wird aber nicht mal als fahrender Händler fungieren.</p><p>-- : DeactivateTravelingSalesman</p><p>-- @param[type=number] _PlayerID Spieler-ID des Händlers</p><p>-- @within Anwenderfunktionen</p><p>-- @usage -- Fahrenden Händler von Spieler 2 löschen</p><p>-- API.TravelingSalesmanDeactivate(2)</p><p>function API.TravelingSalesmanDeactivate(_PlayerID)</p><p>    if GUI then</p><p>        API.Bridge("API.TravelingSalesmanDeactivate(" .._PlayerID.. ")");</p><p>        return;</p><p>    end</p><p>    QSB.TravelingSalesman:GetInstance(_PlayerID):Dispose();</p><p>-- Legt fest, ob die diplomatischen Beziehungen zwischen dem Spieler und dem</p><p>-- Hafen überschrieben werden.</p><p>-- Die diplomatischen Beziehungen werden überschrieben, wenn sich ein Schiff</p><p>-- im Hafen befindet und wenn es abreist. Der Hafen ist "Handelspartner", wenn</p><p>-- ein Schiff angelegt hat, sonst "Bekannt".</p><p>-- Bei diplomatischen Beziehungen geringer als "Bekannt", kann es zu Fehlern</p><p>-- kommen. Dann werden Handelsangebote angezeigt, konnen aber nicht durch</p><p>-- den Spieler erworben werden.</p><p>-- : Überschreiben der Beziehungen ist Standardmäßig als aktiv</p><p>-- voreingestellt.</p><p>-- : TravelingSalesmanDiplomacyOverride</p><p>-- @param[type=number]  _PlayerID Spieler-ID des Händlers</p><p>-- @param[type=boolean] _Flag Diplomatie überschreiben</p><p>-- @within Anwenderfunktionen</p><p>-- @usage -- Spieler 2 überschreibt nicht mehr die Diplomatie</p><p>-- API.TravelingSalesmanDiplomacyOverride(2, false)</p><p>function API.TravelingSalesmanDiplomacyOverride(_PlayerID, _Flag)</p><p>    if GUI then</p><p>        API.Bridge("API.TravelingSalesmanDiplomacyOverride(" .._PlayerID.. ", " ..tostring(_Flag).. ")");</p><p>        return;</p><p>    end</p><p>    QSB.TravelingSalesman:GetInstance(_PlayerID):UseChangeDiplomacy(_Flag);</p><p>-- Legt fest, ob die Angebote der Reihe nach durchgegangen werden (beginnt von</p><p>-- vorn, wenn am Ende angelangt) oder zufällig ausgesucht werden.</p><p>-- : TravelingSalesmanRotationMode</p><p>-- @param[type=number]  _PlayerID Spieler-ID des Händlers</p><p>-- @param[type=boolean] _Flag Angebotsrotation einschalten</p><p>-- @within Anwenderfunktionen</p><p>-- @usage -- Spieler 2 geht Angebote der Reihe nach durch.</p><p>-- API.TravelingSalesmanRotationMode(2, true)</p><p>function API.TravelingSalesmanRotationMode(_PlayerID, _Flag)</p><p>    if GUI then</p><p>        API.Bridge("API.TravelingSalesmanRotationMode(" .._PlayerID.. ", " ..tostring(_Flag).. ")");</p><p>        return;</p><p>    end</p><p>    QSB.TravelingSalesman:GetInstance(_PlayerID):UseOfferRotation(_Flag);</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {</p><p>        Data = {},</p><p>    },</p><p>-- Global Script ---------------------------------------------------------------</p><p>-- Initialisiert das Bundle im globalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    StartSimpleJobEx(BundleTravelingSalesman.Global.TravelingSalesmanController);</p><p>-- Ruft die Loop-Funktion aller Fahrenden Händler auf.</p><p>-- @within Internal</p><p>-- @local</p><p>    for i= 1, 8, 1 do</p><p>        if QSB.TravelingSalesman:GetInstance(i) then</p><p>            QSB.TravelingSalesman:GetInstance(i):Loop();</p><p>        end</p><p>    end</p><p>-- Klassen ------------------------------------------------------------------ --</p><p>-- Konstruktor</p><p>-- @param[type=number] _PlayerID Player-ID des Händlers</p><p>-- @within QSB.TravelingSalesman</p><p>-- @local</p><p>    local salesman = API.InstanceTable(self);</p><p>    salesman.m_PlayerID = _PlayerID;</p><p>    salesman.m_Offers = {};</p><p>    salesman.m_Appearance = {{3, 5}, {7, 9}};</p><p>    salesman.m_Waypoints = {};</p><p>    salesman.m_Reversed = {};</p><p>    salesman.m_ChangeDiplomacy = true;</p><p>    salesman.m_OfferRotation = false;</p><p>    salesman.m_LastOffer = 0;</p><p>    salesman.m_Status = 0;</p><p>    QSB.TravelingSalesmanInstances[_PlayerID] = salesman;</p><p>    return salesman;</p><p>-- Gibt die Instanz des Fahrenden Händlers für die Player-ID zurück.</p><p>-- Sollte keine Instanz für den Spieler existieren, wird eine Null-Instanz</p><p>-- erzeugt und zurückgegeben.</p><p>-- @param[type=number] _PlayerID Player-ID des Händlers</p><p>-- @return[type=table] Instanz</p><p>-- @within QSB.TravelingSalesman</p><p>-- @local</p><p>    if QSB.TravelingSalesmanInstances[_PlayerID] then</p><p>        return QSB.TravelingSalesmanInstances[_PlayerID];</p><p>    end</p><p>    local NullInstance = QSB.TravelingSalesman:New(_PlayerID);</p><p>    NullInstance.SymfoniaDebugValue_NullInstance = true;</p><p>    return NullInstance;</p><p>-- Gibt die ID des ersten aktiven menschlichen Spielers zurück.</p><p>-- @return[type=number] Player-ID</p><p>-- @within QSB.TravelingSalesman</p><p>-- @local</p><p>    for i= 1, 8, 1 do</p><p>        if Logic.PlayerGetIsHumanFlag(1) == true then</p><p>            return i;</p><p>        end</p><p>    end</p><p>    return 0;</p><p>-- Entfernt alle Angebotsblöcke des Fahrenden Händlers.</p><p>-- @return[type=table] self</p><p>-- @within QSB.TravelingSalesman</p><p>-- @local</p><p>    return self:SetOffers({});</p><p>-- Setzt eine Liste von Angebotsblöcken für den Fahrenden Händler.</p><p>-- @param[type=table] _Offers Definierte Angebotsblöcke</p><p>-- @return[type=table] self</p><p>-- @within QSB.TravelingSalesman</p><p>-- @local</p><p>    self.m_Offers = _Offers;</p><p>    return self;</p><p>-- Fügt dem Fahrenden Händler einen Angebotsblock hinzu. Es wird zuerst der</p><p>-- Warentyp als String und danach die Anzahl angegeben.</p><p>-- @return[type=table] self</p><p>-- @within QSB.TravelingSalesman</p><p>-- @local</p><p>    local Offer = {};</p><p>    for i= 1, #arg, 2 do</p><p>        table.insert(Offer, {arg[i], arg[i+1]});</p><p>    end</p><p>    table.insert(self.m_Offers, Offer);</p><p>    return self;</p><p>-- Löscht die Aufenthaltszeitspanne des Fahrenden Händlers.</p><p>-- @return[type=table] self</p><p>-- @within QSB.TravelingSalesman</p><p>-- @local</p><p>    return self:SetApperance({});</p><p>-- Fügt einen Zeitraum zur Aufenthalt des Fliegenden Händlers hinzu. Ein</p><p>-- Zeitraum besteht aus Startmonat und Endmonat.</p><p>-- @return[type=table] self</p><p>-- @within QSB.TravelingSalesman</p><p>-- @local</p><p>    table.insert(self.m_Appearance, {_Start, _End});</p><p>    return self;</p><p>-- Setzt die Aufenthaltszeitspanne des Fliegenden Händlers</p><p>-- @param[type=table] _Apperance Aufenthaltszeitspanne</p><p>-- @return[type=table] self</p><p>-- @within QSB.TravelingSalesman</p><p>-- @local</p><p>    self.m_Appearance = _Apperance or self.m_Appearance;</p><p>    return self;</p><p>-- Setzt die Route für die Ankunft des Fahrenden Händlers.</p><p>-- @param[type=table] _List Liste der Wegpunkte</p><p>-- @return[type=table] self</p><p>-- @within QSB.TravelingSalesman</p><p>-- @local</p><p>    self.m_Waypoints = API.InstanceTable(_List);</p><p>    self.m_SpawnPos = self.m_Waypoints[1];</p><p>    self.m_Destination = self.m_Waypoints[#_List];</p><p>    return self;</p><p>-- Setzt die Wegpunkte für die Abfahrt des Fliegenden Händlers. Ist die Liste</p><p>-- nil, werden die Wegpunkte für die Anfahrt invertiert.</p><p>-- @param[type=table] _List Liste der Wegpunkte</p><p>-- @return[type=table] self</p><p>-- @within QSB.TravelingSalesman</p><p>-- @local</p><p>    local Reversed = _List;</p><p>    if type(Reversed) ~= "table" then</p><p>        Reversed = {};</p><p>        for i= #self.m_Waypoints, 1, -1 do</p><p>            table.insert(Reversed, self.m_Waypoints[i]);</p><p>        end</p><p>    end</p><p>    self.m_Reversed = API.InstanceTable(Reversed);</p><p>    return self;</p><p>-- Aktiviert oder deaktiviert die sequentielle Abarbeitung der Angebote dieses</p><p>-- Fliegenden Händlers.</p><p>-- @param[type=boolean] _Flag Angebote sequenziell durchlaufen</p><p>-- @return[type=table] self</p><p>-- @within QSB.TravelingSalesman</p><p>-- @local</p><p>    self.m_OfferRotation = _Flag == true;</p><p>    return self;</p><p>-- Aktiviert oder deaktiviert die automatische Anpasung der Diplomatie.</p><p>-- @param[type=boolean] _Flag Diplomatie wird überschrieben</p><p>-- @return[type=table] self</p><p>-- @within QSB.TravelingSalesman</p><p>-- @local</p><p>    self.m_ChangeDiplomacy = _Flag == true;</p><p>    return self;</p><p>-- Invalidiert die Instanz dieses Fliegenden Händlers.</p><p>-- @within QSB.TravelingSalesman</p><p>-- @local</p><p>    Logic.RemoveAllOffers(Logic.GetStoreHouse(self.m_PlayerID));</p><p>    DestroyEntity("TravelingSalesmanShip_Player" ..self.m_PlayerID);</p><p>    QSB.TravelingSalesmanInstances[self.m_PlayerID] = nil;</p><p>-- Gibt einen Block Angebote für diesen Fahrenden Händler zurück.</p><p>-- @return[type=table] Angebote</p><p>-- @within QSB.TravelingSalesman</p><p>-- @local</p><p>    local NextOffer;</p><p>    if self.m_OfferRotation then</p><p>        self.m_LastOffer = self.m_LastOffer +1;</p><p>        if self.m_LastOffer  #self.m_Offers then</p><p>            self.m_LastOffer = 1;</p><p>        end</p><p>        NextOffer = self.m_Offers[self.m_LastOffer];</p><p>    else</p><p>        local RandomIndex = 1;</p><p>        if #self.m_Offers  1 then</p><p>            repeat</p><p>                RandomIndex = math.random(1,#self.m_Offers);</p><p>            until (RandomIndex ~= self.m_LastOffer);</p><p>        end</p><p>        self.m_LastOffer = RandomIndex;</p><p>        NextOffer = self.m_Offers[self.m_LastOffer];</p><p>    end</p><p>    return NextOffer;</p><p>-- Zeigt die Info-Nachricht an, wenn ein Schiff im Hafen anlegt.</p><p>-- @return[type=table] self</p><p>-- @within QSB.TravelingSalesman</p><p>-- @local</p><p>    if ((IsBriefingActive and not IsBriefingActive()) or true) then</p><p>        local InfoQuest = Quests[GetQuestID("TravelingSalesman_Info_P" ..self.m_PlayerID)];</p><p>        if InfoQuest then</p><p>            API.RestartQuest("TravelingSalesman_Info_P" ..self.m_PlayerID, true);</p><p>            InfoQuest:SetMsgKeyOverride();</p><p>            InfoQuest:SetIconOverride();</p><p>            InfoQuest:Trigger();</p><p>            return self;</p><p>        end</p><p>        local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>        local Text = { de = "Ein Schiff hat angelegt. Es bringt Güter von weit her.",</p><p>                       en = "A ship is at the pier. It delivers goods from far away."};</p><p>        QuestTemplate:New(</p><p>            "TravelingSalesman_Info_P" ..self.m_PlayerID,</p><p>            self.m_PlayerID,</p><p>            self:GetHumanPlayer(),</p><p>            {{ Objective.Dummy,}},</p><p>            {{ Triggers.Time, 0 }},</p><p>            0,</p><p>            nil, nil, nil, nil, false, true,</p><p>            nil, nil,</p><p>            Text[lang],</p><p>            nil</p><p>        );</p><p>    end</p><p>    return self;</p><p>-- Fügt dem Fahrenden Händler ein neues Angebot hinzu.</p><p>-- @return[type=table] self</p><p>-- @within QSB.TravelingSalesman</p><p>-- @local</p><p>    MerchantSystem.TradeBlackList[self.m_PlayerID] = {};</p><p>    MerchantSystem.TradeBlackList[self.m_PlayerID][0] = #MerchantSystem.TradeBlackList[3];</p><p>    local traderId = Logic.GetStoreHouse(self.m_PlayerID);</p><p>    local offer = self:NextOffer();</p><p>    Logic.RemoveAllOffers(traderId);</p><p>    if #offer  0 then</p><p>        for i=1,#offer,1 do</p><p>            local offerType = offer[i][1];</p><p>            local isGoodType = false;</p><p>            for k,v in pairs(Goods)do</p><p>                if k == offerType then</p><p>                    isGoodType = true;</p><p>                end</p><p>            end</p><p>            if isGoodType then</p><p>                local amount = offer[i][2];</p><p>                AddOffer(traderId,amount,Goods[offerType], 9999);</p><p>            else</p><p>                if Logic.IsEntityTypeInCategory(Entities[offerType],EntityCategories.Military)== 0 then</p><p>                    AddEntertainerOffer(traderId,Entities[offerType]);</p><p>                else</p><p>                    local amount = offer[i][2];</p><p>                    AddMercenaryOffer(traderId,amount,Entities[offerType], 9999);</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>    if self.m_ChangeDiplomacy then</p><p>        SetDiplomacyState(self:GetHumanPlayer(), self.m_PlayerID, DiplomacyStates.TradeContact);</p><p>    end</p><p>    Logic.SetTraderPlayerState(Logic.GetStoreHouse(self.m_PlayerID), self:GetHumanPlayer(), 1);</p><p>    return self;</p><p>-- Steuert den Ablauf des fliegenden Händlers.</p><p>-- @return[type=table] self</p><p>-- @within QSB.TravelingSalesman</p><p>-- @local</p><p>    if not self.SymfoniaDebugValue_NullInstance and Logic.PlayerGetIsHumanFlag(self.m_PlayerID) == false then</p><p>        if self.m_Status == 0 then</p><p>            local month = Logic.GetCurrentMonth();</p><p>            local start = false;</p><p>            for i=1, #self.m_Appearance,1 do</p><p>                if month == self.m_Appearance[i][1] then</p><p>                    start = true;</p><p>                end</p><p>            end</p><p>            if start then</p><p>                local orientation = Logic.GetEntityOrientation(GetID(self.m_SpawnPos))</p><p>                local ID = CreateEntity(0, Entities.D_X_TradeShip, GetPosition(self.m_SpawnPos), "TravelingSalesmanShip_Player" ..self.m_PlayerID, orientation);</p><p>                Path:new(ID,self.m_Waypoints, nil, nil, nil, nil, true, nil, nil, 300);</p><p>                self.m_Status = 1;</p><p>            end</p><p>        elseif self.m_Status == 1 then</p><p>            if IsNear("TravelingSalesmanShip_Player" ..self.m_PlayerID, self.m_Destination, 400) then</p><p>                self:IntroduceNewOffer():DisplayInfoMessage();</p><p>                self.m_Status = 2;</p><p>            end</p><p>            </p><p>        elseif self.m_Status == 2 then</p><p>            local month = Logic.GetCurrentMonth();</p><p>            local stop = false;</p><p>            for i=1, #self.m_Appearance,1 do</p><p>                if month == self.m_Appearance[i][2] then</p><p>                    stop = true;</p><p>                end</p><p>            end</p><p>            if stop then</p><p>                if self.m_ChangeDiplomacy then</p><p>                    SetDiplomacyState(self:GetHumanPlayer(), self.m_PlayerID, DiplomacyStates.EstablishedContact);</p><p>                end</p><p>                Path:new(GetID("TravelingSalesmanShip_Player" ..self.m_PlayerID), self.m_Reversed, nil, nil, nil, nil, true, nil, nil, 300);</p><p>                Logic.RemoveAllOffers(Logic.GetStoreHouse(self.m_PlayerID));</p><p>                self.m_Status = 3;</p><p>            end</p><p>        elseif self.m_Status == 3 then</p><p>            if IsNear("TravelingSalesmanShip_Player" ..self.m_PlayerID, self.m_SpawnPos, 400) then</p><p>                DestroyEntity("TravelingSalesmanShip_Player" ..self.m_PlayerID);</p><p>                self.m_Status = 0;</p><p>            end</p><p>        end</p><p>    end</p><p>    return self;</p><p>-- -------------------------------------------------------------------------- --</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundleweathermanipulation.lua.html">
            <div class='doclink'>
                <div>BundleWeatherManipulation</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia BundleWeatherManipulation                                    # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Mit diesem Modul können Wetterevents und Wetteranimationen kombiniert</p><p>-- gestartet werden.</p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Erzeugt ein neues Wetterevent und gibt es zurück.</p><p>-- @param[type=string]  _GFX Verwendetes Display Set</p><p>-- @param[type=boolean] _Rain Niederschlag aktivieren</p><p>-- @param[type=boolean] _Snow Niederschlag ist Schnee</p><p>-- @param[type=boolean] _Ice Wasser gefriert</p><p>-- @param[type=boolean] _Monsoon Blockendes Monsunwasser aktivieren</p><p>-- @param[type=number]  _Temp Temperatur während des Events</p><p>-- @param[type=table]   _NotGrowing Liste der nicht nachwachsenden Güter</p><p>-- @return[type=table] Neues Wetterevent</p><p>-- @within WeatherEvent</p><p>function API.WeatherEventCreate(_GFX, _Rain, _Snow, _Ice, _Monsoon, _Temp, _NotGrowing)</p><p>    if GUI then</p><p>        fatal("API.WeatherEventCreate: Events must be created in the global script!");</p><p>        return;</p><p>    end</p><p>    </p><p>    local Event = WeatherEvent:New();</p><p>    Event.GFX = _GFX or Event.GFX;</p><p>    Event.Rain = _Rain or Event.Rain;</p><p>    Event.Snow = _Snow or Event.Snow;</p><p>    Event.Ice = _Ice or Event.Ice;</p><p>    Event.Monsoon = _Monsoon or Event.Monsoon;</p><p>    Event.Temperature = _Temp or Event.Temperature;</p><p>    Event.NotGrowing = NotGrowing or Event.NotGrowing;</p><p>    return Event;</p><p>-- Registiert ein Event für eine bestimmte Dauer. Das Event wird auf der</p><p>-- "Wartebank" eingereiht.</p><p>-- @param[type=table]  _Event     Event-Instanz</p><p>-- @param[type=string] _Name      Name des Events</p><p>-- @param[type=number] _Duration  Name des Events</p><p>-- @within WeatherEvent</p><p>function API.WeatherEventRegister(_Event, _Name, _Duration)</p><p>    if GUI then</p><p>        fatal("API.WeatherEventStart: Events must be started in the global script!");</p><p>        return;</p><p>    end</p><p>    if type(_Event) ~= "table" or not _Event.GFX then</p><p>        fatal("API.WeatherEventStart: Invalid weather event!");</p><p>        return;</p><p>    end</p><p>    BundleWeatherManipulation.Global:AddEvent(_Event, _Name, _Duration);</p><p>-- Registiert ein Event als Endlosschleife. Das Event wird immer wieder neu</p><p>-- starten, kurz bevor es eigentlich endet. Es darf keine anderen Events auf</p><p>-- der "Wartebank" geben.</p><p>-- @param[type=table]  _Event Event-Instanz</p><p>-- @param[type=string] _Name  Name des Events</p><p>-- @within WeatherEvent</p><p>function API.WeatherEventRegisterLoop(_Event, _Name)</p><p>    if GUI then</p><p>        fatal("API.WeatherEventStartLoop: Events must be started in the global script!");</p><p>        return;</p><p>    end</p><p>    if type(_Event) ~= "table" or not _Event.GFX then</p><p>        fatal("API.WeatherEventStartLoop: Invalid weather event!");</p><p>        return;</p><p>    end</p><p>    </p><p>    _Event.Loop = function(_Data)</p><p>        if _Data.Duration = 36 then</p><p>            BundleWeatherManipulation.Global:AddEvent(_Event, _Data.Name, 120);</p><p>            BundleWeatherManipulation.Global:StopEvent();</p><p>            BundleWeatherManipulation.Global:ActivateEvent();</p><p>        end</p><p>    end</p><p>    BundleWeatherManipulation.Global:AddEvent(_Event, _Name, 120);</p><p>-- Startet das nächste Wetterevent auf der "Wartebank". Wenn bereits ein Event</p><p>-- aktiv ist, wird dieses gestoppt. Allerdings bleibt die Animation erhalten.</p><p>-- @within WeatherEvent</p><p>function API.WeatherEventNext()</p><p>    BundleWeatherManipulation.Global:StopEvent();</p><p>    BundleWeatherManipulation.Global:ActivateEvent();</p><p>-- Bricht das aktuelle Event inklusive der Animation sofort ab.</p><p>-- @within WeatherEvent</p><p>function API.WeatherEventAbort()</p><p>    API.Bridge("Display.StopAllEnvironmentSettingsSequences()");</p><p>    BundleWeatherManipulation.Global:StopEvent();</p><p>-- Bricht das aktuelle Event ab und löscht alle eingereihten Events.</p><p>-- @within WeatherEvent</p><p>function API.WeatherEventPurge()</p><p>    BundleWeatherManipulation.Global:PurgeAllEvents();</p><p>    API.Bridge("Display.StopAllEnvironmentSettingsSequences()");</p><p>    BundleWeatherManipulation.Global:StopEvent();</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {</p><p>        Data = {</p><p>            EventQueue = {},</p><p>            ActiveEvent = nil,</p><p>        },</p><p>    },</p><p>    Local = {</p><p>        Data = {</p><p>            ActiveEvent = nil,</p><p>        },</p><p>    },</p><p>-- Global Script ------------------------------------------------------------ --</p><p>-- Installiert das Bundle im globalen Skript.</p><p>-- @within WeatherEvent</p><p>-- @local</p><p>    API.AddSaveGameAction(self.OnSaveGameLoaded);</p><p>    StartSimpleJobEx(self.EventController);</p><p>-- Fügt ein Event zur Event Queue hinzu.</p><p>-- @param[type=table]  _Event    Wetterevent</p><p>-- @param[type=string] _Name     Name des Events</p><p>-- @param[type=string] _Duration Dauer des Ereignisses</p><p>-- @within WeatherEvent</p><p>-- @local</p><p>    local Event = API.InstanceTable(_Event);</p><p>    Event.Duration = _Duration;</p><p>    Event.Name = _Name;</p><p>    table.insert(self.Data.EventQueue, Event);</p><p>    -- self:NextEvent();</p><p>-- Entfernt alle Events aus der Event Queue, die den gleichen Namen haben.</p><p>-- @param[type=string] _EventName Name des Events</p><p>-- @within WeatherEvent</p><p>-- @local</p><p>    if #self.Data.EventQueue  0 then</p><p>        for i= #self.Data.EventQueue, 1 -1 do</p><p>            if self.Data.EventQueue[i].Name == _EventName then</p><p>                self.Data.EventQueue:remove(i);</p><p>            end</p><p>        end</p><p>    end</p><p>-- Leer die Event Queue komplett.</p><p>-- @within WeatherEvent</p><p>-- @local</p><p>    if #self.Data.EventQueue  0 then</p><p>        for i= #self.Data.EventQueue, 1 -1 do</p><p>            self.Data.EventQueue:remove(i);</p><p>        end</p><p>    end</p><p>-- Startet das nächste Wetterevent in der Wetterwarteschlange, aber nur, wenn</p><p>-- kein Event aktiv ist.</p><p>-- @within WeatherEvent</p><p>-- @local</p><p>    if not self:IsEventActive() then</p><p>        if #self.Data.EventQueue  0 then</p><p>            self:ActivateEvent();</p><p>        end</p><p>    end</p><p>-- Startet das nächste Wetterevent in der Wetterwarteschlange.</p><p>-- @within WeatherEvent</p><p>-- @local</p><p>    if #self.Data.EventQueue == 0 then</p><p>        return;</p><p>    end</p><p>    local Event = table.remove(self.Data.EventQueue, 1);</p><p>    self.Data.ActiveEvent = Event;</p><p>    API.Bridge([[</p><p>        BundleWeatherManipulation.Local.Data.ActiveEvent = ]] ..API.ConvertTableToString(Event).. [[</p><p>        BundleWeatherManipulation.Local:DisplayEvent()</p><p>    ]]);</p><p>    API.Note("Debug: Event activated")</p><p>    Logic.WeatherEventClearGoodTypesNotGrowing();</p><p>    for i= 1, #Event.NotGrowing, 1 do</p><p>        Logic.WeatherEventAddGoodTypeNotGrowing(Event.NotGrowing[i]);</p><p>    end</p><p>    if Event.Rain then</p><p>        Logic.WeatherEventSetPrecipitationFalling(true);</p><p>        Logic.WeatherEventSetPrecipitationHeaviness(1);</p><p>        Logic.WeatherEventSetWaterRegenerationFactor(1);</p><p>        if Event.Snow then</p><p>            Logic.WeatherEventSetPrecipitationIsSnow(true);</p><p>        end</p><p>    end</p><p>    if Event.Ice then</p><p>        Logic.WeatherEventSetWaterFreezes(true);</p><p>    end</p><p>    if Event.Monsoon then</p><p>        Logic.WeatherEventSetShallowWaterFloods(true);</p><p>    end</p><p>    Logic.WeatherEventSetTemperature(Event.Temperature);</p><p>    Logic.ActivateWeatherEvent();</p><p>-- Stoppt das aktuelle Wettervent und die Wetteranimation.</p><p>-- @within WeatherEvent</p><p>-- @local</p><p>    API.Bridge("BundleWeatherManipulation.Local.Data.ActiveEvent = nil");</p><p>    BundleWeatherManipulation.Global.Data.ActiveEvent = nil;</p><p>    Logic.DeactivateWeatherEvent();</p><p>-- Gibt die verbleibende Dauer des aktuellen Wetterevnts zurück. Ist kein</p><p>-- Event aktiv, wird 0 zurückgegeben.</p><p>-- @return[type=number] Übrige Dauer des Events</p><p>-- @within WeatherEvent</p><p>-- @local</p><p>    if not self:IsEventActive() then</p><p>        return 0;</p><p>    end</p><p>    return self.Data.ActiveEvent.Duration;</p><p>-- Prüft, ob ein Wetterevent aktiv ist.</p><p>-- @return[type=boolean] Event ist aktiv</p><p>-- @within WeatherEvent</p><p>-- @local</p><p>    return self.Data.ActiveEvent ~= nil;</p><p>-- Startet nach dem Laden eines Spielstandes die Wetteranimation neu mit</p><p>-- der verbleibenden Zeit des Events.</p><p>-- @within WeatherEvent</p><p>-- @local</p><p>    if BundleWeatherManipulation.Global:IsEventActive() then</p><p>        API.Bridge([[</p><p>            Display.StopAllEnvironmentSettingsSequences()</p><p>            BundleWeatherManipulation.Local:DisplayEvent(]] ..BundleWeatherManipulation.Global:GetEventRemainingTime().. [[)</p><p>        ]]);</p><p>    end</p><p>-- Steuert die Event Queue und startet das jeweils nächste Event.</p><p>-- @within WeatherEvent</p><p>-- @local</p><p>    if BundleWeatherManipulation.Global:IsEventActive() then</p><p>        BundleWeatherManipulation.Global.Data.ActiveEvent.Duration = BundleWeatherManipulation.Global.Data.ActiveEvent.Duration -1;</p><p>        if BundleWeatherManipulation.Global.Data.ActiveEvent.Loop then</p><p>            BundleWeatherManipulation.Global.Data.ActiveEvent:Loop();</p><p>        end</p><p>        </p><p>        if BundleWeatherManipulation.Global.Data.ActiveEvent.Duration == 0 then</p><p>            BundleWeatherManipulation.Global:StopEvent();</p><p>            BundleWeatherManipulation.Global:NextEvent();</p><p>        end</p><p>    end</p><p>-- Local Script ------------------------------------------------------------- --</p><p>-- Installiert das Bundle im globalen Skript.</p><p>-- @within WeatherEvent</p><p>-- @local</p><p>-- Startet die Wetteranimation mit der Duration des Events. Optional kann</p><p>-- eine andere Duration angegeben werden.</p><p>-- @param[type=number] Optionale Dauer der Animation</p><p>-- @within WeatherEvent</p><p>-- @local</p><p>    if self:IsEventActive() then</p><p>        local SequenceID = Display.AddEnvironmentSettingsSequence(self.Data.ActiveEvent.GFX);</p><p>        Display.PlayEnvironmentSettingsSequence(SequenceID, _Duration or self.Data.ActiveEvent.Duration);</p><p>    end</p><p>-- Prüft, ob ein Wetterevent aktiv ist.</p><p>-- @return[type=boolean] Event ist aktiv</p><p>-- @within WeatherEvent</p><p>-- @local</p><p>    return self.Data.ActiveEvent ~= nil;</p><p>    GFX = "ne_winter_sequence.xml",</p><p>    NotGrowing = {},</p><p>    Rain = false,</p><p>    Snow = false,</p><p>    Ice = false,</p><p>    Monsoon = false,</p><p>    Temperature = 10,</p><p>-- Erstellt ein neues Wetterevent.</p><p>-- Ein Wetterevent ist standardmäßig eingestellt. Es gibt keinen Niederschlag,</p><p>-- und keinen Monsun, alle Güter wachsen, die Temperatur ist 10°C und als</p><p>-- GFX wird ne_winter_sequence.xml verwendet.</p><p>-- Um Werte anzupassen muss auf die Felder in einem neuen Wetterevent</p><p>-- zugegriffen werden. Ein Beispiel:</p><p>-- </p><p>-- Um Güter, die nicht nachwachsen sollen, hinzuzufügen, muss auf das Table</p><p>-- NotGrowing zugegriffen werden. Ein Beispiel:</p><p>-- </p><p>-- Ein einmal erstelltes Event kann immer wieder verwendet werden! Speichere</p><p>-- es also in einer globalen Variable.</p><p>-- Ein Event hat folgende Felder:</p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- String: Die verwendete Display-Animation. Hierbei muss es sich im eine</p><p>-- dynamische Display-Animation handeln.</p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- @within WeatherEvent</p><p>-- @local</p><p>-- @usage MyEvent = WeatherEvent:New();</p><p>    return API.InstanceTable(self);</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/addoncastlestore.lua.html">
            <div class='doclink'>
                <div>AddOnCastleStore</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia AddOnCastleStore                                             # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Dieses Bundle stellt ein Burglager zur Verfügung, das sich ähnlich wie das</p><p>-- normale Lager verhält. Das Burglager ist von der Ausbaustufe der Burg</p><p>-- abhängig. Je weiter die Burg ausgebaut wird, desto höher ist das Limit.</p><p>-- Eine Ware wird dann im Burglager eingelagert, wenn das eingestellte Limit</p><p>-- der Ware im Lagerhaus erreicht wird.</p><p>-- Der Spieler kann das allgemeine Verhalten des Lagers für alle Waren wählen</p><p>-- und zusätzlich für einzelne Waren andere Verhalten bestimmen. Waren können</p><p>-- eingelagert und ausgelagert werden. Eingelagerte Waren können zusätzlich</p><p>-- gesperrt werden. Eine gesperrte Ware wird nicht wieder ausgelagert, auch</p><p>-- wenn Platz im Lager frei wird.</p><p>-- Muss ein Spieler einen Tribut aus dem lagerhaus begleichen, eine bestimmte</p><p>-- Menge an Waren erreichen oder die Kosten Zur aktivierung eines interaktien</p><p>-- Objektes bezahlen, werden die Güter im Burglager automatisch mit einbezogen,</p><p>-- wenn sie nicht gesperrt wurden.</p><p>-- Das wichtigste Auf einen Blick:</p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Erstellt ein Burglager für den angegebenen Spieler.</p><p>-- @param[type=number] _PlayerID ID des Spielers</p><p>-- @return[type=table] Burglager-Instanz</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.CastleStoreCreate(1);</p><p>function API.CastleStoreCreate(_PlayerID)</p><p>    if GUI then</p><p>        API.Bridge("API.CastleStoreCreate(" .._PlayerID.. ")");</p><p>        return;</p><p>    end</p><p>    return QSB.CastleStore:New(_PlayerID);</p><p>-- Zerstört das Burglager des angegebenen Spielers.</p><p>-- Alle Waren im Burglager werden dabei unwiederuflich gelöscht!</p><p>-- @param[type=number] _PlayerID ID des Spielers</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.CastleStoreDestroy(1)</p><p>function API.CastleStoreDestroy(_PlayerID)</p><p>    if GUI then</p><p>        API.Bridge("API.CastleStoreCreate(" .._PlayerID.. ")");</p><p>        return;</p><p>    end</p><p>    local Store = QSB.CastleStore:GetInstance(_PlayerID);</p><p>    if Store then</p><p>        Store:Dispose();</p><p>    end</p><p>-- Fügt dem Burglager des Spielers eine Menga an Waren hinzu.</p><p>-- @param[type=number] _PlayerID ID des Spielers</p><p>-- @param[type=number] _Good Typ der Ware</p><p>-- @param[type=number] _Amount Menge der Ware</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.CastleStoreAddGood(1, Goods.G_Wood, 50);</p><p>function API.CastleStoreAddGood(_PlayerID, _Good, _Amount)</p><p>    if GUI then</p><p>        API.Bridge("API.CastleStoreAddGood(" .._PlayerID.. "," .._Good.. "," .._Amount.. ")");</p><p>        return;</p><p>    end</p><p>    local Store = QSB.CastleStore:GetInstance(_PlayerID);</p><p>    if Store then</p><p>        Store:Add(_Good, _Amount);</p><p>    end</p><p>-- Entfernt eine Menge von Waren aus dem Burglager des Spielers.</p><p>-- @param[type=number] _PlayerID ID des Spielers</p><p>-- @param[type=number] _Good Typ der Ware</p><p>-- @param[type=number] _Amount Menge der Ware</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.CastleStoreRemoveGood(1, Goods.G_Iron, 15);</p><p>function API.CastleStoreRemoveGood(_PlayerID, _Good, _Amount)</p><p>    if GUI then</p><p>        API.Bridge("API.CastleStoreRemoveGood(" .._PlayerID.. "," .._Good.. "," .._Amount.. ")");</p><p>        return;</p><p>    end</p><p>    local Store = QSB.CastleStore:GetInstance(_PlayerID);</p><p>    if Store then</p><p>        Store:Remove(_Good, _Amount);</p><p>    end</p><p>-- Gibt die Menge an Waren des Typs im Burglager des Spielers zurück.</p><p>-- @param[type=number] _PlayerID ID des Spielers</p><p>-- @param[type=number] _Good Typ der Ware</p><p>-- @return[type=number] Menge an Waren</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- local Amount = API.CastleStoreCountGood(1, Goods.G_Milk);</p><p>function API.CastleStoreGetGoodAmount(_PlayerID, _Good)</p><p>    if GUI then</p><p>        return QSB.CastleStore:GetAmount(_PlayerID, _Good);</p><p>    end</p><p>    local Store = QSB.CastleStore:GetInstance(_PlayerID);</p><p>    if Store then</p><p>        return Store:GetAmount(_Good);</p><p>    end</p><p>    return 0;</p><p>-- Gibt die Gesamtmenge aller Waren im Burglager zurück.</p><p>-- @param[type=number] _PlayerID ID des Spielers</p><p>-- @return[type=number] Menge an Waren</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- local Amount = API.CastleStoreTotalAmount(1);</p><p>function API.CastleStoreGetTotalAmount(_PlayerID)</p><p>    if GUI then</p><p>        return QSB.CastleStore:GetTotalAmount(_PlayerID);</p><p>    end</p><p>    local Store = QSB.CastleStore:GetInstance(_PlayerID);</p><p>    if Store then</p><p>        return Store:GetTotalAmount();</p><p>    end</p><p>    return 0;</p><p>-- Gibt die maximale Kapazität des Burglagers zurück.</p><p>-- @param[type=number] _PlayerID ID des Spielers</p><p>-- @return[type=number] Große des Lagers</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- local Size = API.CastleStoreGetSize(1);</p><p>function API.CastleStoreGetSize(_PlayerID)</p><p>    if GUI then</p><p>        return QSB.CastleStore:GetLimit(_PlayerID);</p><p>    end</p><p>    local Store = QSB.CastleStore:GetInstance(_PlayerID);</p><p>    if Store then</p><p>        return Store:GetLimit();</p><p>    end</p><p>    return 0;</p><p>-- Setzt die Basiskapazität des Burglagers.</p><p>-- Die Basiskapazität ist das Limit der ersten Stufe der Burg. Mit jedem</p><p>-- Ausbau wird dieser Wert verdoppelt.</p><p>-- @param[type=number] _PlayerID ID des Spielers</p><p>-- @param[type=number] _Capacity Basisgröße des Lagers</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- -- - [150, 300, 600, 1200]</p><p>-- API.CastleStoreSetBaseCapacity(1, 150);</p><p>function API.CastleStoreSetBaseCapacity(_PlayerID, _Capacity)</p><p>    if GUI then</p><p>        API.Bridge("API.CastleStoreSetBaseCapacity(" .._PlayerID.. "," .._Capacity.. ")");</p><p>        return;</p><p>    end</p><p>    local Store = QSB.CastleStore:GetInstance(_PlayerID);</p><p>    if Store then</p><p>        Store:SetStorageLimit(_Capacity);</p><p>    end</p><p>-- Setzt die Obergrenze ab der ins Burglager ausgelagert wird.</p><p>-- @param[type=number] _PlayerID ID des Spielers</p><p>-- @param[type=number] _Good     Warentyp</p><p>-- @param[type=number] _Limit    Obergrenze</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.CastleStoreSetOutsourceBoundary(1, Goods.G_Milk, 50);</p><p>function API.CastleStoreSetOutsourceBoundary(_PlayerID, _Good, _Limit)</p><p>    if GUI then</p><p>        API.Bridge("API.CastleStoreOutsourceBoundary(" .._PlayerID.. "," .._Good.. "," .._Limit.. ")");</p><p>        return;</p><p>    end</p><p>    local Store = QSB.CastleStore:GetInstance(_PlayerID);</p><p>    if Store then</p><p>        Stores:SetUperLimitInStorehouseForGoodType(_Good, _Limit)</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {</p><p>        Data = {</p><p>            UpdateCastleStore = false,</p><p>            CastleStoreObjects = {},</p><p>        },</p><p>        CastleStore = {</p><p>            Data = {</p><p>                CapacityBase = 75,</p><p>                Goods = {</p><p>                    -- [Ware] = {Menge, Einlager-Flag, Gesperrt-Flag, Untergrenze}</p><p>                    [Goods.G_Wood]      = {0, true, false, 35},</p><p>                    [Goods.G_Stone]     = {0, true, false, 35},</p><p>                    [Goods.G_Iron]      = {0, true, false, 35},</p><p>                    [Goods.G_Carcass]   = {0, true, false, 15},</p><p>                    [Goods.G_Grain]     = {0, true, false, 15},</p><p>                    [Goods.G_RawFish]   = {0, true, false, 15},</p><p>                    [Goods.G_Milk]      = {0, true, false, 15},</p><p>                    [Goods.G_Herb]      = {0, true, false, 15},</p><p>                    [Goods.G_Wool]      = {0, true, false, 15},</p><p>                    [Goods.G_Honeycomb] = {0, true, false, 15},</p><p>                }</p><p>            },</p><p>        },</p><p>    },</p><p>    Local = {</p><p>        Data = {},</p><p>        CastleStore = {</p><p>            Data = {}</p><p>        },</p><p>        Description = {</p><p>            ShowCastle = {</p><p>                Text = {</p><p>                    de = "Finanzansicht",</p><p>                    en = "Financial view",</p><p>                },</p><p>            },</p><p>            ShowCastleStore = {</p><p>                Text = {</p><p>                    de = "Lageransicht",</p><p>                    en = "Storeage view",</p><p>                },</p><p>            },</p><p>            GoodButtonDisabled = {</p><p>                Text = {</p><p>                    de = "Diese Ware wird nicht angenommen.",</p><p>                    en = "This good will not be stored.",</p><p>                },</p><p>            },</p><p>            CityTab = {</p><p>                Title = {</p><p>                    de = "Güter verwaren",</p><p>                    en = "Keep goods",</p><p>                },</p><p>                Text = {</p><p>                    de = "[UMSCHALT + N]{cr}- Lagert Waren im Burglager ein {cr}- Waren verbleiben auch im Lager, wenn Platz vorhanden ist",</p><p>                    en = "[SHIFT + N]{cr}- Stores goods inside the vault {cr}- Goods also remain in the warehouse when space is available",</p><p>                },</p><p>            },</p><p>            StorehouseTab = {</p><p>                Title = {</p><p>                    de = "Güter zwischenlagern",</p><p>                    en = "Store in vault",</p><p>                },</p><p>                Text = {</p><p>                    de = "[UMSCHALT + B]{cr}- Lagert Waren im Burglager ein {cr}- Lagert waren wieder aus, sobald Platz frei wird",</p><p>                    en = "[SHIFT + B]{cr}- Stores goods inside the vault {cr}- Allows to extrac goods as soon as space becomes available",</p><p>                },</p><p>            },</p><p>            MultiTab = {</p><p>                Title = {</p><p>                    de = "Lager räumen",</p><p>                    en = "Clear store",</p><p>                },</p><p>                Text = {</p><p>                    de = "[UMSCHALT + M]{cr}- Lagert alle Waren aus {cr}- Benötigt Platz im Lagerhaus",</p><p>                    en = "[Shift + M]{cr}- Removes all goods {cr}- Requires space in the storehouse",</p><p>                },</p><p>            },</p><p>        },</p><p>    },</p><p>-- Global Script ---------------------------------------------------------------</p><p>-- Initalisiert das Bundle im globalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    QSB.CastleStore = self.CastleStore;</p><p>    self:OverwriteGameFunctions()</p><p>    API.AddSaveGameAction(self.OnSaveGameLoaded);</p><p>-- Erzeugt ein neues Burglager-Objekt und gibt es zurück.</p><p>-- </p><p>-- @param _PlayerID [number] PlayerID des Spielers</p><p>-- @return [table] QSB.CastleStore Instanz</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>-- @usage</p><p>-- -- Erstellt ein Burglager für Spieler 1</p><p>-- local Store = QSB.CastleStore:new(1);</p><p>    assert(self == AddOnCastleStore.Global.CastleStore, "Can not be used from instance!");</p><p>    local Store = API.InstanceTable(self);</p><p>    Store.Data.PlayerID = _PlayerID;</p><p>    AddOnCastleStore.Global.Data.CastleStoreObjects[_PlayerID] = Store;</p><p>    if not self.Data.UpdateCastleStore then</p><p>        self.Data.UpdateCastleStore = true;</p><p>        StartSimpleHiResJobEx(AddOnCastleStore.Global.CastleStore.UpdateStores);</p><p>    end</p><p>    Logic.ExecuteInLuaLocalState([[</p><p>        QSB.CastleStore:CreateStore(]] ..Store.Data.PlayerID.. [[);</p><p>    ]])</p><p>    return Store;</p><p>-- Gibt die Burglagerinstanz für den Spieler zurück.</p><p>-- Wurde kein Burglager für den Spieler erstellt, wird nil zurückgegeben.</p><p>-- </p><p>-- @param _PlayerID [number] PlayerID des Spielers</p><p>-- @return [table] QSB.CastleStore Instanz</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>-- @usage</p><p>-- -- Ermittelt das Burglager von Spieler 1</p><p>-- local Store = QSB.CastleStore:GetInstance(1);</p><p>    assert(self == AddOnCastleStore.Global.CastleStore, "Can not be used from instance!");</p><p>    return AddOnCastleStore.Global.Data.CastleStoreObjects[_PlayerID];</p><p>-- Gibt die Menge an Waren des Spielers zurück, eingeschlossen</p><p>-- der Waren im Burglager. Hat der Spieler kein Burglager, wird</p><p>-- nur die Menge im Lagerhaus zurückgegeben.</p><p>-- </p><p>-- @param _Good [number] Warentyp</p><p>-- @param _PlayerIDvID des Spielers</p><p>-- @return [number] Warenmenge mit Menge in Burglager</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>-- @usage</p><p>-- -- Menge an Holz in beiden Lagern</p><p>-- local WoodAmount = QSB.CastleStore:GetGoodAmountWithCastleStore(Goods.G_Wood, 1);</p><p>    assert(self == AddOnCastleStore.Global.CastleStore, "Can not be used from instance!");</p><p>    local CastleStore = self:GetInstance(_PlayerID);</p><p>    local Amount = GetPlayerGoodsInSettlement(_Good, _PlayerID, true);</p><p>    if CastleStore ~= nil and _Good ~= Goods.G_Gold and Logic.GetGoodCategoryForGoodType(_Good) == GoodCategories.GC_Resource then</p><p>        Amount = Amount + CastleStore:GetAmount(_Good);</p><p>    end</p><p>    return Amount;</p><p>-- Zerstört das Burglager.</p><p>-- Die Burg wird dabei natürlich nicht zerstört.</p><p>-- </p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>-- @usage</p><p>-- -- Löschen des Burglagers von Spieler 1 ohne Referenz</p><p>-- QSB.CastleStore:GetInstance(1):Dispose();</p><p>-- -- Loschen mit Referenzvariable (z.B. Store)</p><p>-- Store:Dispose();</p><p>    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");</p><p>    Logic.ExecuteInLuaLocalState([[</p><p>        QSB.CastleStore:DeleteStore(]] ..self.Data.PlayerID.. [[);</p><p>    ]])</p><p>    AddOnCastleStore.Global.Data.CastleStoreObjects[self.Data.PlayerID] = nil;</p><p>-- Setzt die Obergrenze für eine Ware, ab der ins Burglager</p><p>-- ausgelagert wird.</p><p>-- </p><p>-- @param _Good [number] Warentyp</p><p>-- @param _Limit [number] Obergrenze</p><p>-- @return self</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");</p><p>    self.Data.Goods[_Good][4] = _Limit;</p><p>    Logic.ExecuteInLuaLocalState([[</p><p>        AddOnCastleStore.Local.CastleStore.Data[]] ..self.Data.PlayerID.. [[].Goods[]] .._Good.. [[][4] = ]] .._Limit.. [[</p><p>    ]])</p><p>    return self;</p><p>-- Setzt den Basiswert für die maximale Kapazität des Burglagers.</p><p>-- Der Basiswert dient zur Berechnung der Kapazität für die Ausbaustufen und</p><p>-- muss durch 2 teilbar sein.</p><p>-- Ist also der Basiswert 150, ergibt sich daraus:</p><p>-- </p><p>-- 150, 300, 600, 1200</p><p>-- </p><p>-- </p><p>-- @param _Limit [number] Maximale Kapazität</p><p>-- @return self</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>-- @usage</p><p>-- -- Basiswert auf 100 setzen.</p><p>-- -- - [100, 200, 400, 800]</p><p>-- QSB.CastleStore:GetInstance(1):SetStorageLimit(100);</p><p>    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");</p><p>    self.Data.CapacityBase = math.floor(_Limit/2);</p><p>    Logic.ExecuteInLuaLocalState([[</p><p>        AddOnCastleStore.Local.CastleStore.Data[]] ..self.Data.PlayerID.. [[].CapacityBase = ]] ..math.floor(_Limit/2).. [[</p><p>    ]])</p><p>    return self;</p><p>-- Gibt die Menge an Waren des Typs im Burglager zurück.</p><p>-- </p><p>-- @param _Good [number] Warentyp</p><p>-- @return [number] Menge an Waren im Burglager</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");</p><p>    if self.Data.Goods[_Good] then</p><p>        return self.Data.Goods[_Good][1];</p><p>    end</p><p>    return 0;</p><p>-- Gibt die Gesamtmenge aller Waren im Burglager zurück.</p><p>-- </p><p>-- @return [number] Gesamtmenge aller Waren</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");</p><p>    local TotalAmount = 0;</p><p>    for k, v in pairs(self.Data.Goods) do</p><p>        TotalAmount = TotalAmount + v[1];</p><p>    end</p><p>    return TotalAmount;</p><p>-- Gibt das aktuelle Lagerlimit zurück.</p><p>-- </p><p>-- @return [number] Lagerlimt in der Burg</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");</p><p>    local Level = 0;</p><p>    local Headquarters = Logic.GetHeadquarters(self.Data.PlayerID);</p><p>    if Headquarters ~= 0 then</p><p>        Level = Logic.GetUpgradeLevel(Headquarters);</p><p>    end</p><p>    local Capacity = self.Data.CapacityBase;</p><p>    for i= 1, (Level+1), 1 do</p><p>        Capacity = Capacity * 2;</p><p>    end</p><p>    return Capacity;</p><p>-- Gibt zurück, ob die Ware akzeptiert wird.</p><p>-- </p><p>-- @param _Good [number] Warentyp</p><p>-- @return [boolean] Ware wird akzeptiert</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");</p><p>    return self.Data.Goods[_Good][2] == true;</p><p>-- Setzt, ob die Ware akzeptiert wird.</p><p>-- </p><p>-- @param _Good [number] Watentyp</p><p>-- @param _Flag [boolean] Akzeptanz-Flag</p><p>-- @return self</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");</p><p>    self.Data.Goods[_Good][2] = _Flag == true;</p><p>    Logic.ExecuteInLuaLocalState([[</p><p>        QSB.CastleStore:SetAccepted(</p><p>            ]] ..self.Data.PlayerID.. [[, ]] .._Good.. [[, ]] ..tostring(_Flag == true).. [[</p><p>        )</p><p>    ]])</p><p>    return self;</p><p>-- Gibt zurück, ob die Ware gesperrt ist.</p><p>-- </p><p>-- @param _Good [number] Warentyp</p><p>-- @return [boolean] Ware ist gesperrt</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");</p><p>    return self.Data.Goods[_Good][3] == true;</p><p>-- Setzt ob die Ware gesperrt ist, also nicht ausgelagert wird.</p><p>-- </p><p>-- @param _Good [number] Watentyp</p><p>-- @param _Flag [boolean] Akzeptanz-Flag</p><p>-- @return self</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");</p><p>    self.Data.Goods[_Good][3] = _Flag == true;</p><p>    Logic.ExecuteInLuaLocalState([[</p><p>        QSB.CastleStore:SetLocked(</p><p>            ]] ..self.Data.PlayerID.. [[, ]] .._Good.. [[, ]] ..tostring(_Flag == true).. [[</p><p>        )</p><p>    ]])</p><p>    return self;</p><p>-- Setzt den Modus "Zwischenlagerung", als ob der Tab geklickt wird.</p><p>-- </p><p>-- @return self</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");</p><p>    Logic.ExecuteInLocalLuaState([[</p><p>        QSB.CastleStore.OnStorehouseTabClicked(QSB.CastleStore, ]] ..self.Data.PlayerID.. [[)</p><p>    ]])</p><p>    return self;</p><p>-- Setzt den Modus "Verwahrung", als ob der Tab geklickt wird.</p><p>-- </p><p>-- @return self</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");</p><p>    Logic.ExecuteInLocalLuaState([[</p><p>        QSB.CastleStore.OnCityTabClicked(QSB.CastleStore, ]] ..self.Data.PlayerID.. [[)</p><p>    ]])</p><p>    return self;</p><p>-- Setzt den Modus "Auslagerung", als ob der Tab geklickt wird.</p><p>-- </p><p>-- @return self</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");</p><p>    Logic.ExecuteInLocalLuaState([[</p><p>        QSB.CastleStore.OnMultiTabClicked(QSB.CastleStore, ]] ..self.Data.PlayerID.. [[)</p><p>    ]])</p><p>    return self;</p><p>-- Lagert eine Menge von Waren im Burglager ein.</p><p>-- Die Ware wird eingelagert wenn die Ware angenommen wird und noch</p><p>-- Platz im Burglager vorhanden ist.</p><p>-- </p><p>-- @param _Good [number] Watentyp</p><p>-- @param _Amount [number] Menge</p><p>-- @return self</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");</p><p>    if self:IsGoodAccepted(_Good) then</p><p>        if self:GetLimit() = self:GetTotalAmount() + _Amount then</p><p>            local Level = Logic.GetUpgradeLevel(Logic.GetHeadquarters(self.Data.PlayerID));</p><p>            if GetPlayerResources(_Good, self.Data.PlayerID)  (self.Data.Goods[_Good][4] * (Level+1)) then</p><p>                AddGood(_Good, _Amount * (-1), self.Data.PlayerID);</p><p>                self.Data.Goods[_Good][1] = self.Data.Goods[_Good][1] + _Amount;</p><p>                Logic.ExecuteInLuaLocalState([[</p><p>                    QSB.CastleStore:SetAmount(</p><p>                        ]] ..self.Data.PlayerID.. [[, ]] .._Good.. [[, ]] ..self.Data.Goods[_Good][1].. [[</p><p>                    )</p><p>                ]]);</p><p>            end</p><p>        end</p><p>    end</p><p>    return self;</p><p>-- Lagert eine Menge von Waren aus dem Burglager aus.</p><p>-- </p><p>-- </p><p>-- @param _Good [number] Watentyp</p><p>-- @param _Amount [number] Menge</p><p>-- @return self</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");</p><p>    local Level = Logic.GetUpgradeLevel(Logic.GetHeadquarters(self.Data.PlayerID));</p><p>    if Logic.GetPlayerUnreservedStorehouseSpace(self.Data.PlayerID) = _Amount then</p><p>        if self:GetAmount(_Good) = _Amount then</p><p>            AddGood(_Good, _Amount, self.Data.PlayerID);</p><p>            self.Data.Goods[_Good][1] = self.Data.Goods[_Good][1] - _Amount;</p><p>            Logic.ExecuteInLuaLocalState([[</p><p>                QSB.CastleStore:SetAmount(</p><p>                    ]] ..self.Data.PlayerID.. [[, ]] .._Good.. [[, ]] ..self.Data.Goods[_Good][1].. [[</p><p>                )</p><p>            ]]);</p><p>        end</p><p>    end</p><p>    return self;</p><p>-- Fügt eine Menge an Waren dem Burglager hinzu, solange noch</p><p>-- Platz vorhanden ist.</p><p>-- </p><p>-- @param _Good [number] Watentyp</p><p>-- @param _Amount [number] Menge</p><p>-- @return self</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");</p><p>    for i= 1, _Amount, 1 do</p><p>        if self:GetLimit()  self:GetTotalAmount() then</p><p>            self.Data.Goods[_Good][1] = self.Data.Goods[_Good][1] + 1;</p><p>        end</p><p>    end</p><p>    Logic.ExecuteInLuaLocalState([[</p><p>        QSB.CastleStore:SetAmount(</p><p>            ]] ..self.Data.PlayerID.. [[, ]] .._Good.. [[, ]] ..self.Data.Goods[_Good][1].. [[</p><p>        )</p><p>    ]]);</p><p>    return self;</p><p>-- Entfernt eine Menge an Waren aus dem Burglager ohne sie ins</p><p>-- Lagerhaus zu legen.</p><p>-- </p><p>-- @param _Good [number] Watentyp</p><p>-- @param _Amount [number] Menge</p><p>-- @return self</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");</p><p>    if self:GetAmount(_Good)  0 then</p><p>        local ToRemove = (_Amount = self:GetAmount(_Good) and _Amount) or self:GetAmount(_Good);</p><p>        self.Data.Goods[_Good][1] = self.Data.Goods[_Good][1] - ToRemove;</p><p>        Logic.ExecuteInLuaLocalState([[</p><p>            QSB.CastleStore:SetAmount(</p><p>                ]] ..self.Data.PlayerID.. [[, ]] .._Good.. [[, ]] ..self.Data.Goods[_Good][1].. [[</p><p>            )</p><p>        ]]);</p><p>    end</p><p>    return self;</p><p>-- Aktualisiert die Waren im Lager und im Burglager.</p><p>-- </p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self == nil, "This method is only procedural!");</p><p>    for k, v in pairs(AddOnCastleStore.Global.Data.CastleStoreObjects) do</p><p>        if v ~= nil and Logic.GetStoreHouse(k) ~= 0 then</p><p>            local Level = Logic.GetUpgradeLevel(Logic.GetHeadquarters(v.Data.PlayerID));</p><p>            for kk, vv in pairs(v.Data.Goods) do</p><p>                if vv ~= nil then</p><p>                    -- Ware wird angenommen</p><p>                    if vv[2] == true then</p><p>                        local AmountInStore  = GetPlayerResources(kk, v.Data.PlayerID)</p><p>                        local AmountInCastle = v:GetAmount(kk)</p><p>                        -- Auslagern, wenn möglich</p><p>                        if AmountInStore  (v.Data.Goods[kk][4] * (Level+1)) then</p><p>                            if vv[3] == false then</p><p>                                v:Outsource(kk, 1);</p><p>                            end</p><p>                        -- Einlagern, falls möglich</p><p>                        else</p><p>                            v:Store(kk, 1);</p><p>                        end</p><p>                    -- Ware ist gebannt</p><p>                    else</p><p>                        v:Outsource(kk, 1);</p><p>                    end</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>-- Wirt ausgeführt, nachdem ein Spielstand geladen wurde. Diese Funktion Stellt</p><p>-- alle nicht persistenten Änderungen wieder her.</p><p>-- @within Internal</p><p>-- @local</p><p>    API.Bridge("AddOnCastleStore.Local:OverwriteGetStringTableText()")</p><p>    API.Bridge("AddOnCastleStore.Local.CastleStore:ActivateHotkeys()")</p><p>-- Überschreibt die globalen Spielfunktionen, die mit dem Burglager in</p><p>-- Konfilckt stehen.</p><p>-- @within Internal</p><p>-- @local</p><p>    QuestTemplate.IsObjectiveCompleted_Orig_QSB_CastleStore = QuestTemplate.IsObjectiveCompleted;</p><p>    QuestTemplate.IsObjectiveCompleted = function(self, objective)</p><p>        local objectiveType = objective.Type;</p><p>        local data = objective.Data;</p><p>        if objective.Completed ~= nil then</p><p>            return objective.Completed;</p><p>        end</p><p>        if objectiveType == Objective.Produce then</p><p>            local GoodAmount = GetPlayerGoodsInSettlement(data[1], self.ReceivingPlayer, true);</p><p>            local CastleStore = QSB.CastleStore:GetInstance(self.ReceivingPlayer);</p><p>            if CastleStore and Logic.GetGoodCategoryForGoodType(data[1]) == GoodCategories.GC_Resource then</p><p>                GoodAmount = GoodAmount + CastleStore:GetAmount(data[1]);</p><p>            end</p><p>            if (not data[3] and GoodAmount = data[2]) or (data[3] and GoodAmount  data[2]) then</p><p>                objective.Completed = true;</p><p>            end</p><p>        else</p><p>            return QuestTemplate.IsObjectiveCompleted_Orig_QSB_CastleStore(self, objective);</p><p>        end</p><p>    end</p><p>    QuestTemplate.SendGoods = function(self)</p><p>        for i=1, self.Objectives[0] do</p><p>            if self.Objectives[i].Type == Objective.Deliver then</p><p>                if self.Objectives[i].Data[3] == nil then</p><p>                    local goodType = self.Objectives[i].Data[1]</p><p>                    local goodQuantity = self.Objectives[i].Data[2]</p><p>                    local amount = QSB.CastleStore:GetGoodAmountWithCastleStore(goodType, self.ReceivingPlayer, true);</p><p>                    if amount = goodQuantity then</p><p>                        local Sender = self.ReceivingPlayer</p><p>                        local Target = self.Objectives[i].Data[6] and self.Objectives[i].Data[6] or self.SendingPlayer</p><p>                        local expectedMerchant = {}</p><p>                        expectedMerchant.Good = goodType</p><p>                        expectedMerchant.Amount = goodQuantity</p><p>                        expectedMerchant.PlayerID = Target</p><p>                        expectedMerchant.ID = nil</p><p>                        self.Objectives[i].Data[5] = expectedMerchant</p><p>                        self.Objectives[i].Data[3] = 1</p><p>                        QuestMerchants[#QuestMerchants+1] = expectedMerchant</p><p>                        if goodType == Goods.G_Gold then</p><p>                            local BuildingID = Logic.GetHeadquarters(Sender)</p><p>                            if BuildingID == 0 then</p><p>                                BuildingID = Logic.GetStoreHouse(Sender)</p><p>                            end</p><p>                            self.Objectives[i].Data[3] = Logic.CreateEntityAtBuilding(Entities.U_GoldCart, BuildingID, 0, Target)</p><p>                            Logic.HireMerchant(self.Objectives[i].Data[3], Target, goodType, goodQuantity, self.ReceivingPlayer)</p><p>                            Logic.RemoveGoodFromStock(BuildingID,goodType,goodQuantity)</p><p>                            if MapCallback_DeliverCartSpawned then</p><p>                                MapCallback_DeliverCartSpawned( self, self.Objectives[i].Data[3], goodType )</p><p>                            end</p><p>                        elseif goodType == Goods.G_Water then</p><p>                            local BuildingID = Logic.GetMarketplace(Sender)</p><p>                            self.Objectives[i].Data[3] = Logic.CreateEntityAtBuilding(Entities.U_Marketer, BuildingID, 0, Target)</p><p>                            Logic.HireMerchant(self.Objectives[i].Data[3], Target, goodType, goodQuantity, self.ReceivingPlayer)</p><p>                            Logic.RemoveGoodFromStock(BuildingID,goodType,goodQuantity)</p><p>                            if MapCallback_DeliverCartSpawned then</p><p>                                MapCallback_DeliverCartSpawned( self, self.Objectives[i].Data[3], goodType )</p><p>                            end</p><p>                        else</p><p>                            if Logic.GetGoodCategoryForGoodType(goodType) == GoodCategories.GC_Resource then</p><p>                                local StorehouseID = Logic.GetStoreHouse(Target)</p><p>                                local NumberOfGoodTypes = Logic.GetNumberOfGoodTypesOnOutStock(StorehouseID)</p><p>                                if NumberOfGoodTypes ~= nil then</p><p>                                    for j = 0, NumberOfGoodTypes-1 do</p><p>                                        local StoreHouseGoodType = Logic.GetGoodTypeOnOutStockByIndex(StorehouseID,j)</p><p>                                        local Amount = Logic.GetAmountOnOutStockByIndex(StorehouseID, j)</p><p>                                        if Amount = goodQuantity then</p><p>                                            Logic.RemoveGoodFromStock(StorehouseID, StoreHouseGoodType, goodQuantity, false)</p><p>                                        end</p><p>                                    end</p><p>                                end</p><p>                                local SenderStorehouse = Logic.GetStoreHouse(Sender);</p><p>                                local AmountInStorehouse = GetPlayerResources(goodType, Sender);</p><p>                                if AmountInStorehouse  goodQuantity then</p><p>                                    -- Entferne aus Lager</p><p>                                    local AmountDifference = goodQuantity - AmountInStorehouse;</p><p>                                    AddGood(goodType, AmountInStorehouse * (-1), Sender);</p><p>                                    -- Entferne aus Burg</p><p>                                    local StoreInstance = QSB.CastleStore:GetInstance(self.ReceivingPlayer);</p><p>                                    if StoreInstance then</p><p>                                        StoreInstance:Remove(goodType, AmountDifference);</p><p>                                    end</p><p>                                else</p><p>                                    -- Entferne aus Lager</p><p>                                    AddGood(goodType, goodQuantity * (-1), Sender);</p><p>                                end</p><p>                                self.Objectives[i].Data[3] = Logic.CreateEntityAtBuilding(Entities.U_ResourceMerchant, SenderStorehouse, 0, Target);</p><p>                                Logic.HireMerchant(self.Objectives[i].Data[3], Target, goodType, goodQuantity, self.ReceivingPlayer);</p><p>                            else</p><p>                                Logic.StartTradeGoodGathering(Sender, Target, goodType, goodQuantity, 0)</p><p>                            end</p><p>                        end</p><p>                    end</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>-- Local Script ----------------------------------------------------------------</p><p>-- Initalisiert das Bundle im lokalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    QSB.CastleStore = self.CastleStore;</p><p>    self:OverwriteGameFunctions();</p><p>    self:OverwriteGetStringTableText();</p><p>    self:OverwriteInteractiveObject();</p><p>-- Erzeugt eine neue lokale Referenz zum Burglager des Spielers.</p><p>-- </p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");</p><p>    local Store = {</p><p>        StoreMode = 1,</p><p>        CapacityBase = 75,</p><p>        Goods = {</p><p>            [Goods.G_Wood]      = {0, true, false, 35},</p><p>            [Goods.G_Stone]     = {0, true, false, 35},</p><p>            [Goods.G_Iron]      = {0, true, false, 35},</p><p>            [Goods.G_Carcass]   = {0, true, false, 15},</p><p>            [Goods.G_Grain]     = {0, true, false, 15},</p><p>            [Goods.G_RawFish]   = {0, true, false, 15},</p><p>            [Goods.G_Milk]      = {0, true, false, 15},</p><p>            [Goods.G_Herb]      = {0, true, false, 15},</p><p>            [Goods.G_Wool]      = {0, true, false, 15},</p><p>            [Goods.G_Honeycomb] = {0, true, false, 15},</p><p>        }</p><p>    }</p><p>    self.Data[_PlayerID] = Store;</p><p>    </p><p>    self:ActivateHotkeys();</p><p>    self:DescribeHotkeys();</p><p>-- Entfernt eine lokale Referenz auf ein Burglager des Spielers.</p><p>-- </p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");</p><p>    self.Data[_PlayerID] = nil;</p><p>-- Gibt die Menge an Waren des Typs zurück.</p><p>-- </p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @param _Good [number] Warentyp</p><p>-- @return [number] Menge an Waren</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");</p><p>    if not self:HasCastleStore(_PlayerID) or not self.Data[_PlayerID].Goods[_Good] then</p><p>        return 0;</p><p>    end</p><p>    return self.Data[_PlayerID].Goods[_Good][1];</p><p>-- Gibt die Menge an Waren des Spielers zurück, eingeschlossen</p><p>-- der Waren im Burglager. Hat der Spieler kein Burglager, wird</p><p>-- nur die Menge im Lagerhaus zurückgegeben.</p><p>-- </p><p>-- @param _Good [number] Warentyp</p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @return [number] Menge an Waren</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");</p><p>    local Amount = GetPlayerGoodsInSettlement(_Good, _PlayerID, true);</p><p>    if self:HasCastleStore(_PlayerID) then</p><p>        if _Good ~= Goods.G_Gold and Logic.GetGoodCategoryForGoodType(_Good) == GoodCategories.GC_Resource then</p><p>            Amount = Amount + self:GetAmount(_PlayerID, _Good);</p><p>        end</p><p>    end</p><p>    return Amount;</p><p>-- Gibt die Gesamtmenge aller Waren im Burglager zurück.</p><p>-- </p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @return [number] Absolute Menge im Burglager</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");</p><p>    if not self:HasCastleStore(_PlayerID) then</p><p>        return 0;</p><p>    end</p><p>    local TotalAmount = 0;</p><p>    for k, v in pairs(self.Data[_PlayerID].Goods) do</p><p>        TotalAmount = TotalAmount + v[1];</p><p>    end</p><p>    return TotalAmount;</p><p>-- Ändert die Menge an Waren des Typs.</p><p>-- </p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @param _Good [number] Warentyp</p><p>-- @param _Amount [number] Warenmenge</p><p>-- @return self</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");</p><p>    if not self:HasCastleStore(_PlayerID) or not self.Data[_PlayerID].Goods[_Good] then</p><p>        return;</p><p>    end</p><p>    self.Data[_PlayerID].Goods[_Good][1] = _Amount;</p><p>    return self;</p><p>-- Gibt zurück, ob die Ware des Typs akzeptiert wird.</p><p>-- </p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @param _Good [number] Warentyp</p><p>-- @return [boolean] Ware wird angenommen</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");</p><p>    if not self:HasCastleStore(_PlayerID) or not self.Data[_PlayerID].Goods[_Good] then</p><p>        return false;</p><p>    end</p><p>    return self.Data[_PlayerID].Goods[_Good][2] == true;</p><p>-- Setzt eine Ware als akzeptiert.</p><p>-- </p><p>-- @param _PlayerIDvID des Spielers</p><p>-- @param _Good [number] Warentyp</p><p>-- @param _Flag [boolean] Akzeptanz-Flag</p><p>-- @return self</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");</p><p>    if self:HasCastleStore(_PlayerID) and self.Data[_PlayerID].Goods[_Good] then</p><p>        self.Data[_PlayerID].Goods[_Good][2] = _Flag == true;</p><p>    end</p><p>    return self;</p><p>-- Gibt zurück, ob die Ware des Typs gesperrt ist.</p><p>-- </p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @param _Good [number] Warentyp</p><p>-- @return [boolean] Ware ist gesperrt</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");</p><p>    if not self:HasCastleStore(_PlayerID) or not self.Data[_PlayerID].Goods[_Good] then</p><p>        return true;</p><p>    end</p><p>    return self.Data[_PlayerID].Goods[_Good][3] == true;</p><p>-- Setzt eine Ware als gesperrt.</p><p>-- </p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @param _Good [number] Warentyp</p><p>-- @param _Flag [boolean] Akzeptanz-Flag</p><p>-- @return self</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");</p><p>    if self:HasCastleStore(_PlayerID) and self.Data[_PlayerID].Goods[_Good] then</p><p>        self.Data[_PlayerID].Goods[_Good][3] = _Flag == true;</p><p>    end</p><p>    return self;</p><p>-- Gibt zurück, ob der Spieler ein Burglager hat.</p><p>-- </p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @return [boolean] Spieler hat ein Burglager</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");</p><p>    return self.Data[_PlayerID] ~= nil;</p><p>-- Gibt die Referenz des Burglagers des Spielers zurück.</p><p>-- </p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @return [table] Instanz des Burglagers</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");</p><p>    return self.Data[_PlayerID];</p><p>-- Gibt das aktuelle Lagerlimit des Burglagers zurück.</p><p>-- </p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");</p><p>    local Level = 0;</p><p>    local Headquarters = Logic.GetHeadquarters(_PlayerID);</p><p>    if Headquarters ~= 0 then</p><p>        Level = Logic.GetUpgradeLevel(Headquarters);</p><p>    end</p><p>    local Capacity = self.Data[_PlayerID].CapacityBase;</p><p>    for i= 1, (Level+1), 1 do</p><p>        Capacity = Capacity * 2;</p><p>    end</p><p>    return Capacity;</p><p>-- "Waren einlagern" wurde geklickt.</p><p>-- </p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");</p><p>    self.Data[_PlayerID].StoreMode = 1;</p><p>    self:UpdateBehaviorTabs(_PlayerID);</p><p>    GUI.SendScriptCommand([[</p><p>        local Store = QSB.CastleStore:GetInstance(]] .._PlayerID.. [[);</p><p>        for k, v in pairs(Store.Data.Goods) do</p><p>            Store:SetGoodAccepted(k, true);</p><p>            Store:SetGoodLocked(k, false);</p><p>        end</p><p>    ]]);</p><p>-- "Waren verwahren" wurde gedrückt.</p><p>-- </p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");</p><p>    self.Data[_PlayerID].StoreMode = 2;</p><p>    self:UpdateBehaviorTabs(_PlayerID);</p><p>    GUI.SendScriptCommand([[</p><p>        local Store = QSB.CastleStore:GetInstance(]] .._PlayerID.. [[);</p><p>        for k, v in pairs(Store.Data.Goods) do</p><p>            Store:SetGoodAccepted(k, true);</p><p>            Store:SetGoodLocked(k, true);</p><p>        end</p><p>    ]]);</p><p>-- "Lager räumen" wurde gedrückt.</p><p>-- </p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");</p><p>    self.Data[_PlayerID].StoreMode = 3;</p><p>    self:UpdateBehaviorTabs(_PlayerID);</p><p>    GUI.SendScriptCommand([[</p><p>        local Store = QSB.CastleStore:GetInstance(]] .._PlayerID.. [[);</p><p>        for k, v in pairs(Store.Data.Goods) do</p><p>            Store:SetGoodLocked(k, false);</p><p>            Store:SetGoodAccepted(k, false);</p><p>        end</p><p>    ]]);</p><p>-- Ein GoodType-Button wurde geklickt.</p><p>-- </p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @param _GoodType [number] Warentyp</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");</p><p>    if self:HasCastleStore(_PlayerID) then</p><p>        local CurrentWirgetID = XGUIEng.GetCurrentWidgetID();</p><p>        GUI.SendScriptCommand([[</p><p>            local Store = QSB.CastleStore:GetInstance(]] .._PlayerID.. [[);</p><p>            local Accepted = Store:IsGoodAccepted(]] .._GoodType.. [[)</p><p>            local Locked   = Store:IsGoodLocked(]] .._GoodType.. [[)</p><p>            </p><p>            if Accepted and not Locked then</p><p>                Store:SetGoodLocked(]] .._GoodType.. [[, true);</p><p>                Store:SetGoodAccepted(]] .._GoodType.. [[, true);</p><p>            elseif Accepted and Locked then</p><p>                Store:SetGoodLocked(]] .._GoodType.. [[, false);</p><p>                Store:SetGoodAccepted(]] .._GoodType.. [[, false);</p><p>            elseif not Accepted and not Locked then</p><p>                Store:SetGoodAccepted(]] .._GoodType.. [[, true);</p><p>            else</p><p>                Store:SetGoodLocked(]] .._GoodType.. [[, false);</p><p>                Store:SetGoodAccepted(]] .._GoodType.. [[, true);</p><p>            end</p><p>        ]]);</p><p>    end</p><p>-- Der Spieler wechselt zwischen den Ansichten in der Burg.</p><p>-- </p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");</p><p>    if self:HasCastleStore(_PlayerID) then</p><p>        QSB.CastleStore.ToggleStore();</p><p>    end</p><p>-- Aktualisiert das Burgmenü, sobald sich die Selektion ändert.</p><p>-- </p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");</p><p>    if self:HasCastleStore(_PlayerID) then</p><p>        local SelectedID = GUI.GetSelectedEntity();</p><p>        if Logic.GetHeadquarters(_PlayerID) == SelectedID then</p><p>            self:ShowCastleMenu();</p><p>        else</p><p>            self:RestoreStorehouseMenu();</p><p>        end</p><p>    end</p><p>-- Aktualisiert die Burglager-Tabs.</p><p>-- </p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");</p><p>    if not QSB.CastleStore:HasCastleStore(GUI.GetPlayerID()) then</p><p>        return;</p><p>    end</p><p>    XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/TabButtons", 0);</p><p>    if self.Data[_PlayerID].StoreMode == 1 then</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/TabButtons/StorehouseTabButtonUp", 1);</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/TabButtons/CityTabButtonDown", 1);</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/TabButtons/Tab03Down", 1);</p><p>    elseif self.Data[_PlayerID].StoreMode == 2 then</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/TabButtons/StorehouseTabButtonDown", 1);</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/TabButtons/CityTabButtonUp", 1);</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/TabButtons/Tab03Down", 1);</p><p>    else</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/TabButtons/StorehouseTabButtonDown", 1);</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/TabButtons/CityTabButtonDown", 1);</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/TabButtons/Tab03Up", 1);</p><p>    end</p><p>-- Aktualisiert die Mengenanzeige der Waren im Burglager.</p><p>-- </p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");</p><p>    if not self:HasCastleStore(_PlayerID) then</p><p>        return;</p><p>    end</p><p>    local MotherContainer  = "/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/InStorehouse/Goods";</p><p>    local WarningColor = "";</p><p>    if self:GetLimit(_PlayerID) == self:GetTotalAmount(_PlayerID) then</p><p>        WarningColor = "{@color:255,32,32,255}";</p><p>    end</p><p>    for k, v in pairs(self.Data[_PlayerID].Goods) do</p><p>        local GoodTypeName = Logic.GetGoodTypeName(k);</p><p>        local AmountWidget = MotherContainer.. "/" ..GoodTypeName.. "/Amount";</p><p>        local ButtonWidget = MotherContainer.. "/" ..GoodTypeName.. "/Button";</p><p>        local BGWidget = MotherContainer.. "/" ..GoodTypeName.. "/BG";</p><p>        XGUIEng.SetText(AmountWidget, "{center}" .. WarningColor .. v[1]);</p><p>        XGUIEng.DisableButton(ButtonWidget, 0)</p><p>        -- Ware ist gesperrt</p><p>        if self:IsAccepted(_PlayerID, k) and self:IsLocked(_PlayerID, k) then</p><p>            XGUIEng.SetMaterialColor(ButtonWidget, 0, 230, 180, 120, 255);</p><p>            XGUIEng.SetMaterialColor(ButtonWidget, 1, 230, 180, 120, 255);</p><p>            XGUIEng.SetMaterialColor(ButtonWidget, 7, 230, 180, 120, 255);</p><p>        -- Ware wird nicht angenommen</p><p>        elseif not self:IsAccepted(_PlayerID, k) and not self:IsLocked(_PlayerID, k) then</p><p>            XGUIEng.SetMaterialColor(ButtonWidget, 0, 190, 90, 90, 255);</p><p>            XGUIEng.SetMaterialColor(ButtonWidget, 1, 190, 90, 90, 255);</p><p>            XGUIEng.SetMaterialColor(ButtonWidget, 7, 190, 90, 90, 255);</p><p>        -- Ware wird eingelagert</p><p>        else</p><p>            XGUIEng.SetMaterialColor(ButtonWidget, 0, 255, 255, 255, 255);</p><p>            XGUIEng.SetMaterialColor(ButtonWidget, 1, 255, 255, 255, 255);</p><p>            XGUIEng.SetMaterialColor(ButtonWidget, 7, 255, 255, 255, 255);</p><p>        end</p><p>    end</p><p>-- Aktualisiert die Lagerauslastungsanzeige des Burglagers.</p><p>-- </p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");</p><p>    if not self:HasCastleStore(_PlayerID) then</p><p>        return;</p><p>    end</p><p>    local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();</p><p>    local PlayerID = GUI.GetPlayerID();</p><p>    local StorageUsed = QSB.CastleStore:GetTotalAmount(PlayerID);</p><p>    local StorageLimit = QSB.CastleStore:GetLimit(PlayerID);</p><p>    local StorageLimitText = XGUIEng.GetStringTableText("UI_Texts/StorageLimit_colon");</p><p>    local Text = "{center}" ..StorageLimitText.. " " ..StorageUsed.. "/" ..StorageLimit;</p><p>    XGUIEng.SetText(CurrentWidgetID, Text);</p><p>-- Wechselt zwischen der Finanzansicht und dem Burglager.</p><p>-- </p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self == nil, "This function is procedural!");</p><p>    if QSB.CastleStore:HasCastleStore(GUI.GetPlayerID()) then</p><p>        if Logic.GetHeadquarters(GUI.GetPlayerID()) == GUI.GetSelectedEntity() then</p><p>            if XGUIEng.IsWidgetShown("/InGame/Root/Normal/AlignBottomRight/Selection/Castle") == 1 then</p><p>                QSB.CastleStore.ShowCastleStoreMenu(QSB.CastleStore);</p><p>            else</p><p>                QSB.CastleStore.ShowCastleMenu(QSB.CastleStore);</p><p>            end</p><p>        end</p><p>    end</p><p>-- Stellt das normale Lagerhausmenü wieder her.</p><p>-- </p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/TabButtons", 1);</p><p>    XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/InCity/Goods", 1);</p><p>    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/InCity", 0);</p><p>    SetIcon("/InGame/Root/Normal/AlignBottomRight/DialogButtons/PlayerButtons/DestroyGoods", {16, 8});</p><p>    local MotherPath = "/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/TabButtons/";</p><p>    SetIcon(MotherPath.. "StorehouseTabButtonUp/up/B_StoreHouse", {3, 13});</p><p>    SetIcon(MotherPath.. "StorehouseTabButtonDown/down/B_StoreHouse", {3, 13});</p><p>    SetIcon(MotherPath.. "CityTabButtonUp/up/CityBuildingsNumber", {8, 1});</p><p>    SetIcon(MotherPath.. "TabButtons/CityTabButtonDown/down/CityBuildingsNumber", {8, 1});</p><p>    SetIcon(MotherPath.. "TabButtons/Tab03Up/up/B_Castle_ME", {3, 14});</p><p>    SetIcon(MotherPath.. "Tab03Down/down/B_Castle_ME", {3, 14});</p><p>    for k, v in ipairs {"G_Carcass", "G_Grain", "G_Milk", "G_RawFish", "G_Iron","G_Wood", "G_Stone", "G_Honeycomb", "G_Herb", "G_Wool"} do</p><p>        local MotherPath = "/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/InStorehouse/Goods/";</p><p>        XGUIEng.SetMaterialColor(MotherPath.. v.. "/Button", 0, 255, 255, 255, 255);</p><p>        XGUIEng.SetMaterialColor(MotherPath.. v.. "/Button", 1, 255, 255, 255, 255);</p><p>        XGUIEng.SetMaterialColor(MotherPath.. v.. "/Button", 7, 255, 255, 255, 255);</p><p>    end</p><p>-- Das normale Burgmenü wird angezeigt.</p><p>-- </p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    local MotherPath = "/InGame/Root/Normal/AlignBottomRight/";</p><p>    XGUIEng.ShowWidget(MotherPath.. "Selection/BGBig", 0)</p><p>    XGUIEng.ShowWidget(MotherPath.. "Selection/Storehouse", 0)</p><p>    XGUIEng.ShowWidget(MotherPath.. "Selection/BGSmall", 1)</p><p>    XGUIEng.ShowWidget(MotherPath.. "Selection/Castle", 1)</p><p>    if g_HideSoldierPayment ~= nil then</p><p>        XGUIEng.ShowWidget(MotherPath.. "Selection/Castle/Treasury/Payment", 0)</p><p>        XGUIEng.ShowWidget(MotherPath.. "Selection/Castle/LimitSoldiers", 0)</p><p>    end</p><p>    GUI_BuildingInfo.PaymentLevelSliderUpdate()</p><p>    GUI_BuildingInfo.TaxationLevelSliderUpdate()</p><p>    GUI_Trade.StorehouseSelected()</p><p>    local AnchorInfoForSmallX, AnchorInfoForSmallY = XGUIEng.GetWidgetLocalPosition(MotherPath.. "Selection/AnchorInfoForSmall")</p><p>    XGUIEng.SetWidgetLocalPosition(MotherPath.. "Selection/Info", AnchorInfoForSmallX, AnchorInfoForSmallY)</p><p>    XGUIEng.ShowWidget(MotherPath.. "DialogButtons/PlayerButtons", 1)</p><p>    XGUIEng.ShowWidget(MotherPath.. "DialogButtons/PlayerButtons/DestroyGoods", 1)</p><p>    XGUIEng.DisableButton(MotherPath.. "DialogButtons/PlayerButtons/DestroyGoods", 0)</p><p>    SetIcon(MotherPath.. "DialogButtons/PlayerButtons/DestroyGoods", {10, 9})</p><p>-- Das Burglager wird angezeigt.</p><p>-- </p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    local MotherPath = "/InGame/Root/Normal/AlignBottomRight/";</p><p>    XGUIEng.ShowWidget(MotherPath.. "Selection/Selection/BGSmall", 0);</p><p>    XGUIEng.ShowWidget(MotherPath.. "Selection/Castle", 0);</p><p>    XGUIEng.ShowWidget(MotherPath.. "Selection/BGSmall", 0);</p><p>    XGUIEng.ShowWidget(MotherPath.. "Selection/BGBig", 1);</p><p>    XGUIEng.ShowWidget(MotherPath.. "Selection/Storehouse", 1);</p><p>    XGUIEng.ShowWidget(MotherPath.. "Selection/Storehouse/AmountContainer", 0);</p><p>    XGUIEng.ShowAllSubWidgets(MotherPath.. "Selection/Storehouse/TabButtons", 1);</p><p>    GUI_Trade.StorehouseSelected()</p><p>    local AnchorInfoForBigX, AnchorInfoForBigY = XGUIEng.GetWidgetLocalPosition(MotherPath.. "Selection/AnchorInfoForBig")</p><p>    XGUIEng.SetWidgetLocalPosition(MotherPath.. "Selection/Info", AnchorInfoForBigX, AnchorInfoForBigY)</p><p>    XGUIEng.ShowWidget(MotherPath.. "DialogButtons/PlayerButtons", 1)</p><p>    XGUIEng.ShowWidget(MotherPath.. "DialogButtons/PlayerButtons/DestroyGoods", 1)</p><p>    XGUIEng.ShowWidget(MotherPath.. "Selection/Storehouse/InStorehouse", 1)</p><p>    XGUIEng.ShowWidget(MotherPath.. "Selection/Storehouse/InMulti", 0)</p><p>    XGUIEng.ShowWidget(MotherPath.. "Selection/Storehouse/InCity", 1)</p><p>    XGUIEng.ShowAllSubWidgets(MotherPath.. "Selection/Storehouse/InCity/Goods", 0);</p><p>    XGUIEng.ShowWidget(MotherPath.. "Selection/Storehouse/InCity/Goods/G_Beer", 1)</p><p>    XGUIEng.DisableButton(MotherPath.. "DialogButtons/PlayerButtons/DestroyGoods", 0)</p><p>    local MotherPathDialog = MotherPath.. "DialogButtons/PlayerButtons/";</p><p>    local MotherPathTabs = MotherPath.. "Selection/Storehouse/TabButtons/";</p><p>    SetIcon(MotherPathDialog.. "DestroyGoods", {3, 14});</p><p>    SetIcon(MotherPathTabs.. "StorehouseTabButtonUp/up/B_StoreHouse", {10, 9});</p><p>    SetIcon(MotherPathTabs.. "StorehouseTabButtonDown/down/B_StoreHouse", {10, 9});</p><p>    SetIcon(MotherPathTabs.. "CityTabButtonUp/up/CityBuildingsNumber", {15, 6});</p><p>    SetIcon(MotherPathTabs.. "CityTabButtonDown/down/CityBuildingsNumber", {15, 6});</p><p>    SetIcon(MotherPathTabs.. "Tab03Up/up/B_Castle_ME", {7, 1});</p><p>    SetIcon(MotherPathTabs.. "Tab03Down/down/B_Castle_ME", {7, 1});</p><p>    self:UpdateBehaviorTabs(GUI.GetPlayerID());</p><p>-- Überschreibt den Bezahlvorgang der Kosten eines interaktiven Objektes.</p><p>-- @within Internal</p><p>-- @local</p><p>    function BundleInteractiveObjects.Local:CanBeBought(_PlayerID, _Good, _Amount)</p><p>        local AmountOfGoods = GetPlayerGoodsInSettlement(_Good, _PlayerID, true);</p><p>        if AddOnCastleStore.Local.CastleStore:HasCastleStore(_PlayerID) then</p><p>            if Logic.GetGoodCategoryForGoodType(_Good) == GoodCategories.GC_Resource and _Good ~= Goods.G_Gold then</p><p>                local AmountInCastle = AddOnCastleStore.Local.CastleStore:GetAmount(_PlayerID, _Good);</p><p>                AmountOfGoods = AmountOfGoods + AmountInCastle;</p><p>            end</p><p>        end</p><p>        if AmountOfGoods  _Amount then</p><p>            return false;</p><p>        end</p><p>        return true;</p><p>    end</p><p>    function BundleInteractiveObjects.Local:BuyObject(_PlayerID, _Good, _Amount)</p><p>        if Logic.GetGoodCategoryForGoodType(_Good) ~= GoodCategories.GC_Resource and _Good ~= Goods.G_Gold then</p><p>            local buildings = GetPlayerEntities(_PlayerID,0);</p><p>            local goodAmount = _Amount;</p><p>            for i=1,#buildings do</p><p>                if Logic.IsBuilding(buildings[i]) == 1 and goodAmount  0 then</p><p>                    if Logic.GetBuildingProduct(buildings[i]) == _Good then</p><p>                        local goodAmountInBuilding = Logic.GetAmountOnOutStockByIndex(buildings[i],0);</p><p>                        for j=1,goodAmountInBuilding do</p><p>                            API.Bridge("Logic.RemoveGoodFromStock("..buildings[i]..",".._Good..",1)");</p><p>                            goodAmount = goodAmount -1;</p><p>                        end</p><p>                    end</p><p>                end</p><p>            end</p><p>        else</p><p>            local AmountInStore = GetPlayerGoodsInSettlement(_Good, _PlayerID, true);</p><p>            local GoodsToRemove = ((AmountInStore - _Amount) = 0 and _Amount) or AmountInStore;</p><p>            API.Bridge("AddGood(".._Good..", "..(GoodsToRemove*(-1))..", ".._PlayerID..")");</p><p>            if AddOnCastleStore.Local.CastleStore:HasCastleStore(_PlayerID) then</p><p>                _Amount = _Amount - GoodsToRemove;</p><p>                if _Amount  0 then</p><p>                    API.Bridge("QSB.CastleStore:GetInstance(" .._PlayerID.. "):Remove(" .._Good.. ", " .._Amount.. ")");</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>-- Hotkey-Callback für den Modus "Waren einlagern".</p><p>-- @within Internal</p><p>-- @local</p><p>    local PlayerID = GUI.GetPlayerID();</p><p>    if AddOnCastleStore.Local.CastleStore:HasCastleStore(PlayerID) == false then </p><p>        return;</p><p>    end</p><p>    AddOnCastleStore.Local.CastleStore:OnStorehouseTabClicked(PlayerID);</p><p>-- Hotkey-Callback für den Modus "Waren sperren".</p><p>-- @within Internal</p><p>-- @local</p><p>    local PlayerID = GUI.GetPlayerID();</p><p>    if AddOnCastleStore.Local.CastleStore:HasCastleStore(PlayerID) == false then </p><p>        return;</p><p>    end</p><p>    AddOnCastleStore.Local.CastleStore:OnCityTabClicked(PlayerID);</p><p>-- Hotkey-Callback für den Modus "Lager räumen".</p><p>-- @within Internal</p><p>-- @local</p><p>    local PlayerID = GUI.GetPlayerID();</p><p>    if AddOnCastleStore.Local.CastleStore:HasCastleStore(PlayerID) == false then </p><p>        return;</p><p>    end</p><p>    AddOnCastleStore.Local.CastleStore:OnMultiTabClicked(PlayerID);</p><p>-- Versieht die Hotkeys des Burglagers mit ihren Funktionen.</p><p>-- @within Internal</p><p>-- @local</p><p>    -- Waren einlagern</p><p>    Input.KeyBindDown(</p><p>        Keys.ModifierShift + Keys.B,</p><p>        "AddOnCastleStore.Local.CastleStore:HotkeyStoreGoods()",</p><p>        2,</p><p>        false</p><p>    );</p><p>    -- Waren verwahren</p><p>    Input.KeyBindDown(</p><p>        Keys.ModifierShift + Keys.N,</p><p>        "AddOnCastleStore.Local.CastleStore:HotkeyLockGoods()",</p><p>        2,</p><p>        false</p><p>    );</p><p>    </p><p>    -- Lager räumen</p><p>    Input.KeyBindDown(</p><p>        Keys.ModifierShift + Keys.M,</p><p>        "AddOnCastleStore.Local.CastleStore:HotkeyEmptyStore()",</p><p>        2,</p><p>        false</p><p>    );</p><p>-- Fügt die Beschreibung der Hotkeys der Hotkey-Tabelle hinzu.</p><p>-- @within Internal</p><p>-- @local</p><p>    if not self.HotkeysAddToList then</p><p>        API.AddHotKey("Umschalt + B", {de = "Burglager: Waren einlagern", en = "Vault: Store goods"});</p><p>        API.AddHotKey("Umschalt + N", {de = "Burglager: Waren sperren", en = "Vault: Lock goods"});</p><p>        API.AddHotKey("Umschalt + M", {de = "Burglager: Lager räumen", en = "Vault: Empty store"});</p><p>        self.HotkeysAddToList = true;</p><p>    end</p><p>-- Überschreibt die Textausgabe mit den eigenen Texten.</p><p>-- @within Internal</p><p>-- @local</p><p>    GetStringTableText_Orig_QSB_CatsleStore = XGUIEng.GetStringTableText;</p><p>    XGUIEng.GetStringTableText = function(_key)</p><p>        local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>        local SelectedID = GUI.GetSelectedEntity();</p><p>        local PlayerID = GUI.GetPlayerID();</p><p>        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();</p><p>        if _key == "UI_ObjectNames/DestroyGoods" then</p><p>            if Logic.GetHeadquarters(PlayerID) == SelectedID then</p><p>                if XGUIEng.IsWidgetShown("/InGame/Root/Normal/AlignBottomRight/Selection/Castle") == 1 then</p><p>                    return AddOnCastleStore.Local.Description.ShowCastleStore.Text[lang];</p><p>                else</p><p>                    return AddOnCastleStore.Local.Description.ShowCastle.Text[lang];</p><p>                end</p><p>            end</p><p>        end</p><p>        if _key == "UI_ObjectDescription/DestroyGoods" then</p><p>            return "";</p><p>        end</p><p>        if _key == "UI_ObjectNames/CityBuildingsNumber" then</p><p>            if Logic.GetHeadquarters(PlayerID) == SelectedID then</p><p>                return AddOnCastleStore.Local.Description.CityTab.Title[lang];</p><p>            end</p><p>        end</p><p>        if _key == "UI_ObjectDescription/CityBuildingsNumber" then</p><p>            if Logic.GetHeadquarters(PlayerID) == SelectedID then</p><p>                return AddOnCastleStore.Local.Description.CityTab.Text[lang];</p><p>            end</p><p>        end</p><p>        if _key == "UI_ObjectNames/B_StoreHouse" then</p><p>            if Logic.GetHeadquarters(PlayerID) == SelectedID then</p><p>                return AddOnCastleStore.Local.Description.StorehouseTab.Title[lang];</p><p>            end</p><p>        end</p><p>        if _key == "UI_ObjectDescription/B_StoreHouse" then</p><p>            if Logic.GetHeadquarters(PlayerID) == SelectedID then</p><p>                return AddOnCastleStore.Local.Description.StorehouseTab.Text[lang];</p><p>            end</p><p>        end</p><p>        if _key == "UI_ObjectNames/B_Castle_ME" then</p><p>            local WidgetMotherName = "/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/TabButtons/";</p><p>            local WidgetDownButton = WidgetMotherName.. "Tab03Down/down/B_Castle_ME";</p><p>            local WidgetUpButton = WidgetMotherName.. "Tab03Up/up/B_Castle_ME";</p><p>            if XGUIEng.GetWidgetPathByID(CurrentWidgetID) == WidgetDownButton or XGUIEng.GetWidgetPathByID(CurrentWidgetID) == WidgetUpButton then</p><p>                if Logic.GetHeadquarters(PlayerID) == SelectedID then</p><p>                    return AddOnCastleStore.Local.Description.MultiTab.Title[lang];</p><p>                end</p><p>            end</p><p>        end</p><p>        if _key == "UI_ObjectDescription/B_Castle_ME" then</p><p>            if Logic.GetHeadquarters(PlayerID) == SelectedID then</p><p>                return AddOnCastleStore.Local.Description.MultiTab.Text[lang];</p><p>            end</p><p>        end</p><p>        if _key == "UI_ButtonDisabled/NotEnoughGoods" then</p><p>            if Logic.GetHeadquarters(PlayerID) == SelectedID then</p><p>                return AddOnCastleStore.Local.Description.GoodButtonDisabled.Text[lang];</p><p>            end</p><p>        end</p><p>        return GetStringTableText_Orig_QSB_CatsleStore(_key);</p><p>    end</p><p>-- Überschreibt die lokalen Spielfunktionen, die benötigt werden, damit das</p><p>-- Burglager funktioniert.</p><p>-- @within Internal</p><p>-- @local</p><p>    GameCallback_GUI_SelectionChanged_Orig_QSB_CastleStore = GameCallback_GUI_SelectionChanged;</p><p>    GameCallback_GUI_SelectionChanged = function(_Source)</p><p>        GameCallback_GUI_SelectionChanged_Orig_QSB_CastleStore(_Source);</p><p>        QSB.CastleStore:SelectionChanged(GUI.GetPlayerID());</p><p>    end</p><p>    GUI_Trade.GoodClicked_Orig_QSB_CastleStore = GUI_Trade.GoodClicked;</p><p>    GUI_Trade.GoodClicked = function()</p><p>        local GoodType = Goods[XGUIEng.GetWidgetNameByID(XGUIEng.GetWidgetsMotherID(XGUIEng.GetCurrentWidgetID()))];</p><p>        local SelectedID = GUI.GetSelectedEntity();</p><p>        local PlayerID   = GUI.GetPlayerID();</p><p>        if Logic.IsEntityInCategory(SelectedID, EntityCategories.Storehouse) == 1 then</p><p>            GUI_Trade.GoodClicked_Orig_QSB_CastleStore();</p><p>            return;</p><p>        end</p><p>        QSB.CastleStore:GoodClicked(PlayerID, GoodType);</p><p>    end</p><p>    GUI_Trade.DestroyGoodsClicked_Orig_QSB_CastleStore = GUI_Trade.DestroyGoodsClicked;</p><p>    GUI_Trade.DestroyGoodsClicked = function()</p><p>        local SelectedID = GUI.GetSelectedEntity();</p><p>        local PlayerID   = GUI.GetPlayerID();</p><p>        if Logic.IsEntityInCategory(SelectedID, EntityCategories.Storehouse) == 1 then</p><p>            GUI_Trade.DestroyGoodsClicked_Orig_QSB_CastleStore();</p><p>            return;</p><p>        end</p><p>        QSB.CastleStore:DestroyGoodsClicked(PlayerID);</p><p>    end</p><p>    GUI_Trade.SellUpdate_Orig_QSB_CastleStore = GUI_Trade.SellUpdate;</p><p>    GUI_Trade.SellUpdate = function()</p><p>        local SelectedID = GUI.GetSelectedEntity();</p><p>        local PlayerID   = GUI.GetPlayerID();</p><p>        if Logic.IsEntityInCategory(SelectedID, EntityCategories.Storehouse) == 1 then</p><p>            GUI_Trade.SellUpdate_Orig_QSB_CastleStore();</p><p>            return;</p><p>        end</p><p>        QSB.CastleStore:UpdateGoodsDisplay(PlayerID);</p><p>    end</p><p>    GUI_Trade.CityTabButtonClicked_Orig_QSB_CastleStore = GUI_Trade.CityTabButtonClicked;</p><p>    GUI_Trade.CityTabButtonClicked = function()</p><p>        local SelectedID = GUI.GetSelectedEntity();</p><p>        local PlayerID   = GUI.GetPlayerID();</p><p>        if Logic.IsEntityInCategory(SelectedID, EntityCategories.Storehouse) == 1 then</p><p>            GUI_Trade.CityTabButtonClicked_Orig_QSB_CastleStore();</p><p>            return;</p><p>        end</p><p>        QSB.CastleStore:OnCityTabClicked(PlayerID);</p><p>    end</p><p>    GUI_Trade.StorehouseTabButtonClicked_Orig_QSB_CastleStore = GUI_Trade.StorehouseTabButtonClicked;</p><p>    GUI_Trade.StorehouseTabButtonClicked = function()</p><p>        local SelectedID = GUI.GetSelectedEntity();</p><p>        local PlayerID   = GUI.GetPlayerID();</p><p>        if Logic.IsEntityInCategory(SelectedID, EntityCategories.Storehouse) == 1 then</p><p>            GUI_Trade.StorehouseTabButtonClicked_Orig_QSB_CastleStore();</p><p>            return;</p><p>        end</p><p>        QSB.CastleStore:OnStorehouseTabClicked(PlayerID);</p><p>    end</p><p>    GUI_Trade.MultiTabButtonClicked_Orig_QSB_CastleStore = GUI_Trade.MultiTabButtonClicked;</p><p>    GUI_Trade.MultiTabButtonClicked = function()</p><p>        local SelectedID = GUI.GetSelectedEntity();</p><p>        local PlayerID   = GUI.GetPlayerID();</p><p>        if Logic.IsEntityInCategory(SelectedID, EntityCategories.Storehouse) == 1 then</p><p>            GUI_Trade.MultiTabButtonClicked_Orig_QSB_CastleStore();</p><p>            return;</p><p>        end</p><p>        QSB.CastleStore:OnMultiTabClicked(PlayerID);</p><p>    end</p><p>    GUI_BuildingInfo.StorageLimitUpdate_Orig_QSB_CastleStore = GUI_BuildingInfo.StorageLimitUpdate;</p><p>    GUI_BuildingInfo.StorageLimitUpdate = function()</p><p>        local SelectedID = GUI.GetSelectedEntity();</p><p>        local PlayerID   = GUI.GetPlayerID();</p><p>        if Logic.IsEntityInCategory(SelectedID, EntityCategories.Storehouse) == 1 then</p><p>            GUI_BuildingInfo.StorageLimitUpdate_Orig_QSB_CastleStore();</p><p>            return;</p><p>        end</p><p>        QSB.CastleStore:UpdateStorageLimit(PlayerID);</p><p>    end</p><p>    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</p><p>    GUI_Interaction.SendGoodsClicked = function()</p><p>        local Quest, QuestType = GUI_Interaction.GetPotentialSubQuestAndType(g_Interaction.CurrentMessageQuestIndex);</p><p>        if not Quest then</p><p>            return;</p><p>        end</p><p>        local QuestIndex = GUI_Interaction.GetPotentialSubQuestIndex(g_Interaction.CurrentMessageQuestIndex);</p><p>        local GoodType = Quest.Objectives[1].Data[1];</p><p>        local GoodAmount = Quest.Objectives[1].Data[2];</p><p>        local Costs = {GoodType, GoodAmount};</p><p>        local CanBuyBoolean, CanNotBuyString = AreCostsAffordable(Costs, true);</p><p>        local PlayerID = GUI.GetPlayerID();</p><p>        if Logic.GetGoodCategoryForGoodType(GoodType) == GoodCategories.GC_Resource then</p><p>            CanNotBuyString = XGUIEng.GetStringTableText("Feedback_TextLines/TextLine_NotEnough_Resources");</p><p>            CanBuyBoolean = false;</p><p>            if QSB.CastleStore:IsLocked(PlayerID, GoodType) then</p><p>                CanBuyBoolean = GetPlayerResources(GoodType, PlayerID) = GoodAmount;</p><p>            else</p><p>                CanBuyBoolean = (GetPlayerResources(GoodType, PlayerID) + QSB.CastleStore:GetAmount(PlayerID, GoodType)) = GoodAmount;</p><p>            end</p><p>        end</p><p>        local TargetPlayerID = Quest.Objectives[1].Data[6] and Quest.Objectives[1].Data[6] or Quest.SendingPlayer;</p><p>        local PlayerSectorType = PlayerSectorTypes.Thief;</p><p>        local IsReachable = CanEntityReachTarget(TargetPlayerID, Logic.GetStoreHouse(GUI.GetPlayerID()), Logic.GetStoreHouse(TargetPlayerID), nil, PlayerSectorType);</p><p>        if IsReachable == false then</p><p>            local MessageText = XGUIEng.GetStringTableText("Feedback_TextLines/TextLine_GenericUnreachable");</p><p>            Message(MessageText);</p><p>            return</p><p>        end</p><p>        if CanBuyBoolean == true then</p><p>            Sound.FXPlay2DSound( "ui\\menu_click");</p><p>            GUI.QuestTemplate_SendGoods(QuestIndex);</p><p>            GUI_FeedbackSpeech.Add("SpeechOnly_CartsSent", g_FeedbackSpeech.Categories.CartsUnderway, nil, nil);</p><p>        else</p><p>            Message(CanNotBuyString);</p><p>        end</p><p>    end</p><p>    GUI_Tooltip.SetCosts = function(_TooltipCostsContainer, _Costs, _GoodsInSettlementBoolean)</p><p>        local TooltipCostsContainerPath = XGUIEng.GetWidgetPathByID(_TooltipCostsContainer);</p><p>        local Good1ContainerPath = TooltipCostsContainerPath .. "/1Good";</p><p>        local Goods2ContainerPath = TooltipCostsContainerPath .. "/2Goods";</p><p>        local NumberOfValidAmounts = 0;</p><p>        local Good1Path;</p><p>        local Good2Path;</p><p>        for i = 2, #_Costs, 2 do</p><p>            if _Costs[i] ~= 0 then</p><p>                NumberOfValidAmounts = NumberOfValidAmounts + 1;</p><p>            end</p><p>        end</p><p>        if NumberOfValidAmounts == 0 then</p><p>            XGUIEng.ShowWidget(Good1ContainerPath, 0);</p><p>            XGUIEng.ShowWidget(Goods2ContainerPath, 0);</p><p>            return</p><p>        elseif NumberOfValidAmounts == 1 then</p><p>            XGUIEng.ShowWidget(Good1ContainerPath, 1);</p><p>            XGUIEng.ShowWidget(Goods2ContainerPath, 0);</p><p>            Good1Path = Good1ContainerPath .. "/Good1Of1";</p><p>        elseif NumberOfValidAmounts == 2 then</p><p>            XGUIEng.ShowWidget(Good1ContainerPath, 0);</p><p>            XGUIEng.ShowWidget(Goods2ContainerPath, 1);</p><p>            Good1Path = Goods2ContainerPath .. "/Good1Of2";</p><p>            Good2Path = Goods2ContainerPath .. "/Good2Of2";</p><p>        elseif NumberOfValidAmounts  2 then</p><p>            GUI.AddNote("Debug: Invalid Costs table. Not more than 2 GoodTypes allowed.");</p><p>        end</p><p>        local ContainerIndex = 1;</p><p>        for i = 1, #_Costs, 2 do</p><p>            if _Costs[i + 1] ~= 0 then</p><p>                local CostsGoodType = _Costs[i];</p><p>                local CostsGoodAmount = _Costs[i + 1];</p><p>                local IconWidget;</p><p>                local AmountWidget;</p><p>                if ContainerIndex == 1 then</p><p>                    IconWidget = Good1Path .. "/Icon";</p><p>                    AmountWidget = Good1Path .. "/Amount";</p><p>                else</p><p>                    IconWidget = Good2Path .. "/Icon";</p><p>                    AmountWidget = Good2Path .. "/Amount";</p><p>                end</p><p>                SetIcon(IconWidget, g_TexturePositions.Goods[CostsGoodType], 44);</p><p>                local PlayerID = GUI.GetPlayerID();</p><p>                local PlayersGoodAmount = GetPlayerGoodsInSettlement(CostsGoodType, PlayerID, _GoodsInSettlementBoolean);</p><p>                if Logic.GetGoodCategoryForGoodType(CostsGoodType) == GoodCategories.GC_Resource and CostsGoodType ~= Goods.G_Gold then</p><p>                    if not QSB.CastleStore:IsLocked(PlayerID, CostsGoodType) then</p><p>                        PlayersGoodAmount = PlayersGoodAmount + QSB.CastleStore:GetAmount(PlayerID, CostsGoodType);</p><p>                    end</p><p>                end</p><p>                local Color = "";</p><p>                if PlayersGoodAmount  CostsGoodAmount then</p><p>                    Color = "{@script:ColorRed}";</p><p>                end</p><p>                if CostsGoodAmount  0 then</p><p>                    XGUIEng.SetText(AmountWidget, "{center}" .. Color .. CostsGoodAmount);</p><p>                else</p><p>                    XGUIEng.SetText(AmountWidget, "");</p><p>                end</p><p>                ContainerIndex = ContainerIndex + 1;</p><p>            end</p><p>        end</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/addoninteractiveobjecttemplates.lua.html">
            <div class='doclink'>
                <div>AddOnInteractiveObjectTemplates</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia AddOnInteractiveObjectTemplates                              # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Dieses Bundle bietet fertige Schablonen für interaktive Objekte. Mit diesen</p><p>-- Schablonen können komplexere interaktive Objekte einfach erstellt und durch</p><p>-- den Mapper genutzt werden.</p><p>-- </p><p>-- </p><p>-- Ermöglicht es den Spieler auf einem beliebigen Territorium einer Partei</p><p>-- ein Gebäude bauen zu lassen.</p><p>-- Die Baustelle muss durch den Helden aktiviert</p><p>-- werden. Ein Siedler wird aus dem Lagerhaus kommen und das Gebäude bauen.</p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- Es werden Schatztruhen mit zufälligem Inhalt erzeugt. Diese Truhen werden</p><p>-- aktiviert und der Inhalt wird in einem Karren abtransportiert.</p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- Der Spieler kann eine Stein- oder Eisenmine erzeugen, die zuerst durch</p><p>-- Begleichen der Kosten aufgebaut werden muss, bevor sie genutzt werden kann.</p><p>-- Optional kann die Mine einstürzen, wenn sie erschöpft wurde.</p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- Der Spieler kann Trebuchet mieten. Das Trebuchet fährt als Karren vor,</p><p>-- wird aufgebaut und kann anschließend benutzt werden. Das Trebuchet fährt</p><p>-- ab, wenn die Munition alle ist oder der Spieler das Trebuchet abbaut.</p><p>-- Sobald ein Trebuchet zerstört wird oder sein Karren wieder am Lagerhaus</p><p>-- ankommt, wird die Baustelle wieder freigegeben.</p><p>-- </p><p>-- </p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Erstelle eine verschüttete Mine eines bestimmten Typs. Es können zudem eine</p><p>-- Bedingung und zwei verschiedene Callbacks vereinbart werden.</p><p>-- Minen können als "nicht auffüllbar" markiert werden. In diesem Fall werden</p><p>-- sie zusammenstützen, sobald die Rohstoffe verbraucht sind.</p><p>-- Verschüttete Minen können durch einen Helden in normale Minen umgewandelt</p><p>-- werden. FÜr diese Umwandlung können Kosten anfallen, müssen aber nicht. Es</p><p>-- dürfen immer maximal 2 Waren als Kosten verwendet werden.</p><p>-- Es können weitere Funktionen hinzugefügt werden, um die Mine anzupassen:</p><p>-- </p><p>--  Eine Funktion, die true oder false zurückgeben muss.</p><p>-- Mit dieser Funktion wird bestimmt, ob die Mine gebaut werden darf.</p><p>--  Eine Funktion, die ausgeführt wird, wenn</p><p>-- die Mine erfolgreich aktiviert wurde (evtl. Kosten bezahlt und/oder</p><p>-- Bedingung erfüllt).</p><p>--  Eine Funktion, die ausgeführt wird, sobald</p><p>-- die Rohstoffe der Mine erschöpft sind.</p><p>-- </p><p>-- </p><p>-- @param[type=string]   _Position         Script Entity, die mit Mine ersetzt wird</p><p>-- @param[type=number]   _Type             Typ der Mine</p><p>-- @param[type=table]    _Costs            (optional) Kostentabelle</p><p>-- @param[type=boolean]  _NotRefillable    (optional) Die Mine wird weiterhin überwacht</p><p>-- @param[type=function] _Condition        (optional) Bedingungsfunktion</p><p>-- @param[type=function] _CreationCallback (optional) Funktion nach Kauf ausführen</p><p>-- @param[type=function] _CallbackDepleted (optional) Funktion nach Ausbeutung ausführen</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- -- Beispiel für eine Mine</p><p>-- API.CreateIOMine("mine", Entities.B_IronMine, {Goods.G_Wood, 20}, true)</p><p>-- -- Die Mine kann für 20 Holz erschlossen werden. Sobald die Rohstoffe</p><p>-- -- erschöpft sind, stürzt die Mine zusammen.</p><p>function API.CreateIOMine(_Position, _Type, _Costs, _NotRefillable, _Condition, _CreationCallback, _CallbackDepleted)</p><p>    if GUI then</p><p>        API.Fatal("API.CreateIOMine: Can not be used from local script!");</p><p>        return;</p><p>    end</p><p>    AddOnInteractiveObjectTemplates.Global:CreateIOMine(_Position, _Type, _Costs, _NotRefillable, _Condition, _CreationCallback, _CallbackDepleted);</p><p>-- Erstelle eine verschüttete Eisenmine.</p><p>-- </p><p>-- @param[type=string]  _Position      Script Entity, die mit Mine ersetzt wird</p><p>-- @param[type=number]  _Cost1Type     (optional) Kostenware 1</p><p>-- @param[type=number]  _Cost1Amount   (optional) Kostenmenge 1</p><p>-- @param[type=number]  _Cost2Type     (optional) Kostenware 2</p><p>-- @param[type=number]  _Cost2Amount   (optional) Kostenmenge 2</p><p>-- @param[type=boolean] _NotRefillable (optional) Mine wird nach Ausbeutung zerstört</p><p>-- @within Anwenderfunktionen</p><p>-- @see API.CreateIOMine</p><p>-- @usage</p><p>-- -- Beispiel für eine Mine</p><p>-- API.CreateIOMine("mine", Goods.G_Wood, 20)</p><p>function API.CreateIOIronMine(_Position, _Cost1Type, _Cost1Amount, _Cost2Type, _Cost2Amount, _NotRefillable)</p><p>    if GUI then</p><p>        API.Fatal("API.CreateIOIronMine: Can not be used from local script!");</p><p>        return;</p><p>    end</p><p>    AddOnInteractiveObjectTemplates.Global:CreateIOIronMine(_Position, _Cost1Type, _Cost1Amount, _Cost2Type, _Cost2Amount, _NotRefillable);</p><p>-- Erstelle eine verschüttete Steinmine.</p><p>-- </p><p>-- @param[type=string]  _Position      Script Entity, die mit Mine ersetzt wird</p><p>-- @param[type=number]  _Cost1Type     (optional) Kostenware 1</p><p>-- @param[type=number]  _Cost1Amount   (optional) Kostenmenge 1</p><p>-- @param[type=number]  _Cost2Type     (optional) Kostenware 2</p><p>-- @param[type=number]  _Cost2Amount   (optional) Kostenmenge 2</p><p>-- @param[type=boolean] _NotRefillable (optional) Mine wird nach Ausbeutung zerstört</p><p>-- @within Anwenderfunktionen</p><p>-- @see API.CreateIOMine</p><p>-- @usage</p><p>-- -- Beispiel für eine Mine</p><p>-- API.CreateIOMine("mine", Goods.G_Wood, 20)</p><p>function API.CreateIOStoneMine(_Position, _Cost1Type, _Cost1Amount, _Cost2Type, _Cost2Amount, _NotRefillable)</p><p>    if GUI then</p><p>        API.Fatal("API.CreateIOStoneMine: Can not be used from local script!");</p><p>        return;</p><p>    end</p><p>    AddOnInteractiveObjectTemplates.Global:CreateIOStoneMine(_Position, _Cost1Type, _Cost1Amount, _Cost2Type, _Cost2Amount, _NotRefillable);</p><p>-- Erzeugt eine Baustelle eines beliebigen Gebäudetyps an der Position.</p><p>-- Diese Baustelle kann durch einen Helden aktiviert werden. Dann wird ein</p><p>-- Siedler zur Baustelle eilen und das Gebäude aufbauen. Es ist egal, ob es</p><p>-- sich um ein Territorium des Spielers oder einer KI handelt.</p><p>-- Es ist dabei zu beachten, dass der Spieler, dem die Baustelle zugeordnet</p><p>-- wird, das Territorium besitzt, auf dem er bauen soll. Des weiteren muss</p><p>-- er über ein Lagerhaus/Hauptzelt verfügen.</p><p>--  Es kann vorkommen, dass das Model der Baustelle nicht</p><p>-- geladen wird. Dann ist der Boden der Baustelle schwarz. Sobald wenigstens</p><p>-- ein reguläres Gebäude gebaut wurde, sollte die Textur jedoch vorhanden sein.</p><p>-- </p><p>-- </p><p>-- @param[type=string]   _Position Zielpunkt</p><p>-- @param[type=number]   _PlayerID Besitzer des Gebäudes</p><p>-- @param[type=number]   _Type Typ des Gebäudes</p><p>-- @param[type=table]    _Costs (optional) Eigene Gebäudekosten</p><p>-- @param[type=number]   _Distance (optional) Aktivierungsentfernung</p><p>-- @param[type=table]    _Icon (optional) Icon des Schalters</p><p>-- @param[type=string]   _Title (optional) Titel der Beschreibung</p><p>-- @param[type=string]   _Text(optional) Text der Beschreibung</p><p>-- @param[type=function] _Callback (optional) Funktion nach Fertigstellung</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- -- Erzeugt eine Baustelle ohne besondere Einstellungen</p><p>-- API.CreateIOBuildingSite("haus", 1, Entities.B_Bakery)</p><p>-- -- Baustelle mit Kosten und Aktivierungsdistanz</p><p>-- API.CreateIOBuildingSite("haus", 1, Entities.B_Bakery, {Goods.G_Wood, 4}, 1000)</p><p>function API.CreateIOBuildingSite(_Position, _PlayerID, _Type, _Costs, _Distance, _Icon, _Title, _Text, _Callback)</p><p>    if GUI then</p><p>        API.Fatal("API.CreateIOBuildingSite: Can not be used from local script!");</p><p>        return;</p><p>    end</p><p>    AddOnInteractiveObjectTemplates.Global:CreateIOBuildingSite(_Position, _PlayerID, _Type, _Costs, _Distance, _Icon, _Title, _Text, _Callback);</p><p>-- Erstellt eine Schatztruhe mit einer zufälligen Menge an Waren</p><p>-- des angegebenen Typs.</p><p>-- Die Menge der Ware ist dabei zufällig und liegt zwischen dem Minimalwert</p><p>-- und dem Maximalwert. Optional kann eine Funktion angegeben werden, die</p><p>-- ausgeführt wird, wenn die Truhe geöffnet wird. Diese Funktion verhält sich</p><p>-- wie das Callback eines interaktiven Objektes.</p><p>-- </p><p>-- @param[type=string]   _Name Name der zu ersetzenden Script Entity</p><p>-- @param[type=number]   _Good Warentyp</p><p>-- @param[type=number]   _Min Mindestmenge</p><p>-- @param[type=number]   _Max Maximalmenge</p><p>-- @param[type=function] _Callback Callback-Funktion</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.CreateRandomChest("chest", Goods.G_Gems, 100, 300, OnChestOpened)</p><p>function API.CreateRandomChest(_Name, _Good, _Min, _Max, _Callback)</p><p>    if GUI then</p><p>        API.Fatal("API.CreateRandomChest: Can not be used from local script!");</p><p>        return;</p><p>    end</p><p>    AddOnInteractiveObjectTemplates.Global:CreateRandomChest(_Name, _Good, _Min, _Max, _Callback);</p><p>-- Erstellt eine Schatztruhe mit einer zufälligen Menge Gold.</p><p>-- </p><p>-- @param[type=string] _Name Name der zu ersetzenden Script Entity</p><p>-- @within Anwenderfunktionen</p><p>function API.CreateRandomGoldChest(_Name)</p><p>    if GUI then</p><p>        API.Fatal("API.CreateRandomGoldChest('" .._Name.. "')");</p><p>        return;</p><p>    end</p><p>    AddOnInteractiveObjectTemplates.Global:CreateRandomChest(_Name, Goods.G_Gold, 300, 600);</p><p>-- Erstellt eine Schatztruhe mit einer zufälligen Art und Menge</p><p>-- an Gütern.</p><p>-- Güter können seien: Eisen, Fisch, Fleisch, Getreide, Holz,</p><p>-- Honig, Kräuter, Milch, Stein, Wolle.</p><p>-- </p><p>-- @param[type=string] _Name Name der zu ersetzenden Script Entity</p><p>-- @within Anwenderfunktionen</p><p>function API.CreateRandomResourceChest(_Name)</p><p>    if GUI then</p><p>        API.Bridge("API.CreateRandomResourceChest('" .._Name.. "')");</p><p>        return;</p><p>    end</p><p>    AddOnInteractiveObjectTemplates.Global:CreateRandomResourceChest(_Name);</p><p>-- Erstellt eine Schatztruhe mit einer zufälligen Art und Menge</p><p>-- an Luxusgütern.</p><p>-- Luxusgüter können seien: Edelsteine, Farben, Musikinstrumente</p><p>-- Salz oder Weihrauch.</p><p>-- </p><p>-- @param[type=string] _Name Name der zu ersetzenden Script Entity</p><p>-- @within Anwenderfunktionen</p><p>function API.CreateRandomLuxuryChest(_Name)</p><p>    if GUI then</p><p>        API.Bridge("API.CreateRandomLuxuryChest('" .._Name.. "')");</p><p>        return;</p><p>    end</p><p>    AddOnInteractiveObjectTemplates.Global:CreateRandomLuxuryChest(_Name);</p><p>-- Erstellt eine Trebuchet-Baustelle an der Position mit den</p><p>-- angegebenen Baukosten.</p><p>-- Das Trebuchet kann von einem Helden aufgebaut werden. Es wird ein Karren</p><p>-- aus dem Lagerhaus zur Baustelle fahren. Erreicht der Karren die Baustelle,</p><p>-- wird er durch ein Trebuchet ersetzt.</p><p>-- Das Trebuchet hat dann 10 Schuss. Sind diese aufgebraucht wird das Trebuchet</p><p>-- abgebaut und fährt in das Lagerhaus zurück. Sobald der Karren angekommen</p><p>-- ist, kann die Baustelle erneut aktiviert werden.</p><p>-- Das Auffüllen von Trebuchets wird deaktiviert, sobald eine</p><p>-- Baustelle erzeugt wird. Es wird NICHT empfohlen dem Spieler beides, normale</p><p>-- Trebuchets und Trebuchetbaustellen, zur gleichen Zeit zu geben!</p><p>-- </p><p>-- @param[type=string] _Name Skriptname Position</p><p>-- @param[type=number] _GoldCost Goldkosten</p><p>-- @param[type=number] _WoodCost Holzkosten</p><p>-- @within Anwenderfunktionen</p><p>function API.CreateTrebuchetConstructionSite(_Name, _GoldCost, _WoodCost)</p><p>    if GUI then</p><p>        API.Bridge("API.CreateTrebuchetConstructionSite('" .._Name.. "', " .._GoldCost.. ", " .._WoodCost.. ")");</p><p>        return;</p><p>    end</p><p>    AddOnInteractiveObjectTemplates.Global:CreateTrebuchetConstructionSite(_Name, _GoldCost, _WoodCost);</p><p>-- Zerstört eine Trebuchet-Baustelle, aber nicht die Skript Entity.</p><p>-- Die Baustelle wird in jedem möglichen Status zerstört. Es ist egal, ob das</p><p>-- Trebuchet aufgebaut ist, gerade ein Karren unterwegs ist, oder die Baustelle</p><p>-- noch nie berührt wurde.</p><p>-- </p><p>-- @param[type=string] _Name Skriptname Position</p><p>-- @within Anwenderfunktionen</p><p>function API.DestroyTrebuchetConstructionSite(_Name)</p><p>    if GUI then</p><p>        API.Bridge("API.DestroyTrebuchetConstructionSite('" .._Name.. "')");</p><p>        return;</p><p>    end</p><p>    AddOnInteractiveObjectTemplates.Global:DestroyTrebuchetConstructionSite(_Name);</p><p>-- Gibt die EntityID aufgebaute Trebuchet der Trebuchet-Baustelle zurück.</p><p>-- Sollte kein Trebuchet aufgebaut sein, wird 0 zurückgegeben.</p><p>-- @param[type=string] _Name Skriptname der Trebuchet-Baustelle</p><p>-- @return[type=number] EntityID des Trebuchet</p><p>-- @within Anwenderfunktionen</p><p>function API.GetTrebuchetByTrebuchetConstructionSite(_Name)</p><p>    if GUI then</p><p>        API.Fatal("API.GetTrebuchetByTrebuchetConstructionSite: Can only be used in global script!");</p><p>        return;</p><p>    end</p><p>    if not self.Data.Trebuchet.Sites[_Name] then</p><p>        API.Warn("API.GetTrebuchetByTrebuchetConstructionSite: Site '" ..tostring(_Name).. "' does not exist!");</p><p>        return 0;</p><p>    end</p><p>    return self.Data.Trebuchet.Sites[_Name].ConstructedTrebuchet;</p><p>-- Gibt die EntityID des Anforderungswagens der Trebuchet-Baustelle zurück.</p><p>-- Sollte kein Anforderungswagen unterwegs sein, wird 0 zurückgegeben.</p><p>-- @param[type=string] _Name Skriptname der Trebuchet-Baustelle</p><p>-- @return[type=number] EntityID des angeforderten Wagens</p><p>-- @within Anwenderfunktionen</p><p>function API.GetReturningCartByTrebuchetConstructionSite(_Name)</p><p>    if GUI then</p><p>        API.Fatal("API.GetReturningCartByTrebuchetConstructionSite: Can only be used in global script!");</p><p>        return;</p><p>    end</p><p>    if not self.Data.Trebuchet.Sites[_Name] then</p><p>        API.Warn("API.GetReturningCartByTrebuchetConstructionSite: Site '" ..tostring(_Name).. "' does not exist!");</p><p>        return 0;</p><p>    end</p><p>    return self.Data.Trebuchet.Sites[_Name].ReturningCart;</p><p>-- Gibt die EntityID des Abreisewagens der Trebuchet-Baustelle zurück. Sollte</p><p>-- kein Abreisewagens unterwegs sein, wird 0 zurückgegeben.</p><p>-- @param[type=string] _Name Skriptname der Trebuchet-Baustelle</p><p>-- @return[type=number] EntityID des angeforderten Wagens</p><p>-- @within Anwenderfunktionen</p><p>function API.GetConstructionCartByTrebuchetConstructionSite(_Name)</p><p>    if GUI then</p><p>        API.Fatal("API.GetConstructionCartByTrebuchetConstructionSite: Can only be used in global script!");</p><p>        return;</p><p>    end</p><p>    if not self.Data.Trebuchet.Sites[_Name] then</p><p>        API.Warn("API.GetConstructionCartByTrebuchetConstructionSite: Site '" ..tostring(_Name).. "' does not exist!");</p><p>        return 0;</p><p>    end</p><p>    return self.Data.Trebuchet.Sites[_Name].ConstructionCart;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {</p><p>        Data = {</p><p>            ConstructionSite = {</p><p>                Sites = {},</p><p>                Description = {</p><p>                    Title = {</p><p>                        de = "Gebäude bauen",</p><p>                        en = "Create building",</p><p>                    },</p><p>                    Text = {</p><p>                        de = "Beauftragt den Bau eines Gebäudes. Ein Siedler wird aus"..</p><p>                             " dem Lagerhaus kommen und mit dem Bau beginnen.",</p><p>                        en = "Order a building. A worker will come out of the"..</p><p>                             " storehouse and erect it.",</p><p>                    },</p><p>                    Unfulfilled = {</p><p>                        de = "Das Gebäude kann derzeit nicht gebaut werden.",</p><p>                        en = "The building can not be built at the moment.",</p><p>                    },</p><p>                }</p><p>            },</p><p>            Mines = {</p><p>                Description = {</p><p>                    Title = {</p><p>                        de = "Mine errichten",</p><p>                        en = "Build pit",</p><p>                    },</p><p>                    Text = {</p><p>                        de = "An diesem Ort könnt Ihr eine Mine errichten!",</p><p>                        en = "You're able to create a pit at this location!",</p><p>                    },</p><p>                    Unfulfilled = {</p><p>                        de = "Die Mine kann nicht umgewandelt werden!",</p><p>                        en = "The mine can not be transformed!",</p><p>                    },</p><p>                },</p><p>            },</p><p>            Chests = {</p><p>                Description = {</p><p>                    Title = {</p><p>                        de = "Schatztruhe",</p><p>                        en = "Treasure Chest",</p><p>                    },</p><p>                    Text = {</p><p>                        de = "Diese Truhe enthält einen geheimen Schatz. Öffnet sie um den Schatz zu bergen.",</p><p>                        en = "This chest contains a secred treasure. Open it to salvage the treasure.",</p><p>                    },</p><p>                },</p><p>            },</p><p>            Trebuchet = {</p><p>                Error = {</p><p>                    de = "Euer Ritter benötigt einen höheren Titel!",</p><p>                    en = "Your knight need a higher title to use this site!",</p><p>                },</p><p>                Description = {</p><p>                    Title = {</p><p>                        de = "Trebuchet anfordern",</p><p>                        en = "Order trebuchet",</p><p>                    },</p><p>                    Text = {</p><p>                        de = "- Fordert ein Trebuchet aus der Stadt an {cr}- Trebuchet wird gebaut, wenn Wagen Baustelle erreicht {cr}- Fährt zurück, wenn Munition aufgebraucht {cr}- Trebuchet kann manuell zurückgeschickt werden",</p><p>                        en = "- Order a trebuchet from your city {cr}- The trebuchet is build after the cart has arrived {cr}- Returns after ammunition is depleted {cr}- The trebuchet can be manually send back to the city",</p><p>                    },</p><p>                },</p><p>                Sites = {},</p><p>                NeededKnightTitle = 0,</p><p>                IsActive = false,</p><p>            },</p><p>        }</p><p>    },</p><p>    Local = {</p><p>        Data = {},</p><p>    },</p><p>-- Global ----------------------------------------------------------------------</p><p>-- Initalisiert das AddOn.</p><p>-- @within Internal</p><p>-- @local</p><p>-- Initialisiert die interaktiven Trebuchet-Baustellen.</p><p>-- @within Internal</p><p>-- @local</p><p>    if not self.Data.Trebuchet.IsActive then</p><p>        GameCallback_QSB_OnDisambleTrebuchet = AddOnInteractiveObjectTemplates.Global.OnTrebuchetDisambled;</p><p>        GameCallback_QSB_OnErectTrebuchet = function() end;</p><p>        StartSimpleJobEx(self.WatchTrebuchetsAndCarts);</p><p>        API.DisableRefillTrebuchet(true);</p><p>        self.Data.Trebuchet.IsActive = true;</p><p>    end</p><p>-- Prüft, ob der menschliche Spieler einen ausreichenden Titel</p><p>-- hat um Trebuchets zu bauen.</p><p>-- @return boolean: Titel hoch genug</p><p>-- @within Internal</p><p>-- @local</p><p>    local pID = 1;</p><p>    for i=1,8 do</p><p>        if Logic.PlayerGetIsHumanFlag(i) == 1 then</p><p>            pID = i;</p><p>            break;</p><p>        end</p><p>    end</p><p>    return Logic.GetKnightTitle(pID) = AddOnInteractiveObjectTemplates.Global.Data.Trebuchet.NeededKnightTitle;</p><p>-- Setzt den mindestens benötigten Titel um Trebuchets zu bauen.</p><p>-- @param _KnightTitle Titel</p><p>-- @within Internal</p><p>-- @local</p><p>    self.Data.Trebuchet.NeededKnightTitle = _KnightTitle;</p><p>-- Erstellt eine Trebuchet-Baustelle an der Position mit den</p><p>-- angegebenen Baukosten.</p><p>-- @param _Name [string] Skriptname Position</p><p>-- @param _GoldCost Goldkosten</p><p>-- @param _WoodCost Holzkosten</p><p>-- @within Internal</p><p>-- @local</p><p>    self:TrebuchetActivate();</p><p>    _GoldCost = _GoldCost or 4500;</p><p>    _WoodCost = _WoodCost or 35;</p><p>    local eID = GetID(_Name);</p><p>    Logic.SetModel(eID, Models.Buildings_B_BuildingPlot_8x8);</p><p>    Logic.SetVisible(eID, true);</p><p>    self.Data.Trebuchet.Sites[_Name] = {</p><p>        ConstructedTrebuchet = 0,</p><p>        ConstructionCart = 0,</p><p>        ReturningCart = 0,</p><p>    }</p><p>    CreateObject {</p><p>        Name                    = _Name,</p><p>        Title                   = self.Data.Trebuchet.Description.Title,</p><p>        Text                    = self.Data.Trebuchet.Description.Text,</p><p>        Costs                   = {Goods.G_Gold, _GoldCost, Goods.G_Wood, _WoodCost},</p><p>        Distance                = 1000,</p><p>        State                   = 0,</p><p>        Condition               = self.TrebuchetHasSufficentTitle,</p><p>        ConditionUnfulfilled    = self.Data.Trebuchet.Error,</p><p>        Callback                = function(t, PlayerID)</p><p>            AddOnInteractiveObjectTemplates.Global:SpawnTrebuchetCart(PlayerID, t.Name);</p><p>        end,</p><p>    }</p><p>-- Zerstört eine Trebuchet-Baustelle.</p><p>-- @param _Name [string] Skriptname Position</p><p>-- @within Internal</p><p>-- @local</p><p>    local ConstructionCart = self.Data.Trebuchet.Sites[_Name].ConstructionCart;</p><p>    DestroyEntity(ConstructionCart);</p><p>    local ConstructedTrebuchet = self.Data.Trebuchet.Sites[_Name].ConstructedTrebuchet;</p><p>    DestroyEntity(ConstructedTrebuchet);</p><p>    local ReturningCart = self.Data.Trebuchet.Sites[_Name].ReturningCart;</p><p>    DestroyEntity(ReturningCart);</p><p>    self.Data.Trebuchet.Sites[_Name] = nil;</p><p>    Logic.SetVisible(GetID(_Name), false);</p><p>    RemoveInteractiveObject(_Name);</p><p>-- Erzeugt einen Trebuchetwagen für die Baustelle.</p><p>-- @param _PlayerID Besitzer</p><p>-- @param _Site     Baustelle</p><p>-- @within Internal</p><p>-- @local</p><p>    local StoreID = Logic.GetStoreHouse(_PlayerID);</p><p>    local x,y = Logic.GetBuildingApproachPosition(StoreID);</p><p>    local CartID = Logic.CreateEntity(Entities.U_SiegeEngineCart, x, y, 0, _PlayerID);</p><p>    Logic.SetEntitySelectableFlag(CartID, 0);</p><p>    self.Data.Trebuchet.Sites[_Site].ConstructionCart = CartID;</p><p>-- Erzeugt das Trebuchet an der Baustelle.</p><p>-- @param _PlayerID Besitzer</p><p>-- @param _Site     Baustelle</p><p>-- @within Internal</p><p>-- @local</p><p>    local pos = GetPosition(_Site);</p><p>    local TrebuchetID = Logic.CreateEntity(Entities.U_Trebuchet, pos.X, pos.Y, 0, _PlayerID);</p><p>    self.Data.Trebuchet.Sites[_Site].ConstructedTrebuchet = TrebuchetID;</p><p>-- Baut das Trebuchet zum Wagen zurück und lässt es wieder ins</p><p>-- Lagerhaus des Besitzers fahren.</p><p>-- @param _PlayerID  Besitzer</p><p>-- @param _Trebuchet Baustelle</p><p>-- @within Internal</p><p>-- @local</p><p>    local x,y,z = Logic.EntityGetPos(_Trebuchet);</p><p>    local CartID = Logic.CreateEntity(Entities.U_SiegeEngineCart, x, y, 0, _PlayerID);</p><p>    Logic.SetEntitySelectableFlag(CartID, 0);</p><p>    local SiteName;</p><p>    for k,v in pairs(self.Data.Trebuchet.Sites) do</p><p>        if v.ConstructedTrebuchet == _Trebuchet then</p><p>            SiteName = k;</p><p>        end</p><p>    end</p><p>    if SiteName then</p><p>        self.Data.Trebuchet.Sites[SiteName].ReturningCart = CartID;</p><p>        self.Data.Trebuchet.Sites[SiteName].ConstructedTrebuchet = 0;</p><p>        Logic.SetVisible(GetID(SiteName), true);</p><p>        DestroyEntity(_Trebuchet);</p><p>    else</p><p>        DestroyEntity(CartID);</p><p>    end</p><p>-- Callback: Ein Trebuchet wird manuell zurückgebaut.</p><p>-- @param _EntityID Entity-ID des Trebuchet</p><p>-- @param _PlayerID Besitzer</p><p>-- @param _x        X-Position</p><p>-- @param _y        Y-Position</p><p>-- @param _z        Z-Position</p><p>-- @within Internal</p><p>-- @local</p><p>    AddOnInteractiveObjectTemplates.Global:ReturnTrebuchetToStorehouse(_PlayerID, _EntityID);</p><p>-- Steuert die Trebuchet-Mechanik.</p><p>-- @within Internal</p><p>-- @local</p><p>    for k,v in pairs(AddOnInteractiveObjectTemplates.Global.Data.Trebuchet.Sites) do</p><p>        local SiteID = GetID(k);</p><p>        -- Stufe 1: Karren kommt</p><p>        if v.ConstructionCart ~= 0 then</p><p>            -- Bauwagen wurde zerstört</p><p>            if not IsExisting(v.ConstructionCart) then</p><p>                AddOnInteractiveObjectTemplates.Global.Data.Trebuchet.Sites[k].ConstructionCart = 0;</p><p>                API.InteractiveObjectActivate(k);</p><p>            end</p><p>            -- Bauwagen bewegt sich nicht zum Ziel</p><p>            if not Logic.IsEntityMoving(v.ConstructionCart) then</p><p>                local SiteID = GetID(k);</p><p>                local x,y,z = Logic.EntityGetPos(SiteID);</p><p>                Logic.MoveSettler(v.ConstructionCart, x, y);</p><p>            end</p><p>            -- Bauwagen ist angekommen</p><p>            if IsNear(v.ConstructionCart, k, 500) then</p><p>                local x,y,z = Logic.EntityGetPos(SiteID);</p><p>                local PlayerID = Logic.EntityGetPlayer(v.ConstructionCart);</p><p>                AddOnInteractiveObjectTemplates.Global:SpawnTrebuchet(PlayerID, k);</p><p>                DestroyEntity(v.ConstructionCart);</p><p>                AddOnInteractiveObjectTemplates.Global.Data.Trebuchet.Sites[k].ConstructionCart = 0;</p><p>                Logic.SetVisible(SiteID, false);</p><p>                Logic.CreateEffect(EGL_Effects.E_Shockwave01, x, y, 0);</p><p>            end</p><p>        end</p><p>        -- Stufe 2: Trebuchet steht</p><p>        if v.ConstructedTrebuchet ~= 0 then</p><p>            -- Trebuchet wurde zerstört</p><p>            if not IsExisting(v.ConstructedTrebuchet) then</p><p>                AddOnInteractiveObjectTemplates.Global.Data.Trebuchet.Sites[k].ConstructedTrebuchet = 0;</p><p>                Logic.SetVisible(SiteID, true);</p><p>                API.InteractiveObjectActivate(k);</p><p>            end</p><p>            -- Trebuchet hat keine Munition</p><p>            if Logic.GetAmmunitionAmount(v.ConstructedTrebuchet) == 0 and BundleEntitySelection.Local.Data.RefillTrebuchet == false then</p><p>                local PlayerID = Logic.EntityGetPlayer(v.ConstructedTrebuchet);</p><p>                AddOnInteractiveObjectTemplates.Global:ReturnTrebuchetToStorehouse(PlayerID, v.ConstructedTrebuchet);</p><p>            end</p><p>        end</p><p>        -- Stufe 3: Rückweg</p><p>        if v.ReturningCart ~= 0 then</p><p>            -- Rückkehrwagen wurde zerstört</p><p>            if not IsExisting(v.ReturningCart) then</p><p>                AddOnInteractiveObjectTemplates.Global.Data.Trebuchet.Sites[k].ReturningCart = 0;</p><p>                API.InteractiveObjectActivate(k);</p><p>            end</p><p>            local PlayerID = Logic.EntityGetPlayer(v.ReturningCart);</p><p>            local StoreID = Logic.GetStoreHouse(PlayerID);</p><p>            -- Rückkehrwagen muss sich zum Ziel bewegen</p><p>            if not Logic.IsEntityMoving(v.ReturningCart) then</p><p>                local x,y = Logic.GetBuildingApproachPosition(StoreID);</p><p>                Logic.MoveSettler(v.ReturningCart, x, y);</p><p>            end</p><p>            -- Rückkehrwagen kommt an</p><p>            if IsNear(v.ReturningCart, StoreID, 1100) then</p><p>                local PlayerID = Logic.EntityGetPlayer(v.ConstructionCart);</p><p>                DestroyEntity(v.ReturningCart);</p><p>            end</p><p>        end</p><p>    end</p><p>-- Erstellt eine Schatztruhe mit einer zufälligen Menge an Waren</p><p>-- des angegebenen Typs.</p><p>-- @param _Name [string] Name der zu ersetzenden Script Entity</p><p>-- @param _Good [number] Warentyp</p><p>-- @param _Min [number] Mindestmenge</p><p>-- @param _Max [number] Maximalmenge</p><p>-- @param _Callback [function] Callback-Funktion</p><p>-- @within Internal</p><p>-- @local</p><p>    _Min = (_Min ~= nil and _Min  0 and _Min) or 1;</p><p>    _Max = (_Max ~= nil and _Max  1 and _Max) or 2;</p><p>    if not _Callback then</p><p>        _Callback = function(t) end</p><p>    end</p><p>    assert(_Good ~= nil, "CreateRandomChest: Good does not exist!");</p><p>    assert(_Min  _Max, "CreateRandomChest: min amount must be smaller than max amount!");</p><p>    local eID = ReplaceEntity(_Name, Entities.XD_ScriptEntity, 0);</p><p>    Logic.SetModel(eID, Models.Doodads_D_X_ChestClose);</p><p>    Logic.SetVisible(eID, true);</p><p>    CreateObject {</p><p>        Name                    = _Name,</p><p>        Title                   = self.Data.Chests.Description.Title,</p><p>        Text                    = self.Data.Chests.Description.Text,</p><p>        Reward                  = {_Good, math.random(_Min, _Max)},</p><p>        Texture                 = {1, 6},</p><p>        Distance                = 650,</p><p>        State                   = 0,</p><p>        CallbackOpened          = _Callback,</p><p>        Callback                = function(_Data)</p><p>            ReplaceEntity(_Data.Name, Entities.D_X_ChestOpenEmpty);</p><p>            _Data.CallbackOpened(_Data);</p><p>        end,</p><p>    }</p><p>-- Erstellt eine Schatztruhe mit einer zufälligen Menge an Gold</p><p>-- des angegebenen Typs.</p><p>-- @param _Name [string] Name der zu ersetzenden Script Entity</p><p>-- @within Internal</p><p>-- @local</p><p>    AddOnInteractiveObjectTemplates.Global:CreateRandomChest(_Name, Goods.G_Gold, 300, 600);</p><p>-- Erstellt eine Schatztruhe mit einer zufälligen Art und Menge</p><p>-- an Gütern.</p><p>-- Güter können seien: Eisen, Fisch, Fleisch, Getreide, Holz,</p><p>-- Honig, Kräuter, Milch, Stein, Wolle.</p><p>-- @param _Name [string] Name der zu ersetzenden Script Entity</p><p>-- @within Internal</p><p>-- @local</p><p>    local PossibleGoods = {</p><p>        Goods.G_Iron, Goods.G_Stone, Goods.G_Wood, Goods.G_Wool,</p><p>        Goods.G_Carcass, Goods.G_Herb, Goods.G_Honeycomb,</p><p>        Goods.G_Milk, Goods.G_RawFish, Goods.G_Grain</p><p>    };</p><p>    local Good = PossibleGoods[math.random(1, #PossibleGoods)];</p><p>    AddOnInteractiveObjectTemplates.Global:CreateRandomChest(_Name, Good, 30, 60);</p><p>-- Erstellt eine Schatztruhe mit einer zufälligen Art und Menge</p><p>-- an Luxusgütern.</p><p>-- Luxusgüter können seien: Edelsteine, Farben, Musikinstrumente</p><p>-- Salz oder Weihrauch.</p><p>-- @param _Name [string] Name der zu ersetzenden Script Entity</p><p>-- @within Internal</p><p>-- @local</p><p>    local Luxury = {Goods.G_Salt, Goods.G_Dye};</p><p>    if g_GameExtraNo = 1 then</p><p>        table.insert(Luxury, Goods.G_Gems);</p><p>        table.insert(Luxury, Goods.G_MusicalInstrument);</p><p>        table.insert(Luxury, Goods.G_Olibanum);</p><p>    end</p><p>    local Good = Luxury[math.random(1, #Luxury)];</p><p>    AddOnInteractiveObjectTemplates.Global:CreateRandomChest(_Name, Good, 50, 100);</p><p>-- Erstelle eine Mine eines bestimmten Typs. Es können zudem eine Bedingung</p><p>-- und zwei verschiedene Callbacks vereinbart werden.</p><p>-- @param _Position [string] Script Entity, die mit Mine ersetzt wird</p><p>-- @param _Type [number] Typ der Mine</p><p>-- @param _Costs [table] (optional) Kostentabelle</p><p>-- @param _NotRefillable [boolean] (optional) Die Mine wird weiterhin überwacht</p><p>-- @param _Condition [function] (optional) Bedingungsfunktion</p><p>-- @param _CreationCallback (optional) Funktion nach Kauf ausführen</p><p>-- @param _CallbackDepleted (optional) Funktion nach Ausbeutung ausführen</p><p>-- @within Internal</p><p>-- @local</p><p>    -- Objekt austauschen und Model anpassen</p><p>    local eID = ReplaceEntity(_Position, Entities.XD_ScriptEntity);</p><p>    local Model = Models.Doodads_D_SE_ResourceIron_Wrecked;</p><p>    if _Type == Entities.R_StoneMine then</p><p>        Model = Models.R_SE_ResorceStone_10;</p><p>    end</p><p>    Logic.SetVisible(eID, true);</p><p>    Logic.SetModel(eID, Model);</p><p>    local x, y, z = Logic.EntityGetPos(eID);</p><p>    local BlockerID = Logic.CreateEntity(Entities.D_ME_Rock_Set01_B_07, x, y, 0, 0);</p><p>    Logic.SetVisible(BlockerID, false);</p><p>    CreateObject {</p><p>        Name                 = _Position,</p><p>        Title                = self.Data.Mines.Description.Title,</p><p>        Text                 = self.Data.Mines.Description.Text,</p><p>        Type                 = _Type,</p><p>        Special              = _NotRefillable,</p><p>        Costs                = _Costs,</p><p>        InvisibleBlocker     = BlockerID,</p><p>        Distance             = 1500,</p><p>        Condition            = self.ConditionBuildIOMine,</p><p>        CustomCondition      = _Condition,</p><p>        ConditionUnfulfilled = self.Data.Mines.Description.Unfulfilled,</p><p>        CallbackCreate       = _CreationCallback,</p><p>        CallbackDepleted     = _CallbackDepleted,</p><p>        Callback             = self.ActionBuildIOMine,</p><p>    };</p><p>-- Erstelle eine verschüttete Eisenmine.</p><p>-- @param _Position [string] Script Entity, die mit Mine ersetzt wird</p><p>-- @param _Cost1Type [number] (optional) Kostenware 1</p><p>-- @param _Cost1Amount [number] (optional) Kostenmenge 1</p><p>-- @param _Cost2Type [number] (optional) Kostenware 2</p><p>-- @param _Cost2Amount [number] (optional) Kostenmenge 2</p><p>-- @param _NotRefillable [boolean] (optional) Mine wird nach Ausbeutung zerstört</p><p>-- @within Internal</p><p>-- @local</p><p>    assert(IsExisting(_Position));</p><p>    if _Cost1Type then</p><p>        assert(API.TraverseTable(_Cost1Type, Goods));</p><p>        assert(type(_Cost1Amount) == "number");</p><p>    end</p><p>    if _Cost2Type then</p><p>        assert(API.TraverseTable(_Cost2Type, Goods));</p><p>        assert(type(_Cost2Amount) == "number");</p><p>    end</p><p>    self:CreateIOMine(</p><p>        _Position, Entities.R_IronMine,</p><p>        {_Cost1Type, _Cost1Amount, _Cost2Type, _Cost2Amount},</p><p>        _NotRefillable</p><p>    );</p><p>-- Erstelle eine verschüttete Steinmine.</p><p>-- @param _Position [string] Script Entity, die mit Mine ersetzt wird</p><p>-- @param _Cost1Type [number] (optional) Kostenware 1</p><p>-- @param _Cost1Amount [number] (optional) Kostenmenge 1</p><p>-- @param _Cost2Type [number] (optional) Kostenware 2</p><p>-- @param _Cost2Amount [number] (optional) Kostenmenge 2</p><p>-- @param _NotRefillable [boolean] (optional) Mine wird nach Ausbeutung zerstört</p><p>-- @within Internal</p><p>-- @local</p><p>    assert(IsExisting(_Position));</p><p>    if _Cost1Type then</p><p>        assert(API.TraverseTable(_Cost1Type, Goods));</p><p>        assert(type(_Cost1Amount) == "number");</p><p>    end</p><p>    if _Cost2Type then</p><p>        assert(API.TraverseTable(_Cost2Type, Goods));</p><p>        assert(type(_Cost2Amount) == "number");</p><p>    end</p><p>    self:CreateIOMine(</p><p>        _Position, Entities.R_StoneMine,</p><p>        {_Cost1Type, _Cost1Amount, _Cost2Type, _Cost2Amount},</p><p>        _NotRefillable</p><p>    );</p><p>-- Testet die Bedingung, unter der die Mine errichtet werden kann.</p><p>-- @param _Data Daten des Objektes</p><p>-- @return boolean: Bedingung erfüllt</p><p>-- @within Internal</p><p>-- @local</p><p>    if _Data.CustomCondition then</p><p>        return _Data.CustomCondition(_Data) == true;</p><p>    end</p><p>    return true;</p><p>    ReplaceEntity(_Data.Name, _Data.Type);</p><p>    DestroyEntity(_Data.InvisibleBlocker);</p><p>    if type(_Data.CallbackCreate) == "function" then</p><p>        _Data.CallbackCreate(_Data);</p><p>    end</p><p>    Trigger.RequestTrigger( Events.LOGIC_EVENT_EVERY_SECOND, "", "ControlIOMine", 1, {}, { _Data.Name });</p><p>-- Prüft gebaute Minen ob diese ausgebeutet sind. Ist das der Fall</p><p>-- werden sie "zerstört" und ggf. das Callback ausgelöst.</p><p>-- @param _Mine Zu überwachende Mine</p><p>-- @return boolean: Job beendet</p><p>-- @within Internal</p><p>-- @local</p><p>    if not IO[_Mine] then</p><p>        return true;</p><p>    end</p><p>    if not IsExisting(_Mine) then</p><p>        return true;</p><p>    end</p><p>    local eID = GetID(_Mine);</p><p>    if Logic.GetResourceDoodadGoodAmount(eID) == 0 then</p><p>        if IO[_Mine].Special == true then</p><p>            local Model = Models.Doodads_D_SE_ResourceIron_Wrecked;</p><p>            if IO[_Mine].Type == Entities.R_StoneMine then</p><p>                Model = Models.R_ResorceStone_Scaffold_Destroyed;</p><p>            end</p><p>            eID = ReplaceEntity(eID, Entities.XD_ScriptEntity);</p><p>            Logic.SetVisible(eID, true);</p><p>            Logic.SetModel(eID, Model);</p><p>        end</p><p>        if type(IO[_Mine].CallbackDepleted) == "function" then</p><p>            IO[_Mine].CallbackDepleted(IO[_Mine]);</p><p>        end</p><p>        return true;</p><p>    end</p><p>-- Initialisiert die interaktiven Baustellen.</p><p>-- @within Internal</p><p>-- @local</p><p>    if self.Data.ConstructionSiteActivated then</p><p>        return;</p><p>    end</p><p>    self.Data.ConstructionSiteActivated = true;</p><p>    Core:AppendFunction(</p><p>        "GameCallback_OnBuildingConstructionComplete",</p><p>        self.OnConstructionComplete</p><p>    );</p><p>-- Ruft das Callback einer Baustelle auf, sofern eins definiert wurde.</p><p>-- @param _PlayerID Besitzer des Gebäudes</p><p>-- @param _EntityID Entity-ID des Gebäudes</p><p>-- @within Internal</p><p>-- @local</p><p>    local IO = AddOnInteractiveObjectTemplates.Global.Data.ConstructionSite.Sites[_EntityID];</p><p>    if IO ~= nil and IO.CompletedCallback then</p><p>        IO.CompletedCallback(IO, _EntityID);</p><p>    end</p><p>-- Erzeugt eine echte Baustelle an der Position. Ein Siedler wird das Gebäude</p><p>-- aufbauen.</p><p>-- @param _Position [string] Zielpunkt</p><p>-- @param _PlayerID Besitzer des Gebäudes</p><p>-- @param _Type [number] Typ des Gebäudes</p><p>-- @param _Costs [table] (optional) Eigene Gebäudekosten</p><p>-- @param _Distance [number] (optional) Aktivierungsentfernung</p><p>-- @param _Icon [table] (optional) Icon des Schalters</p><p>-- @param _Title [string] (optional) Titel der Beschreibung</p><p>-- @param _Text [string] (optional) Text der Beschreibung</p><p>-- @param _Callback [function] (optional) Funktion nach fertigstellung</p><p>-- @within Internal</p><p>-- @local</p><p>    AddOnInteractiveObjectTemplates.Global:ConstructionSiteActivate();</p><p>    local Costs = _Costs or {Logic.GetEntityTypeFullCost(_Type)};</p><p>    local Title = _Title or self.Data.ConstructionSite.Description.Title;</p><p>    local Text  = Text or self.Data.ConstructionSite.Description.Text;</p><p>    local eID = GetID(_Position);</p><p>    Logic.SetModel(eID, Models.Buildings_B_BuildingPlot_10x10);</p><p>    Logic.SetVisible(eID, true);</p><p>    CreateObject {</p><p>        Name                 = _Position,</p><p>        Title                = Title,</p><p>        Text                 = Text,</p><p>        Texture              = _Icon or {14, 10},</p><p>        Distance             = _Distance or 1500,</p><p>        Type                 = _Type,</p><p>        Costs                = Costs,</p><p>        Condition            = AddOnInteractiveObjectTemplates.Global.ConditionConstructionSite,</p><p>        ConditionUnfulfilled = AddOnInteractiveObjectTemplates.Global.Data.ConstructionSite.Description.Unfulfilled,</p><p>        PlayerID             = _PlayerID,</p><p>        CompletedCallback    = _Callback,</p><p>        Callback             = AddOnInteractiveObjectTemplates.Global.CallbackIOConstructionSite;</p><p>    };</p><p>-- Lässt einen Siedler die Baustelle zum Gebäude aufbauen.</p><p>-- @param _Data Daten des Objekt</p><p>-- @within Internal</p><p>-- @local</p><p>    local pos  = GetPosition(_Data.Name);</p><p>    local eID  = GetID(_Data.Name);</p><p>    local ori  = Logic.GetEntityOrientation(eID);</p><p>    local site = Logic.CreateConstructionSite(pos.X, pos.Y, ori, _Data.Type, _Data.PlayerID);</p><p>    Logic.SetVisible(eID, false);</p><p>    if (site == nil) then</p><p>        API.Fatal('AddOnInteractiveObjectTemplates.Global:CreateIOBuildingSite: Failed to place construction site!');</p><p>        return;</p><p>    end</p><p>    AddOnInteractiveObjectTemplates.Global.Data.ConstructionSite.Sites[site] = _Data;</p><p>    StartSimpleJobEx(AddOnInteractiveObjectTemplates.Global.ControlConstructionSite, site);</p><p>-- Prüft ob das Gebäude theoretisch gebaut werden kann.</p><p>-- @param _Data Daten des Objekt</p><p>-- @return boolean: Kann aktiviert werden</p><p>-- @within Internal</p><p>-- @local</p><p>    local eID = GetID(_Data.Name);</p><p>    local tID = GetTerritoryUnderEntity(eID);</p><p>    local pID = Logic.GetTerritoryPlayerID(tID);</p><p>    if Logic.GetStoreHouse(_Data.PlayerID) == 0 then</p><p>        return false;</p><p>    end</p><p>    if _Data.PlayerID ~= pID then</p><p>        return false;</p><p>    end</p><p>    return true;</p><p>-- Überwacht eine Gebäudebaustelle und reaktiviert sie falls nötig.</p><p>-- @param _eID EntityID des Gebäudes</p><p>-- @return boolean: Job beenden</p><p>-- @within Internal</p><p>-- @local</p><p>    if AddOnInteractiveObjectTemplates.Global.Data.ConstructionSite.Sites[_eID] == nil then</p><p>        return true;</p><p>    end</p><p>    if not IsExisting(_eID) then</p><p>        local Name = AddOnInteractiveObjectTemplates.Global.Data.ConstructionSite.Sites[_eID].Name;</p><p>        Logic.SetVisible(GetID(Name), true);</p><p>        API.InteractiveObjectActivate(Name);</p><p>        return true;</p><p>    end</p><p>-- Local -----------------------------------------------------------------------</p><p>-- Initalisiert das AddOn.</p><p>-- @within Internal</p><p>-- @local</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/addonquestdebug.lua.html">
            <div class='doclink'>
                <div>AddOnQuestDebug</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia AddOnQuestDebug                                              # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Erweitert den mitgelieferten Debug des Spiels um eine Vielzahl nützlicher</p><p>-- neuer Möglichkeiten.</p><p>-- Die wichtigste Neuerung ist die Konsole, die es erlaubt Quests direkt über</p><p>-- die Eingabe von Befehlen zu steuern, einzelne Lua-Funktionen im Spiel</p><p>-- auszuführen und sogar komplette Skripte zu laden.</p><p>-- </p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>    Global =  {</p><p>        Data = {},</p><p>    },</p><p>    Local = {</p><p>        Data = {},</p><p>    },</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Aktiviert den Debug.</p><p>-- Der Developing Mode bietet viele Hotkeys und eine Konsole. Die Konsole ist</p><p>-- ein mächtiges Werkzeug. Es ist möglich tief in das Spiel einzugreifen und</p><p>-- sogar Funktionen während des Spiels zu überschreiben.</p><p>-- Die Konsole kann über  geöffnet werden.</p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- @param[type=boolean] _CheckAtRun Prüfe Quests zur Laufzeit</p><p>-- @param[type=boolean] _TraceQuests Aktiviert Questverfolgung</p><p>-- @param[type=boolean] _DevelopingCheats Aktiviert Cheats</p><p>-- @param[type=boolean] _DevelopingShell Aktiviert Eingabe</p><p>-- @see Reward_DEBUG</p><p>-- @within Anwenderfunktionen</p><p>function API.ActivateDebugMode(_CheckAtRun, _TraceQuests, _DevelopingCheats, _DevelopingShell)</p><p>    if GUI then</p><p>        API.Bridge("API.ActivateDebugMode(" ..tostring(_CheckAtRun).. ", " ..tostring(_TraceQuests).. ", " ..tostring(_DevelopingCheats).. ", " ..tostring(_DevelopingShell).. ")");</p><p>        return;</p><p>    end</p><p>    AddOnQuestDebug.Global:ActivateDebug(_CheckAtRun, _TraceQuests, _DevelopingCheats, _DevelopingShell);</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Rewards                                                                    --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Aktiviert den Debug.</p><p>-- @param[type=boolean] _CheckAtRun Prüfe Quests zur Laufzeit</p><p>-- @param[type=boolean] _TraceQuests Aktiviert Questverfolgung</p><p>-- @param[type=boolean] _DevelopingCheats Aktiviert Cheats</p><p>-- @param[type=boolean] _DevelopingShell Aktiviert Eingabe</p><p>-- @see API.ActivateDebugMode</p><p>-- @within Reward</p><p>    return b_Reward_DEBUG:new(...);</p><p>Reward_DEBUG</p><p>    Name = "Reward_DEBUG",</p><p>    Description = {</p><p>        en = "Reward: Start the debug mode. See documentation for more information.",</p><p>        de = "Lohn: Startet den Debug-Modus. Für mehr Informationen siehe Dokumentation.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Custom,     en = "Check quest while runtime", de = "Quests zur Laufzeit prüfen" },</p><p>        { ParameterType.Custom,     en = "Use quest trace", de = "Questverfolgung" },</p><p>        { ParameterType.Custom,     en = "Activate developing cheats", de = "Cheats aktivieren" },</p><p>        { ParameterType.Custom,     en = "Activate developing shell", de = "Eingabe aktivieren" },</p><p>    },</p><p>    return { Reward.Custom, {self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.CheckWhileRuntime = AcceptAlternativeBoolean(_Parameter)</p><p>    elseif (_Index == 1) then</p><p>        self.UseQuestTrace = AcceptAlternativeBoolean(_Parameter)</p><p>    elseif (_Index == 2) then</p><p>        self.DevelopingCheats = AcceptAlternativeBoolean(_Parameter)</p><p>    elseif (_Index == 3) then</p><p>        self.DevelopingShell = AcceptAlternativeBoolean(_Parameter)</p><p>    end</p><p>    API.ActivateDebugMode(self.CheckWhileRuntime, self.UseQuestTrace, self.DevelopingCheats, self.DevelopingShell);</p><p>    return {"true","false"};</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Global Script ---------------------------------------------------------------</p><p>-- Initalisiert das Bundle im globalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    AddOnQuestDebug.Global.Data.DebugCommands = {</p><p>        -- groupless commands</p><p>        {"clear",       AddOnQuestDebug.Global.Clear,},</p><p>        {"diplomacy",   AddOnQuestDebug.Global.Diplomacy,},</p><p>        {"restartmap",  AddOnQuestDebug.Global.RestartMap,},</p><p>        {"reveal",      AddOnQuestDebug.Global.ShareView,                1},</p><p>        {"conceal",     AddOnQuestDebug.Global.ShareView,                0},</p><p>        {"setposition", AddOnQuestDebug.Global.SetPosition,},</p><p>        {"version",     AddOnQuestDebug.Global.ShowVersion,},</p><p>        -- quest control</p><p>        {"win",         AddOnQuestDebug.Global.SetQuestState,            1},</p><p>        {"fail",        AddOnQuestDebug.Global.SetQuestState,            2},</p><p>        {"stop",        AddOnQuestDebug.Global.SetQuestState,            3},</p><p>        {"start",       AddOnQuestDebug.Global.SetQuestState,            4},</p><p>        {"restart",     AddOnQuestDebug.Global.SetQuestState,            5},</p><p>        {"won",         AddOnQuestDebug.Global.FindQuestsByState,        1},</p><p>        {"failed",      AddOnQuestDebug.Global.FindQuestsByState,        2},</p><p>        {"stoped",      AddOnQuestDebug.Global.FindQuestsByState,        3},</p><p>        {"active",      AddOnQuestDebug.Global.FindQuestsByState,        4},</p><p>        {"waiting",     AddOnQuestDebug.Global.FindQuestsByState,        5},</p><p>        {"find",        AddOnQuestDebug.Global.FindQuestsByState,        6},</p><p>        -- loading scripts into running game and execute them</p><p>        {"",          AddOnQuestDebug.Global.LoadScript,               true},</p><p>        {"",           AddOnQuestDebug.Global.LoadScript,               false},</p><p>        -- execute short lua commands</p><p>        {"",          AddOnQuestDebug.Global.ExecuteCommand,           true},</p><p>        {"",           AddOnQuestDebug.Global.ExecuteCommand,           false},</p><p>    }</p><p>    for k,v in pairs(_G) do</p><p>        if type(v) == "table" and v.Name and k == "b_"..v.Name and v.CustomFunction and not v.CustomFunction2 then</p><p>            v.CustomFunction2 = v.CustomFunction;</p><p>            v.CustomFunction = function(self, __quest_)</p><p>                if AddOnQuestDebug.Global.Data.CheckAtRun then</p><p>                    if self.DEBUG and not self.FOUND_ERROR and self:Debug(__quest_) then</p><p>                        self.FOUND_ERROR = true;</p><p>                    end</p><p>                end</p><p>                if not self.FOUND_ERROR then</p><p>                    return self:CustomFunction2(__quest_);</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>    self:OverwriteCreateQuests();</p><p>    API.AddSaveGameAction(self.OnSaveGameLoad);</p><p>-- Aktiviert den Debug.</p><p>-- Der Developing Mode bietet viele Hotkeys und eine Konsole. Die Konsole ist</p><p>-- ein mächtiges Werkzeug. Es ist möglich tief in das Spiel einzugreifen und</p><p>-- sogar Funktionen während des Spiels zu überschreiben.</p><p>-- @param _CheckAtRun [boolean] Prüfe Quests zur Laufzeit</p><p>-- @param _TraceQuests [boolean] Aktiviert Questverfolgung</p><p>-- @param _Cheats [boolean] Aktiviert Cheats</p><p>-- @param _Shell [boolean] Aktiviert Konsole</p><p>-- @within Internal</p><p>-- @local</p><p>    if self.Data.DebugModeIsActive then</p><p>        return;</p><p>    end</p><p>    self.Data.DebugModeIsActive = true;</p><p>    self.Data.CheckAtRun       = _CheckAtRun == true;</p><p>    self.Data.TraceQuests      = _TraceQuests == true;</p><p>    self.Data.DevelopingCheats = _Cheats == true;</p><p>    self.Data.DevelopingShell  = _Shell == true;</p><p>    self:ActivateQuestTrace();</p><p>    self:ActivateDevelopingCheats();</p><p>    self:ActivateDevelopingShell();</p><p>-- Aktiviert die Questverfolgung. Jede Statusänderung wird am Bildschirm</p><p>-- angezeigt.</p><p>-- @within Internal</p><p>-- @local</p><p>    if self.Data.TraceQuests then</p><p>        DEBUG_EnableQuestDebugKeys();</p><p>        DEBUG_QuestTrace(true);</p><p>    end</p><p>-- </p><p>-- </p><p>-- @within Internal</p><p>-- @local</p><p>    if self.Data.DevelopingCheats then</p><p>        Logic.ExecuteInLuaLocalState("AddOnQuestDebug.Local:ActivateDevelopingCheats()");</p><p>    end</p><p>-- </p><p>-- </p><p>-- </p><p>-- </p><p>-- @within Internal</p><p>-- @local</p><p>    if self.Data.DevelopingShell then</p><p>        Logic.ExecuteInLuaLocalState("AddOnQuestDebug.Local:ActivateDevelopingShell()");</p><p>    end</p><p>-- Ließt eingegebene Kommandos und führt entsprechende Funktionen aus.</p><p>-- Für die Zerlegung der Kommandizeile wird der Tokenizer benutzt.</p><p>-- Für die Nutzung im LuaDebugger des Spiels, müssen Kommandos mit</p><p>-- eval() aufgerufen werden.</p><p>-- @within Internal</p><p>-- @local</p><p>-- @see AddOnQuestDebug.Global:Tokenize</p><p>    local Results = {};</p><p>    local Commands = self:Tokenize(_Input);</p><p>    for k, v in pairs(Commands) do</p><p>        local Action = string.lower(v[1]);</p><p>        for i= 1, #AddOnQuestDebug.Global.Data.DebugCommands, 1 do</p><p>            if v[1] == AddOnQuestDebug.Global.Data.DebugCommands[i][1] then</p><p>                local SelectedCommand = AddOnQuestDebug.Global.Data.DebugCommands[i];</p><p>                for j=2, #v, 1 do</p><p>                    local Number = tonumber(v[j]);</p><p>                    if Number then</p><p>                        v[j] = Number;</p><p>                    end</p><p>                end</p><p>                local CommandResult = SelectedCommand[2](v, SelectedCommand[3]);</p><p>                if CommandResult then</p><p>                    table.insert(Results, CommandResult);</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>    return Results;</p><p>    return AddOnQuestDebug.Global:Parser(_Input);</p><p>-- Zerlegt den Eingabestring in einzelne Kommandos und gibt diese als Table</p><p>-- zurück. Unterschiedliche Kommandos werden mit && abgetrennt und entsprechend</p><p>-- als mehrere Einträge im Table angelegt. Mit dem Wiederholungszeichen &</p><p>-- wird das Komanndo für alle angegebenen Eingaben wiederholt.</p><p>-- Beispiel:</p><p>-- </p><p>-- Eingabe:</p><p>-- "win QuestA & QuestB && fail QuestC && stop QuestD & Quest E"</p><p>-- Ausgabe:</p><p>-- {</p><p>-- {"win", "QuestA"}</p><p>-- {"win", "QuestB"}</p><p>-- {"fail", "QuestC"}</p><p>-- {"stop", "QuestD"}</p><p>-- {"stop", "QuestE"}</p><p>-- }</p><p>-- @return Table mit Tokens</p><p>-- @within Internal</p><p>-- @local</p><p>    local Commands = {};</p><p>    local DAmberCommands = {_Input};</p><p>    local AmberCommands = {};</p><p>    -- parse & delimiter</p><p>    local s, e = string.find(_Input, "s+&&s+");</p><p>    if s then</p><p>        DAmberCommands = {};</p><p>        while (s) do</p><p>            local tmp = string.sub(_Input, 1, s-1);</p><p>            table.insert(DAmberCommands, tmp);</p><p>            _Input = string.sub(_Input, e+1);</p><p>            s, e = string.find(_Input, "s+&&s+");</p><p>        end</p><p>        if string.len(_Input)  0 then </p><p>            table.insert(DAmberCommands, _Input);</p><p>        end</p><p>    end</p><p>    -- parse & delimiter</p><p>    for i= 1, #DAmberCommands, 1 do</p><p>        local s, e = string.find(DAmberCommands[i], "s+&s+");</p><p>        if s then</p><p>            local LastCommand = "";</p><p>            while (s) do</p><p>                local tmp = string.sub(DAmberCommands[i], 1, s-1);</p><p>                table.insert(AmberCommands, LastCommand .. tmp);</p><p>                if string.find(tmp, " ") then</p><p>                    LastCommand = string.sub(tmp, 1, string.find(tmp, " ")-1) .. " ";</p><p>                end</p><p>                DAmberCommands[i] = string.sub(DAmberCommands[i], e+1);</p><p>                s, e = string.find(DAmberCommands[i], "s+&s+");</p><p>            end</p><p>            if string.len(DAmberCommands[i])  0 then </p><p>                table.insert(AmberCommands, LastCommand .. DAmberCommands[i]);</p><p>            end</p><p>        else</p><p>            table.insert(AmberCommands, DAmberCommands[i]);</p><p>        end</p><p>    end</p><p>    -- parse spaces</p><p>    for i= 1, #AmberCommands, 1 do</p><p>        local CommandLine = {};</p><p>        local s, e = string.find(AmberCommands[i], "s+");</p><p>        if s then</p><p>            while (s) do</p><p>                local tmp = string.sub(AmberCommands[i], 1, s-1);</p><p>                table.insert(CommandLine, tmp);</p><p>                AmberCommands[i] = string.sub(AmberCommands[i], e+1);</p><p>                s, e = string.find(AmberCommands[i], "s+");</p><p>            end</p><p>            table.insert(CommandLine, AmberCommands[i]);</p><p>        else</p><p>            table.insert(CommandLine, AmberCommands[i]);</p><p>        end</p><p>        table.insert(Commands, CommandLine);</p><p>    end</p><p>    return Commands;</p><p>-- Läd ein Lua-Skript in das Enviorment.</p><p>-- @within Internal</p><p>-- @local</p><p>    if _Arguments[2] then</p><p>        if _Flags == true then</p><p>            Logic.ExecuteInLuaLocalState([[Script.Load("]].._Arguments[2]..[[")]]);</p><p>        elseif _Flags == false then</p><p>            Script.Load(_Arguments[2]);</p><p>        end</p><p>        API.Note("load script ".._Arguments[2]);</p><p>    end</p><p>-- Ruft eine Funktion (optional mit Parametern) im Enviorment auf.</p><p>-- @within Internal</p><p>-- @local</p><p>    if _Arguments[2] then</p><p>        local args = "";</p><p>        for i=3,#_Arguments do</p><p>            args = args .. ((i3 and ",") or "");</p><p>            args = args .. " " .. _Arguments[i];</p><p>        end</p><p>        if _Flags == true then</p><p>            Logic.ExecuteInLuaLocalState([[]].. _Arguments[2] .. [[(]] ..args..[[)]]);</p><p>        elseif _Flags == false then</p><p>            Logic.ExecuteInLuaLocalState([[GUI.SendScriptCommand("]].. _Arguments[2] .. [[(]]..args..[[)")]]);</p><p>        end</p><p>    end</p><p>-- Konsolenbefehl: Leert das Debug Window.</p><p>-- @within Internal</p><p>-- @local</p><p>    Logic.ExecuteInLuaLocalState("GUI.ClearNotes()");</p><p>-- Konsolenbefehl: Ändert die Diplomatie zwischen zwei Spielern.</p><p>-- @within Internal</p><p>-- @local</p><p>    SetDiplomacyState(_Arguments[2], _Arguments[3], _Arguments[4]);</p><p>--  Konsolenbefehl: Startet die Map umgehend neu.</p><p>-- @within Internal</p><p>-- @local</p><p>    Logic.ExecuteInLuaLocalState("Framework.RestartMap()");</p><p>-- Konsolenbefehl: Aktiviert/deaktiviert die geteilte Sicht zweier Spieler.</p><p>-- @within Internal</p><p>-- @local</p><p>    Logic.SetShareExplorationWithPlayerFlag(_Arguments[2], _Arguments[3], _Flag);</p><p>-- Konsolenbefehl: Setzt die Position eines Entity.</p><p>-- @within Internal</p><p>-- @local</p><p>    local entity = GetID(_Arguments[2]);</p><p>    local target = GetID(_Arguments[3]);</p><p>    local x,y,z  = Logic.EntityGetPos(target);</p><p>    if Logic.IsBuilding(target) == 1 then</p><p>        x,y = Logic.GetBuildingApproachPosition(target);</p><p>    end</p><p>    Logic.DEBUG_SetSettlerPosition(entity, x, y);</p><p>    if Logic.IsLeader(entity) == 1 then</p><p>        local Soldiers = {Logic.GetSoldiersAttachedToLeader(entity)};</p><p>        for i= 1, #Soldiers, 1 do</p><p>            if isExisting(Soldiers[i]) then</p><p>                Logic.DEBUG_SetSettlerPosition(Soldiers[i], x, y);</p><p>            end</p><p>        end</p><p>    end</p><p>-- Konsolenbefehl: Zeigt die Version der QSB an.</p><p>-- @within Internal</p><p>-- @local</p><p>    API.Bridge("GUI.ClearNotes(); GUI.AddStaticNote(QSB.Version)");</p><p>    return QSB.Version;</p><p>-- Konsolenbefehl: Sucht nach allen Quests, auf die den angegebenen Namen</p><p>-- enthalten und gibt die Namen der gefundenen Quests zurück.</p><p>-- @within Internal</p><p>-- @local</p><p>    local FoundQuests = FindQuestsByName(_Pattern, _ExactName);</p><p>    if #FoundQuests == 0 then</p><p>        return {};</p><p>    end</p><p>    local NamesOfFoundQuests = {};</p><p>    for i= 1, #FoundQuests, 1 do</p><p>        table.insert(NamesOfFoundQuests, FoundQuests[i].Identifier);</p><p>    end</p><p>    return NamesOfFoundQuests;</p><p>-- Konsolenbefehl: Gibt die Namen aller Quests mit dem Status zurück. Die</p><p>-- Suche kann mit einem Pattern eingeschränkt werden. Es werden maximal 12</p><p>-- Quests angezeigt.</p><p>-- @within Internal</p><p>-- @local</p><p>    local QuestsOfState = {};</p><p>    for i= 1, Quests[0], 1 do</p><p>        if _Flag == 1 and Quests[i].Result == QuestResult.Success then</p><p>            table.insert(QuestsOfState, Quests[i]);</p><p>        end</p><p>        if _Flag == 2 and Quests[i].Result == QuestResult.Failure then</p><p>            table.insert(QuestsOfState, Quests[i]);</p><p>        end</p><p>        if _Flag == 3 and Quests[i].Result == QuestResult.Interrupted then</p><p>            table.insert(QuestsOfState, Quests[i]);</p><p>        end</p><p>        if _Flag == 4 and Quests[i].State == QuestState.Active then</p><p>            table.insert(QuestsOfState, Quests[i]);</p><p>        end</p><p>        if _Flag == 5 and Quests[i].State == QuestState.NotTriggered then</p><p>            table.insert(QuestsOfState, Quests[i]);</p><p>        end</p><p>        if _Flag == 6 and ((_Data[2] and string.find(Quests[i].Identifier, _Data[2])) or not _Data[2]) then</p><p>            table.insert(QuestsOfState, Quests[i]);</p><p>        end</p><p>    end</p><p>    local QuestNames = "";</p><p>    local Matching = 0;</p><p>    for i= 1, #QuestsOfState, 1 do</p><p>        if Matching  15 then</p><p>            if _Data[2] then</p><p>                if string.find(QuestsOfState[i].Identifier, _Data[2]) then</p><p>                    QuestNames = QuestNames .. "- " .. QuestsOfState[i].Identifier .. "{cr}";</p><p>                    Matching = Matching +1;</p><p>                end</p><p>            else</p><p>                QuestNames = QuestNames .. "- " .. QuestsOfState[i].Identifier .. "{cr}";</p><p>                Matching = Matching +1;</p><p>            end</p><p>        else</p><p>            QuestNames = QuestNames .. "... (" .. (#QuestsOfState-Matching) .. " more)";</p><p>            break;</p><p>        end</p><p>    end</p><p>    Logic.ExecuteInLuaLocalState([[</p><p>        GUI.ClearNotes()</p><p>        GUI.AddStaticNote("Found quests:{cr}]]..QuestNames..[[")</p><p>    ]]);</p><p>    return "Found quests:{cr}"..QuestNames;</p><p>-- Konsolenbefehl: Setzt den Status eines Quests. Mit der Statusänderung wird</p><p>-- ggf. Fortschrit zurückgesetzt.</p><p>-- @within Internal</p><p>-- @local</p><p>    local FoundQuests = AddOnQuestDebug.Global.FindQuestNames(_Data[2], true);</p><p>    if #FoundQuests ~= 1 then</p><p>        API.Note("Unable to find quest containing '" .._Data[2].. "'");</p><p>        return "Unable to find quest containing '" .._Data[2].. "'";</p><p>    end</p><p>    if _Flag == 1 then</p><p>        API.WinQuest(FoundQuests[1], true);</p><p>        API.Note("win quest '" ..FoundQuests[1].. "'");</p><p>        return "win quest '" ..FoundQuests[1].. "'"</p><p>    elseif _Flag == 2 then</p><p>        API.FailQuest(FoundQuests[1], true);</p><p>        API.Note("fail quest '" ..FoundQuests[1].. "'");</p><p>        return "fail quest '" ..FoundQuests[1].. "'"</p><p>    elseif _Flag == 3 then</p><p>        API.StopQuest(FoundQuests[1], true);</p><p>        API.Note("interrupt quest '" ..FoundQuests[1].. "'");</p><p>        return "interrupt quest '" ..FoundQuests[1].. "'";</p><p>    elseif _Flag == 4 then</p><p>        API.StartQuest(FoundQuests[1], true);</p><p>        API.Note("trigger quest '" ..FoundQuests[1].. "'");</p><p>        return "trigger quest '" ..FoundQuests[1].. "'";</p><p>    else</p><p>        API.RestartQuest(FoundQuests[1], true);</p><p>        API.Note("restart quest '" ..FoundQuests[1].. "'");</p><p>        return "restart quest '" ..FoundQuests[1].. "'";</p><p>    end</p><p>-- Überschreibt CreateQuests, sodass Assistentenquests über das Skript erzeugt</p><p>-- werden um diese sinnvoll überprüfen zu können.</p><p>-- @within Internal</p><p>-- @local</p><p>    AddOnQuestDebug.Global.Data.CreateQuestsOriginal = CreateQuests;</p><p>    CreateQuests = function()</p><p>        local QuestNames = Logic.Quest_GetQuestNames()</p><p>        for i=1, #QuestNames, 1 do</p><p>            local QuestName = QuestNames[i]</p><p>            local QuestData = {Logic.Quest_GetQuestParamter(QuestName)};</p><p>            -- Behavior ermitteln</p><p>            local Behaviors = {};</p><p>            local Amount = Logic.Quest_GetQuestNumberOfBehaviors(QuestName);</p><p>            if Amount  0 then</p><p>                for j=0, Amount-1, 1 do</p><p>                    local Name = Logic.Quest_GetQuestBehaviorName(QuestName, j);</p><p>                    local Template = GetBehaviorTemplateByName(Name);</p><p>                    assert(Template ~= nil);</p><p>                    local Parameters = Logic.Quest_GetQuestBehaviorParameter(QuestName, j);</p><p>                    table.insert(Behaviors, Template:new(unpack(Parameters)));</p><p>                end</p><p>                local SuggestionText;</p><p>                if (QuestData[6] and QuestData[6] ~= "" and QuestData[6] ~= "KEY(NO_MESSAGE)") then</p><p>                    SuggestionText = QuestData[6];</p><p>                end</p><p>                local SuccessText;</p><p>                if (QuestData[8] and QuestData[8] ~= "" and QuestData[8] ~= "KEY(NO_MESSAGE)") then</p><p>                    SuccessText = QuestData[8];</p><p>                end</p><p>                local FailureText;</p><p>                if (QuestData[7] and QuestData[7] ~= "" and QuestData[7] ~= "KEY(NO_MESSAGE)") then</p><p>                    FailureText = QuestData[7];</p><p>                end</p><p>                API.CreateQuest {</p><p>                    Name        = QuestName,</p><p>                    Sender      = QuestData[1],</p><p>                    Receiver    = QuestData[2],</p><p>                    Time        = QuestData[4],</p><p>                    Description = QuestData[5],</p><p>                    Suggestion  = SuggestionText,</p><p>                    Failure     = FailureText,</p><p>                    Success     = SuccessText,</p><p>                    unpack(Behaviors),</p><p>                };</p><p>            end</p><p>        end</p><p>    end</p><p>-- Stellt den Debug nach dem Laden eines Spielstandes wieder her.</p><p>-- @param _Arguments Argumente der überschriebenen Funktion</p><p>-- @param _Original  Referenz auf Save-Funktion</p><p>-- @within Internal</p><p>-- @local</p><p>    AddOnQuestDebug.Global:ActivateDevelopingCheats();</p><p>    AddOnQuestDebug.Global:ActivateDevelopingShell();</p><p>    AddOnQuestDebug.Global:ActivateQuestTrace();</p><p>-- Local Script ----------------------------------------------------------------</p><p>-- Initalisiert das Bundle im lokalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>-- Aktiviert die Development Cheats des Spiels.</p><p>-- @see AddOnQuestDebug.Global:ActivateDevelopingCheats</p><p>-- @within Internal</p><p>-- @local</p><p>    KeyBindings_EnableDebugMode(1);</p><p>    KeyBindings_EnableDebugMode(2);</p><p>    KeyBindings_EnableDebugMode(3);</p><p>    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft/GameClock",1);</p><p>-- Aktiviert die Kommandokonsole.</p><p>-- @see AddOnQuestDebug.Global:ActivateDevelopingShell</p><p>-- @within Internal</p><p>-- @local</p><p>    GUI_Chat.Abort = function() end</p><p>    GUI_Chat.Confirm = function()</p><p>        Input.GameMode();</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/ChatInput",0);</p><p>        AddOnQuestDebug.Local.Data.ChatBoxInput = XGUIEng.GetText("/InGame/Root/Normal/ChatInput/ChatInput");</p><p>        g_Chat.JustClosed = 1;</p><p>        Game.GameTimeSetFactor( GUI.GetPlayerID(), 1 );</p><p>    end</p><p>    QSB_DEBUG_InputBoxJob = function()</p><p>        if not AddOnQuestDebug.Local.Data.BoxShown then</p><p>            Input.ChatMode();</p><p>            Game.GameTimeSetFactor( GUI.GetPlayerID(), 0 );</p><p>            XGUIEng.ShowWidget("/InGame/Root/Normal/ChatInput", 1);</p><p>            XGUIEng.SetText("/InGame/Root/Normal/ChatInput/ChatInput", "");</p><p>            XGUIEng.SetFocus("/InGame/Root/Normal/ChatInput/ChatInput");</p><p>            AddOnQuestDebug.Local.Data.BoxShown = true</p><p>        elseif AddOnQuestDebug.Local.Data.ChatBoxInput then</p><p>            AddOnQuestDebug.Local.Data.ChatBoxInput = string.gsub(AddOnQuestDebug.Local.Data.ChatBoxInput,"'","\'");</p><p>            GUI.SendScriptCommand("AddOnQuestDebug.Global:Parser('"..AddOnQuestDebug.Local.Data.ChatBoxInput.."')");</p><p>            AddOnQuestDebug.Local.Data.BoxShown = nil;</p><p>            return true;</p><p>        end</p><p>    end</p><p>    Input.KeyBindDown(Keys.ModifierShift + Keys.OemPipe, "StartSimpleJob('QSB_DEBUG_InputBoxJob')", 2);</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/addonrandomrequests.lua.html">
            <div class='doclink'>
                <div>AddOnRandomRequests</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia AddOnRandomRequests                                          # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Dieses Bundle stellt zufällige Aufgaben durch NPC-Spieler bereit.</p><p>-- Es gibt verschiedene Typen von zufälligen Aufträgen. Es wird versucht, immer</p><p>-- einen einzigartigen Auftrag für den jeweiligen Auftraggeber zu erzeugen.</p><p>-- Wenn kein Auftrag erzeugt werden kann, wird der Spieler aufgefordert 2000</p><p>-- Gold zu bezahlen.</p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {</p><p>        Data = {</p><p>            RandomQuestNameCounter = 0;</p><p>            Claim = {},</p><p>            Deliver = {},</p><p>            Reputation = {},</p><p>            KnightTitle = {},</p><p>            Text = {</p><p>                Suggestion = {</p><p>                    {de = "Ihr müsst Euer Können unter Beweis stellen!",</p><p>                     en = "Please show us what you are capable of!"},</p><p>                    {de = "Bei diesem Problem benötigen wir Eure Unterstützung!",</p><p>                     en = "This problem is driving us nuts! Please help us!"},</p><p>                    {de = "Euer Volk braucht Eure Hilfe! Werdet Ihr uns helfen?",</p><p>                     en = "Your pepole demand your attantion. Will you help them?"},</p><p>                },</p><p>                Success = {</p><p>                    {de = "Wir möchten Euch von Herzen für Eure Hilfe danken!",</p><p>                     en = "Let us thank you from the bottem of out hearts!"},</p><p>                    {de = "Ihr habt bewiesen, dass man Euch vertrauen kann!",</p><p>                     en = "You have proven the trust we have in your, Milord!"},</p><p>                    {de = "Gott segne Euch! Wir sind gerettet!",</p><p>                     en = "God be praised! You saved us all!"},</p><p>                },</p><p>                Failure = {</p><p>                    {de = "Wir haben Euch vertraut! Mich deucht Euer Wort ist nichts wert!",</p><p>                     en = "We trusted you! So that is what your words are worth! Nothing!"},</p><p>                    {de = "Anführer! Es sind viele an der Zahl doch taugen alle wenig!",</p><p>                     en = "Leaders! They are many but they can't even tie their shoes!"},</p><p>                    {de = "Ein Herrscher wollt Ihr sein? Lernt das Volk zu schätzen!",</p><p>                     en = "You call yourself a ruler? Go and remember the needs of the pepole!"},</p><p>                },</p><p>            }</p><p>        },</p><p>    },</p><p>    Local = {},</p><p>-- Global ----------------------------------------------------------------------</p><p>-- Initalisiert das AddOn.</p><p>-- @within Internal</p><p>-- @local</p><p>-- Erzeugt einen zufälligen Slave Quest anhand der Einstellungen im Quest.</p><p>-- @param[type=table] _Behavior Behavior Data</p><p>-- @param[type=table] _Quest    Quest Data</p><p>-- @within Internal</p><p>-- @local</p><p>    if not _Behavior.SlaveQuest then</p><p>        local QuestGoals = self:GetPossibleBehaviors(_Behavior, _Quest);</p><p>        -- Fallback</p><p>        if #QuestGoals == 0 then</p><p>            QuestGoals[#QuestGoals+1] = {"Goal_Deliver", "G_Gold", 2000};</p><p>        end</p><p>        local SelectedGoal = QuestGoals[math.random(1, #QuestGoals)];</p><p>        local FunctionName = table.remove(SelectedGoal, 1);</p><p>        self.Data.RandomQuestNameCounter = self.Data.RandomQuestNameCounter +1;</p><p>        local QuestName = API.CreateQuest {</p><p>            Name        = "RandomRequest_Player" .._Quest.SendingPlayer.. "_" ..self.Data.RandomQuestNameCounter;</p><p>            Suggestion  = _Behavior.OptionalSuggestion or self.Data.Text.Suggestion[math.random(1, 3)],</p><p>            Success     = _Behavior.OptionalSuccess or self.Data.Text.Success[math.random(1, 3)],</p><p>            Failure     = _Behavior.OptionalFailure or self.Data.Text.Failure[math.random(1, 3)],</p><p>            Receiver    = _Quest.ReceivingPlayer,</p><p>            Sender      = _Quest.SendingPlayer,</p><p>            Time        = _Behavior.TimeLimit,</p><p>            _G[FunctionName](unpack(SelectedGoal)),</p><p>            Trigger_Time(0),</p><p>        };</p><p>        _Behavior.SlaveQuest = Quests[GetQuestID(QuestName)];</p><p>    end</p><p>-- Gibt eine Liste mit Behavior zurück, die für den Random Quest verfügbar</p><p>-- sind. Es wird eines der Behavior ausgewählt.</p><p>-- @param[type=table] _Behavior Behavior Data</p><p>-- @param[type=table] _Quest    Quest Data</p><p>-- @within Internal</p><p>-- @local</p><p>    local QuestGoals = {};</p><p>    if _Behavior.TypeDeliverGoods then</p><p>        QuestGoals[#QuestGoals+1] = self:GetDeliverGoodsBehavior(_Behavior, _Quest);</p><p>    end</p><p>    if _Behavior.TypeDeliverGold then</p><p>        local Amount = math.random(150, 225) * (Logic.GetKnightTitle(_Quest.ReceivingPlayer) +1);</p><p>        QuestGoals[#QuestGoals+1] = {"Goal_Deliver", "G_Gold", Amount};</p><p>    end</p><p>    if _Behavior.TypeClaim then</p><p>        QuestGoals[#QuestGoals+1] = self:GetClaimTerritoryBehavior(_Behavior, _Quest);</p><p>    end</p><p>    if _Behavior.TypeKnightTitle then</p><p>        QuestGoals[#QuestGoals+1] = self:GetKnightTitleBehavior(_Behavior, _Quest);</p><p>    end</p><p>    if _Behavior.TypeReputation then</p><p>        self.Data.KnightTitle[_Quest.ReceivingPlayer] = self.Data.KnightTitle[_Quest.ReceivingPlayer] or {};</p><p>        local Reputation = 25 + (10 * Logic.GetKnightTitle(_Quest.ReceivingPlayer));</p><p>        if self.Data.KnightTitle[_Quest.ReceivingPlayer][Reputation] then</p><p>            return QuestGoals;</p><p>        end</p><p>        self.Data.KnightTitle[_Quest.ReceivingPlayer][Reputation] = true;</p><p>        QuestGoals[#QuestGoals+1] = {"Goal_CityReputation", Reputation};</p><p>    end</p><p>    if _Behavior.TypeBuildWall then</p><p>        QuestGoals[#QuestGoals+1] = self:GetBuildWallBehavior(_Behavior, _Quest);</p><p>    end</p><p>    return QuestGoals;</p><p>-- Erstellt Goal_KnightTitle für den Random Quest.</p><p>-- @param[type=table] _Behavior Behavior Data</p><p>-- @param[type=table] _Quest    Quest Data</p><p>-- @within Internal</p><p>-- @local</p><p>    if Logic.GetKnightTitle(_Quest.ReceivingPlayer)  KnightTitles.Archduke then</p><p>        local PossibleTitles = {"Mayor", "Baron", "Earl", "Marquees", "Duke", "Archduke"};</p><p>        local NextTitle = PossibleTitles[Logic.GetKnightTitle(_Quest.ReceivingPlayer)+1];</p><p>        self.Data.KnightTitle[_Quest.ReceivingPlayer] = self.Data.KnightTitle[_Quest.ReceivingPlayer] or {};</p><p>        if self.Data.KnightTitle[_Quest.ReceivingPlayer][NextTitle] then</p><p>            return;</p><p>        end</p><p>        self.Data.KnightTitle[_Quest.ReceivingPlayer][NextTitle] = true;</p><p>        return {"Goal_KnightTitle", NextTitle};</p><p>    end </p><p>-- Erstellt Goal_BuildWall für den Random Quest.</p><p>-- @param[type=table] _Behavior Behavior Data</p><p>-- @param[type=table] _Quest    Quest Data</p><p>-- @within Internal</p><p>-- @local</p><p>    local FirstEnemy;</p><p>    for i= 1, 8, 1 do</p><p>        if i ~= _Quest.SendingPlayer and i ~= _Quest.ReceivingPlayer and DiplomaticEntity.GetRelationBetween(i, _Quest.ReceivingPlayer) == DiplomacyStates.Enemy then</p><p>            FirstEnemy = i;</p><p>            break;</p><p>        end</p><p>    end</p><p>    if FirstEnemy then</p><p>        local SPStorehouse = Logic.GetStoreHouse(_Quest.SendingPlayer);</p><p>        local RPStorehouse = Logic.GetStoreHouse(_Quest.ReceivingPlayer);</p><p>        return {"Goal_BuildWall", FirstEnemy, RPStorehouse, SPStorehouse};</p><p>    end</p><p>-- Erstellt Goal_Claim für den Random Quest.</p><p>-- @param[type=table] _Behavior Behavior Data</p><p>-- @param[type=table] _Quest    Quest Data</p><p>-- @within Internal</p><p>-- @local</p><p>    local AllTerritories = {Logic.GetTerritories()};</p><p>    self.Data.Claim[_Quest.ReceivingPlayer] = self.Data.Claim[_Quest.ReceivingPlayer] or {};</p><p>    for i= #AllTerritories, 1, -1 do</p><p>        if self.Data.Claim[_Quest.ReceivingPlayer][NextTitle] then</p><p>            return;</p><p>        end</p><p>        if AllTerritories[i] == 0 or Logic.GetTerritoryPlayerID(AllTerritories[i]) ~= 0 </p><p>        or self.Data.Claim[_Quest.ReceivingPlayer][AllTerritories[i]] then</p><p>            table.remove(AllTerritories, i);</p><p>        end</p><p>    end</p><p>    if #AllTerritories  0 then</p><p>        local Territory = AllTerritories[math.random(1, #AllTerritories)];</p><p>        self.Data.Claim[_Quest.ReceivingPlayer][Territory] = true;</p><p>        return {"Goal_Claim", AllTerritories[math.random(1, #AllTerritories)]};</p><p>    end</p><p>-- Erstellt Goal_Deliver (Rohstoffe) für den Random Quest.</p><p>-- @param[type=table] _Behavior Behavior Data</p><p>-- @param[type=table] _Quest    Quest Data</p><p>-- @within Internal</p><p>-- @local</p><p>    local GoodTypes = {</p><p>        "G_Wood", "G_Iron", "G_Stone", "G_Carcass", "G_Herb", "G_Wool",</p><p>        "G_Honeycomb", "G_Grain", "G_Milk", "G_RawFish"</p><p>    };</p><p>    local Receiver = _Quest.ReceivingPlayer;</p><p>    local Sender   = _Quest.SendingPlayer;</p><p>    self.Data.Deliver[Receiver] = self.Data.Deliver[Receiver] or {};</p><p>    self.Data.Deliver[Receiver][Sender] = self.Data.Deliver[Receiver][Sender] or {};</p><p>    local SelectedGood;</p><p>    repeat</p><p>        SelectedGood = GoodTypes[math.random(1, #GoodTypes)];</p><p>    until (self:CanGoodBeSetAsGoal(Sender, Receiver, Goods[SelectedGood]));</p><p>    local Amount = math.random(15, 25) * (Logic.GetKnightTitle(Receiver) +1);</p><p>    self.Data.Deliver[Receiver][Sender][Goods[SelectedGood]] = true;</p><p>    return {"Goal_Deliver", SelectedGood, Amount};</p><p>-- Prüft, ob eine Ware für ein Goal_Deliver verwendet werden kann.</p><p>-- @param[type=number] _SenderID   Sendender Spieler</p><p>-- @param[type=number] _ReceiverID Empfangender Spieler</p><p>-- @param[type=number] _Good       Warentyp</p><p>-- @return[type=boolean] Ware kann benutzt werden.</p><p>-- @within Internal</p><p>-- @local</p><p>    if self.Data.Deliver[_ReceiverID][_SenderID][_Good] then</p><p>        return false;</p><p>    end</p><p>    if MerchantSystem.TradeBlackList[_SenderID] then</p><p>        for k, v in pairs(MerchantSystem.TradeBlackList[_SenderID]) do</p><p>            if v == _Good then</p><p>                return false;</p><p>            end</p><p>        end</p><p>    end</p><p>    return true;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Wählt einen zufälligen Auftrag für den Spieler aus. Über die Parameter kann</p><p>-- bestimmt werden, welche Typen von Aufträgen erscheinen können. Dieses</p><p>-- Behavior sollte in versteckten Quests benutzt werden.</p><p>-- Tribute und Warenanforderungen steigen in der Menge mit höherem Titel</p><p>-- des Auftragnehmers.</p><p>-- : Das Behavior erzeugt einen weiteren Quest mit dem zufällig</p><p>-- gewählten Ziel. Somit ist es mit den Tribut-Quests vergleichbar.</p><p>-- @param[type=boolean] _DeliverGoods   Ziel: Waren liefern</p><p>-- @param[type=boolean] _DeliverGold    Ziel: Tribut bezahlen</p><p>-- @param[type=boolean] _ClaimTerritory Ziel: Territorium erobern</p><p>-- @param[type=boolean] _KnightTitle    Ziel: Nächst höherer Titel</p><p>-- @param[type=boolean] _CityReputation Ziel: Ruf der Stadt</p><p>-- @param[type=number]  _Time           Zeit bis zur Niederlage (0 = aus)</p><p>-- @param[type=string]  _Suggestion     (optional) Startnachricht</p><p>-- @param[type=string]  _Success        (optional) Erfolgsnachricht</p><p>-- @param[type=string]  _Failure        (optional) Fehlschlagnachricht</p><p>-- @within Goal</p><p>    return b_Goal_RandomRequest:new(...);</p><p>Goal_RandomRequest</p><p>    Name = "Goal_RandomRequest",</p><p>    Description = {</p><p>        en = "Goal: Der Spieler erhält einen zufällig generierten Auftrag, der erfüllt werden muss. Über die Parameter wird bestimmt, welche Typen von Aufträgen möglich sind. Tipp: Für versteckten Quest nutzen!",</p><p>        de = "Ziel: The player receives an randomly generated quest that he needs to complete. Define which types of quest possibly appear by setting the parameters. Tip: Use this quest as invisible quest!",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Custom,  en = "Deliver goods",           de = "Waren liefern" },</p><p>        { ParameterType.Custom,  en = "Pay tribute",             de = "Tribut entrichten" },</p><p>        { ParameterType.Custom,  en = "Claim territory",         de = "Territorium beanspruchen" },</p><p>        { ParameterType.Custom,  en = "Knight title",            de = "Titel erreichen" },</p><p>        { ParameterType.Custom,  en = "City reputation",         de = "Ruf der Stadt" },</p><p>        { ParameterType.Custom,  en = "Build rampart",           de = "Festung bauen" },</p><p>        { ParameterType.Number,  en = "Time limit (0 = off)",    de = "Leitlimit (0 = aus)" },</p><p>        { ParameterType.Default, en = "(optional) Mission text", de = "(optional) Auftragsnachricht" },</p><p>        { ParameterType.Default, en = "(optional) Success text", de = "(optional) Erfolgsnachricht" },</p><p>        { ParameterType.Default, en = "(optional) Failure text", de = "(optional) Fehlschlagsnachricht" },</p><p>    },</p><p>    return {Objective.Custom2, {self, self.CustomFunction}};</p><p>    if (_Index == 0) then</p><p>        self.TypeDeliverGoods = API.ToBoolean(_Parameter);</p><p>    elseif (_Index == 1) then</p><p>        self.TypeDeliverGold = API.ToBoolean(_Parameter);</p><p>    elseif (_Index == 2) then</p><p>        self.TypeClaim = API.ToBoolean(_Parameter);</p><p>    elseif (_Index == 3) then</p><p>        self.TypeKnightTitle = API.ToBoolean(_Parameter);</p><p>    elseif (_Index == 4) then</p><p>        self.TypeReputation = API.ToBoolean(_Parameter);</p><p>    elseif (_Index == 5) then</p><p>        self.TypeBuildWall = API.ToBoolean(_Parameter);</p><p>    elseif (_Index == 6) then</p><p>        self.TimeLimit = _Parameter * 1;</p><p>    elseif (_Index == 7) then</p><p>        if _Parameter and _Parameter ~= "" then</p><p>            self.OptionalSuggestion = _Parameter;</p><p>        end</p><p>    elseif (_Index == 8) then</p><p>        if _Parameter and _Parameter ~= "" then</p><p>            self.OptionalSuccess = _Parameter;</p><p>        end</p><p>    elseif (_Index == 9) then</p><p>        if _Parameter and _Parameter ~= "" then</p><p>            self.OptionalFailure = _Parameter;</p><p>        end</p><p>    end</p><p>    return {"true", "false"};</p><p>    AddOnRandomRequests.Global:CreateSlaveQuest(self, _Quest);</p><p>    if self.SlaveQuest and self.SlaveQuest.Result == QuestResult.Success then</p><p>        return true;</p><p>    end</p><p>    if self.SlaveQuest and self.SlaveQuest.Result == QuestResult.Failure then</p><p>        return false;</p><p>    end</p><p>    self:Interrupt(_Quest);</p><p>    if self.SlaveQuest then</p><p>        API.RestartQuest(self.SlaveQuest.Identifier, false);</p><p>    end</p><p>    if self.SlaveQuest and self.SlaveQuest.State == QuestState.Active then</p><p>        API.StopQuest(self.SlaveQuest.Identifier, false);</p><p>    end</p><p>    if (type(self.TimeLimit) ~= "number" or self.TimeLimit  0) then </p><p>        API.Fatal(_Quest.Identifier.. ": " ..self.Name.. ": Time limit must be a number and at least 0!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/addoncutscenesystem.lua.html">
            <div class='doclink'>
                <div>AddonCutsceneSystem</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia AddOnCutsceneSystem                                          # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Mit diesem Modul können Cutscenes abgespielt werden.</p><p>-- </p><p>-- </p><p>-- Cutscenes sind als CS-Datei vordefinierte Kameraflüge. Mit diesem Modul</p><p>-- können diese Kameraflüge gruppiert werden. Diese Gruppierung ist das, was</p><p>-- die Cutscene ausmacht.</p><p>-- Pro Flug können Titel und Text eingeblendet werden und eine Lua-Funktion</p><p>-- aufgerufen werden.</p><p>-- Flights können entweder im Internal-Mode des Mapeditors oder über externe</p><p>-- Tools erzeugt werden. Sie müssen jedoch immer in das Hauptverzeichnis der</p><p>-- Map kopiert werden.</p><p>-- </p><p>-- Gibt Deinen Flights passende Namen, um die Zuordnung zu erleichtern.</p><p>-- cs01_flight1.cs</p><p>-- Während der Mapentwicklung können die CS-Dateien nicht in der Map liegen,</p><p>-- da sie bei jedem Speichern gelöscht werden. Wenn die Datei nicht vorhanden</p><p>-- ist, wird der Flight übersprungen. Sind also keine Flights da, gilt die</p><p>-- Cutscene trotzdem als abgespielt, sobald sie beendet ist. Das erleichtert</p><p>-- das Testen. Du siehst nur nix.</p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet eine Cutscene.</p><p>-- Die einzelnen Flights einer Cutscene werden als CS-Dateien definiert.</p><p>-- Eine Cutscene besteht aus den einzelnen Flights und speziellen Feldern, mit</p><p>-- denen weitere Einstellungen gemacht werden können. Siehe dazu auch das</p><p>-- Briefing System für einen Vergleich.</p><p>-- Das Gerüst für eine Cutscene sieht wie folgt aus:</p><p>-- local Cutscene = {</p><p>--    CameraLookAt = {X, Y},   -- Kameraposition am Ende setzen</p><p>--    RestoreGameSpeed = true, -- Spielgeschwindigkeit wiederherstellen</p><p>--    TransperentBars = false, -- Durchsichtige Bars verwenden</p><p>--    HideBorderPins = true,   -- Grenzsteine ausblenden</p><p>--    FastForward = false,     -- Beschleunigt abspielen erlauben</p><p>--    ... -- Hier nacheinander die Flights auflisten</p><p>--    Starting = function(_Data)</p><p>--        -- Hier werden Aktionen vor dem Start ausgeführt.</p><p>--    end,</p><p>--    Finished = function(_Data)</p><p>--        -- Hier kann eine abschließende Aktion ausgeführt werden.</p><p>--    end</p><p>-- Die einzelnen Flights werden nacheinander als Tables angegeben:</p><p>-- {</p><p>--    Flight = "some_file", -- .cs wird nicht mit angegeben!</p><p>--    Title  = "Angezeigter Titel",</p><p>--    Text   = "Angezeigter Text",</p><p>--    Action = function(_Data)</p><p>--        -- Aktion für den Flight ausführen</p><p>--    end,</p><p>-- Ersetze ... mit den Flights, die zur Cutscene gehören sollen.</p><p>-- Die Funktion gibt die ID der Cutscene zurück, mit der geprüft werden kann,</p><p>-- ob die Cutscene beendet ist.</p><p>-- </p><p>-- : StartCutscene</p><p>-- @param[type=table]   _Cutscene Cutscene table</p><p>-- @return[type=number] ID der Cutscene</p><p>-- @within Anwenderfunktionen</p><p>function API.CutsceneStart(_Cutscene)</p><p>    if GUI then</p><p>        fatal("API.CutsceneStart: Cannot start cutscene from local script!");</p><p>        return;</p><p>    end</p><p>    -- Lokalisierung Texte</p><p>    local Language = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>    for i= 1, #_Cutscene, 1 do</p><p>        if _Cutscene[i].Title and type(_Cutscene[i].Title) == "table" then</p><p>            _Cutscene[i].Title = _Cutscene[i].Title[Language];</p><p>        end</p><p>        if _Cutscene[i].Text and type(_Cutscene[i].Text) == "table" then</p><p>            _Cutscene[i].Text = _Cutscene[i].Text[Language];</p><p>        end</p><p>    end</p><p>    return AddOnCutsceneSystem.Global:StartCutscene(_Cutscene);</p><p>-- Prüft, ob zur Zeit eine Cutscene aktiv ist.</p><p>-- </p><p>-- : IsCutsceneActive</p><p>-- </p><p>-- @return[type=boolean] Cutscene aktiv</p><p>-- @within Anwenderfunktionen</p><p>function API.CutsceneIsActive()</p><p>    if GUI then</p><p>        return AddOnCutsceneSystem.Local:IsCutsceneActive();</p><p>    end</p><p>    return AddOnCutsceneSystem.Global:IsCutsceneActive();</p><p>-- Setzt die Geschwindigkeit für den schnellen Vorlauf für alle Cutscenes.</p><p>-- Beim schnellen Vorlauf wird eine Cutscene beschleunigt abgespielt.</p><p>-- : SetCutsceneFastForwardSpeed</p><p>-- </p><p>-- @param[type=number] _Speed Geschwindigkeit</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.CutsceneSetFastForwardSpeed(6);</p><p>function API.CutsceneSetFastForwardSpeed(_Speed)</p><p>    if not GUI then</p><p>        API.Bridge("API.CutsceneSetFastForwardSpeed(" .._Speed.. ")");</p><p>        return;</p><p>    end</p><p>    AddOnCutsceneSystem.LoadScreenVisible.Data.FastForward.Speed = _Speed;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {</p><p>        Data = {</p><p>            CurrentCutscene = {},</p><p>            CutsceneQueue = {},</p><p>            CutsceneActive = false,</p><p>        },</p><p>    },</p><p>    Local = {</p><p>        Data = {</p><p>            CurrentCutscene = {},</p><p>            CurrentFlight = 1,</p><p>            CutsceneActive = false,</p><p>            CinematicActive = false,</p><p>            FastForward = {</p><p>                Active = false,</p><p>                Indent = 1,</p><p>                Speed = 15,</p><p>            },</p><p>            Fader = {</p><p>                From = 1.0,</p><p>                To = 0.0,</p><p>                TimeStamp = 0,</p><p>                Duration = 0,</p><p>                Callback = nil,</p><p>                Widget = "/InGame/Fader/Element",      </p><p>                Page = "/InGame/Fader" </p><p>            }</p><p>        },</p><p>    },</p><p>    Text = {</p><p>        FastForwardActivate   = {de = "Beschleunigen", en = "Fast Forward"},</p><p>        FastForwardDeactivate = {de = "Zurücksetzen",  en = "Normal Speed"},</p><p>        FastFormardMessage    = {de = "SCHNELLER VORLAUF",  en = "FAST FORWARD"},</p><p>    }</p><p>-- Global Script ---------------------------------------------------------------</p><p>-- Initalisiert das Bundle im globalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>-- Startet die Cutscene im globalen Skript. Es wird eine neue ID für die</p><p>-- Cutscene erzeugt und zurückgegeben. Die Cutscehe wird als CurrentCutscene</p><p>-- gespeichert und in das lokale Skript kopiert.</p><p>-- Damit keine Briefings starten, wird die entsprechende Variable im</p><p>-- Briefingsystem true gesetzt.</p><p>-- @param[type=table]   _Cutscene Cutscene table</p><p>-- @return[type=number] ID der Cutscene</p><p>-- @within Internal</p><p>-- @local</p><p>    if not self.Data.LoadScreenHidden or self:IsCutsceneActive() then</p><p>        table.insert(self.Data.CutsceneQueue, _Cutscene);</p><p>        if not self.Data.CutsceneQueueJobID then</p><p>            self.Data.CutsceneQueueJobID = StartSimpleHiResJobEx(AddOnCutsceneSystem.Global.CutsceneQueueController);</p><p>        end</p><p>        return;</p><p>    end</p><p>    if _Cutscene.Starting then</p><p>        _Cutscene:Starting();</p><p>    end</p><p>    BundleBriefingSystem.Global.Data.BriefingID = BundleBriefingSystem.Global.Data.BriefingID +1;</p><p>    self.Data.CurrentCutscene = _Cutscene;</p><p>    self.Data.CurrentCutscene.ID = BundleBriefingSystem.Global.Data.BriefingID;</p><p>    local Cutscene = API.ConvertTableToString(self.Data.CurrentCutscene);</p><p>    API.Bridge("AddOnCutsceneSystem.Local:StartCutscene(" ..Cutscene.. ")");</p><p>    self.Data.CutsceneActive = true;</p><p>    BundleBriefingSystem.Global.Data.BriefingActive = true;</p><p>    BundleBriefingSystem.Global.Data.DisplayIngameCutscene = true;</p><p>    return BundleBriefingSystem.Global.Data.BriefingID;</p><p>-- Stoppt die Cutscene im globalen Skript. Falls eine Finished-Funktion für</p><p>-- die Cutscene definiert ist, wird diese ausgeführt. Wenn weitere Cutscenes</p><p>-- in der Warteschlange stehen, wird die nächste Cutscene gestartet. Die</p><p>-- aktuelle Cutscene wird als beendet vermerkt.</p><p>-- Das Starten von Briefings wird wieder erlaubt.</p><p>-- @within Internal</p><p>-- @local</p><p>    if self.Data.CurrentCutscene.Finished then</p><p>        self.Data.CurrentCutscene:Finished();</p><p>    end</p><p>    self.Data.CutsceneActive = false;</p><p>    BundleBriefingSystem.Global.Data.BriefingActive = false;</p><p>    BundleBriefingSystem.Global.Data.DisplayIngameCutscene = false;</p><p>    local CutsceneID = self.Data.CurrentCutscene.ID;</p><p>    BundleBriefingSystem.Global.Data.FinishedBriefings[CutsceneID] = true;</p><p>    API.Bridge("AddOnCutsceneSystem.Local:StopCutscene()");</p><p>-- Prüft, ob eine Cutscene aktiv ist.</p><p>-- @param[type=boolean] Cutscene ist aktiv</p><p>-- @within Internal</p><p>-- @local</p><p>    return IsBriefingActive() == true or self.Data.CutsceneActive == true;</p><p>-- Steuert die Cutscene-Warteschlange.</p><p>-- @within Internal</p><p>-- @local</p><p>    if #AddOnCutsceneSystem.Global.Data.CutsceneQueue == 0 then</p><p>        AddOnCutsceneSystem.Global.Data.CutsceneQueueJobID = nil;</p><p>        return true;</p><p>    end</p><p>    </p><p>    if AddOnCutsceneSystem.Global.Data.LoadScreenHidden and not AddOnCutsceneSystem.Global:IsCutsceneActive() then</p><p>        local Next = table.remove(AddOnCutsceneSystem.Global.Data.CutsceneQueue, 1);</p><p>        AddOnCutsceneSystem.Global:StartCutscene(Next);</p><p>    end</p><p>-- Local Script ----------------------------------------------------------------</p><p>-- Initalisiert das Bundle im lokalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    StartSimpleHiResJobEx(AddOnCutsceneSystem.Local.WaitForLoadScreenHidden);</p><p>    StartSimpleHiResJobEx(AddOnCutsceneSystem.Local.DisplayFastForwardMessage);</p><p>    self:OverrideUpdateFader();</p><p>-- Startet die Cutscene im lokalen Skript. Die Spielansicht wird versteckt</p><p>-- und der Cinematic Mode aktiviert.</p><p>-- @param[type=table] _Cutscene Cutscene table</p><p>-- @within Internal</p><p>-- @local</p><p>    BundleBriefingSystem.Local.Data.DisplayIngameCutscene = true;</p><p>    self.Data.CurrentFlight = 1;</p><p>    self.Data.CurrentCutscene = _Cutscene;</p><p>    self.Data.CutsceneActive = true;</p><p>    </p><p>    Display.SetRenderSky(1);</p><p>    if self.Data.CurrentCutscene.HideBorderPins then</p><p>        Display.SetRenderBorderPins(0);</p><p>    end</p><p>    if Game.GameTimeGetFactor() ~= 0 then</p><p>        if self.Data.CurrentCutscene.RestoreGameSpeed and not self.Data.GaneSpeedBackup then</p><p>            self.Data.GaneSpeedBackup = Game.GameTimeGetFactor();</p><p>        end</p><p>        Game.GameTimeSetFactor(GUI.GetPlayerID(), 1);</p><p>    end</p><p>    self.Data.SelectedEntities = {GUI.GetSelectedEntities()};</p><p>    </p><p>    if not self.Data.CinematicActive then</p><p>        self:ActivateCinematicMode();</p><p>    end</p><p>    self:NextFlight();</p><p>-- Stoppt die Cutscene im lokalen Skript. Hier wird der Cinematic Mode</p><p>-- deaktiviert und die Spielansicht wiederhergestellt.</p><p>-- @within Internal</p><p>-- @local</p><p>    if self.Data.CurrentCutscene.CameraLookAt then </p><p>        Camera.RTS_SetLookAtPosition(unpack(self.Data.CurrentCutscene.CameraLookAt));</p><p>    end</p><p>    for k, v in pairs(self.Data.SelectedEntities) do</p><p>        GUI.SelectEntity(v);</p><p>    end</p><p>    Display.SetRenderBorderPins(1);</p><p>    Display.SetRenderSky(0);</p><p>    local GameSpeed = (self.Data.GaneSpeedBackup or 1);</p><p>    Game.GameTimeSetFactor(GUI.GetPlayerID(), GameSpeed);</p><p>    self.Data.GaneSpeedBackup = nil;</p><p>    BundleBriefingSystem.Local.Data.DisplayIngameCutscene = false;</p><p>    self:DeactivateCinematicMode();</p><p>    self.Data.CutsceneActive = false;</p><p>    self.Data.FastForward.Active = false;</p><p>-- Prüft, ob eine Cutscene aktiv ist.</p><p>-- @param[type=boolean] Cutscene ist aktiv</p><p>-- @within Internal</p><p>-- @local</p><p>    return IsBriefingActive() == true or self.Data.CutsceneActive == true;</p><p>-- Startet den nächsten Flight.</p><p>-- @within Internal</p><p>-- @local</p><p>    local FlightIndex = self.Data.CurrentFlight;</p><p>    local CurrentFlight = self.Data.CurrentCutscene[FlightIndex];</p><p>    if not CurrentFlight then</p><p>        return;</p><p>    end</p><p>    if Camera.IsValidCutscene(CurrentFlight.Flight) then</p><p>        Camera.StartCutscene(CurrentFlight.Flight);</p><p>    else</p><p>        self:FlightFinished();</p><p>    end</p><p>-- Script Event: Flight wurde gestartet.</p><p>-- @param[type=number] _Duration Dauer in Turns</p><p>-- @within Internal</p><p>-- @local</p><p>    if self:IsCutsceneActive() then</p><p>        local FlightIndex = self.Data.CurrentFlight;</p><p>        local CurrentFlight = self.Data.CurrentCutscene[FlightIndex];</p><p>        if not CurrentFlight then</p><p>            return;</p><p>        end</p><p>        local Flight  = CurrentFlight.Flight;</p><p>        local Title   = CurrentFlight.Title or "";</p><p>        local Text    = CurrentFlight.Text or "";</p><p>        local Action  = CurrentFlight.Action;</p><p>        -- Setze Title</p><p>        if string.sub(Title, 1, 1) ~= "{" then</p><p>            Title = "{@color:255,250,0,255}{center}{darkshadow}" .. Title;</p><p>        end</p><p>        XGUIEng.SetText("/InGame/ThroneRoom/Main/DialogTopChooseKnight/ChooseYourKnight", Title);</p><p>        -- Setze Text</p><p>        if string.sub(Text, 1, 1) ~= "{" then</p><p>            Text = "{center}" .. Text;</p><p>        end</p><p>        XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Text", "{cr}{cr}{cr}" .. Text);</p><p>        -- Führe Action aus</p><p>        if Action then</p><p>            API.Bridge("AddOnCutsceneSystem.Global.Data.CurrentCutscene[" ..FlightIndex.. "]:Action()");</p><p>        end</p><p>        XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/Skip", (self.Data.CurrentCutscene.FastForward and 1) or 0);</p><p>        -- Handle fader</p><p>        self.Data.Fader.To = 0;</p><p>        self:SetFaderAlpha(0);</p><p>        if CurrentFlight.FadeIn then</p><p>            self:FadeIn(CurrentFlight.FadeIn);</p><p>        end</p><p>        if CurrentFlight.FadeOut then</p><p>            StartSimpleHiResJobEx(function(_Time, _FadeOut)</p><p>                if Logic.GetTimeMs()  _Time - (_FadeOut * 1000) then</p><p>                    self:FadeOut(_FadeOut);</p><p>                    return true;</p><p>                end</p><p>            end, Logic.GetTimeMs() + (_Duration*100), CurrentFlight.FadeOut);</p><p>        end</p><p>    end</p><p>    AddOnCutsceneSystem.Local:FlightStarted(_Duration);</p><p>-- Script Event: Flight ist beendet.</p><p>-- @within Internal</p><p>-- @local</p><p>    if self:IsCutsceneActive() then</p><p>        local FlightIndex = self.Data.CurrentFlight;</p><p>        if FlightIndex == #self.Data.CurrentCutscene then</p><p>            API.Bridge("AddOnCutsceneSystem.Global:StopCutscene()");</p><p>            return true;</p><p>        end</p><p>        self.Data.CurrentFlight = self.Data.CurrentFlight +1;</p><p>        self:SetFaderAlpha(1);</p><p>        self:NextFlight();</p><p>    end</p><p>    AddOnCutsceneSystem.Local:FlightFinished();</p><p>-- Steuert die Wiedergabe der Cutscenes.</p><p>-- @within Internal</p><p>-- @local</p><p>    if self:IsCutsceneActive() then</p><p>        local Language = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>        if self.Data.FastForward.Active == false then</p><p>            XGUIEng.SetText("/InGame/ThroneRoom/Main/Skip", "{center}" ..AddOnCutsceneSystem.Text.FastForwardActivate[Language]);</p><p>        else </p><p>            XGUIEng.SetText("/InGame/ThroneRoom/Main/Skip", "{center}" ..AddOnCutsceneSystem.Text.FastForwardDeactivate[Language]);</p><p>        end</p><p>    end</p><p>-- Steuert Reaktionen auf Klicks des Spielers.</p><p>-- @within Internal</p><p>-- @local</p><p>    if self:IsCutsceneActive() then</p><p>        if self.Data.CurrentCutscene.LeftClick then</p><p>            self.Data.CurrentCutscene:LeftClick();</p><p>        end</p><p>    end</p><p>-- Startet oder beendet den schnellen Vorlauf, wenn der Spieler den Skip-Button</p><p>-- klickt. Außerdem wird der Text des Skip-Button gesetzt und ein Flag gesetzt.</p><p>-- @within Internal</p><p>-- @local</p><p>    if self:IsCutsceneActive() then</p><p>        if Game.GameTimeGetFactor()  1 then</p><p>            Game.GameTimeSetFactor(GUI.GetPlayerID(), 1);</p><p>            self.Data.FastForward.Active = false;</p><p>        else</p><p>            Game.GameTimeSetFactor(GUI.GetPlayerID(), self.Data.FastForward.Speed);</p><p>            self.Data.FastForward.Active = true;</p><p>        end</p><p>    end</p><p>-- Initialisiert den Fader. Bei diesem Fader handelt es sich um eine leicht</p><p>-- abgewandelte Version des normalen Fader. Dieser Fader verhält sich relativ</p><p>-- zur Spielgeschwindigkeit.</p><p>-- @return[type=boolean] Fading läuft gerade</p><p>-- @within Internal</p><p>-- @local</p><p>    self.Data.Fader.Duration = 0;</p><p>    self.Data.Fader.To = 0;</p><p>    self:SetFaderAlpha(1.0);</p><p>    XGUIEng.PushPage(self.Data.Fader.Page, false);</p><p>-- Prüft, ob gerade ein Fading-Prozess läuft.</p><p>-- @return[type=boolean] Fading läuft gerade</p><p>-- @within Internal</p><p>-- @local</p><p>-- Blendet zur Fader-Maske aus. Callback wird am Ende ausgeführt.</p><p>-- @param[type=number] _Duration Dauer in Sekunden</p><p>-- @param[type=number] _Callback (optional) Callback-Funktion</p><p>-- @within Internal</p><p>-- @local</p><p>        local time = Logic.GetTimeMs();</p><p>        local progress = (time - self.Data.Fader.TimeStamp) / (self.Data.Fader.Duration * 1000);</p><p>        local alpha = self:LERP(self.Data.Fader.From, self.Data.Fader.To, progress);</p><p>        self.Data.Fader.From = 0;</p><p>        self.Data.Fader.To = 1;</p><p>        self.Data.Fader.Duration = _Duration;</p><p>    self.Data.Fader.Callback = _Callback;</p><p>    self.Data.Fader.TimeStamp = Logic.GetTimeMs();</p><p>-- Blendet von der Fader-Maske ein. Callback wird am Ende ausgeführt.</p><p>-- @param[type=number] _Duration Dauer in Sekunden</p><p>-- @param[type=number] _Callback (optional) Callback-Funktion</p><p>-- @within Internal</p><p>-- @local</p><p>    self.Data.Fader.Callback = _Callback;</p><p>    self.Data.Fader.Duration = _Duration;</p><p>    self.Data.Fader.From = 1;</p><p>    self.Data.Fader.To = 0;</p><p>    self.Data.Fader.TimeStamp = Logic.GetTimeMs();</p><p>-- Setzt den Alpha-Wert der Fader-Maske auf den angegebenen Wert.</p><p>-- @param[type=number] _Alpha Alpha-Wert</p><p>-- @within Internal</p><p>-- @local</p><p>-- Berechnet die lineare Interpolation des Alpha der Fader-Maske.</p><p>-- @param[type=number] _A Startwert</p><p>-- @param[type=number] _B Endwert</p><p>-- @param[type=number] _T Zeitfaktor</p><p>-- @return[number] Interpolationsfaktor</p><p>-- @within Internal</p><p>-- @local</p><p>    return _A + ((_B - _A) * _T);</p><p>-- Überschreibt die Update-Funktion des normalen Fader, sodass während einer</p><p>-- Cutscene Spielzeit statt Realzeit verwendet wird.</p><p>-- @within Internal</p><p>-- @local</p><p>    UpdateFader_Orig_CutsceneSystem = UpdateFader;</p><p>    UpdateFader = function()</p><p>        if AddOnCutsceneSystem.Local.Data.CutsceneActive then</p><p>            AddOnCutsceneSystem.Local:UpdateFader();</p><p>        else</p><p>            UpdateFader_Orig_CutsceneSystem();</p><p>        end</p><p>    end</p><p>-- Aktualisiert den Alpha-Wert der Fader-Maske, wenn eine Cutscene aktiv ist.</p><p>-- @within Internal</p><p>-- @local</p><p>    if self.Data.CutsceneActive == true then</p><p>        if self.Data.Fader.Duration  0 then</p><p>            local time = Logic.GetTimeMs();</p><p>            local progress = (time - self.Data.Fader.TimeStamp) / (self.Data.Fader.Duration * 1000);</p><p>            local alpha = self:LERP(self.Data.Fader.From, self.Data.Fader.To, progress);</p><p>            self:SetFaderAlpha(alpha);</p><p>            if time  self.Data.Fader.TimeStamp + (self.Data.Fader.Duration * 1000)  then</p><p>                self.Data.Fader.Duration = 0;</p><p>                if self.Data.Fader.Callback ~= nil then</p><p>                    self.Data.Fader:Callback();</p><p>                    return false;</p><p>                end</p><p>            end</p><p>        else</p><p>            self:SetFaderAlpha(self.Data.Fader.To);</p><p>        end</p><p>    end</p><p>-- Setzt den Bar-Style für die aktuelle Cutscene.</p><p>-- @within Internal</p><p>-- @local</p><p>    local Alpha = (_Transparend and 100) or 255;</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoomBars", 0);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2", 1);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_Dodge", 0);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2_Dodge", 1);</p><p>    XGUIEng.SetMaterialAlpha("/InGame/ThroneRoomBars/BarBottom", 1, Alpha);</p><p>    XGUIEng.SetMaterialAlpha("/InGame/ThroneRoomBars/BarTop", 1, Alpha);</p><p>    XGUIEng.SetMaterialAlpha("/InGame/ThroneRoomBars_2/BarBottom", 1, Alpha);</p><p>    XGUIEng.SetMaterialAlpha("/InGame/ThroneRoomBars_2/BarTop", 1, Alpha);</p><p>-- Aktiviert den Cinematic Mode. Alle selektierten Entities werden gespeichert</p><p>-- und anschließend deselektiert. Optional wird die Kameraposition und die</p><p>-- Spielgeschwindigkeit ebenfalls gespeichert.</p><p>-- @within Internal</p><p>-- @local</p><p>    self.Data.CinematicActive = true;</p><p>    </p><p>    local LoadScreenVisible = XGUIEng.IsWidgetShownEx("/LoadScreen/LoadScreen") == 1;</p><p>    if LoadScreenVisible then</p><p>        XGUIEng.PopPage();</p><p>    end</p><p>    XGUIEng.ShowWidget("/InGame/Root/3dOnScreenDisplay", 0);</p><p>    XGUIEng.ShowWidget("/InGame/Root/Normal", 0);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom", 1);</p><p>    XGUIEng.PushPage("/InGame/ThroneRoomBars", false);</p><p>    XGUIEng.PushPage("/InGame/ThroneRoomBars_2", false);</p><p>    XGUIEng.PushPage("/InGame/ThroneRoom/Main", false);</p><p>    XGUIEng.PushPage("/InGame/ThroneRoomBars_Dodge", false);</p><p>    XGUIEng.PushPage("/InGame/ThroneRoomBars_2_Dodge", false);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/Skip", 1);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogTopChooseKnight", 1);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogTopChooseKnight/Frame", 0);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogTopChooseKnight/DialogBG", 0);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogTopChooseKnight/FrameEdges", 0);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogBottomRight3pcs", 0);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/KnightInfoButton", 0);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/Briefing", 0);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/BackButton", 0);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/TitleContainer", 0);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/StartButton", 0);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/MissionBriefing/Text", 1);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/MissionBriefing/Title", 1);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/MissionBriefing/Objectives", 1);</p><p>    XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Text", " ");</p><p>    XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Title", " ");</p><p>    XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Objectives", " ");</p><p>    local x,y = XGUIEng.GetWidgetScreenPosition("/InGame/ThroneRoom/Main/DialogTopChooseKnight/ChooseYourKnight");</p><p>    XGUIEng.SetWidgetScreenPosition("/InGame/ThroneRoom/Main/DialogTopChooseKnight/ChooseYourKnight", x, 65);</p><p>    XGUIEng.SetWidgetPositionAndSize("/InGame/ThroneRoom/KnightInfo/Objectives", 2, 0, 2000, 20);</p><p>    XGUIEng.PushPage("/InGame/ThroneRoom/KnightInfo", false);</p><p>    XGUIEng.ShowAllSubWidgets("/InGame/ThroneRoom/KnightInfo", 0);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom/KnightInfo/Text", 1);</p><p>    XGUIEng.SetText("/InGame/ThroneRoom/KnightInfo/Text", " ");</p><p>    XGUIEng.SetWidgetPositionAndSize("/InGame/ThroneRoom/KnightInfo/Text", 200, 300, 1000, 10);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom/KnightInfo/LeftFrame", 1);</p><p>    XGUIEng.ShowAllSubWidgets("/InGame/ThroneRoom/KnightInfo/LeftFrame", 0);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom/KnightInfo/KnightBG", 1);</p><p>    XGUIEng.SetWidgetPositionAndSize("/InGame/ThroneRoom/KnightInfo/KnightBG", 0, 6000, 400, 600);</p><p>    XGUIEng.SetMaterialAlpha("/InGame/ThroneRoom/KnightInfo/KnightBG", 0, 0);</p><p>    AddOnCutsceneSystem.Local:SetBarStyle(self.Data.CurrentCutscene.TransperentBars);</p><p>    if not self.Data.SkipButtonTextBackup then</p><p>        self.Data.SkipButtonTextBackup = XGUIEng.GetText("/InGame/ThroneRoom/Main/Skip");</p><p>    end</p><p>    GUI.ClearSelection();</p><p>    GUI.ForbidContextSensitiveCommandsInSelectionState();</p><p>    GUI.ActivateCutSceneState();</p><p>    GUI.SetFeedbackSoundOutputState(0);</p><p>    GUI.EnableBattleSignals(false);</p><p>    Input.CutsceneMode();</p><p>    Display.SetRenderFogOfWar(0);</p><p>    Display.SetUserOptionOcclusionEffect(0);</p><p>    Camera.SwitchCameraBehaviour(0);</p><p>    self:InitializeFader();</p><p>    self:SetFaderAlpha(0);</p><p>    if LoadScreenVisible then</p><p>        XGUIEng.PushPage("/LoadScreen/LoadScreen", false);</p><p>    end</p><p>-- Stoppt den Cinematic Mode. Die Selektion wird wiederhergestellt. Falls</p><p>-- aktiviert, werden auch Kameraposition und Spielgeschwindigkeit auf ihre</p><p>-- alten Werte zurückgesetzt.</p><p>-- @within Internal</p><p>-- @local</p><p>    self.Data.CinematicActive = false;</p><p>    if not self.Data.SkipButtonTextBackup then</p><p>        XGUIEng.SetText("/InGame/ThroneRoom/Main/Skip", self.Data.SkipButtonTextBackup);</p><p>        self.Data.SkipButtonTextBackup =  nil;</p><p>    end</p><p>    self.Data.Fader.To = 0;</p><p>    self:SetFaderAlpha(0);</p><p>    XGUIEng.PopPage();</p><p>    Camera.SwitchCameraBehaviour(0);</p><p>    Display.UseStandardSettings();</p><p>    Input.GameMode();</p><p>    GUI.EnableBattleSignals(true);</p><p>    GUI.SetFeedbackSoundOutputState(1);</p><p>    GUI.ActivateSelectionState();</p><p>    GUI.PermitContextSensitiveCommandsInSelectionState();</p><p>    Display.SetRenderFogOfWar(1);</p><p>    if Options.GetIntValue("Display", "Occlusion", 0)  0 then</p><p>        Display.SetUserOptionOcclusionEffect(1);</p><p>    end</p><p>    XGUIEng.PopPage();</p><p>    XGUIEng.PopPage();</p><p>    XGUIEng.PopPage();</p><p>    XGUIEng.PopPage();</p><p>    XGUIEng.PopPage();</p><p>    XGUIEng.PopPage();</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom", 0);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoomBars", 0);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2", 0);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_Dodge", 0);</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2_Dodge", 0);</p><p>    XGUIEng.ShowWidget("/InGame/Root/Normal", 1);</p><p>    XGUIEng.ShowWidget("/InGame/Root/3dOnScreenDisplay", 1);</p><p>    XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Objectives", " ");</p><p>-- Steuert die Nachricht bei aktiven schnellen Vorlauf von Cutscenes.</p><p>-- @within Internal</p><p>-- @local</p><p>    if AddOnCutsceneSystem.Local.Data.CutsceneActive == true then</p><p>        if AddOnCutsceneSystem.Local.Data.FastForward.Active then</p><p>            -- Realzeit ermitteln</p><p>            local RealTime = API.RealTimeGetSecondsPassedSinceGameStart();</p><p>            if not AddOnCutsceneSystem.Local.Data.FastForward.RealTime then</p><p>                AddOnCutsceneSystem.Local.Data.FastForward.RealTime = RealTime;</p><p>            end</p><p>            -- Einrückung anpassen</p><p>            if AddOnCutsceneSystem.Local.Data.FastForward.RealTime  RealTime then</p><p>                AddOnCutsceneSystem.Local.Data.FastForward.Indent = AddOnCutsceneSystem.Local.Data.FastForward.Indent +1;</p><p>                if AddOnCutsceneSystem.Local.Data.FastForward.Indent  4 then</p><p>                    AddOnCutsceneSystem.Local.Data.FastForward.Indent = 1;</p><p>                end</p><p>                AddOnCutsceneSystem.Local.Data.FastForward.RealTime = RealTime;</p><p>            end</p><p>            -- Message anzeigen</p><p>            local Language = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>            local Text = "{cr}{cr}" ..AddOnCutsceneSystem.Text.FastFormardMessage[Language];</p><p>            local Indent = string.rep("  ", AddOnCutsceneSystem.Local.Data.FastForward.Indent);</p><p>            XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Objectives", Text..Indent.. ". . .");</p><p>        else</p><p>            XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Objectives", " ");</p><p>        end</p><p>    end</p><p>-- Wartet bis der Ladebildschirm inaktiv ist und setzt dann ein Flag, dass</p><p>-- das Starten von Cutscenes erlaubt.</p><p>-- @within Internal</p><p>-- @local</p><p>    if XGUIEng.IsWidgetShownEx("/LoadScreen/LoadScreen") == 0 then</p><p>        GUI.SendScriptCommand("AddOnCutsceneSystem.Global.Data.LoadScreenHidden = true;");</p><p>        return true;</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p> </p></div>
    </div>
</div>
                </div>
                <p id="notFound">Leider wurden keine Ergebnisse gefunden!</p>
            </div>
        </div>
    </bod>
</html>