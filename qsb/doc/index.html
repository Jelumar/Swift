<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8" />
        <title>Symfonia</title>
        <link rel="stylesheet" href="css/main.css" />
        <script src="js/jquery.js"></script>
        <script src="js/search.js"></script>
    </head>
    <body>
        <div id="modules">
            <div id="searchContainer">
                <h1>Symfonia</h1>
                <p>Willkommen in der Dokumentation von Symfonia!</p>
                <p>
                    Die Dokumentation soll Dir beim Erstellen von neuen Maps zur Seite stehen. Damit du nicht von all den Modulen erschlagen wirst, 
                    wurde diese Startseite vorangestellt. Gib eindach einen Suchbegriff ein. Alle passenden Bundles von Symfonia werden anschließend 
                    in einer Liste angezeigt. Wähle das passende Bundle durch klicken aus.
                </p>
                <hr/>
                <form id="searchForm">
                    <input type="text" id="pattern" />
                    <input type="button" name="search" id="search" value="Suchen" />
                    <input type="button" name="reset" id="reset" value="Zurücksetzen" />
                    <input type="submit" style="display: none" />
                </form>
            <div>
            <div id="searchResultsContainer">
                <h3>Index</h3>
                <div id="modulesContainer">
                    <div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/core.lua.html">
            <div class='doclink'>
                <div>Core</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia Core                                                         # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Die Hauptaufgabe des Framework ist es, Funktionen zur Installation und der</p><p>-- Verwaltung der einzelnen Bundles bereitzustellen. Bundles sind in sich</p><p>-- geschlossene Module, die wenig bis gar keine Abhänigkeiten haben. Damit</p><p>-- das funktioniert, muss das Framework auch allgemeingültige Funktionen</p><p>-- bereitstellen, auf die Bundles aufbauen können.</p><p>-- Im Framework werden zudem überschriebene Spielfunktionen angelegt und so</p><p>-- aufbereitet, dass Bundles ihre Inhalte einfach ergänzen können. Dies wird</p><p>-- jedoch nicht für alle Funktionen des Spiels möglich sein.</p><p>-- Wie die einzelnen Bundles ist auch das Framework in einen Public und einen</p><p>-- Private Space aufgeteilt. Der Public Space enthält Funktionen innerhalb</p><p>-- der Bibliothek "API". Alle Bundles ergänzen ihre Public-Funktionen dort.</p><p>-- Außer den Aliases auf API-Funktionen, den Behavior-Funktionen und evtl.</p><p>-- Klassen von Objekten sind keine anderen Funktionen für den Anwendern</p><p>-- sichtbar zu machen!</p><p>-- Sinn des Public Space ist es, Funktionsaufrufe, die zum Teil nur in einer</p><p>-- Skriptumgebung bekannt sind, zu verallgemeinern. Wird die Funktion nun aus</p><p>-- der falschen Umgebung aufgerufen, wird der Aufruf an die richtige Umgebung</p><p>-- weitergereicht oder, falls dies nicht möglich ist, abgebrochen. Dies soll</p><p>-- Fehler vermeiden.</p><p>-- Im Private Space liegen die privaten Funktionen und Variablen, die</p><p>-- nicht in der Dokumentation erscheinen. Sie sind mit einem Local-Tag zu</p><p>-- versehen! Der Nutzer soll diese Funktionen in der Regel nicht anfassen,</p><p>-- daher muss er auch nicht wissen, dass es sie gibt!</p><p>-- Ziel der Teilung zwischen Public Space und Private Space ist es, dem</p><p>-- Anwender eine saubere und leicht verständliche Oberfläche zu Bieten, mit</p><p>-- der er einfach arbeiten kann. Kenntnis über die komplexen Prozesse hinter</p><p>-- den Kulissen sind dafür nicht notwendig.</p><p>-- Hier werden wichtige Basisfunktionen bereitgestellt. Diese Funktionen sind</p><p>-- auch in der Minimalkonfiguration der QSB vorhanden.</p><p>-- @set sort=true</p><p>-- Das ist die Version der QSB.</p><p>-- Bei jedem Release wird die Tausenderstelle hochgezählt.</p><p>-- Bei Bugfixes werden die anderen Stellen hochgezählt.</p><p>-- AddOn Versionsnummer</p><p>-- @local</p><p>    g_GameExtraNo = Framework.GetGameExtraNo();</p><p>    g_GameExtraNo = MapEditor.GetGameExtraNo();</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Initialisiert alle verfügbaren Bundles und führt ihre Install-Methode aus.</p><p>-- Bundles werden immer getrennt im globalen und im lokalen Skript gestartet.</p><p>-- Diese Funktion muss zwingend im globalen und lokalen Skript ausgeführt</p><p>-- werden, bevor die QSB verwendet werden kann.</p><p>-- @within Anwenderfunktionen</p><p>function API.Install()</p><p>    Core:InitalizeBundles();</p><p>-- Tables --------------------------------------------------------------------</p><p>-- Kopiert eine komplette Table und gibt die Kopie zurück. Tables können</p><p>-- nicht durch Zuweisungen kopiert werden. Verwende diese Funktion. Wenn ein</p><p>-- Ziel angegeben wird, ist die zurückgegebene Table eine Vereinigung der 2</p><p>-- angegebenen Tables.</p><p>-- Die Funktion arbeitet rekursiv.</p><p>-- <p><b>Alias:</b> CopyTableRecursive</p></p><p>-- @param _Source    [table] Quelltabelle</p><p>-- @param _Dest      [table] (optional) Zieltabelle</p><p>-- @return [table] Kopie der Tabelle</p><p>-- @within Anwenderfunktionen</p><p>-- @usage Table = {1, 2, 3, {a = true}}</p><p>-- Copy = API.InstanceTable(Table)</p><p>function API.InstanceTable(_Source, _Dest)</p><p>    return copy(_Source, _Dest);</p><p>-- Sucht in einer Table nach einem Wert. Das erste Aufkommen des Suchwerts</p><p>-- wird als Erfolg gewertet.</p><p>-- <p><b>Alias:</b> Inside</p></p><p>-- @param _Data  [mixed] Datum, das gesucht wird</p><p>-- @param _Table [table] Tabelle, die durchquert wird</p><p>-- @return [booelan] Wert gefunden</p><p>-- @within Anwenderfunktionen</p><p>-- @usage Table = {1, 2, 3, {a = true}}</p><p>-- local Found = API.TraverseTable(3, Table)</p><p>function API.TraverseTable(_Data, _Table)</p><p>    for k,v in pairs(_Table) do</p><p>        if v == _Data then</p><p>            return true;</p><p>        end</p><p>    end</p><p>    return false;</p><p>-- Schreibt ein genaues Abbild der Table ins Log. Funktionen, Threads und</p><p>-- Metatables werden als Adresse geschrieben.</p><p>-- @param _Table [table] Tabelle, die gedumpt wird</p><p>-- @param _Name  [name] Optionaler Name im Log</p><p>-- @within Anwenderfunktionen</p><p>-- @local</p><p>-- @usage Table = {1, 2, 3, {a = true}}</p><p>-- API.DumpTable(Table)</p><p>function API.DumpTable(_Table, _Name)</p><p>    local Start = "{";</p><p>    if _Name then</p><p>        Start = _Name.. " = \n" ..Start;</p><p>    end</p><p>    Framework.WriteToLog(Start);</p><p>    for k, v in pairs(_Table) do</p><p>        if type(v) == "table" then</p><p>            Framework.WriteToLog("[" ..k.. "] = ");</p><p>            API.DumpTable(v);</p><p>        elseif type(v) == "string" then</p><p>            Framework.WriteToLog("[" ..k.. "] = \"" ..v.. "\"");</p><p>        else</p><p>            Framework.WriteToLog("[" ..k.. "] = " ..tostring(v));</p><p>        end</p><p>    end</p><p>    Framework.WriteToLog("}");</p><p>-- Konvertiert alle Strings, Booleans und Numbers einer Tabelle in</p><p>-- einen String. Die Funktion ist rekursiv, d.h. es werden auch alle</p><p>-- Untertabellen mit konvertiert. Alles was kein Number, Boolean oder</p><p>-- String ist, wird als Adresse geschrieben.</p><p>-- @param _Table [table] Table zum konvertieren</p><p>-- @return [string] Converted table</p><p>-- @within Anwenderfunktionen</p><p>-- @local</p><p>function API.ConvertTableToString(_Table)</p><p>    assert(type(_Table) == "table");</p><p>    local TableString = "{";</p><p>    for k, v in pairs(_Table) do</p><p>        local key;</p><p>        if (tonumber(k)) then</p><p>            key = ""..k;</p><p>        else</p><p>            key = "\""..k.."\"";</p><p>        end</p><p>        if type(v) == "table" then</p><p>            TableString = TableString .. "[" .. key .. "] = " .. API.ConvertTableToString(v) .. ", ";</p><p>        elseif type(v) == "number" then</p><p>            TableString = TableString .. "[" .. key .. "] = " .. v .. ", ";</p><p>        elseif type(v) == "string" then</p><p>            TableString = TableString .. "[" .. key .. "] = \"" .. v .. "\", ";</p><p>        elseif type(v) == "boolean" or type(v) == "nil" then</p><p>            TableString = TableString .. "[" .. key .. "] = \"" .. tostring(v) .. "\", ";</p><p>        else</p><p>            TableString = TableString .. "[" .. key .. "] = \"" .. tostring(v) .. "\", ";</p><p>        end</p><p>    end</p><p>    TableString = TableString .. "}";</p><p>    return TableString</p><p>-- Quests ----------------------------------------------------------------------</p><p>-- Gibt die ID des Quests mit dem angegebenen Namen zurück. Existiert der</p><p>-- Quest nicht, wird nil zurückgegeben.</p><p>-- <p><b>Alias:</b> GetQuestID</p></p><p>-- @param _Name [string] Name des Quest</p><p>-- @return [number] ID des Quest</p><p>-- @within Anwenderfunktionen</p><p>function API.GetQuestID(_Name)</p><p>    if type(_Name) == "number" then</p><p>        return _Name;</p><p>    end</p><p>    for k, v in pairs(Quests) do</p><p>        if v and k > 0 then</p><p>            if v.Identifier == _Name then</p><p>                return k;</p><p>            end</p><p>        end</p><p>    end</p><p>-- Prüft, ob die ID zu einem Quest gehört bzw. der Quest existiert. Es kann</p><p>-- auch ein Questname angegeben werden.</p><p>-- <p><b>Alias:</b> IsValidQuest</p></p><p>-- @param _QuestID [number] ID oder Name des Quest</p><p>-- @return [boolean] Quest existiert</p><p>-- @within Anwenderfunktionen</p><p>function API.IsValidateQuest(_QuestID)</p><p>    return Quests[_QuestID] ~= nil or Quests[API.GetQuestID(_QuestID)] ~= nil;</p><p>-- Lässt eine Liste von Quests fehlschlagen.</p><p>-- Der Status wird auf Over und das Resultat auf Failure gesetzt.</p><p>-- <p><b>Alias:</b> FailQuestsByName</p></p><p>-- @param ...  [string..] Liste mit Quests</p><p>-- @within Anwenderfunktionen</p><p>-- @local</p><p>function API.FailAllQuests(...)</p><p>    for i=1, #arg, 1 do</p><p>        API.FailQuest(arg[i]);</p><p>    end</p><p>-- Lässt den Quest fehlschlagen.</p><p>-- Der Status wird auf Over und das Resultat auf Failure gesetzt.</p><p>-- <p><b>Alias:</b> FailQuestByName</p></p><p>-- @param _QuestName  [string] Name des Quest</p><p>-- @param _Quiet      [boolean] Keine Meldung anzeigen</p><p>-- @within Anwenderfunktionen</p><p>function API.FailQuest(_QuestName, _Quiet)</p><p>    local Quest = Quests[GetQuestID(_QuestName)];</p><p>    if Quest then</p><p>        if not _Quiet then</p><p>            API.Info("fail quest " .._QuestName);</p><p>        end</p><p>        Quest:RemoveQuestMarkers();</p><p>        Quest:Fail();</p><p>    end</p><p>-- Startet eine Liste von Quests neu.</p><p>-- <p><b>Alias:</b> StartQuestsByName</p></p><p>-- @param ...  [string..] Liste mit Quests</p><p>-- @within Anwenderfunktionen</p><p>-- @local</p><p>function API.RestartAllQuests(...)</p><p>    for i=1, #arg, 1 do</p><p>        API.RestartQuest(arg[i]);</p><p>    end</p><p>-- Startet den Quest neu.</p><p>-- Der Quest muss beendet sein um ihn wieder neu zu starten. Wird ein Quest</p><p>-- neu gestartet, müssen auch alle Trigger wieder neu ausgelöst werden, außer</p><p>-- der Quest wird manuell getriggert.</p><p>-- Alle Änderungen an Standardbehavior müssen hier berücksichtigt werden. Wird</p><p>-- ein Standardbehavior in einem Bundle verändern, muss auch diese Funktion</p><p>-- angepasst oder überschrieben werden.</p><p>-- <p><b>Alias:</b> RestartQuestByName</p></p><p>-- @param _QuestName  [string] Name des Quest</p><p>-- @param _Quiet      [boolean] Keine Meldung anzeigen</p><p>-- @within Anwenderfunktionen</p><p>function API.RestartQuest(_QuestName, _Quiet)</p><p>    local QuestID = GetQuestID(_QuestName);</p><p>    local Quest = Quests[QuestID];</p><p>    if Quest then</p><p>        if not _Quiet then</p><p>            API.Info("restart quest " .._QuestName);</p><p>        end</p><p>        if Quest.Objectives then</p><p>            local questObjectives = Quest.Objectives;</p><p>            for i = 1, questObjectives[0] do</p><p>                local objective = questObjectives[i];</p><p>                objective.Completed = nil</p><p>                local objectiveType = objective.Type;</p><p>                if objectiveType == Objective.Deliver then</p><p>                    local data = objective.Data;</p><p>                    data[3] = nil</p><p>                    data[4] = nil</p><p>                    data[5] = nil</p><p>                elseif g_GameExtraNo and g_GameExtraNo >= 1 and objectiveType == Objective.Refill then</p><p>                    objective.Data[2] = nil</p><p>                elseif objectiveType == Objective.Protect or objectiveType == Objective.Object then</p><p>                    local data = objective.Data;</p><p>                    for j=1, data[0], 1 do</p><p>                        data[-j] = nil</p><p>                    end</p><p>                elseif objectiveType == Objective.DestroyEntities and objective.Data[1] ~= 1 and objective.DestroyTypeAmount then</p><p>                    objective.Data[3] = objective.DestroyTypeAmount;</p><p>                elseif objectiveType == Objective.Distance then</p><p>                    if objective.Data[1] == -65565 then</p><p>                        objective.Data[4].NpcInstance = nil;</p><p>                    end</p><p>                elseif objectiveType == Objective.Custom2 and objective.Data[1].Reset then</p><p>                    objective.Data[1]:Reset(Quest, i)</p><p>                end</p><p>            end</p><p>        end</p><p>        local function resetCustom(_type, _customType)</p><p>            local Quest = Quest;</p><p>            local behaviors = Quest[_type];</p><p>            if behaviors then</p><p>                for i = 1, behaviors[0] do</p><p>                    local behavior = behaviors[i];</p><p>                    if behavior.Type == _customType then</p><p>                        local behaviorDef = behavior.Data[1];</p><p>                        if behaviorDef and behaviorDef.Reset then</p><p>                            behaviorDef:Reset(Quest, i);</p><p>                        end</p><p>                    end</p><p>                end</p><p>            end</p><p>        end</p><p>        resetCustom("Triggers", Triggers.Custom2);</p><p>        resetCustom("Rewards", Reward.Custom);</p><p>        resetCustom("Reprisals", Reprisal.Custom);</p><p>        Quest.Result = nil</p><p>        local OldQuestState = Quest.State</p><p>        Quest.State = QuestState.NotTriggered</p><p>        Logic.ExecuteInLuaLocalState("LocalScriptCallback_OnQuestStatusChanged("..Quest.Index..")")</p><p>        if OldQuestState == QuestState.Over then</p><p>            Trigger.RequestTrigger(Events.LOGIC_EVENT_EVERY_SECOND, "", QuestTemplate.Loop, 1, 0, { Quest.QueueID })</p><p>        end</p><p>        return QuestID, Quest;</p><p>    end</p><p>-- Startet eine Liste von Quests.</p><p>-- <p><b>Alias:</b> StartQuestsByName</p></p><p>-- @param ...  [string..] Liste mit Quests</p><p>-- @within Anwenderfunktionen</p><p>-- @local</p><p>function API.StartAllQuests(...)</p><p>    for i=1, #arg, 1 do</p><p>        API.StartQuest(arg[i]);</p><p>    end</p><p>-- Startet den Quest sofort, sofern er existiert.</p><p>-- Dabei ist es unerheblich, ob die Bedingungen zum Start erfüllt sind.</p><p>-- <p><b>Alias:</b> StartQuestByName</p></p><p>-- @param _QuestName  [string] Name des Quest</p><p>-- @param _Quiet      [boolean] Keine Meldung anzeigen</p><p>-- @within Anwenderfunktionen</p><p>function API.StartQuest(_QuestName, _Quiet)</p><p>    local Quest = Quests[GetQuestID(_QuestName)];</p><p>    if Quest then</p><p>        if not _Quiet then</p><p>            API.Info("start quest " .._QuestName);</p><p>        end</p><p>        Quest:SetMsgKeyOverride();</p><p>        Quest:SetIconOverride();</p><p>        Quest:Trigger();</p><p>    end</p><p>-- Unterbricht eine Liste von Quests.</p><p>-- <p><b>Alias:</b> StopQuestsByName</p></p><p>-- @param ...  [string..] Liste mit Quests</p><p>-- @within Anwenderfunktionen</p><p>-- @local</p><p>function API.StopAllQuests(...)</p><p>    for i=1, #arg, 1 do</p><p>        API.StopQuest(arg[i]);</p><p>    end</p><p>-- Unterbricht den Quest.</p><p>-- Der Status wird auf Over und das Resultat auf Interrupt gesetzt. Sind Marker</p><p>-- gesetzt, werden diese entfernt.</p><p>-- <p><b>Alias:</b> StopQuestByName</p></p><p>-- @param _QuestName  [string] Name des Quest</p><p>-- @param _Quiet      [boolean] Keine Meldung anzeigen</p><p>-- @within Anwenderfunktionen</p><p>function API.StopQuest(_QuestName, _Quiet)</p><p>    local Quest = Quests[GetQuestID(_QuestName)];</p><p>    if Quest then</p><p>        if not _Quiet then</p><p>            API.Info("interrupt quest " .._QuestName);</p><p>        end</p><p>        Quest:RemoveQuestMarkers();</p><p>        Quest:Interrupt(-1);</p><p>    end</p><p>-- Gewinnt eine Liste von Quests.</p><p>-- Der Status wird auf Over und das Resultat auf Success gesetzt.</p><p>-- <p><b>Alias:</b> WinQuestsByName</p></p><p>-- @param ...  [string..] Liste mit Quests</p><p>-- @within Anwenderfunktionen</p><p>-- @local</p><p>function API.WinAllQuests(...)</p><p>    for i=1, #arg, 1 do</p><p>        API.WinQuest(arg[i]);</p><p>    end</p><p>-- Gewinnt den Quest.</p><p>-- Der Status wird auf Over und das Resultat auf Success gesetzt.</p><p>-- <p><b>Alias:</b> WinQuestByName</p></p><p>-- @param _QuestName  [string] Name des Quest</p><p>-- @param _Quiet      [boolean] Keine Meldung anzeigen</p><p>-- @within Anwenderfunktionen</p><p>function API.WinQuest(_QuestName, _Quiet)</p><p>    local Quest = Quests[GetQuestID(_QuestName)];</p><p>    if Quest then</p><p>        if not _Quiet then</p><p>            API.Info("win quest " .._QuestName);</p><p>        end</p><p>        Quest:RemoveQuestMarkers();</p><p>        Quest:Success();</p><p>    end</p><p>-- Messages --------------------------------------------------------------------</p><p>-- Schreibt eine Nachricht in das Debug Window. Der Text erscheint links am</p><p>-- Bildschirm und ist nicht statisch.</p><p>-- <p><b>Alias:</b> GUI_Note</p></p><p>-- @param _Message [string] Anzeigetext</p><p>-- @within Anwenderfunktionen</p><p>-- @local</p><p>function API.Note(_Message)</p><p>    _Message = API.EnsureMessage(_Message);</p><p>    local MessageFunc = Logic.DEBUG_AddNote;</p><p>    if GUI then</p><p>        MessageFunc = GUI.AddNote;</p><p>    end</p><p>    MessageFunc(_Message);</p><p>-- Schreibt eine Nachricht in das Debug Window. Der Text erscheint links am</p><p>-- Bildschirm und verbleibt dauerhaft am Bildschirm.</p><p>-- @param _Message [string] Anzeigetext</p><p>-- @within Anwenderfunktionen</p><p>function API.StaticNote(_Message)</p><p>    _Message = API.EnsureMessage(_Message);</p><p>    if not GUI then</p><p>        Logic.ExecuteInLuaLocalState('GUI.AddStaticNote("' .._Message.. '")');</p><p>        return;</p><p>    end</p><p>    GUI.AddStaticNote(_Message);</p><p>-- Löscht alle Nachrichten im Debug Window.</p><p>-- @within Anwenderfunktionen</p><p>function API.ClearNotes()</p><p>    if not GUI then</p><p>        Logic.ExecuteInLuaLocalState('GUI.ClearNotes()');</p><p>        return;</p><p>    end</p><p>    GUI.ClearNotes();</p><p>-- Schreibt eine einzelne Zeile Text ins Log. Vor dem Text steh, ob aus dem</p><p>-- globalen oder lokalen Skript geschrieben wurde und bei welchem Turn des</p><p>-- Spiels die Nachricht gesendet wurde.</p><p>-- @param _Message [string] Nachricht für's Log</p><p>-- @within Anwenderfunktionen</p><p>-- @local</p><p>function API.Log(_Message)</p><p>    local Env  = (GUI and "Local") or "Global";</p><p>    local Turn = Logic.GetTimeMs();</p><p>    Framework.WriteToLog(Env.. ":" ..Turn.. ": " .._Message);</p><p>-- Schreibt eine Nachricht in das Nachrichtenfenster unten in der Mitte.</p><p>-- <p><b>Alias:</b> GUI_NoteDown</p></p><p>-- @param _Message [string] Anzeigetext</p><p>-- @within Anwenderfunktionen</p><p>function API.Message(_Message)</p><p>    _Message = API.EnsureMessage(_Message);</p><p>    if not GUI then</p><p>        Logic.ExecuteInLuaLocalState('Message("' .._Message.. '")');</p><p>        return;</p><p>    end</p><p>    Message(_Message);</p><p>-- Ermittelt automatisch den Nachrichtentext, falls eine lokalisierte Table</p><p>-- übergeben wird.</p><p>-- @param _Message [string] Anzeigetext</p><p>-- @return string: Message</p><p>-- @within Anwenderfunktionen</p><p>-- @local</p><p>function API.EnsureMessage(_Message)</p><p>    local Language = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>    if type(_Message) == "table" then</p><p>        _Message = _Message[Language];</p><p>    end</p><p>    return tostring(_Message);</p><p>-- Schreibt einen FATAL auf den Bildschirm und ins Log.</p><p>-- <p><b>Alias:</b> dbg</p></p><p>-- @param _Message [string] Anzeigetext</p><p>-- @within Anwenderfunktionen</p><p>-- @local</p><p>function API.Fatal(_Message)</p><p>    if QSB.Log.CurrentLevel <= QSB.Log.Level.FATAL then</p><p>        API.StaticNote("FATAL: " .._Message)</p><p>    end</p><p>    API.Log("FATAL: " .._Message);</p><p>-- Schreibt eine WARNING auf den Bildschirm und ins Log.</p><p>-- <p><p><b>Alias:</b> warn</p></p></p><p>-- @param _Message [string] Anzeigetext</p><p>-- @within Anwenderfunktionen</p><p>-- @local</p><p>function API.Warn(_Message)</p><p>    if QSB.Log.CurrentLevel <= QSB.Log.Level.WARNING then</p><p>        API.StaticNote("WARNING: " .._Message)</p><p>    end</p><p>    API.Log("WARNING: " .._Message);</p><p>-- Schreibt eine INFO auf den Bildschirm und ins Log.</p><p>-- <p><b>Alias:</b> info</p></p><p>-- @param _Message [string] Anzeigetext</p><p>-- @within Anwenderfunktionen</p><p>-- @local</p><p>function API.Info(_Message)</p><p>    if QSB.Log.CurrentLevel <= QSB.Log.Level.INFO then</p><p>        API.Note("INFO: " .._Message)</p><p>    end</p><p>    API.Log("INFO: " .._Message);</p><p>-- Schreibt einen TRACE auf den Bildschirm und ins Log.</p><p>-- <p><b>Alias:</b> info</p></p><p>-- @param _Message [string] Anzeigetext</p><p>-- @within Anwenderfunktionen</p><p>-- @local</p><p>function API.Trace(_Message)</p><p>    if QSB.Log.CurrentLevel <= QSB.Log.Level.TRACE then</p><p>        API.Note("TRACE: " .._Message)</p><p>    end</p><p>    API.Log("TRACE: " .._Message);</p><p>-- Log Levels</p><p>    Level = {</p><p>        OFF      = 90000,</p><p>        FATAL    = 4000,</p><p>        WARNING  = 3000,</p><p>        INFO     = 2000,</p><p>        TRACE    = 1000,</p><p>        ALL      = 0,</p><p>    },</p><p>-- Aktuelles Level</p><p>-- Setzt das Log-Level für die aktuelle Skriptumgebung.</p><p>-- Als Voreinstellung werden nur FATAL-Meldungen angezeigt!</p><p>-- Das Log-Level bestimmt, welche Meldungen ausgegeben und welche unterdrückt</p><p>-- werden. Somit können Debug-Meldungen unterdrückt, während Fehlermeldungen</p><p>-- angezeigt werden.</p><p>-- <table border="1"></p><p>-- <tr></p><p>-- <th></p><p>-- Level</p><p>-- </th></p><p>-- <th></p><p>-- Beschreibung</p><p>-- </th></p><p>-- </tr></p><p>-- <td></p><p>-- QSB.Log.Level.OFF</p><p>-- </td></p><p>-- <td></p><p>-- Alle Meldungen werden unterdrückt.</p><p>-- </td></p><p>-- <tr></p><p>-- <td></p><p>-- QSB.Log.Level.FATAL</p><p>-- </td></p><p>-- <td></p><p>-- Es werden nur Fehler angezeigt.</p><p>-- </td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td></p><p>-- QSB.Log.Level.WARNING</p><p>-- </td></p><p>-- <td></p><p>-- Es werden nur Warnungen und Fehler angezeigt.</p><p>-- </td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td></p><p>-- QSB.Log.Level.INFO</p><p>-- </td></p><p>-- <td></p><p>-- Es werden Meldungen aller Stufen angezeigt.</p><p>-- </td></p><p>-- </tr></p><p>-- </table></p><p>-- @param _Level [number] Level</p><p>-- @within Anwenderfunktionen</p><p>-- @local</p><p>function API.SetLogLevel(_Level)</p><p>    assert(type(_Level) == "number");</p><p>    QSB.Log.CurrentLevel = _Level;</p><p>-- Entities --------------------------------------------------------------------</p><p>-- Sendet einen Handelskarren zu dem Spieler. Startet der Karren von einem</p><p>-- Gebäude, wird immer die Position des Eingangs genommen.</p><p>-- <p><b>Alias:</b> SendCart</p></p><p>-- @param _position            [string|number] Position</p><p>-- @param _player              [number] Zielspieler</p><p>-- @param _good                [number] Warentyp</p><p>-- @param _amount              [number] Warenmenge</p><p>-- @param _cartOverlay         [number] (optional) Overlay für Goldkarren</p><p>-- @param _ignoreReservation   [boolean] (optional) Marktplatzreservation ignorieren</p><p>-- @return number: Entity-ID des erzeugten Wagens</p><p>-- @within Anwenderfunktionen</p><p>-- @usage -- API-Call</p><p>-- API.SendCart(Logic.GetStoreHouse(1), 2, Goods.G_Grain, 45)</p><p>-- -- Legacy-Call mit ID-Speicherung</p><p>-- local ID = SendCart("Position_1", 5, Goods.G_Wool, 5)</p><p>function API.SendCart(_position, _player, _good, _amount, _cartOverlay, _ignoreReservation)</p><p>    local eID = GetID(_position);</p><p>    if not IsExisting(eID) then</p><p>        return;</p><p>    end</p><p>    local ID;</p><p>    local x,y,z = Logic.EntityGetPos(eID);</p><p>    local resCat = Logic.GetGoodCategoryForGoodType(_good);</p><p>    local orientation = 0;</p><p>    if Logic.IsBuilding(eID) == 1 then</p><p>        x,y = Logic.GetBuildingApproachPosition(eID);</p><p>        orientation = Logic.GetEntityOrientation(eID)-90;</p><p>    end</p><p>    if resCat == GoodCategories.GC_Resource then</p><p>        ID = Logic.CreateEntityOnUnblockedLand(Entities.U_ResourceMerchant, x, y,orientation,_player)</p><p>    elseif _good == Goods.G_Medicine then</p><p>        ID = Logic.CreateEntityOnUnblockedLand(Entities.U_Medicus, x, y,orientation,_player)</p><p>    elseif _good == Goods.G_Gold then</p><p>        if _cartOverlay then</p><p>            ID = Logic.CreateEntityOnUnblockedLand(_cartOverlay, x, y,orientation,_player)</p><p>        else</p><p>            ID = Logic.CreateEntityOnUnblockedLand(Entities.U_GoldCart, x, y,orientation,_player)</p><p>        end</p><p>    else</p><p>        ID = Logic.CreateEntityOnUnblockedLand(Entities.U_Marketer, x, y,orientation,_player)</p><p>    end</p><p>    Logic.HireMerchant( ID, _player, _good, _amount, _player, _ignoreReservation)</p><p>    return ID</p><p>-- Ersetzt ein Entity mit einem neuen eines anderen Typs. Skriptname,</p><p>-- Rotation, Position und Besitzer werden übernommen.</p><p>-- <p><b>Alias:</b> ReplaceEntity</p></p><p>-- @param _Entity   [string|number] Entity</p><p>-- @param _Type     [number] Neuer Typ</p><p>-- @param _NewOwner [number] (optional) Neuer Besitzer</p><p>-- @return [number] Entity-ID des Entity</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.ReplaceEntity("Stein", Entities.XD_ScriptEntity)</p><p>function API.ReplaceEntity(_Entity, _Type, _NewOwner)</p><p>    local eID = GetID(_Entity);</p><p>    if eID == 0 then</p><p>        return;</p><p>    end</p><p>    local pos = GetPosition(eID);</p><p>    local player = _NewOwner or Logic.EntityGetPlayer(eID);</p><p>    local orientation = Logic.GetEntityOrientation(eID);</p><p>    local name = Logic.GetEntityName(eID);</p><p>    DestroyEntity(eID);</p><p>    if Logic.IsEntityTypeInCategory(_Type, EntityCategories.Soldier) == 1 then</p><p>        return CreateBattalion(player, _Type, pos.X, pos.Y, 1, name, orientation);</p><p>    else</p><p>        return CreateEntity(player, _Type, pos, name, orientation);</p><p>    end</p><p>-- Rotiert ein Entity, sodass es zum Ziel schaut.</p><p>-- <p><b>Alias:</b> LookAt</p></p><p>-- @param _entity           [string|number] Entity</p><p>-- @param _entityToLookAt   [string|number] Ziel</p><p>-- @param _offsetEntity   [number] Winkel Offset</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.LookAt("Hakim", "Alandra")</p><p>function API.LookAt(_entity, _entityToLookAt, _offsetEntity)</p><p>    local entity = GetEntityId(_entity);</p><p>    local entityTLA = GetEntityId(_entityToLookAt);</p><p>    if not IsExisting(entity) or not IsExisting(entityTLA) then</p><p>        API.Warn("API.LookAt: One entity is invalid or dead!");</p><p>        return;</p><p>    end</p><p>    local eX, eY = Logic.GetEntityPosition(entity);</p><p>    local eTLAX, eTLAY = Logic.GetEntityPosition(entityTLA);</p><p>    local orientation = math.deg( math.atan2( (eTLAY - eY) , (eTLAX - eX) ) );</p><p>    if Logic.IsBuilding(entity) == 1 then</p><p>        orientation = orientation - 90;</p><p>    end</p><p>    _offsetEntity = _offsetEntity or 0;</p><p>    Logic.SetOrientation(entity, orientation + _offsetEntity);</p><p>-- Lässt zwei Entities sich gegenseitig anschauen.</p><p>-- @param _entity           [string|number] Erstes Entity</p><p>-- @param _entityToLookAt   [string|number] Zweites Entity</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.Confront("Hakim", "Alandra")</p><p>function API.Confront(_entity, _entityToLookAt)</p><p>    API.LookAt(_entity, _entityToLookAt);</p><p>    API.LookAt(_entityToLookAt, _entity);</p><p>-- Bestimmt die Distanz zwischen zwei Punkten. Es können Entity-IDs,</p><p>-- Skriptnamen oder Positionstables angegeben werden.</p><p>-- <p><b>Alias:</b> GetDistance</p></p><p>-- @param _pos1 [string|number|table] Erste Vergleichsposition</p><p>-- @param _pos2 [string|number|table] Zweite Vergleichsposition</p><p>-- @return [number] Entfernung zwischen den Punkten</p><p>-- @within Anwenderfunktionen</p><p>-- @usage local Distance = API.GetDistance("HQ1", Logic.GetKnightID(1))</p><p>function API.GetDistance( _pos1, _pos2 )</p><p>    if (type(_pos1) == "string") or (type(_pos1) == "number") then</p><p>        _pos1 = GetPosition(_pos1);</p><p>    end</p><p>    if (type(_pos2) == "string") or (type(_pos2) == "number") then</p><p>        _pos2 = GetPosition(_pos2);</p><p>    end</p><p>    if type(_pos1) ~= "table" or type(_pos2) ~= "table" then</p><p>        return {X= 1, Y= 1};</p><p>    end</p><p>    local xDistance = (_pos1.X - _pos2.X);</p><p>    local yDistance = (_pos1.Y - _pos2.Y);</p><p>    return math.sqrt((xDistance^2) + (yDistance^2));</p><p>-- Prüft, ob eine Positionstabelle eine gültige Position enthält.</p><p>-- <p><b>Alias:</b> IsValidPosition</p></p><p>-- @param _pos [table] Positionstable {X= x, Y= y}</p><p>-- @return [boolean] Position ist valide</p><p>-- @within Anwenderfunktionen</p><p>function API.ValidatePosition(_pos)</p><p>    if type(_pos) == "table" then</p><p>        if (_pos.X ~= nil and type(_pos.X) == "number") and (_pos.Y ~= nil and type(_pos.Y) == "number") then</p><p>            local world = {Logic.WorldGetSize()}</p><p>            if _pos.X <= world[1] and _pos.X >= 0 and _pos.Y <= world[2] and _pos.Y >= 0 then</p><p>                return true;</p><p>            end</p><p>        end</p><p>    end</p><p>    return false;</p><p>-- Lokalisiert ein Entity auf der Map. Es können sowohl Skriptnamen als auch</p><p>-- IDs verwendet werden. Wenn das Entity nicht gefunden wird, wird eine</p><p>-- Tabelle mit XYZ = 0 zurückgegeben.</p><p>-- <p><b>Alias:</b> GetPosition</p></p><p>-- @param _Entity [string|number] Entity, dessen Position bestimmt wird.</p><p>-- @return [table] Positionstabelle {X= x, Y= y, Z= z}</p><p>-- @within Anwenderfunktionen</p><p>-- @usage local Position = API.LocateEntity("Hans")</p><p>function API.LocateEntity(_Entity)</p><p>    if (type(_Entity) == "table") then</p><p>        return _Entity;</p><p>    end</p><p>    if (not IsExisting(_Entity)) then</p><p>        return {X= 0, Y= 0, Z= 0};</p><p>    end</p><p>    local x, y, z = Logic.EntityGetPos(GetID(_Entity));</p><p>    return {X= x, Y= y, Z= z};</p><p>-- Aktiviert ein interaktives Objekt, sodass es benutzt werden kann.</p><p>-- Der State bestimmt, ob es immer aktiviert werden kann, oder ob der Spieler</p><p>-- einen Helden benutzen muss. Wird der Parameter weggelassen, muss immer ein</p><p>-- Held das Objekt aktivieren.</p><p>-- <p><b>Alias:</b> InteractiveObjectActivate</p></p><p>-- @param _ScriptName  [string] Skriptname des IO</p><p>-- @param _State       [number] Aktivierungszustand</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.ActivateIO("Haus1", 0)</p><p>-- API.ActivateIO("Hut1")</p><p>function API.ActivateIO(_ScriptName, _State)</p><p>    State = State or 0;</p><p>    if GUI then</p><p>        GUI.SendScriptCommand('API.ActivateIO("' .._ScriptName.. '", ' ..State..')');</p><p>        return;</p><p>    end</p><p>    if not IsExisting(_ScriptName) then</p><p>        return</p><p>    end</p><p>    Logic.InteractiveObjectSetAvailability(GetID(_ScriptName), true);</p><p>    for i = 1, 8 do</p><p>        Logic.InteractiveObjectSetPlayerState(GetID(_ScriptName), i, State);</p><p>    end</p><p>-- Deaktiviert ein Interaktives Objekt, sodass es nicht mehr vom Spieler</p><p>-- aktiviert werden kann.</p><p>-- <p><b>Alias:</b> InteractiveObjectDeactivate</p></p><p>-- @param _ScriptName [string] Skriptname des IO</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.DeactivateIO("Hut1")</p><p>function API.DeactivateIO(_ScriptName)</p><p>    if GUI then</p><p>        GUI.SendScriptCommand('API.DeactivateIO("' .._ScriptName.. '")');</p><p>        return;</p><p>    end</p><p>    if not IsExisting(_ScriptName) then</p><p>        return;</p><p>    end</p><p>    Logic.InteractiveObjectSetAvailability(GetID(_ScriptName), false);</p><p>    for i = 1, 8 do</p><p>        Logic.InteractiveObjectSetPlayerState(GetID(_ScriptName), i, 2);</p><p>    end</p><p>-- Ermittelt alle Entities in der Kategorie auf dem Territorium und gibt</p><p>-- sie als Liste zurück.</p><p>-- <p><b>Alias:</b> GetEntitiesOfCategoryInTerritory</p></p><p>-- @param _player    [number] PlayerID [0-8] oder -1 für alle</p><p>-- @param _category  [number] Kategorie, der die Entities angehören</p><p>-- @param _territory [number] Zielterritorium</p><p>-- @within Anwenderfunktionen</p><p>-- @usage local Found = API.GetEntitiesOfCategoryInTerritory(1, EntityCategories.Hero, 5)</p><p>function API.GetEntitiesOfCategoryInTerritory(_player, _category, _territory)</p><p>    local PlayerEntities = {};</p><p>    local Units = {};</p><p>    if (_player == -1) then</p><p>        for i=0,8 do</p><p>            local NumLast = 0;</p><p>            repeat</p><p>                Units = { Logic.GetEntitiesOfCategoryInTerritory(_territory, i, _category, NumLast) };</p><p>                PlayerEntities = Array_Append(PlayerEntities, Units);</p><p>                NumLast = NumLast + #Units;</p><p>            until #Units == 0;</p><p>        end</p><p>    else</p><p>        local NumLast = 0;</p><p>        repeat</p><p>            Units = { Logic.GetEntitiesOfCategoryInTerritory(_territory, _player, _category, NumLast) };</p><p>            PlayerEntities = Array_Append(PlayerEntities, Units);</p><p>            NumLast = NumLast + #Units;</p><p>        until #Units == 0;</p><p>    end</p><p>    return PlayerEntities;</p><p>-- Gibt dem Entity einen eindeutigen Skriptnamen und gibt ihn zurück.</p><p>-- Hat das Entity einen Namen, bleibt dieser unverändert und wird</p><p>-- zurückgegeben.</p><p>-- @param _EntityID [number] Entity ID</p><p>-- @return [string] Skriptname</p><p>-- @within Anwenderfunktionen</p><p>function API.EnsureScriptName(_EntityID)</p><p>    if type(_EntityID) == "string" then</p><p>        return _EntityID;</p><p>    else</p><p>        assert(type(_EntityID) == "number");</p><p>        local name = Logic.GetEntityName(_EntityID);</p><p>        if (type(name) ~= "string" or name == "" ) then</p><p>            QSB.GiveEntityNameCounter = (QSB.GiveEntityNameCounter or 0)+ 1;</p><p>            name = "EnsureScriptName_Name_"..QSB.GiveEntityNameCounter;</p><p>            Logic.SetEntityName(_EntityID, name);</p><p>        end</p><p>        return name;</p><p>    end</p><p>-- Overwrite -------------------------------------------------------------------</p><p>-- Schickt einen Skriptbefehl an die jeweils andere Skriptumgebung.</p><p>-- Wird diese Funktion als dem globalen Skript aufgerufen, sendet sie den</p><p>-- Befehl an das lokale Skript. Wird diese Funktion im lokalen Skript genutzt,</p><p>-- wird der Befehl an das globale Skript geschickt.</p><p>-- @param _Command [string] Lua-Befehl als String</p><p>-- @param _Flag [boolean] FIXME Optional für GUI.SendScriptCommand benötigt</p><p>-- @within Anwenderfunktionen</p><p>-- @local</p><p>function API.Bridge(_Command, _Flag)</p><p>    if not GUI then</p><p>        Logic.ExecuteInLuaLocalState(_Command)</p><p>    else</p><p>        GUI.SendScriptCommand(_Command, _Flag)</p><p>    end</p><p>-- Wandelt underschiedliche Darstellungen einer Boolean in eine echte um.</p><p>-- Jeder String, der mit j, t, y oder + beginnt, wird als true interpretiert.</p><p>-- Alles andere als false.</p><p>-- Ist die Eingabe bereits ein Boolean wird es direkt zurückgegeben.</p><p>-- <p><b>Alias:</b> AcceptAlternativeBoolean</p></p><p>-- @param _Value [mixed] Wahrheitswert</p><p>-- @return [boolean] Wahrheitswert</p><p>-- @within Anwenderfunktionen</p><p>-- @local</p><p>-- @usage local Bool = API.ToBoolean("+")  --> Bool = true</p><p>-- local Bool = API.ToBoolean("no") --> Bool = false</p><p>function API.ToBoolean(_Value)</p><p>    return Core:ToBoolean(_Value);</p><p>-- Registriert eine Funktion, die nach dem laden ausgeführt wird.</p><p>-- <b>Alias</b>: AddOnSaveGameLoadedAction</p><p>-- @param _Function [function] Funktion, die ausgeführt werden soll</p><p>-- @within Anwenderfunktionen</p><p>-- @usage SaveGame = function()</p><p>--     API.Note("foo")</p><p>-- end</p><p>-- API.AddSaveGameAction(SaveGame)</p><p>function API.AddSaveGameAction(_Function)</p><p>    if GUI then</p><p>        API.Fatal("API.AddSaveGameAction: Can not be used from the local script!");</p><p>        return;</p><p>    end</p><p>    return Core:AppendFunction("Mission_OnSaveGameLoaded", _Function)</p><p>-- Fügt eine Beschreibung zu einem selbst gewählten Hotkey hinzu.</p><p>-- Ist der Hotkey bereits vorhanden, wird -1 zurückgegeben.</p><p>-- @param _Key         [string] Tastenkombination</p><p>-- @param _Description [string] Beschreibung des Hotkey</p><p>-- @return [number] Index oder Fehlercode</p><p>-- @within Anwenderfunktionen</p><p>function API.AddHotKey(_Key, _Description)</p><p>    if not GUI then</p><p>        API.Fatal("API.AddHotKey: Can not be used from the global script!");</p><p>        return;</p><p>    end</p><p>    g_KeyBindingsOptions.Descriptions = nil;</p><p>    table.insert(Core.Data.HotkeyDescriptions, {_Key, _Description});</p><p>    return #Core.Data.HotkeyDescriptions;</p><p>-- Entfernt eine Beschreibung eines selbst gewählten Hotkeys.</p><p>-- @param _Index [number] Index in Table</p><p>-- @within Anwenderfunktionen</p><p>function API.RemoveHotKey(_Index)</p><p>    if not GUI then</p><p>        API.Fatal("API.RemoveHotKey: Can not be used from the global script!");</p><p>        return;</p><p>    end</p><p>    if type(_Index) ~= "number" or _Index > #Core.Data.HotkeyDescriptions then</p><p>        API.Fatal("API.RemoveHotKey: No candidate found or Index is nil!");</p><p>        return;</p><p>    end</p><p>    Core.Data.HotkeyDescriptions[_Index] = nil;</p><p>-- Echtzeit --------------------------------------------------------------------</p><p>-- Gibt die real vergangene Zeit seit dem Spielstart in Sekunden zurück.</p><p>-- @return [number] Vergangene reale Zeit</p><p>-- @within Anwenderfunktionen</p><p>function API.RealTimeGetSecondsPassedSinceGameStart()</p><p>    return QSB.RealTime_SecondsSinceGameStart;</p><p>-- Wartet die angebene Zeit in realen Sekunden und führt anschließend das</p><p>-- Callback aus.</p><p>-- Hinweis: Einmal gestartet, kann wait nicht beendet werden.</p><p>-- @param _Waittime Wartezeit in realen Sekunden</p><p>-- @param _Action [function] Callback-Funktion</p><p>-- @param ... [mixed..] Liste der Argumente</p><p>-- @return [number] Vergangene reale Zeit</p><p>-- @within Anwenderfunktionen</p><p>function API.RealTimeWait(_Waittime, _Action, ...)</p><p>    StartSimpleJobEx( function(_StartTime, _Delay, _Callback, _Arguments)</p><p>        if (QSB.RealTime_SecondsSinceGameStart >= _StartTime + _Delay) then</p><p>            if #_Arguments > 0 then</p><p>                _Callback(unpack(_Arguments));</p><p>            else</p><p>                _Callback();</p><p>            end</p><p>            return true;</p><p>        end</p><p>    end, QSB.RealTime_SecondsSinceGameStart, _Waittime, _Action, {...});</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Object Oriented Programming                                                --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ermöglicht das objektorientierte programmieren in Siedler-Lua. Klassen</p><p>-- müssen sich immer direkt in _G befinden, damit className automatisch</p><p>-- gesetzt werden kann. Andernfalls muss der Name der Klasse per Hand</p><p>-- gesetzt werden.</p><p>-- Kopiert die Quelltabelle rekursiv in die Zieltabelle. Ist ein Wert im</p><p>-- Ziel vorhanden, wird er nicht überschrieben.</p><p>-- @param _Source [table] Quelltabelle</p><p>-- @param _Dest [table] Zieltabelle</p><p>-- @return [table] Kindklasse</p><p>-- @within OOP</p><p>    _Dest = _Dest or {};</p><p>    assert(type(_Source) == "table")</p><p>    assert(type(_Dest) == "table")</p><p>    for k, v in pairs(_Source) do</p><p>        if type(v) == "table" then</p><p>            _Dest[k] = _Dest[k] or {};</p><p>            for kk, vv in pairs(copy(v)) do</p><p>                _Dest[k][kk] = _Dest[k][kk] or vv;</p><p>            end</p><p>        else</p><p>            _Dest[k] = _Dest[k] or v;</p><p>        end</p><p>    end</p><p>    return _Dest;</p><p>-- Fügt einer Table Magic Methods hinzu und macht sie zur Klasse.</p><p>-- @param _Table [table] Referenz auf Table</p><p>-- @return [table] Klasse</p><p>-- @within OOP</p><p>    -- className hinzufügen</p><p>    for k, v in pairs(_G) do </p><p>        if v == _Table then</p><p>            _Table.className = k;</p><p>        end</p><p>    end</p><p>    </p><p>    -- construct hinzufügen</p><p>    _Table.construct = _Table.construct or function(self) end</p><p>    -- clone hinzufügen</p><p>    _Table.clone = _Table.clone or function(self)</p><p>        return copy(self);</p><p>    end</p><p>    -- toString hinzufügen</p><p>    _Table.toString = _Table.toString or function(self)</p><p>        local s = "";</p><p>        for k, v in pairs(self) do</p><p>            s = s .. tostring(k) .. ":" .. tostring(v) .. ";";</p><p>        end</p><p>        return "{" ..s.. "}";</p><p>    end</p><p>    -- equals hinzufügen</p><p>    _Table.equals = _Table.equals or function(self, _Other)</p><p>        -- Anderes Objekt muss table sein.</p><p>        if type(_Other) ~= "table" then </p><p>            return false;</p><p>        end</p><p>        -- Gehe Inhalt durch</p><p>        for k, v in pairs(self) do</p><p>            if v ~= _Other[k] then</p><p>                return false;</p><p>            end</p><p>        end</p><p>        return true;</p><p>    end</p><p>    return _Table;</p><p>-- Erzeugt eine Ableitung einer Klasse</p><p>-- @param _Parent [table] Referenz auf Klasse</p><p>-- @return [table] Kindklasse</p><p>-- @within OOP</p><p>    local c = copy(_Parent, _Class);</p><p>    c.parent = _Parent;</p><p>    return class(c);</p><p>-- Erzeugt eine Instanz der Klasse.</p><p>-- @param _Class [table] Referenz auf Klasse</p><p>-- @param ... [mixed] Argumente des Konstruktors</p><p>-- @return [table] Instanz der Klasse</p><p>-- @within OOP</p><p>    local instance = copy(_Class);</p><p>    -- Parent instanzieren</p><p>    if instance.parent then</p><p>        instance.parent = new(instance.parent, ...);</p><p>    end</p><p>    -- Instanz erzeugen</p><p>    instance:construct(...);</p><p>    return instance;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Data = {</p><p>        Overwrite = {</p><p>            StackedFunctions = {},</p><p>            AppendedFunctions = {},</p><p>            Fields = {},</p><p>        },</p><p>        HotkeyDescriptions = {},</p><p>        BundleInitializerList = {},</p><p>        InitalizedBundles = {},</p><p>    }</p><p>-- Initialisiert alle verfügbaren Bundles und führt ihre Install-Methode aus.</p><p>-- Bundles werden immer getrennt im globalen und im lokalen Skript gestartet.</p><p>-- @within Internal</p><p>-- @local</p><p>    if not GUI then</p><p>        self:SetupGobal_HackCreateQuest();</p><p>        self:SetupGlobal_HackQuestSystem();</p><p>        StartSimpleJobEx(CoreJob_CalculateRealTimeSinceGameStart);</p><p>    else</p><p>        self:SetupLocal_HackRegisterHotkey();</p><p>        StartSimpleJobEx(CoreJob_CalculateRealTimeSinceGameStart);</p><p>    end</p><p>    for k,v in pairs(self.Data.BundleInitializerList) do</p><p>        local Bundle = _G[v];</p><p>        if not GUI then</p><p>            if Bundle.Global ~= nil and Bundle.Global.Install ~= nil then</p><p>                Bundle.Global:Install();</p><p>                Bundle.Local = nil;</p><p>            end</p><p>        else</p><p>            if Bundle.Local ~= nil and Bundle.Local.Install ~= nil then</p><p>                Bundle.Local:Install();</p><p>                Bundle.Global = nil;</p><p>            end</p><p>        end</p><p>        self.Data.InitalizedBundles[v] = true;</p><p>        collectgarbage();</p><p>    end</p><p>-- Überschreibt CreateQuest für die Anbindung an Symfonia.</p><p>-- @within Internal</p><p>-- @local</p><p>    CreateQuest = function(_QuestName, _QuestGiver, _QuestReceiver, _QuestHidden, _QuestTime, _QuestDescription, _QuestStartMsg, _QuestSuccessMsg, _QuestFailureMsg)</p><p>        local Triggers = {};</p><p>        local Goals = {};</p><p>        local Reward = {};</p><p>        local Reprisal = {};</p><p>        local NumberOfBehavior = Logic.Quest_GetQuestNumberOfBehaviors(_QuestName);</p><p>        for i=0, NumberOfBehavior-1, 1 do</p><p>            -- Behavior ermitteln</p><p>            local BehaviorName = Logic.Quest_GetQuestBehaviorName(_QuestName, i);</p><p>            local BehaviorTemplate = GetBehaviorTemplateByName(BehaviorName);</p><p>            assert( BehaviorTemplate, "No template for name: " .. BehaviorName .. " - using an invalid QuestSystemBehavior.lua?!");</p><p>            local NewBehavior = {};</p><p>            Table_Copy(NewBehavior, BehaviorTemplate);</p><p>            local Parameter = Logic.Quest_GetQuestBehaviorParameter(_QuestName, i);</p><p>            for j=1,#Parameter do</p><p>                NewBehavior:AddParameter(j-1, Parameter[j]);</p><p>            end</p><p>            -- Füge als Goal hinzu</p><p>            if (NewBehavior.GetGoalTable ~= nil) then</p><p>                Goals[#Goals + 1] = NewBehavior:GetGoalTable();</p><p>                Goals[#Goals].Context = NewBehavior;</p><p>                Goals[#Goals].FuncOverrideIcon = NewBehavior.GetIcon;</p><p>                Goals[#Goals].FuncOverrideMsgKey = NewBehavior.GetMsgKey;</p><p>            end</p><p>            -- Füge als Trigger hinzu</p><p>            if (NewBehavior.GetTriggerTable ~= nil) then</p><p>                Triggers[#Triggers + 1] = NewBehavior:GetTriggerTable();</p><p>            end</p><p>            -- Füge als Reprisal hinzu</p><p>            if (NewBehavior.GetReprisalTable ~= nil) then</p><p>                Reprisal[#Reprisal + 1] = NewBehavior:GetReprisalTable();</p><p>            end</p><p>            -- Füge als Reward hinzu</p><p>            if (NewBehavior.GetRewardTable ~= nil) then</p><p>                Reward[#Reward + 1] = NewBehavior:GetRewardTable();</p><p>            end</p><p>        end</p><p>        -- Prüfe Mindestkonfiguration des Quest</p><p>        if (#Triggers == 0) or (#Goals == 0) then</p><p>            return;</p><p>        end</p><p>        -- Erzeuge den Quest</p><p>        if Core:CheckQuestName(_QuestName) then</p><p>            local QuestID = QuestTemplate:New(</p><p>                _QuestName,</p><p>                _QuestGiver or 1,</p><p>                _QuestReceiver or 1,</p><p>                Goals,</p><p>                Triggers,</p><p>                tonumber(_QuestTime) or 0,</p><p>                Reward,</p><p>                Reprisal,</p><p>                nil, nil,</p><p>                (not _QuestHidden or ( _QuestStartMsg and _QuestStartMsg ~= "") ),</p><p>                (not _QuestHidden or ( _QuestSuccessMsg and _QuestSuccessMsg ~= "") or ( _QuestFailureMsg and _QuestFailureMsg ~= "") ),</p><p>                _QuestDescription,</p><p>                _QuestStartMsg,</p><p>                _QuestSuccessMsg,</p><p>                _QuestFailureMsg</p><p>            );</p><p>            g_QuestNameToID[_QuestName] = QuestID;</p><p>        else</p><p>            dbg("Quest '"..tostring(questName).."': invalid questname! Contains forbidden characters!");</p><p>        end</p><p>    end</p><p>-- Implementiert die vordefinierten Texte für Custom Behavior und den Aufruf</p><p>-- der :Interrupt Methode.</p><p>-- @within Internal</p><p>-- @local</p><p>    QuestTemplate.Trigger_Orig_QSB_Core = QuestTemplate.Trigger</p><p>    QuestTemplate.Trigger = function(_quest)</p><p>        QuestTemplate.Trigger_Orig_QSB_Core(_quest);</p><p>        for i=1,_quest.Objectives[0] do</p><p>            if _quest.Objectives[i].Type == Objective.Custom2 and _quest.Objectives[i].Data[1].SetDescriptionOverwrite then</p><p>                local Desc = _quest.Objectives[i].Data[1]:SetDescriptionOverwrite(_quest);</p><p>                Core:ChangeCustomQuestCaptionText(Desc, _quest);</p><p>                break;</p><p>            end</p><p>        end</p><p>    end</p><p>    QuestTemplate.Interrupt_Orig_QSB_Core = QuestTemplate.Interrupt;</p><p>    QuestTemplate.Interrupt = function(_quest)</p><p>        QuestTemplate.Interrupt_Orig_QSB_Core(_quest);</p><p>        for i=1, _quest.Objectives[0] do</p><p>            if _quest.Objectives[i].Type == Objective.Custom2 and _quest.Objectives[i].Data[1].Interrupt then</p><p>                _quest.Objectives[i].Data[1]:Interrupt(_quest, i);</p><p>            end</p><p>        end</p><p>        for i=1, _quest.Triggers[0] do</p><p>            if _quest.Triggers[i].Type == Triggers.Custom2 and _quest.Triggers[i].Data[1].Interrupt then</p><p>                _quest.Triggers[i].Data[1]:Interrupt(_quest, i);</p><p>            end</p><p>        end</p><p>    end</p><p>-- Überschreibt das Hotkey-Register, sodass eigene Hotkeys mit im Menü</p><p>-- angezeigt werden können.</p><p>-- @within Internal</p><p>-- @local</p><p>    function g_KeyBindingsOptions:OnShow()</p><p>        local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>        if Game ~= nil then</p><p>            XGUIEng.ShowWidget("/InGame/KeyBindingsMain/Backdrop", 1);</p><p>        else</p><p>            XGUIEng.ShowWidget("/InGame/KeyBindingsMain/Backdrop", 0);</p><p>        end</p><p>        if g_KeyBindingsOptions.Descriptions == nil then</p><p>            g_KeyBindingsOptions.Descriptions = {};</p><p>            DescRegister("MenuInGame");</p><p>            DescRegister("MenuDiplomacy");</p><p>            DescRegister("MenuProduction");</p><p>            DescRegister("MenuPromotion");</p><p>            DescRegister("MenuWeather");</p><p>            DescRegister("ToggleOutstockInformations");</p><p>            DescRegister("JumpMarketplace");</p><p>            DescRegister("JumpMinimapEvent");</p><p>            DescRegister("BuildingUpgrade");</p><p>            DescRegister("BuildLastPlaced");</p><p>            DescRegister("BuildStreet");</p><p>            DescRegister("BuildTrail");</p><p>            DescRegister("KnockDown");</p><p>            DescRegister("MilitaryAttack");</p><p>            DescRegister("MilitaryStandGround");</p><p>            DescRegister("MilitaryGroupAdd");</p><p>            DescRegister("MilitaryGroupSelect");</p><p>            DescRegister("MilitaryGroupStore");</p><p>            DescRegister("MilitaryToggleUnits");</p><p>            DescRegister("UnitSelect");</p><p>            DescRegister("UnitSelectToggle");</p><p>            DescRegister("UnitSelectSameType");</p><p>            DescRegister("StartChat");</p><p>            DescRegister("StopChat");</p><p>            DescRegister("QuickSave");</p><p>            DescRegister("QuickLoad");</p><p>            DescRegister("TogglePause");</p><p>            DescRegister("RotateBuilding");</p><p>            DescRegister("ExitGame");</p><p>            DescRegister("Screenshot");</p><p>            DescRegister("ResetCamera");</p><p>            DescRegister("CameraMove");</p><p>            DescRegister("CameraMoveMouse");</p><p>            DescRegister("CameraZoom");</p><p>            DescRegister("CameraZoomMouse");</p><p>            DescRegister("CameraRotate");</p><p>            for k,v in pairs(Core.Data.HotkeyDescriptions) do</p><p>                if v then</p><p>                    v[1] = (type(v[1]) == "table" and v[1][lang]) or v[1];</p><p>                    v[2] = (type(v[2]) == "table" and v[2][lang]) or v[2];</p><p>                    table.insert(g_KeyBindingsOptions.Descriptions, 1, v);</p><p>                end</p><p>            end</p><p>        end</p><p>        XGUIEng.ListBoxPopAll(g_KeyBindingsOptions.Widget.ShortcutList);</p><p>        XGUIEng.ListBoxPopAll(g_KeyBindingsOptions.Widget.ActionList);</p><p>        for Index, Desc in ipairs(g_KeyBindingsOptions.Descriptions) do</p><p>            XGUIEng.ListBoxPushItem(g_KeyBindingsOptions.Widget.ShortcutList, Desc[1]);</p><p>            XGUIEng.ListBoxPushItem(g_KeyBindingsOptions.Widget.ActionList,   Desc[2]);</p><p>        end</p><p>    end</p><p>-- Prüft, ob das Bundle bereits initalisiert ist.</p><p>-- @param _Bundle Name des Moduls</p><p>-- @return boolean: Bundle initalisiert</p><p>-- @within Internal</p><p>-- @local</p><p>    return self.Data.InitalizedBundles[Bundle] == true;</p><p>-- Registiert ein Bundle, sodass es initialisiert wird.</p><p>-- @param _Bundle Name des Moduls</p><p>-- @within Internal</p><p>-- @local</p><p>    local text = string.format("Error while initialize bundle 's': does not exist!", tostring(_Bundle));</p><p>    assert(_G[_Bundle] ~= nil, text);</p><p>    table.insert(self.Data.BundleInitializerList, _Bundle);</p><p>-- Registiert ein AddOn als Bundle, sodass es initialisiert wird.</p><p>-- Diese Funktion macht prinziplell das Gleiche wie Core:RegisterBundle und</p><p>-- existiert nur zur Übersichtlichkeit.</p><p>-- @param _AddOn Name des Moduls</p><p>-- @within Internal</p><p>-- @local</p><p>    local text = string.format("Error while initialize addon 's': does not exist!", tostring(_AddOn));</p><p>    assert(_G[_AddOn] ~= nil, text);</p><p>    table.insert(self.Data.BundleInitializerList, _AddOn);</p><p>-- Bereitet ein Behavior für den Einsatz im Assistenten und im Skript vor.</p><p>-- Erzeugt zudem den Konstruktor.</p><p>-- @param _Behavior    Behavior-Objekt</p><p>-- @within Internal</p><p>-- @local</p><p>    if GUI then</p><p>        return;</p><p>    end</p><p>    if _Behavior.RequiresExtraNo and _Behavior.RequiresExtraNo > g_GameExtraNo then</p><p>        return;</p><p>    end</p><p>    if not _G["b_" .. _Behavior.Name] then</p><p>        dbg("AddQuestBehavior: can not find ".. _Behavior.Name .."!");</p><p>    else</p><p>        if not _G["b_" .. _Behavior.Name].new then</p><p>            _G["b_" .. _Behavior.Name].new = function(self, ...)</p><p>                local behavior = API.InstanceTable(self);</p><p>                if self.Parameter then</p><p>                    for i=1,table.getn(self.Parameter) do</p><p>                        behavior:AddParameter(i-1, arg[i]);</p><p>                    end</p><p>                end</p><p>                return behavior;</p><p>            end</p><p>        end</p><p>        for i= 1, #g_QuestBehaviorTypes, 1 do</p><p>            if g_QuestBehaviorTypes[i].Name == _Behavior.Name then</p><p>                return;</p><p>            end</p><p>        end</p><p>        table.insert(g_QuestBehaviorTypes, _Behavior);</p><p>    end</p><p>-- Prüft, ob der Questname formal korrekt ist. Questnamen dürfen i.d.R. nur</p><p>-- die Zeichen A-Z, a-7, 0-9, - und _ enthalten.</p><p>-- @param _Name     Quest</p><p>-- @return boolean: Questname ist fehlerfrei</p><p>-- @within Internal</p><p>-- @local</p><p>    return string.find(_Name, "^[A-Za-z0-9_]+$") ~= nil;</p><p>-- Ändert den Text des Beschreibungsfensters eines Quests. Die Beschreibung</p><p>-- wird erst dann aktualisiert, wenn der Quest ausgeblendet wird.</p><p>-- @param _Text   Neuer Text</p><p>-- @param _Quest  Identifier des Quest</p><p>-- @within Internal</p><p>-- @local</p><p>    _Quest.QuestDescription = _Text;</p><p>    Logic.ExecuteInLuaLocalState([[</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomLeft/Message/QuestObjectives/Custom/BGDeco",0)</p><p>        local identifier = "]].._Quest.Identifier..[["</p><p>        for i=1, Quests[0] do</p><p>            if Quests[i].Identifier == identifier then</p><p>                local text = Quests[i].QuestDescription</p><p>                XGUIEng.SetText("/InGame/Root/Normal/AlignBottomLeft/Message/QuestObjectives/Custom/Text", "]].._Text..[[")</p><p>                break</p><p>            end</p><p>        end</p><p>    ]]);</p><p>-- Erweitert eine Funktion um eine andere Funktion.</p><p>-- Jede hinzugefügte Funktion wird vor der Originalfunktion ausgeführt. Es</p><p>-- ist möglich, eine neue Funktion an einem bestimmten Index einzufügen. Diese</p><p>-- Funktion ist nicht gedacht, um sie direkt auszuführen. Für jede Funktion</p><p>-- im Spiel sollte eine API-Funktion erstellt werden.</p><p>-- Wichtig: Die gestapelten Funktionen, die vor der Originalfunktion</p><p>-- ausgeführt werden, müssen etwas zurückgeben, um die Funktion an</p><p>-- gegebener Stelle zu verlassen.</p><p>-- @param _FunctionName</p><p>-- @param _StackFunction</p><p>-- @param _Index</p><p>-- @within Internal</p><p>-- @local</p><p>    if not self.Data.Overwrite.StackedFunctions[_FunctionName] then</p><p>        self.Data.Overwrite.StackedFunctions[_FunctionName] = {</p><p>            Original = self:GetFunctionInString(_FunctionName),</p><p>            Attachments = {}</p><p>        };</p><p>        local batch = function(...)</p><p>            local ReturnValue;</p><p>            for k, v in pairs(self.Data.Overwrite.StackedFunctions[_FunctionName].Attachments) do</p><p>                ReturnValue = v(unpack(arg))</p><p>                if ReturnValue ~= nil then</p><p>                    return ReturnValue;</p><p>                end</p><p>            end</p><p>            ReturnValue = self.Data.Overwrite.StackedFunctions[_FunctionName].Original(unpack(arg));</p><p>            return ReturnValue;</p><p>        end</p><p>        self:ReplaceFunction(_FunctionName, batch);</p><p>    end</p><p>    _Index = _Index or #self.Data.Overwrite.StackedFunctions[_FunctionName].Attachments;</p><p>    table.insert(self.Data.Overwrite.StackedFunctions[_FunctionName].Attachments, _Index, _StackFunction);</p><p>-- Erweitert eine Funktion um eine andere Funktion.</p><p>-- Jede hinzugefügte Funktion wird nach der Originalfunktion ausgeführt. Es</p><p>-- ist möglich eine neue Funktion an einem bestimmten Index einzufügen. Diese</p><p>-- Funktion ist nicht gedacht, um sie direkt auszuführen. Für jede Funktion</p><p>-- im Spiel sollte eine API-Funktion erstellt werden.</p><p>-- @param _FunctionName</p><p>-- @param _AppendFunction</p><p>-- @param _Index</p><p>-- @within Internal</p><p>-- @local</p><p>    if not self.Data.Overwrite.AppendedFunctions[_FunctionName] then</p><p>        self.Data.Overwrite.AppendedFunctions[_FunctionName] = {</p><p>            Original = self:GetFunctionInString(_FunctionName),</p><p>            Attachments = {}</p><p>        };</p><p>        local batch = function(...)</p><p>            local ReturnValue = self.Data.Overwrite.AppendedFunctions[_FunctionName].Original(unpack(arg));</p><p>            for k, v in pairs(self.Data.Overwrite.AppendedFunctions[_FunctionName].Attachments) do</p><p>                ReturnValue = v(unpack(arg))</p><p>            end</p><p>            return ReturnValue;</p><p>        end</p><p>        self:ReplaceFunction(_FunctionName, batch);</p><p>    end</p><p>    _Index = _Index or #self.Data.Overwrite.AppendedFunctions[_FunctionName].Attachments;</p><p>    table.insert(self.Data.Overwrite.AppendedFunctions[_FunctionName].Attachments, _Index, _AppendFunction);</p><p>-- Überschreibt eine Funktion mit einer anderen.</p><p>-- Funktionen in einer Tabelle werden überschrieben, indem jede Ebene des</p><p>-- Tables mit einem Punkt angetrennt wird.</p><p>-- @local</p><p>-- @within Internal</p><p>-- @usage A = {foo = function() API.Note("bar") end}</p><p>-- B = function() API.Note("muh") end</p><p>-- Core:ReplaceFunction("A.foo", B)</p><p>-- -- A.foo() == B() => "muh"</p><p>    assert(type(_FunctionName) == "string");</p><p>    local ref = _G;</p><p>    local s, e = _FunctionName:find(".");</p><p>    while (s ~= nil) do</p><p>        local SubName = _FunctionName:sub(1, e-1);</p><p>        SubName = (tonumber(SubName) ~= nil and tonumber(SubName)) or SubName;</p><p>        ref = ref[SubName];</p><p>        _FunctionName = _FunctionName:sub(e+1);</p><p>        s, e = _FunctionName:find(".");</p><p>    end</p><p>    local SubName = (tonumber(_FunctionName) ~= nil and tonumber(_FunctionName)) or _FunctionName;</p><p>    ref[SubName] = _Function;</p><p>-- Sucht eine Funktion mit dem angegebenen Namen.</p><p>-- Ist die Funktionen innerhalb einer Table, so sind alle Ebenen bis zum</p><p>-- Funktionsnamen mit anzugeben, abgetrennt durch einen Punkt.</p><p>-- @param _FunctionName Name der Funktion</p><p>-- @param _Reference    Aktuelle Referenz (für Rekursion)</p><p>-- @return function: Gefundene Funktion</p><p>-- @within Internal</p><p>-- @local</p><p>    -- Wenn wir uns in der ersten Rekursionsebene beinden, suche in _G</p><p>    if not _Reference then</p><p>        local s, e = _FunctionName:find(".");</p><p>        if s then</p><p>            local FirstLayer = _FunctionName:sub(1, s-1);</p><p>            local Rest = _FunctionName:sub(e+1, _FunctionName:len());</p><p>            return self:GetFunctionInString(Rest, _G[FirstLayer]);</p><p>        else</p><p>            return _G[_FunctionName];</p><p>        end</p><p>    end</p><p>    -- Andernfalls suche in der Referenz</p><p>    if type(_Reference) == "table" then</p><p>        local s, e = _FunctionName:find(".");</p><p>        if s then</p><p>            local FirstLayer = _FunctionName:sub(1, s-1);</p><p>            local Rest = _FunctionName:sub(e+1, _FunctionName:len());</p><p>            return self:GetFunctionInString(Rest, _Reference[FirstLayer]);</p><p>        else</p><p>            return _Reference[_FunctionName];</p><p>        end</p><p>    end</p><p>-- Wandelt underschiedliche Darstellungen einer Boolean in eine echte um.</p><p>-- Jeder String, der mit j, t, y oder + beginnt, wird als true interpretiert.</p><p>-- Alles andere als false.</p><p>-- Ist die Eingabe bereits ein Boolean wird es direkt zurückgegeben.</p><p>-- @param _Input Boolean-Darstellung</p><p>-- @return boolean: Konvertierte Boolean</p><p>-- @within Internal</p><p>-- @local</p><p>    if type(_Input) == "boolean" then</p><p>        return _Input;</p><p>    end</p><p>    if string.find(string.lower(tostring(_Input)), "^[tjy\\+].*$") then</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- Jobs ------------------------------------------------------------------------</p><p>-- Dieser Job ermittelt automatisch, ob eine Sekunde reale Zeit vergangen ist</p><p>-- und zählt eine Variable hoch, die die gesamt verstrichene reale Zeit hält.</p><p>    if not QSB.RealTime_LastTimeStamp then</p><p>        if GUI then</p><p>            QSB.RealTime_LastTimeStamp = XGUIEng.GetSystemTime();</p><p>        else</p><p>            QSB.RealTime_LastTimeStamp = Framework.TimeGetTime();</p><p>        end</p><p>    end</p><p>    local CurrentTimeStamp;</p><p>    if GUI then</p><p>        CurrentTimeStamp = XGUIEng.GetSystemTime();</p><p>    else</p><p>        CurrentTimeStamp = Framework.TimeGetTime();</p><p>    end</p><p>    -- Eine Sekunde ist vergangen</p><p>    if QSB.RealTime_LastTimeStamp+1 <= CurrentTimeStamp then</p><p>        QSB.RealTime_LastTimeStamp = CurrentTimeStamp;</p><p>        QSB.RealTime_SecondsSinceGameStart = QSB.RealTime_SecondsSinceGameStart +1;</p><p>    end</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundlebriefingsystem.lua.html">
            <div class='doclink'>
                <div>BundleBriefingSystem</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia BundleBriefingSystem                                         # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ermöglicht es Briefings und Fake-Cutscenes zu verwenden.</p><p>-- <p><b>Briefing</b><br></p><p>-- Briefings dienen zur Darstellung von Dialogen oder zur näheren Erleuterung</p><p>-- der aktuellen Spielsituation. Mit Multiple Choice können dem Spieler mehrere</p><p>-- Auswahlmöglichkeiten gegeben werden, multiple Handlungsstränge gestartet</p><p>-- oder Menüstrukturen abgebildet werden. Mittels Sprüngen und Leerseiten</p><p>-- kann innerhalb des Multiple Choice Briefings navigiert werden.</p></p><p>-- <p>Das wichtigste auf einen Blick:</p><p>-- <ul></p><p>-- <li><a href="#API.StartBriefing">Ein Briefing starten</a></li></p><p>-- <li><a href="#ASP">Dialogseiten erstellen</a></li></p><p>-- <li><a href="#ASMC">Auswahldialog erstellen</a></li></p><p>-- <li></p><p>-- <a href="#API.GetSelectedAnswerFromMCPage">Multiple Choice</a><br></p><p>-- Antworten aus einem Auswahldialog erhalten</p><p>-- </li></p><p>-- <li></p><p>-- <a href="#API.PauseQuestsDuringBriefings">Quests anhalten</a><br>Während</p><p>-- Briefings halten alle Timer an, sodass es nicht zu unerwünschten Niederlagen</p><p>-- kommnt.</p><p>-- </li></p><p>-- </ul></p></p><p>-- <p><b>Cutscene</b><br></p><p>-- Cutscenes dürfen kein Multiple Choice enthalten und werden immer nur ganz</p><p>-- abgespielt oder abgebrochen. Das Überspringen einzelner Seiten ist nicht</p><p>-- möglich. Cutscenes verfügen über eine neue Kamerasteuerung (Blickrichtung</p><p>-- und Ursprungspunkt) und sollten ausschließlich für szenerische Untermalung</p><p>-- der Handlung eingesetzt werden.</p></p><p>-- <p>Das wichtigste auf einen Blick:</p><p>-- <ul></p><p>-- <li><a href="#API.StartCutscene">Eine Cutscene starten</a></li></p><p>-- <li><a href="#AF">Einen Kameraflug erstellen</a></li></p><p>-- </ul></p></p><p>-- <p><b>Behavior</b><br></p><p>-- Bisher war es schwer ein Briefing in den Ablauf einzubauen. Es wurde immer</p><p>-- ein nebenher laufender Job oder eine Variable zur Steuerung benötigt. Wenn</p><p>-- man nun ein Briefing oder eine Cutscene mit speziellen Behavior an einen</p><p>-- Auftrag anbindet, handhabt das System die nachfolgenden Aufträge.</p></p><p>-- <p>Das wichtigste auf einen Blick:</p><p>-- <ul></p><p>-- <li><a href="#Reprisal_Briefing">Reprisal_Briefing</a><br></p><p>-- Ein Briefing wird als Vergeltugn für einen Fehlschlag gestartet.</p><p>-- </li></p><p>-- <li><a href="#Reward_Briefing">Reward_Briefing</a><br></p><p>-- Ein briefing wird als Lohn für einen Erfolg gestartet.</p><p>-- </li></p><p>-- <li><a href="#Trigger_Briefing">Trigger_Briefing</a><br></p><p>-- Ein Quest wird gestartet, sobald ein Briefing abgeschlossen ist.</p><p>-- </li></p><p>-- </ul></p></p><p>-- <p><b>Splashscreen</b><br></p><p>-- Splashscreens stehen sowohl in Briefings als auch in Cutscenes zuer Verfügung</p><p>-- und bieten die Möglichkeit, Bildschirmfüllende Grafiken zu verwenden. Diese</p><p>-- Grafiken können auch größer als eine Bildschirmfläche sein. Für diesen</p><p>-- Fall kann über die Angabe von UV-Koordinaten zu einem bestimmten Abschnitt</p><p>-- der Grafik gesprungen oder geflogen werden.</p></p><p>-- @within Modulbeschreibung</p><p>-- @set sort=false</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Setzt den Zustand von Quest Timern währenddessen ein Biefings oder eine</p><p>-- Fake-Cutscene aktiv ist.</p><p>-- Während eines Briefings vergeht generell keine Zeit. Folglich ist der</p><p>-- Niederlage Timer generell inaktiv. Werden Quests während Briefings nicht</p><p>-- pausiert, zählen Niederlage Timer unterdessen weiter!</p><p>-- <p><b>Alias</b>: PauseQuestsDuringBriefings</p></p><p>-- @param _Flag [boolean] Quest Timer pausiert</p><p>-- @within Anwenderfunktionen</p><p>function API.PauseQuestsDuringBriefings(_Flag)</p><p>    if GUI then</p><p>        API.Bridge("API.PauseQuestsDuringBriefings(" ..tostring(_Flag).. ")");</p><p>        return;</p><p>    end</p><p>    return BundleBriefingSystem.Global:PauseQuestsDuringBriefings(_Flag);</p><p>-- Prüft, ob das Briefing mit der angegebenen ID beendet ist.</p><p>-- <p><b>Alias</b>: IsBriefingFinished</p></p><p>-- @param _briefingID [number] ID des Briefing</p><p>-- @return [boolean] Briefing ist beendet</p><p>-- @within Anwenderfunktionen</p><p>function API.IsBriefingFinished(_briefingID)</p><p>    if GUI then</p><p>        API.Fatal("API.IsBriefingFinished: Can only be used in the global script!");</p><p>        return;</p><p>    end</p><p>    return BundleBriefingSystem.Global:IsBriefingFinished(_briefingID);</p><p>-- Gibt die gewähtle Antwort für die Multiple Choice Page zurück.</p><p>-- Wird eine Seite mehrmals durchlaufen, wird die jeweils letzte Antwort</p><p>-- zurückgegeben.</p><p>-- <p><b>Alias</b>: MCGetSelectedAnswer</p></p><p>-- @param _page [table] Referenz auf die Seite</p><p>-- @return [number] Gewählte Antwort</p><p>-- @within Anwenderfunktionen</p><p>function API.GetSelectedAnswerFromMCPage(_page)</p><p>    if GUI then</p><p>        API.Fatal("API.GetSelectedAnswerFromMCPage: Can only be used in the global script!");</p><p>        return;</p><p>    end</p><p>    return BundleBriefingSystem.Global:MCGetSelectedAnswer(_page);</p><p>-- Gibt die Definition der Seite im aktuellen Briefing zurück.</p><p>-- Das aktuelle Briefing ist immer das letzte, das gestartet wurde.</p><p>-- <p><b>Alias</b>: GetCurrentBriefingPage</p></p><p>-- @param _pageNumber [number] Index der Seite</p><p>-- @return [table] Seite des aktuellen Briefing</p><p>-- @within Anwenderfunktionen</p><p>function API.GetCurrentBriefingPage(_pageNumber)</p><p>    if GUI then</p><p>        API.Fatal("API.GetCurrentBriefingPage: Can only be used in the global script!");</p><p>        return;</p><p>    end</p><p>    return BundleBriefingSystem.Global:GetCurrentBriefingPage(_pageNumber);</p><p>-- Gibt das aktuelle Briefing zurück.</p><p>-- Das aktuelle Briefing ist immer das letzte, das gestartet wurde.</p><p>-- <p><b>Alias</b>: GetCurrentBriefing</p></p><p>-- @return [table] Briefing mit allen Seiten</p><p>-- @within Anwenderfunktionen</p><p>function API.GetCurrentBriefing()</p><p>    if GUI then</p><p>        API.Fatal("API.GetCurrentBriefing: Can only be used in the global script!");</p><p>        return;</p><p>    end</p><p>    return BundleBriefingSystem.Global:GetCurrentBriefing();</p><p>-- Initalisiert die Page-Funktionen für das übergebene Briefing.</p><p>-- Die zurückgegebenen Funktionen sind für Dialoge gedacht. Auch wenn AP alles</p><p>-- kann, sollte man sich an diese konvention halten.</p><p>-- <p><b>Alias</b>: AddPages</p></p><p>-- @param _Briefing [table] Briefing</p><p>-- @return [function] AP - Allround-Funktion zur Erzeugung von Seiten</p><p>-- @return [function] ASP - Vereinfachte Funktion für Dialoge</p><p>-- @return [function] ASMC - Vereinfachte Funktion für Auswahl-Dialoge</p><p>-- @within Anwenderfunktionen</p><p>function API.AddPages(_Briefing)</p><p>    if GUI then</p><p>        API.Fatal("API.AddPages: Can only be used in the global script!");</p><p>        return;</p><p>    end</p><p>    return BundleBriefingSystem.Global:AddPages(_Briefing);</p><p>-- Initalisiert die Flight-Funktionen für die übergebene Fake-Cutscene.</p><p>-- Die zurückgegebenen Funktionen sind für Kameraflüge gedacht. Vermeide die</p><p>-- Anzeige von langen Texten.</p><p>-- <p><b>Alias</b>: AddPages</p></p><p>-- @param _Cutscene [table] Cutscene</p><p>-- @return [function] AF - Funktion für komfortable Notation von Flights</p><p>-- @return [function] ASF - Kurzschreibweise für AF</p><p>-- @within Anwenderfunktionen</p><p>function API.AddFlights(_Cutscene)</p><p>    if GUI then</p><p>        API.Fatal("API.AddFlights: Can only be used in the global script!");</p><p>        return;</p><p>    end</p><p>    return BundleBriefingSystem.Global:AddFlights(_Cutscene);</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Dummy-Space                                                                --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Erstellt eine Seite für ein Dialog-Briefing in der alten Notation.</p><p>-- <b>Normale Seite</b><br></p><p>-- Die üblichen Parameter können angegeben werden. Beispiele sind zoom, text,</p><p>-- oder action. Zusätzlich hinzugekommen sind lookAt und zOffset. Mittels</p><p>-- lookAt kann die Kamera zum Angesicht eines Siedlers ausgerichtet werden.</p><p>-- zOffset ermöglicht die Nutzung der Z-Achse.</p><p>-- <b>Multiple Choice, Sprünge und Leerseiten</b><br></p><p>-- Eine Multiple-Choice-Seite enthält die Unterseite mc. In mc wird der Text,</p><p>-- der Titel und die möglichen Antwortmöglichkeiten notiiert. Alle Antworten</p><p>-- stehen innerhalb von answers. Jede mögliche Antwort ist eine Table mit dem</p><p>-- Text der Auswahl, dem Sprungziel und einigen Optionen.<br></p><p>-- Mittels eines Sprungs kann zu einer anderen Seite eines Briefings gegangen</p><p>-- werden. Dazu muss der Index der Zielseite angegeben werden. Die erste Seite</p><p>-- eines Briefings darf kein Sprung sein!.<br></p><p>-- Eine Leerseite kann benutzt werden um hinter einem von einer Auswahl</p><p>-- aufgeschlagenen Pfad im Briefing selbiges zu beenden. Sonst würde das</p><p>-- Briefing einfach mit der nächsten Seite weiter machen. Sprungbefehle</p><p>-- können alternativ verwendet werden.</p><p>-- <b>Splashscreens</b><br></p><p>-- Splashscreens können eine Grafik anzeigen. Sie bieten zudem die Möglichkeit</p><p>-- über die Grafik zu scrollen oder zu zoomen.</p><p>-- @param _Page	[table] Spezifikation der Seite</p><p>-- @return [table] Refernez auf die angelegte Seite</p><p>-- @within Briefing</p><p>    -- Diese Funktion ist ein Dummy für LDoc!</p><p>    API.Fatal("AP: Please use the function provides by AddPages!");</p><p>-- Erstellt einen Flight einer Fake-Cutscene.</p><p>-- Flights bestehen aus einem Startpunkt und mindestens einer weitere Position.</p><p>-- Ein Flight kann aus nahezu unbegrenzt vielen Punkten bestehen, die alle</p><p>-- innerhalb der Duration abgefahren werden.</p><p>-- <p><b>Hinweis:</b> Es ist prinzipiell Möglich mehr als 10 Punkte pro Sekunde</p><p>-- anzusteuern, aber nicht sehr sinnvoll. ;)</p></p><p>-- Aufbau einer Station eines Flights:</p><p>-- <table border="1"></p><p>-- <tr></p><p>-- <td><b>Eigenschaft</b></td></p><p>-- <td><b>Beschreibung</b></td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>Position</td></p><p>-- <td>Die Kameraposition der Station</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>LookAt</td></p><p>-- <td>Der Kamerablickpunkt der Station</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>Title</td></p><p>-- <td>Der angezeigte Sprecher</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>Text</td></p><p>-- <td>Der gesprochende Text</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>Action</td></p><p>-- <td>Aktion zu Beginn der Kamerabewegung</td></p><p>-- </tr></p><p>-- </table></p><p>-- Allgemeine Angaben eines Flight:</p><p>-- <table border="1"></p><p>-- <tr></p><p>-- <td><b>Eigenschaft</b></td></p><p>-- <td><b>Beschreibung</b></td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>Duration</td></p><p>-- <td>Dauer des gesamten Flights. Die Zeit wird auf alle Positionen des</p><p>-- Flights der Fake-Cutscene aufgeteilt (mit Ausnahme der Startposition).</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>FadeIn</td></p><p>-- <td>Einblendedauer am Anfang des Flight</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>FadeOut</td></p><p>-- <td>Abblendedauer am Ende des Flight</td></p><p>-- </tr></p><p>-- </table></p><p>-- @param _Flight	[table] Spezifikation des Flight</p><p>-- @within Briefing</p><p>-- @usage</p><p>-- AF {</p><p>--     {</p><p>--         Position = {X= 12300, Y= 23000, Z= 3400},</p><p>--         LookAt   = {X= 22000, Y= 34050, Z= 200},</p><p>--         Text     = "Das ist ein Text....",</p><p>--     },</p><p>--     {</p><p>--         Position = {X= 12300, Y= 23000, Z= 3400},</p><p>--         LookAt   = {X= 22500, Y= 31050, Z= 350},</p><p>--         Text     = "Das ist ein Text....",</p><p>--     },</p><p>--     FadeOut  = 0.5,</p><p>--     FadeIn   = 0.5,</p><p>--     Duration = 24,</p><p>-- };</p><p>    -- Diese Funktion ist ein Dummy für LDoc!</p><p>    API.Fatal("AF: Please use the function provides by AddFlights!");</p><p>-- Ermäglicht einen Flight als Einzeiler zu notieren. Allerdings sind nicht</p><p>-- alle Optionen verfügbar.</p><p>-- Bei der Notation der Koordinaten ist zu beachten, dass zuerst das Triple</p><p>-- der Kameraposition und danach das Triple des Blickpunktes angegeben wird.</p><p>-- Für jeden Punkt müssen also 6 Zahlen angegeben werden.</p><p>-- <p><b>Hinweis:</b> Diese Funktion eignet sich besser für einfache Flüge mit</p><p>-- wenigen Kamerastationen oder für eine generische Nutzung.</p></p><p>-- @param _Text     [string] Angezeigter Text</p><p>-- @param _Duration [number] Dauer des Flight</p><p>-- @param _Action   [function] Aktion zu Beginn des Flight</p><p>-- @param _Fading   [boolen] Einblenden und Abblenden</p><p>-- @param ...       [number] Liste der XYZ-Koordinaten</p><p>-- @within Briefing</p><p>-- @usage</p><p>-- ASF ("Das ist ein Text....", 10, nil, true, 12300, 23000, 3400, 22000, 34050, 200, 12300, 23000, 3400, 22500, 31050, 350);</p><p>    -- Diese Funktion ist ein Dummy für LDoc!</p><p>    API.Fatal("ASF: Please use the function provides by AddFlights!");</p><p>-- Erstellt eine Seite in vereinfachter Syntax. Es wird davon</p><p>-- Ausgegangen, dass das Entity ein Siedler ist. Die Kamera</p><p>-- schaut den Siedler an.</p><p>-- @param _entity		[string] Zielentity</p><p>-- @param _title		[string] Titel der Seite</p><p>-- @param _text		    [string] Text der Seite</p><p>-- @param _dialogCamera [boolean] Nahsicht an/aus</p><p>-- @param _action       [function] Callback-Funktion</p><p>-- @return [table] Referenz auf die Seite</p><p>-- @within Briefing</p><p>-- @usage ASP("hans", "Hänschen-Klein", "Ich gehe in die weitel Welt hinein.", true);</p><p>    -- Diese Funktion ist ein Dummy für LDoc!</p><p>    API.Fatal("ASP: Please use the function provides by AddPages!");</p><p>-- Erstellt eine Multiple Choise Seite in vereinfachter Syntax. Es</p><p>-- wird davon Ausgegangen, dass das Entity ein Siedler ist. Die</p><p>-- Kamera schaut den Siedler an.</p><p>-- @param _entity		[string] Zielentity</p><p>-- @param _title		[tring] Titel der Seite</p><p>-- @param _text		    [string] Text der Seite</p><p>-- @param _dialogCamera [boolean] Nahsicht an/aus</p><p>-- @param ...			[mixed] Liste der Antworten und Sprungziele (string,</p><p>-- number, string, number, ...)</p><p>-- @return [table] Referenz auf die Seite</p><p>-- @within Briefing</p><p>-- @usage</p><p>-- ASMC("hans", "", "In welche Richtung soll Hänschen-Klein gehen?", false,</p><p>--      "Nach links gehen.", 2,</p><p>--      "Lieber nach rechts.", 4)</p><p>    -- Diese Funktion ist ein Dummy für LDoc!</p><p>    API.Fatal("ASMC: Please use the function provides by AddPages!");</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {</p><p>        Data = {</p><p>            PlayedBriefings = {},</p><p>            QuestsPausedWhileBriefingActive = true,</p><p>            BriefingID = 0,</p><p>        }</p><p>    },</p><p>    Local = {</p><p>        Data = {}</p><p>    },</p><p>-- Global Script ---------------------------------------------------------------</p><p>-- Initalisiert das Bundle im globalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    self:InitalizeBriefingSystem();</p><p>-- Setzt den Zustand von Quest Timern während Biefings und Fake-Cutscenes.</p><p>-- Niederlage Timer sind generell inaktiv, können aber aktiviert werden.</p><p>-- @param _Flag Quest Timer pausiert</p><p>-- @within Internal</p><p>-- @local</p><p>    self.Data.QuestsPausedWhileBriefingActive = _Flag == true;</p><p>-- Prüft, ob ein Briefing abgespielt wurde (beendet ist).</p><p>-- @param _briefingID Briefing-ID</p><p>-- @return boolean: Briefing ist beendet</p><p>-- @within Internal</p><p>-- @local</p><p>    return self.Data.PlayedBriefings[_briefingID] == true;</p><p>-- Gibt die gewähtle Antwort für die MC Page zurück.</p><p>-- Wird eine Seite mehrmals durchlaufen, wird die jeweils letzte Antwort</p><p>-- zurückgegeben.</p><p>-- @param _page Seite</p><p>-- @return number: Gewählte Antwort</p><p>-- @within Internal</p><p>-- @local</p><p>    if _page.mc and _page.mc.given then</p><p>        return _page.mc.given;</p><p>    end</p><p>    return 0;</p><p>-- Gibt die Seite im aktuellen Briefing zurück.</p><p>-- Das aktuelle Briefing ist immer das letzte, das gestartet wurde.</p><p>-- @param _pageNumber Index der Page</p><p>-- @return table: Page</p><p>-- @within Internal</p><p>-- @local</p><p>    return BriefingSystem.currBriefing[_pageNumber];</p><p>-- Gibt das aktuelle Briefing zurück.</p><p>-- Das aktuelle Briefing ist immer das letzte, das gestartet wurde.</p><p>-- @return table: Briefing</p><p>-- @within Internal</p><p>-- @local</p><p>    return BriefingSystem.currBriefing;</p><p>-- Initalisiert die Flight-Funktionen für die übergebene Cutscene.</p><p>-- @param _Cutscene Cutscene</p><p>-- @return function: AF</p><p>-- @within Internal</p><p>-- @local</p><p>    local AF = function(_Flight)</p><p>        local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>        assert(type(_Flight) == "table" and #_Flight > 0);</p><p>        local Duration  = _Flight.Duration / (#_Flight -1);</p><p>        local i = 0;</p><p>        for i= 1, #_Flight, 1 do</p><p>            local Title = _Flight[i].Title or "";</p><p>            if type(Title) == "table" then</p><p>                Title = Title[lang];</p><p>            end</p><p>            local Text = _Flight[i].Text or "";</p><p>            if type(Text) == "table" then</p><p>                Text = Text[lang];</p><p>            end</p><p>            local Flight = {</p><p>                cutscene = {</p><p>                    Position = _Flight[i].Position,</p><p>                    LookAt   = _Flight[i].LookAt,</p><p>                },</p><p>                title        = Title,</p><p>                text         = Text,</p><p>                action       = _Flight[i].Action,</p><p>                faderAlpha   = (i == 1 and _Flight.FadeIn and 1) or nil,</p><p>                fadeIn       = (i == 1 and _Flight.FadeIn) or nil,</p><p>                fadeOut      = (i == #_Flight and _Flight.FadeOut and (-_Flight.FadeOut)) or nil,</p><p>                duration     = (i == 1 and 0) or Duration,</p><p>                flyTime      = (i > 1 and Duration) or nil,</p><p>                splashscreen = _Flight.Splashscreen</p><p>            };</p><p>            table.insert(_Cutscene, Flight);</p><p>        end</p><p>    end</p><p>    local ASF = function(_Text, _Duration, _Action, _Fading, ...)</p><p>        local Flights = {};</p><p>        for i= 1, #arg, 6 do</p><p>            local Action = (i == 1 and _Action) or nil;</p><p>            table.insert(Flights, {</p><p>                Position = {X= arg[i],   Y= arg[i+1], Z= arg[i+2]},</p><p>                LookAt   = {X= arg[i+3], Y= arg[i+4], Z= arg[i+5]},</p><p>                Text     = _Text,</p><p>                Action   = Action,</p><p>            });</p><p>        end</p><p>        Flights.FadeIn   = (_Fading == true and 0.5) or 0;</p><p>        Flights.FadeOut  = (_Fading == true and 0.5) or 0;</p><p>        Flights.Duration = _Duration;</p><p>        AF(Flights);</p><p>    end</p><p>    return AF, ASF;</p><p>-- Initalisiert die Page-Funktionen für das übergebene Briefing</p><p>-- @param _briefing</p><p>-- @return function: AP</p><p>-- @return function: ASP</p><p>-- @return function: ASMC</p><p>-- @within Internal</p><p>-- @local</p><p>    local AP = function(_page)</p><p>        if _page and type(_page) == "table" then</p><p>            local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>            if type(_page.title) == "table" then</p><p>                _page.title = _page.title[lang];</p><p>            end</p><p>            _page.title = _page.title or "";</p><p>            if type(_page.text) == "table" then</p><p>                _page.text = _page.text[lang];</p><p>            end</p><p>            _page.text = _page.text or "";</p><p>            -- Multiple Choice Support</p><p>            if _page.mc then</p><p>                if _page.mc.answers then</p><p>                    _page.mc.amount  = #_page.mc.answers;</p><p>                    assert(_page.mc.amount >= 1);</p><p>                    _page.mc.current = 1;</p><p>                    for i=1, _page.mc.amount do</p><p>                        if _page.mc.answers[i] then</p><p>                            if type(_page.mc.answers[i][1]) == "table" then</p><p>                                _page.mc.answers[i][1] = _page.mc.answers[i][1][lang];</p><p>                            end</p><p>                        end</p><p>                    end</p><p>                end</p><p>                if type(_page.mc.title) == "table" then</p><p>                    _page.mc.title = _page.mc.title [lang];</p><p>                end</p><p>                if type(_page.mc.text) == "table" then</p><p>                    _page.mc.text = _page.mc.text[lang];</p><p>                end</p><p>            end</p><p>            _page.cutscene = _page.cutscene or _page.view;</p><p>            if _page.cutscene then</p><p>                _page.flyTime  = _page.cutscene.FlyTime or 0;</p><p>                _page.duration = _page.cutscene.Duration or 0;</p><p>            else</p><p>                if type(_page.position) == "table" then</p><p>                    if not _page.position.X then</p><p>                        _page.zOffset = _page.position[2];</p><p>                        _page.position = _page.position[1];</p><p>                    elseif _page.position.Z then</p><p>                        _page.zOffset = _page.position.Z;</p><p>                    end</p><p>                end</p><p>                if _page.lookAt ~= nil then</p><p>                    local lookAt = _page.lookAt;</p><p>                    if type(lookAt) == "table" then</p><p>                        _page.zOffset = lookAt[2];</p><p>                        lookAt = lookAt[1];</p><p>                    end</p><p>                    if type(lookAt) == "string" or type(lookAt) == "number" then</p><p>                        local eID    = GetID(lookAt);</p><p>                        local ori    = Logic.GetEntityOrientation(eID);</p><p>                        if Logic.IsBuilding(eID) == 0 then</p><p>                            ori = ori + 90;</p><p>                        end</p><p>                        local tpCh = 0.085 * string.len(_page.text);</p><p>                        _page.position = eID;</p><p>                        _page.duration = _page.duration or tpCh;</p><p>                        _page.flyTime  = _page.flyTime;</p><p>                        _page.rotation = (_page.rotation or 0) +ori;</p><p>                    end</p><p>                end</p><p>            end</p><p>            table.insert(_briefing, _page);</p><p>        else</p><p>            -- Sprünge, Rücksprünge und Abbruch</p><p>            table.insert(_briefing, (_page ~= nil and _page) or -1);</p><p>        end</p><p>        return _page;</p><p>    end</p><p>    local ASP = function(_entity, _title, _text, _dialogCamera, _action)</p><p>        local Entity = Logic.GetEntityName(GetID(_entity));</p><p>        assert(Entity ~= nil and Entity ~= "");</p><p>        local page  = {};</p><p>        page.zoom   = (_dialogCamera == true and 2400 ) or 6250;</p><p>        page.angle  = (_dialogCamera == true and 40 ) or 47;</p><p>        page.lookAt = {Entity, 100};</p><p>        page.title  = _title;</p><p>        page.text   = _text or "";</p><p>        page.action = _action;</p><p>        return AP(page);</p><p>    end</p><p>    local ASMC = function(_entity, _title, _text, _dialogCamera, ...)</p><p>        local Entity = Logic.GetEntityName(GetID(_entity));</p><p>        assert(Entity ~= nil and Entity ~= "");</p><p>        local page    = {};</p><p>        page.zoom     = (_dialogCamera == true and 2400 ) or 6250;</p><p>        page.angle    = (_dialogCamera == true and 40 ) or 47;</p><p>        page.lookAt   = {Entity, 100};</p><p>        page.barStyle = "big";</p><p>        page.mc = {</p><p>            title = _title,</p><p>            text = _text,</p><p>            answers = {}</p><p>        };</p><p>        local args = {...};</p><p>        for i=1, #args-1, 2 do</p><p>            page.mc.answers[#page.mc.answers+1] = {args[i], args[i+1]};</p><p>        end</p><p>        return AP(page);</p><p>    end</p><p>    return AP, ASP, ASMC;</p><p>-- Initalisiert das Briefing System im lokalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    -- Setze Standardfarben</p><p>    DBlau   = "{@color:70,70,255,255}";</p><p>    Blau    = "{@color:153,210,234,255}";</p><p>    Weiss   = "{@color:255,255,255,255}";</p><p>    Rot     = "{@color:255,32,32,255}";</p><p>    Gelb    = "{@color:244,184,0,255}";</p><p>    Gruen   = "{@color:173,255,47,255}";</p><p>    Orange  = "{@color:255,127,0,255}";</p><p>    Mint    = "{@color:0,255,255,255}";</p><p>    Grau    = "{@color:180,180,180,255}";</p><p>    Trans   = "{@color:0,0,0,0}";</p><p>    Quest_Loop = function(_arguments)</p><p>        local self = JobQueue_GetParameter(_arguments)</p><p>        if self.LoopCallback ~= nil then</p><p>            self:LoopCallback()</p><p>        end</p><p>        if self.State == QuestState.NotTriggered then</p><p>            local triggered = true</p><p>            for i = 1, self.Triggers[0] do</p><p>                triggered = triggered and self:IsTriggerActive(self.Triggers[i])</p><p>            end</p><p>            if triggered then</p><p>                self:SetMsgKeyOverride()</p><p>                self:SetIconOverride()</p><p>                self:Trigger()</p><p>            end</p><p>        elseif self.State == QuestState.Active then</p><p>            local allTrue = true</p><p>            local anyFalse = false</p><p>            for i = 1, self.Objectives[0] do</p><p>                local completed = self:IsObjectiveCompleted(self.Objectives[i])</p><p>                -- Wenn ein Briefing läuft, vergeht keine Zeit in laufenden Quests</p><p>                if IsBriefingActive() then</p><p>                    if BundleBriefingSystem.Global.Data.QuestsPausedWhileBriefingActive == true then</p><p>                        self.StartTime = self.StartTime +1;</p><p>                    end</p><p>                end</p><p>                if self.Objectives[i].Type == Objective.Deliver and completed == nil then</p><p>                    if self.Objectives[i].Data[4] == nil then</p><p>                        self.Objectives[i].Data[4] = 0</p><p>                    end</p><p>                    if self.Objectives[i].Data[3] ~= nil then</p><p>                        self.Objectives[i].Data[4] = self.Objectives[i].Data[4] + 1</p><p>                    end</p><p>                    local st = self.StartTime</p><p>                    local sd = self.Duration</p><p>                    local dt = self.Objectives[i].Data[4]</p><p>                    local sum = self.StartTime + self.Duration - self.Objectives[i].Data[4]</p><p>                    if self.Duration > 0 and self.StartTime + self.Duration + self.Objectives[i].Data[4] < Logic.GetTime() then</p><p>                        completed = false</p><p>                    end</p><p>                else</p><p>                    if self.Duration > 0 and self.StartTime + self.Duration < Logic.GetTime() then</p><p>                        if completed == nil and</p><p>                            (self.Objectives[i].Type == Objective.Protect or self.Objectives[i].Type == Objective.Dummy or self.Objectives[i].Type == Objective.NoChange) then</p><p>                            completed = true</p><p>                        elseif completed == nil or self.Objectives[i].Type == Objective.DummyFail then</p><p>                            completed = false</p><p>                       end</p><p>                    end</p><p>                end</p><p>                allTrue = (completed == true) and allTrue</p><p>                anyFalse = completed == false or anyFalse</p><p>            end</p><p>            if allTrue then</p><p>                self:Success()</p><p>            elseif anyFalse then</p><p>                self:Fail()</p><p>            end</p><p>        else</p><p>            if self.IsEventQuest == true then</p><p>                Logic.ExecuteInLuaLocalState("StopEventMusic(nil, "..self.ReceivingPlayer..")")</p><p>            end</p><p>            if self.Result == QuestResult.Success then</p><p>                for i = 1, self.Rewards[0] do</p><p>                    self:AddReward(self.Rewards[i])</p><p>                end</p><p>            elseif self.Result == QuestResult.Failure then</p><p>                for i = 1, self.Reprisals[0] do</p><p>                    self:AddReprisal(self.Reprisals[i])</p><p>                end</p><p>            end</p><p>            if self.EndCallback ~= nil then</p><p>                self:EndCallback()</p><p>            end</p><p>            return true</p><p>        end</p><p>        BundleBriefingSystem:OverwriteGetPosition();</p><p>    end</p><p>-- Briefing System Beginn --------------------------------------------------- --</p><p>    BriefingSystem = {</p><p>        isActive = false,</p><p>        waitList = {},</p><p>        isInitialized = false,</p><p>        maxMarkerListEntry = 0,</p><p>        currBriefingIndex = 0,</p><p>        loadScreenHidden = false</p><p>    };</p><p>    BriefingSystem.BRIEFING_CAMERA_ANGLEDEFAULT = 43;</p><p>    BriefingSystem.BRIEFING_CAMERA_ROTATIONDEFAULT = -45;</p><p>    BriefingSystem.BRIEFING_CAMERA_ZOOMDEFAULT = 6250;</p><p>    BriefingSystem.BRIEFING_CAMERA_FOVDEFAULT = 42;</p><p>    BriefingSystem.BRIEFING_DLGCAMERA_ANGLEDEFAULT = 29;</p><p>    BriefingSystem.BRIEFING_DLGCAMERA_ROTATIONDEFAULT = -45;</p><p>    BriefingSystem.BRIEFING_DLGCAMERA_ZOOMDEFAULT = 3400;</p><p>    BriefingSystem.BRIEFING_DLGCAMERA_FOVDEFAULT = 25;</p><p>    BriefingSystem.STANDARDTIME_PER_PAGE = 1;</p><p>    BriefingSystem.SECONDS_PER_CHAR = 0.05;</p><p>    BriefingSystem.COLOR1 = "{@color:255,250,0,255}";</p><p>    BriefingSystem.COLOR2 = "{@color:255,255,255,255}";</p><p>    BriefingSystem.COLOR3 = "{@color:250,255,0,255}";</p><p>    BriefingSystem.BRIEFING_FLYTIME = 0;</p><p>    BriefingSystem.POINTER_HORIZONTAL = 1;</p><p>    BriefingSystem.POINTER_VERTICAL = 4;</p><p>    BriefingSystem.POINTER_VERTICAL_LOW = 5;</p><p>    BriefingSystem.POINTER_VERTICAL_HIGH = 6;</p><p>    BriefingSystem.ANIMATED_MARKER = 1;</p><p>    BriefingSystem.STATIC_MARKER = 2;</p><p>    BriefingSystem.POINTER_PERMANENT_MARKER = 6;</p><p>    BriefingSystem.ENTITY_PERMANENT_MARKER = 8;</p><p>    BriefingSystem.SIGNAL_MARKER = 0;</p><p>    BriefingSystem.ATTACK_MARKER = 3;</p><p>    BriefingSystem.CRASH_MARKER = 4;</p><p>    BriefingSystem.POINTER_MARKER = 5;</p><p>    BriefingSystem.ENTITY_MARKER = 7;</p><p>    BriefingSystem.BRIEFING_EXPLORATION_RANGE = 6000;</p><p>    BriefingSystem.SKIPMODE_ALL = 1;</p><p>    BriefingSystem.SKIPMODE_PERPAGE = 2;</p><p>    BriefingSystem.DEFAULT_EXPLORE_ENTITY = "XD_Camera";</p><p>    ---</p><p>    -- Startet ein Briefing im Cutscene Mode. Alle nicht erlauten Operationen,</p><p>    -- wie seitenweises Überspringen oder Multiple Choice, sind deaktiviert</p><p>    -- bzw. verhindern den Start der Cutscene.</p><p>    --</p><p>    -- <p><b>Hinweis:</b> Bei diesen Cutscenes handelt es sich nicht um echte</p><p>    -- Cutscenes sondern um eine Simulation. Die Kamerabewegung wird</p><p>    -- dementsprechend nicht so flüssig sein und es kann ruckeln!</p></p><p>    --</p><p>    -- <p><b>Alias</b>: BriefingSystem.StartCutscene <br/></p></p><p>    -- <p><b>Alias</b>: StartCutscene</p></p><p>    --</p><p>    -- @param _briefing [table] Briefing</p><p>    -- @return [number] Briefing-ID</p><p>    -- @within Anwenderfunktionen</p><p>    --</p><p>    function API.StartCutscene(_briefing)</p><p>        -- Seitenweises abbrechen ist nicht erlaubt</p><p>        _briefing.skipPerPage = false;</p><p>        for i=1, #_briefing, 1 do</p><p>            -- Multiple Choice ist nicht erlaubt</p><p>            if _briefing[i].mc then</p><p>                API.Fatal("API.StartCutscene: Unallowed multiple choice at page " ..i.. " found!");</p><p>                return;</p><p>            end</p><p>            -- Marker sind nicht erlaubt</p><p>            if _briefing[i].marker then</p><p>                API.Fatal("API.StartCutscene: Unallowed marker at page " ..i.. " found!");</p><p>                return;</p><p>            end</p><p>            -- Pointer sind nicht erlaubt</p><p>            if _briefing[i].pointer then</p><p>                API.Fatal("API.StartCutscene: Unallowed pointer at page " ..i.. " found!");</p><p>                return;</p><p>            end</p><p>            -- Exploration ist nicht erlaubt</p><p>            if _briefing[i].explore then</p><p>                API.Fatal("API.StartCutscene: Unallowed explore at page " ..i.. " found!");</p><p>                return;</p><p>            end</p><p>        end</p><p>        return BriefingSystem.StartBriefing(_briefing, true);</p><p>    end</p><p>    BriefingSystem.StartCutscene = API.StartCutscene;</p><p>    StartCutscene = API.StartCutscene;</p><p>    ---</p><p>    -- Startet ein normales Briefing oder eine Fake-Cutscene.</p><p>    --</p><p>    -- Briefings können mittels Multiple Choice Dialogen über Verzweigungen</p><p>    -- verfügen und so komplexe Dialoge oder Menüstrukturen abbilden. Briefings</p><p>    -- sollten eingesetzt werden, wenn Quests nicht mehr ausreichen um die</p><p>    -- Handlung zu erzählen oder um multiple Handlungsstränge zu starten.</p><p>    --</p><p>    -- <p><b>Alias</b>: BriefingSystem.StartBriefing <br/></p></p><p>    -- <p><b>Alias</b>: StartBriefing</p></p><p>    --</p><p>    -- @param _briefing     [table] Briefing</p><p>    -- @param _cutsceneMode [boolean] Cutscene-Mode nutzen</p><p>    -- @return number: Briefing-ID</p><p>    -- @within Anwenderfunktionen</p><p>    --</p><p>    function API.StartBriefing(_briefing, _cutsceneMode)</p><p>        -- view wird nur Ausgeführt, wenn es sich um eine Cutscene handelt</p><p>        -- CutsceneMode = false -> alte Berechnung und Syntax</p><p>        _cutsceneMode = _cutsceneMode or false;</p><p>        Logic.ExecuteInLuaLocalState([[</p><p>            BriefingSystem.Flight.systemEnabled = ]]..tostring(not _cutsceneMode)..[[</p><p>        ]]);</p><p>        -- Briefing ID erzeugen</p><p>        BundleBriefingSystem.Global.Data.BriefingID = BundleBriefingSystem.Global.Data.BriefingID +1;</p><p>        _briefing.UniqueBriefingID = BundleBriefingSystem.Global.Data.BriefingID;</p><p>        if #_briefing > 0 then</p><p>            _briefing[1].duration = (_briefing[1].duration or 0) + 0.1;</p><p>        end</p><p>        -- Grenzsteine ausblenden</p><p>        if _briefing.hideBorderPins then</p><p>            Logic.ExecuteInLuaLocalState([[Display.SetRenderBorderPins(0)]]);</p><p>        end</p><p>        -- Himmel anzeigen</p><p>        if _briefing.showSky then</p><p>            Logic.ExecuteInLuaLocalState([[Display.SetRenderSky(1)]]);</p><p>        end</p><p>        -- Okklusion abschalten</p><p>        Logic.ExecuteInLuaLocalState([[</p><p>            Display.SetUserOptionOcclusionEffect(0)</p><p>        ]]);</p><p>        -- callback überschreiben</p><p>        _briefing.finished_Orig_QSB_Briefing = _briefing.finished;</p><p>        _briefing.finished = function(self)</p><p>            -- Grenzsteine einschalten</p><p>            if _briefing.hideBorderPins then</p><p>                Logic.ExecuteInLuaLocalState([[Display.SetRenderBorderPins(1)]]);</p><p>            end</p><p>            --</p><p>            if _briefing.showSky then</p><p>                Logic.ExecuteInLuaLocalState([[Display.SetRenderSky(0)]]);</p><p>            end</p><p>            -- Okklusion einschalten, wenn sie aktiv war</p><p>            Logic.ExecuteInLuaLocalState([[</p><p>                if Options.GetIntValue("Display", "Occlusion", 0) > 0 then</p><p>                    Display.SetUserOptionOcclusionEffect(1)</p><p>                end</p><p>            ]]);</p><p>            _briefing.finished_Orig_QSB_Briefing(self);</p><p>            BundleBriefingSystem.Global.Data.PlayedBriefings[_briefing.UniqueBriefingID] = true;</p><p>        end</p><p>        -- Briefing starten</p><p>        if BriefingSystem.isActive then</p><p>            table.insert(BriefingSystem.waitList, _briefing);</p><p>            if not BriefingSystem.waitList.Job then</p><p>                BriefingSystem.waitList.Job = StartSimpleJob("BriefingSystem_WaitForBriefingEnd");</p><p>            end</p><p>        else</p><p>            BriefingSystem.ExecuteBriefing(_briefing);</p><p>        end</p><p>        return BundleBriefingSystem.Global.Data.BriefingID;</p><p>    end</p><p>    BriefingSystem.StartBriefing = API.StartBriefing;</p><p>    StartBriefing = API.StartBriefing;</p><p>    ---</p><p>    -- Beendet ein laufendes Briefing oder eine laufende Fake-Cutscene.</p><p>    --</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem.EndBriefing()</p><p>        BriefingSystem.isActive = false;</p><p>        Logic.SetGlobalInvulnerability(0);</p><p>        local briefing = BriefingSystem.currBriefing;</p><p>        BriefingSystem.currBriefing = nil;</p><p>        BriefingSystem[BriefingSystem.currBriefingIndex] = nil;</p><p>        Logic.ExecuteInLuaLocalState("BriefingSystem.EndBriefing()");</p><p>        EndJob(BriefingSystem.job);</p><p>        if briefing.finished then</p><p>            briefing:finished();</p><p>        end</p><p>    end</p><p>    ---</p><p>    -- Wartet, bis ein Briefing beendet ist und führt dann das nächste</p><p>    -- Briefing in der Warteschlange aus.</p><p>    --</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem_WaitForBriefingEnd()</p><p>        if not BriefingSystem.isActive and BriefingSystem.loadScreenHidden then</p><p>            BriefingSystem.ExecuteBriefing(table.remove(BriefingSystem.waitList), 1);</p><p>            if #BriefingSystem.waitList == 0 then</p><p>                BriefingSystem.waitList.Job = nil;</p><p>                return true;</p><p>            end</p><p>        end</p><p>    end</p><p>    ---</p><p>    -- Führt das aktuelle Briefing aus.</p><p>    --</p><p>    -- @param _briefing Aktuelles Briefing</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem.ExecuteBriefing(_briefing)</p><p>        if not BriefingSystem.isInitialized then</p><p>            Logic.ExecuteInLuaLocalState("BriefingSystem.InitializeBriefingSystem()");</p><p>            BriefingSystem.isInitialized = true;</p><p>        end</p><p>        BriefingSystem.isActive = true;</p><p>        BriefingSystem.currBriefing = _briefing;</p><p>        BriefingSystem.currBriefingIndex = BriefingSystem.currBriefingIndex + 1;</p><p>        BriefingSystem[BriefingSystem.currBriefingIndex] = _briefing;</p><p>        BriefingSystem.timer = 0;</p><p>        BriefingSystem.page = 0;</p><p>        BriefingSystem.skipPlayers = {};</p><p>        BriefingSystem.disableSkipping = BriefingSystem.currBriefing.disableSkipping;</p><p>        BriefingSystem.activate3dOnScreenDisplay = BriefingSystem.currBriefing.activate3dOnScreenDisplay;</p><p>        BriefingSystem.skipAll = BriefingSystem.currBriefing.skipAll;</p><p>        BriefingSystem.skipPerPage = not BriefingSystem.skipAll and BriefingSystem.currBriefing.skipPerPage;</p><p>        if not _briefing.disableGlobalInvulnerability then</p><p>            Logic.SetGlobalInvulnerability(1);</p><p>        end</p><p>        Logic.ExecuteInLuaLocalState("BriefingSystem.PrepareBriefing()");</p><p>        BriefingSystem.currBriefing = BriefingSystem.UpdateMCAnswers(BriefingSystem.currBriefing);</p><p>        BriefingSystem.job = Trigger.RequestTrigger(Events.LOGIC_EVENT_EVERY_TURN, "BriefingSystem_Condition_Briefing", "BriefingSystem_Action_Briefing", 1);</p><p>        if not BriefingSystem.loadScreenHidden then</p><p>            Logic.ExecuteInLuaLocalState("BriefingSystem.Briefing(true)");</p><p>        elseif BriefingSystem_Action_Briefing() then</p><p>            EndJob(BriefingSystem.job);</p><p>        end</p><p>    end</p><p>    ---</p><p>    -- Aktualisiert die verfügbaren Optionen wärhend eines Multiple Choice</p><p>    -- Dialogs.</p><p>    --</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem.UpdateMCAnswers(_briefing)</p><p>        if _briefing then</p><p>            local i = 1;</p><p>            while (_briefing[i] ~= nil and #_briefing >= i)</p><p>            do</p><p>                if type(_briefing[i]) == "table" and _briefing[i].mc and _briefing[i].mc.answers then</p><p>                    local aswID = 1;</p><p>                    local j = 1;</p><p>                    while (_briefing[i].mc.answers[j] ~= nil)</p><p>                    do</p><p>                        -- Speichert die ID der Antwort</p><p>                        if not _briefing[i].mc.answers[j].ID then</p><p>                            _briefing[i].mc.answers[j].ID = aswID;</p><p>                        end</p><p>                        -- Entferne Antwort</p><p>                        if _briefing[i].mc.answers[j].remove then</p><p>                            table.remove(BriefingSystem.currBriefing[i].mc.answers, j);</p><p>                            if #BriefingSystem.currBriefing[i].mc.answers < j then</p><p>                                BriefingSystem.currBriefing[i].mc.current = #BriefingSystem.currBriefing[i].mc.answers</p><p>                            end</p><p>                            Logic.ExecuteInLuaLocalState([[</p><p>                                table.remove(BriefingSystem.currBriefing[]]..i..[[].mc.answers, ]]..j..[[)</p><p>                                if #BriefingSystem.currBriefing[]]..i..[[].mc.answers < ]]..j..[[ then</p><p>                                    BriefingSystem.currBriefing[]]..i..[[].mc.current = #BriefingSystem.currBriefing[]]..i..[[].mc.answers</p><p>                                end</p><p>                            ]]);</p><p>                        end</p><p>                        -- ID hochzählen</p><p>                        aswID = aswID +1;</p><p>                        j = j +1;</p><p>                    end</p><p>                    if #_briefing[i].mc.answers == 0 then</p><p>                        local lang = Network.GetDesiredLanguage();</p><p>                        _briefing[i].mc.answers[1] = {(lang == "de" and "ENDE") or "END", 999999};</p><p>                    end</p><p>                end</p><p>                i = i +1;</p><p>            end</p><p>        end</p><p>        return _briefing;</p><p>    end</p><p>    ---</p><p>    -- Prüft, ob ein Briefing aktiv ist.</p><p>    --</p><p>    -- <p><b>Alias:</b> IsBriefingActive</p></p><p>    --</p><p>    -- @return boolean: Briefing aktiv</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem.IsBriefingActive()</p><p>        return BriefingSystem.isActive;</p><p>    end</p><p>    IsBriefingActive = BriefingSystem.IsBriefingActive</p><p>    ---</p><p>    -- Condition des Briefing-Job: Prüft, ob die Action ausgeführt wird.</p><p>    --</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem_Condition_Briefing()</p><p>        if not BriefingSystem.loadScreenHidden then</p><p>            return false;</p><p>        end</p><p>        BriefingSystem.timer = BriefingSystem.timer - 0.1;</p><p>        return BriefingSystem.timer <= 0;</p><p>    end</p><p>    ---</p><p>    -- Action des Briefing-Job: Führt das eigentliche Briefing aus.</p><p>    --</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem_Action_Briefing()</p><p>        BriefingSystem.page = BriefingSystem.page + 1;</p><p>        local page;</p><p>        if BriefingSystem.currBriefing then</p><p>            page = BriefingSystem.currBriefing[BriefingSystem.page];</p><p>        end</p><p>        if not BriefingSystem.skipAll and not BriefingSystem.disableSkipping then</p><p>            for i = 1, 8 do</p><p>                if BriefingSystem.skipPlayers[i] ~= BriefingSystem.SKIPMODE_ALL then</p><p>                    BriefingSystem.skipPlayers[i] = nil;</p><p>                    if type(page) == "table" and page.skipping == false then</p><p>                        Logic.ExecuteInLuaLocalState("BriefingSystem.EnableBriefingSkipButton(" .. i .. ", false)");</p><p>                    else</p><p>                        Logic.ExecuteInLuaLocalState("BriefingSystem.EnableBriefingSkipButton(" .. i .. ", true)");</p><p>                    end</p><p>                end</p><p>            end</p><p>        end</p><p>        if not page or page == -1 then</p><p>            BriefingSystem.EndBriefing();</p><p>            return true;</p><p>        elseif type(page) == "number" and page > 0 then</p><p>            BriefingSystem.timer = 0;</p><p>            BriefingSystem.page  = page-1;</p><p>            return;</p><p>        end</p><p>        if page.mc then</p><p>            Logic.ExecuteInLuaLocalState('XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/Skip", 0)');</p><p>            BriefingSystem.currBriefing[BriefingSystem.page].duration = 99999999;</p><p>        else</p><p>            local nextPage = BriefingSystem.currBriefing[BriefingSystem.page+1];</p><p>            if not BriefingSystem.disableSkipping then</p><p>                Logic.ExecuteInLuaLocalState('XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/Skip", 1)');</p><p>            end</p><p>        end</p><p>        BriefingSystem.timer = page.duration or BriefingSystem.STANDARDTIME_PER_PAGE;</p><p>        if page.explore then</p><p>            page.exploreEntities = {};</p><p>            if type(page.explore) == "table" then</p><p>                if #page.explore > 0 or page.explore.default then</p><p>                    for pId = 1, 8 do</p><p>                        local playerExplore = page.explore[player] or page.explore.default;</p><p>                        if playerExplore then</p><p>                            if type(playerExplore) == "table" then</p><p>                                BriefingSystem.CreateExploreEntity(page, playerExplore.exploration, playerExplore.type or Entities[BriefingSystem.DEFAULT_EXPLORE_ENTITY], pId, playerExplore.position);</p><p>                            else</p><p>                                BriefingSystem.CreateExploreEntity(page, playerExplore, Entities[BriefingSystem.DEFAULT_EXPLORE_ENTITY], pId);</p><p>                            end</p><p>                        end</p><p>                    end</p><p>                else</p><p>                    BriefingSystem.CreateExploreEntity(page, page.explore.exploration, page.explore.type or Entities[BriefingSystem.DEFAULT_EXPLORE_ENTITY], 1, page.explore.position);</p><p>                end</p><p>            else</p><p>                BriefingSystem.CreateExploreEntity(page, page.explore, Entities[BriefingSystem.DEFAULT_EXPLORE_ENTITY], 1);</p><p>            end</p><p>        end</p><p>        if page.pointer then</p><p>            local pointer = page.pointer;</p><p>            page.pointerList = {};</p><p>            if type(pointer) == "table" then</p><p>                if #pointer > 0 then</p><p>                    for i = 1, #pointer do</p><p>                        BriefingSystem.CreatePointer(page, pointer[i]);</p><p>                    end</p><p>                else</p><p>                    BriefingSystem.CreatePointer(page, pointer);</p><p>                end</p><p>            else</p><p>                BriefingSystem.CreatePointer(page, { type = pointer, position = page.position or page.followEntity });</p><p>            end</p><p>        end</p><p>        if page.marker then</p><p>            BriefingSystem.maxMarkerListEntry = BriefingSystem.maxMarkerListEntry + 1;</p><p>            page.markerList = BriefingSystem.maxMarkerListEntry;</p><p>        end</p><p>        Logic.ExecuteInLuaLocalState("BriefingSystem.Briefing()");</p><p>        if page.action then</p><p>            page:action();</p><p>        end</p><p>    end</p><p>    ---</p><p>    -- Überspringt ein Briefing.</p><p>    --</p><p>    -- @param _player ID des aktiven Spielers</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem.SkipBriefing(_player)</p><p>        if not BriefingSystem.disableSkipping then</p><p>            if BriefingSystem.skipPerPage then</p><p>                BriefingSystem.SkipBriefingPage(_player);</p><p>                return;</p><p>            end</p><p>            BriefingSystem.skipPlayers[_player] = BriefingSystem.SKIPMODE_ALL;</p><p>            for i = 1, 8, 1 do</p><p>                if Logic.PlayerGetIsHumanFlag(i) and BriefingSystem.skipPlayers[i] ~= BriefingSystem.SKIPMODE_ALL then</p><p>                    Logic.ExecuteInLuaLocalState("BriefingSystem.EnableBriefingSkipButton(" .. _player .. ", false)");</p><p>                    return;</p><p>                end</p><p>            end</p><p>            EndJob(BriefingSystem.job);</p><p>            BriefingSystem.EndBriefing();</p><p>        end</p><p>    end</p><p>    ---</p><p>    -- Überspringt eine Briefing-Seite.</p><p>    --</p><p>    -- @param _player ID des aktiven Spielers</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem.SkipBriefingPage(_player)</p><p>        if not BriefingSystem.disableSkipping then</p><p>            if not BriefingSystem.LastSkipTimeStemp or Logic.GetTimeMs() > BriefingSystem.LastSkipTimeStemp + 500 then</p><p>                BriefingSystem.LastSkipTimeStemp = Logic.GetTimeMs();</p><p>                if not BriefingSystem.skipPlayers[_player] then</p><p>                    BriefingSystem.skipPlayers[_player] = BriefingSystem.SKIPMODE_PERPAGE;</p><p>                end</p><p>                for i = 1, 8, 1 do</p><p>                    if Logic.PlayerGetIsHumanFlag(_player) and not BriefingSystem.skipPlayers[_player] then</p><p>                        if BriefingSystem.skipPerPage then</p><p>                            Logic.ExecuteInLuaLocalState("BriefingSystem.EnableBriefingSkipButton(" .. _player .. ", false)");</p><p>                        end</p><p>                        return;</p><p>                    end</p><p>                end</p><p>                if BriefingSystem.skipAll then</p><p>                    BriefingSystem.SkipBriefing(_player);</p><p>                elseif BriefingSystem_Action_Briefing() then</p><p>                    EndJob(BriefingSystem.job);</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>    ---</p><p>    -- Deckt einen bestimmten Bereich auf der Spielwelt auf.</p><p>    -- FIXME: Diese Funktion deckt komplette Territorien auf!</p><p>    --</p><p>    -- @param _page        Aktuelle Seite</p><p>    -- @param _exploration Aufdeckungsradius</p><p>    -- @param _entityType  Typ des Exploration Entity</p><p>    -- @param _player      PlayerID, für die aufgedeckt wird</p><p>    -- @param _position    Mittelpunkt der Aufdeckung</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem.CreateExploreEntity(_page, _exploration, _entityType, _player, _position)</p><p>        local position = _position or _page.position;</p><p>        if position then</p><p>            if type(position) == "table" and (position[_player] or position.default or position.playerPositions) then</p><p>                position = position[_player] or position.default;</p><p>            end</p><p>            if position then</p><p>                local tPosition = type(position);</p><p>                if tPosition == "string" or tPosition == "number" then</p><p>                    position = GetPosition(position);</p><p>                end</p><p>            end</p><p>        end</p><p>        if not position then</p><p>            local followEntity = _page.followEntity;</p><p>            if type(followEntity) == "table" then</p><p>                followEntity = followEntity[_player] or followEntity.default;</p><p>            end</p><p>            if followEntity then</p><p>                position = GetPosition(followEntity);</p><p>            end</p><p>        end</p><p>        assert(position);</p><p>        local entity = Logic.CreateEntity(_entityType, position.X, position.Y, 0, _player);</p><p>        assert(entity ~= 0);</p><p>        Logic.SetEntityExplorationRange(entity, _exploration / 100);</p><p>        table.insert(_page.exploreEntities, entity);</p><p>    end</p><p>    ---</p><p>    -- Erstellt einen Questmarker auf der Spielwelt.</p><p>    --</p><p>    -- @param _page    Aktuelle Seite</p><p>    -- @param _pointer Aufdeckungsradius</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem.CreatePointer(_page, _pointer)</p><p>        local pointerType = _pointer.type or BriefingSystem.POINTER_VERTICAL;</p><p>        local position = _pointer.position;</p><p>        assert(position);</p><p>        if pointerType / BriefingSystem.POINTER_VERTICAL >= 1 then</p><p>            local entity = position;</p><p>            if type(position) == "table" then</p><p>                local _;</p><p>                _, entity = Logic.GetEntitiesInArea(0, position.X, position.Y, 50, 1);</p><p>            else</p><p>                position = GetPosition(position);</p><p>            end</p><p>            local effectType = EGL_Effects.E_Questmarker_low;</p><p>            if pointerType == BriefingSystem.POINTER_VERTICAL_HIGH then</p><p>                effectType = EGL_Effects.E_Questmarker;</p><p>            elseif pointerType ~= BriefingSystem.POINTER_VERTICAL_LOW then</p><p>                if entity ~= 0 then</p><p>                    if Logic.IsBuilding(entity) == 1 then</p><p>                        pointerType = EGL_Effects.E_Questmarker;</p><p>                    end</p><p>                end</p><p>            end</p><p>            table.insert(_page.pointerList, { id = Logic.CreateEffect(effectType, position.X, position.Y, _pointer.player or 0), type = pointerType });</p><p>        else</p><p>            assert(pointerType == BriefingSystem.POINTER_HORIZONTAL);</p><p>            if type(position) ~= "table" then</p><p>                position = GetPosition(position);</p><p>            end</p><p>            table.insert(_page.pointerList, { id = Logic.CreateEntityOnUnblockedLand(Entities.E_DirectionMarker, position.X, position.Y, _pointer.orientation or 0, _pointer.player or 0), type = pointerType });</p><p>        end</p><p>    end</p><p>    ---</p><p>    -- Zerstört den Marker der aktuellen Briefing-Seite.</p><p>    --</p><p>    -- @param _page  Aktuelle Seite</p><p>    -- @param _index Index des Markers</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem.DestroyPageMarker(_page, _index)</p><p>        if _page.marker then</p><p>            Logic.ExecuteInLuaLocalState("BriefingSystem.DestroyPageMarker(" .. _page.markerList .. ", " .. _index .. ")");</p><p>        end</p><p>    end</p><p>    ---</p><p>    -- Aktualisiert alle Marker der Briefing-Seite oder erstellt sie neu.</p><p>    --</p><p>    -- @param _page     Aktuelle Seite</p><p>    -- @param _position Position des markers</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem.RedeployPageMarkers(_page, _position)</p><p>        if _page.marker then</p><p>            if type(_position) ~= "table" then</p><p>                _position = GetPosition(_position);</p><p>            end</p><p>            Logic.ExecuteInLuaLocalState("BriefingSystem.RedeployMarkerList(" .. _page.markerList .. ", " .. _position.X .. ", " .. _position.Y .. ")");</p><p>        end</p><p>    end</p><p>    ---</p><p>    -- Aktualisiert einen Marker der Briefing-Seite oder erstellt ihn neu.</p><p>    --</p><p>    -- @param _page     Aktuelle Seite</p><p>    -- @param _index Index des Markers</p><p>    -- @param _position Position des markers</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem.RedeployPageMarker(_page, _index, _position)</p><p>        if _page.marker then</p><p>            if type(_position) ~= "table" then</p><p>                _position = GetPosition(_position);</p><p>            end</p><p>            Logic.ExecuteInLuaLocalState("BriefingSystem.RedeployMarkerOfList(" .. _page.markerList .. ", " .. _index .. ", " .. _position.X .. ", " .. _position.Y .. ")");</p><p>        end</p><p>    end</p><p>    ---</p><p>    -- Erneuert alle Marker der Briefing-Seite.</p><p>    --</p><p>    -- @param _page     Aktuelle Seite</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem.RefreshPageMarkers(_page)</p><p>        if _page.marker then</p><p>            Logic.ExecuteInLuaLocalState("BriefingSystem.RefreshMarkerList(" .. _page.markerList .. ")");</p><p>        end</p><p>    end</p><p>    ---</p><p>    -- Erneuert einen Marker der Briefing-Seite.</p><p>    --</p><p>    -- @param _page     Aktuelle Seite</p><p>    -- @param _index Index des Markers</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem.RefreshPageMarker(_page, _index)</p><p>        if _page.marker then</p><p>            Logic.ExecuteInLuaLocalState("BriefingSystem.RefreshMarkerOfList(" .. _page.markerList .. ", " .. _index .. ")");</p><p>        end</p><p>    end</p><p>    ---</p><p>    -- Entfernt alle Effekte, die mit der Briefing-Seite verbunden sind.</p><p>    --</p><p>    -- Effekte können sein: Aufdeckungsbereiche, Marker, Pointer.</p><p>    --</p><p>    -- @param _page     Aktuelle Seite</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem.ResolveBriefingPage(_page)</p><p>        if _page.explore and _page.exploreEntities then</p><p>            for i, v in ipairs(_page.exploreEntities) do</p><p>                Logic.DestroyEntity(v);</p><p>            end</p><p>            _page.exploreEntities = nil;</p><p>        end</p><p>        if _page.pointer and _page.pointerList then</p><p>            for i, v in ipairs(_page.pointerList) do</p><p>                if v.type ~= BriefingSystem.POINTER_HORIZONTAL then</p><p>                    Logic.DestroyEffect(v.id);</p><p>                else</p><p>                    Logic.DestroyEntity(v.id);</p><p>                end</p><p>            end</p><p>            _page.pointerList = nil;</p><p>        end</p><p>        if _page.marker and _page.markerList then</p><p>            Logic.ExecuteInLuaLocalState("BriefingSystem.DestroyMarkerList(" .. _page.markerList .. ")");</p><p>            _page.markerList = nil;</p><p>        end</p><p>    end</p><p>    ResolveBriefingPage = BriefingSystem.ResolveBriefingPage;</p><p>    ---</p><p>    -- Wenn eine Antwort ausgewählt wurde, wird der entsprechende</p><p>    -- Sprung durchgeführt. Wenn remove = true ist, wird die Option</p><p>    -- für den Rest des Briefings deaktiviert (für Rücksprünge).</p><p>    --</p><p>    -- @param _aswID			Index der Antwort</p><p>    -- @param _currentPage		Aktuelle Seite</p><p>    -- @param _currentAnswer	Gegebene Antwort</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem.OnConfirmed(_aswID, _currentPage, _currentAnswer)</p><p>        BriefingSystem.timer = 0</p><p>        local page = BriefingSystem.currBriefing[BriefingSystem.page];</p><p>        local pageNumber = BriefingSystem.page;</p><p>        local current = _currentPage;</p><p>        local jump = page.mc.answers[current][2];</p><p>        BriefingSystem.currBriefing[pageNumber].mc.given = _aswID;</p><p>        if type(jump) == "function" then</p><p>            BriefingSystem.page = jump(page.mc.answers[_currentAnswer])-1;</p><p>        else</p><p>            BriefingSystem.page = jump-1;</p><p>        end</p><p>        BriefingSystem.currBriefing = BriefingSystem.UpdateMCAnswers(BriefingSystem.currBriefing);</p><p>    end</p><p>    ---</p><p>    -- Diese Funktion wird aufgerufen, wenn der Spieler während eines</p><p>    -- Briefings auf ein Entity klickt.</p><p>    --</p><p>    -- @param _EntityID	Selected Entity</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem.LeftClickOnEntity(_EntityID)</p><p>        if _EntityID == nil then</p><p>            return;</p><p>        end</p><p>        if BriefingSystem.IsBriefingActive == false then</p><p>            return;</p><p>        end</p><p>        local Page = BriefingSystem.currBriefing[BriefingSystem.page];</p><p>        if Page.entityClicked then</p><p>            Page:entityClicked(_EntityID);</p><p>        end</p><p>    end</p><p>    ---</p><p>    -- Diese Funktion wird aufgerufen, wenn der Spieler während eines</p><p>    -- Briefings in die Spielwelt klickt.</p><p>    --</p><p>    -- @param _X X-Position</p><p>    -- @param _Y Y-Position</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem.LeftClickOnPosition(_X, _Y)</p><p>        if _X == nil or _Y == nil then</p><p>            return;</p><p>        end</p><p>        if BriefingSystem.IsBriefingActive == false then</p><p>            return;</p><p>        end</p><p>        local Page = BriefingSystem.currBriefing[BriefingSystem.page];</p><p>        if Page.positionClicked then</p><p>            Page:positionClicked(_X, _Y);</p><p>        end</p><p>    end</p><p>    ---</p><p>    -- Diese Funktion wird aufgerufen, wenn der Spieler während eines</p><p>    -- Briefings auf die Anzeige klickt.</p><p>    --</p><p>    -- @param _X X-Position</p><p>    -- @param _Y Y-Position</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem.LeftClickOnScreen(_X, _Y)</p><p>        if _X == nil or _Y == nil then</p><p>            return;</p><p>        end</p><p>        if BriefingSystem.IsBriefingActive == false then</p><p>            return;</p><p>        end</p><p>        local Page = BriefingSystem.currBriefing[BriefingSystem.page];</p><p>        if Page.screenClicked then</p><p>            Page:screenClicked(_X, _Y);</p><p>        end</p><p>    end</p><p>-- Local Script ----------------------------------------------------------------</p><p>-- Initalisiert das Bundle im lokalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    self:InitalizeBriefingSystem();</p><p>-- Initalisiert das Briefing System im lokalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    GameCallback_GUI_SelectionChanged_Orig_QSB_Briefing = GameCallback_GUI_SelectionChanged;</p><p>    GameCallback_GUI_SelectionChanged = function(_Source)</p><p>        GameCallback_GUI_SelectionChanged_Orig_QSB_Briefing(_Source);</p><p>        if IsBriefingActive() then</p><p>            GUI.ClearSelection();</p><p>        end</p><p>    end</p><p>    -- ---------------------------------------------------------------------- --</p><p>    DBlau     = "{@color:70,70,255,255}";</p><p>    Blau     = "{@color:153,210,234,255}";</p><p>    Weiss     = "{@color:255,255,255,255}";</p><p>    Rot         = "{@color:255,32,32,255}";</p><p>    Gelb       = "{@color:244,184,0,255}";</p><p>    Gruen     = "{@color:173,255,47,255}";</p><p>    Orange      = "{@color:255,127,0,255}";</p><p>    Mint      = "{@color:0,255,255,255}";</p><p>    Grau     = "{@color:180,180,180,255}";</p><p>    Trans     = "{@color:0,0,0,0}";</p><p>    if not InitializeFader then</p><p>        Script.Load("Script\\MainMenu\\Fader.lua");</p><p>    end</p><p>    BriefingSystem = {</p><p>        listOfMarkers = {},</p><p>        markerUniqueID = 2 ^ 10,</p><p>        Flight = {systemEnabled = true},</p><p>    };</p><p>    ---</p><p>    -- Initalisiert den Kern des Briefing System.</p><p>    --</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem.InitializeBriefingSystem()</p><p>        BriefingSystem.GlobalSystem = Logic.CreateReferenceToTableInGlobaLuaState("BriefingSystem");</p><p>        assert(BriefingSystem.GlobalSystem);</p><p>        if not BriefingSystem.GlobalSystem.loadScreenHidden then</p><p>            BriefingSystem.StartLoadScreenSupervising();</p><p>        end</p><p>        -- Escape deactivated to avoid errors with mc briefings</p><p>        BriefingSystem.GameCallback_Escape = GameCallback_Escape;</p><p>        GameCallback_Escape = function()</p><p>            if not BriefingSystem.IsBriefingActive() then</p><p>                BriefingSystem.GameCallback_Escape();</p><p>            end</p><p>        end</p><p>        BriefingSystem.Flight.Job = Trigger.RequestTrigger(Events.LOGIC_EVENT_EVERY_TURN, nil, "ThroneRoomCameraControl", 0);</p><p>    end</p><p>    ---</p><p>    -- Startet den Job, der darauf wartet, dass der Loadscreen verlassen wird.</p><p>    --</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem.StartLoadScreenSupervising()</p><p>        if not BriefingSystem_LoadScreenSupervising() then</p><p>            Trigger.RequestTrigger(Events.LOGIC_EVENT_EVERY_TURN, nil, "BriefingSystem_LoadScreenSupervising", 1);</p><p>        end</p><p>    end</p><p>    ---</p><p>    -- Setzt das LoadScreenHidden-Flag um dem globalen Skript mitzuteilen,</p><p>    -- das der Loadscreen verlassen ist.</p><p>    --</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem_LoadScreenSupervising()</p><p>        if  XGUIEng.IsWidgetShownEx("/LoadScreen/LoadScreen") == 0 then</p><p>            GUI.SendScriptCommand("BriefingSystem.loadScreenHidden = true;");</p><p>            return true;</p><p>        end</p><p>    end</p><p>    ---</p><p>    -- Bereitet das Interface auf das Briefing / die Cutsene vor.</p><p>    --</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem.PrepareBriefing()</p><p>        BriefingSystem.barType = nil;</p><p>        BriefingSystem.currBriefing = BriefingSystem.GlobalSystem[BriefingSystem.GlobalSystem.currBriefingIndex];</p><p>        Trigger.EnableTrigger(BriefingSystem.Flight.Job);</p><p>        local isLoadScreenVisible = XGUIEng.IsWidgetShownEx("/LoadScreen/LoadScreen") == 1;</p><p>        if isLoadScreenVisible then</p><p>            XGUIEng.PopPage();</p><p>        end</p><p>        if BriefingSystem.GlobalSystem.activate3dOnScreenDisplay ~= true then</p><p>            XGUIEng.ShowWidget("/InGame/Root/3dOnScreenDisplay", 0);</p><p>        end</p><p>        -- Normal briefing widgets</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal", 0);</p><p>        XGUIEng.ShowWidget("/InGame/ThroneRoom", 1);</p><p>        XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/Skip", BriefingSystem.GlobalSystem.disableSkipping and 0 or 1);</p><p>        BriefingSystem.EnableBriefingSkipButton(nil, true);</p><p>        XGUIEng.PushPage("/InGame/ThroneRoomBars", false);</p><p>        XGUIEng.PushPage("/InGame/ThroneRoomBars_2", false);</p><p>        XGUIEng.PushPage("/InGame/ThroneRoom/Main", false);</p><p>        XGUIEng.PushPage("/InGame/ThroneRoomBars_Dodge", false);</p><p>        XGUIEng.PushPage("/InGame/ThroneRoomBars_2_Dodge", false);</p><p>        XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogTopChooseKnight", 1);</p><p>        XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogTopChooseKnight/Frame", 0);</p><p>        XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogTopChooseKnight/DialogBG", 0);</p><p>        XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogTopChooseKnight/FrameEdges", 0);</p><p>        XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogBottomRight3pcs", 0);</p><p>        XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/KnightInfoButton", 0);</p><p>        XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/Briefing", 0);</p><p>        XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/BackButton", 0);</p><p>        XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/TitleContainer", 0);</p><p>        XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/StartButton", 0);</p><p>        XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Text", " ");</p><p>        XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Title", " ");</p><p>        XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Objectives", " ");</p><p>        -- Portrait wirget</p><p>        XGUIEng.PushPage("/InGame/ThroneRoom/KnightInfo", false);</p><p>        XGUIEng.ShowAllSubWidgets("/InGame/ThroneRoom/KnightInfo", 0);</p><p>        XGUIEng.ShowWidget("/InGame/ThroneRoom/KnightInfo/LeftFrame", 1);</p><p>        XGUIEng.ShowAllSubWidgets("/InGame/ThroneRoom/KnightInfo/LeftFrame", 0);</p><p>        XGUIEng.ShowWidget("/InGame/ThroneRoom/KnightInfo/KnightBG", 1);</p><p>        XGUIEng.SetWidgetPositionAndSize("/InGame/ThroneRoom/KnightInfo/KnightBG", 0, 4000, 400, 600);</p><p>        XGUIEng.SetMaterialAlpha("/InGame/ThroneRoom/KnightInfo/KnightBG", 0, 0);</p><p>        local page = BriefingSystem.currBriefing[1];</p><p>        BriefingSystem.SetBriefingPagePortrait(page)</p><p>        BriefingSystem.SetBriefingPageOrSplashscreen(page);</p><p>        BriefingSystem.SetBriefingPageTextPosition(page);</p><p>        if not Framework.IsNetworkGame() and Game.GameTimeGetFactor() ~= 0 then</p><p>            if BriefingSystem.currBriefing.restoreGameSpeed and not BriefingSystem.currBriefing.gameSpeedBackup then</p><p>                BriefingSystem.currBriefing.gameSpeedBackup = Game.GameTimeGetFactor();</p><p>            end</p><p>            Game.GameTimeSetFactor(GUI.GetPlayerID(), 1);</p><p>        end</p><p>        if BriefingSystem.currBriefing.restoreCamera then</p><p>            BriefingSystem.cameraRestore = { Camera.RTS_GetLookAtPosition() };</p><p>        end</p><p>        BriefingSystem.selectedEntities = { GUI.GetSelectedEntities() };</p><p>        GUI.ClearSelection();</p><p>        GUI.ForbidContextSensitiveCommandsInSelectionState();</p><p>        GUI.ActivateCutSceneState();</p><p>        GUI.SetFeedbackSoundOutputState(0);</p><p>        GUI.EnableBattleSignals(false);</p><p>        Mouse.CursorHide();</p><p>        Camera.SwitchCameraBehaviour(5);</p><p>        Input.CutsceneMode();</p><p>        InitializeFader();</p><p>        g_Fade.To = 0;</p><p>        SetFaderAlpha(0);</p><p>        if isLoadScreenVisible then</p><p>            XGUIEng.PushPage("/LoadScreen/LoadScreen", false);</p><p>        end</p><p>        if BriefingSystem.currBriefing.hideFoW then</p><p>            Display.SetRenderFogOfWar(0);</p><p>            GUI.MiniMap_SetRenderFogOfWar(0);</p><p>        end</p><p>    end</p><p>    ---</p><p>    -- Baut die Änderungen im Interface nach dem Ende des Briefings ab.</p><p>    --</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem.EndBriefing()</p><p>        if BriefingSystem.faderJob then</p><p>            Trigger.UnrequestTrigger(BriefingSystem.faderJob);</p><p>            BriefingSystem.faderJob = nil;</p><p>        end</p><p>        if BriefingSystem.currBriefing.hideFoW then</p><p>            Display.SetRenderFogOfWar(1);</p><p>            GUI.MiniMap_SetRenderFogOfWar(1);</p><p>        end</p><p>        g_Fade.To = 0;</p><p>        SetFaderAlpha(0);</p><p>        XGUIEng.PopPage();</p><p>        Display.UseStandardSettings();</p><p>        Input.GameMode();</p><p>        local x, y = Camera.ThroneRoom_GetPosition();</p><p>        Camera.SwitchCameraBehaviour(0);</p><p>        Camera.RTS_SetLookAtPosition(x, y);</p><p>        Mouse.CursorShow();</p><p>        GUI.EnableBattleSignals(true);</p><p>        GUI.SetFeedbackSoundOutputState(1);</p><p>        GUI.ActivateSelectionState();</p><p>        GUI.PermitContextSensitiveCommandsInSelectionState();</p><p>        for _, v in ipairs(BriefingSystem.selectedEntities) do</p><p>            if not Logic.IsEntityDestroyed(v) then</p><p>                GUI.SelectEntity(v);</p><p>            end</p><p>        end</p><p>        if BriefingSystem.currBriefing.restoreCamera then</p><p>            Camera.RTS_SetLookAtPosition(unpack(BriefingSystem.cameraRestore));</p><p>        end</p><p>        if not Framework.IsNetworkGame() then</p><p>            local GameSpeed = (BriefingSystem.currBriefing.gameSpeedBackup or 1);</p><p>            Game.GameTimeSetFactor(GUI.GetPlayerID(), GameSpeed);</p><p>        end</p><p>        XGUIEng.PopPage();</p><p>        XGUIEng.PopPage();</p><p>        XGUIEng.PopPage();</p><p>        XGUIEng.PopPage();</p><p>        XGUIEng.PopPage();</p><p>        XGUIEng.PopPage();</p><p>        XGUIEng.ShowWidget("/InGame/ThroneRoom", 0);</p><p>        XGUIEng.ShowWidget("/InGame/ThroneRoomBars", 0);</p><p>        XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2", 0);</p><p>        XGUIEng.ShowWidget("/InGame/ThroneRoomBars_Dodge", 0);</p><p>        XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2_Dodge", 0);</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal", 1);</p><p>        XGUIEng.ShowWidget("/InGame/Root/3dOnScreenDisplay", 1);</p><p>        Trigger.DisableTrigger(BriefingSystem.Flight.Job);</p><p>    end</p><p>    ---</p><p>    -- Führt das Briefing aus.</p><p>    --</p><p>    -- @param _prepareBriefingStart Briefing muss vorbereitet werden</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem.Briefing(_prepareBriefingStart)</p><p>        if not _prepareBriefingStart then</p><p>            if BriefingSystem.faderJob then</p><p>                Trigger.UnrequestTrigger(BriefingSystem.faderJob);</p><p>                BriefingSystem.faderJob = nil;</p><p>            end</p><p>        end</p><p>        local page = BriefingSystem.currBriefing[_prepareBriefingStart and 1 or BriefingSystem.GlobalSystem.page];</p><p>        if not page then</p><p>            return;</p><p>        end</p><p>        local barStyle = page.barStyle;</p><p>        if barStyle == nil then</p><p>            barStyle = BriefingSystem.currBriefing.barStyle;</p><p>        end</p><p>        BriefingSystem.SetBriefingPagePortrait(page)</p><p>        BriefingSystem.SetBriefingPageOrSplashscreen(page, barStyle);</p><p>        BriefingSystem.SetBriefingPageTextPosition(page);</p><p>        local player = GUI.GetPlayerID();</p><p>        -- Text</p><p>        if page.text then</p><p>            local doNotCalc = page.duration ~= nil;</p><p>            local smallBarShown = ((barStyle == "small" or barStyle == "transsmall") and not page.splashscreen);</p><p>            if type(page.text) == "string" then</p><p>                BriefingSystem.ShowBriefingText(page.text, doNotCalc, smallBarShown);</p><p>            elseif page.text[player] or page.text.default then</p><p>                for i = 1, player do</p><p>                    if page.text[i] and Logic.GetIsHumanFlag(i) then</p><p>                        doNotCalc = true;</p><p>                    end</p><p>                end</p><p>                BriefingSystem.ShowBriefingText(page.text[player] or page.text.default, doNotCalc, smallBarShown);</p><p>            end</p><p>        end</p><p>        -- Titel</p><p>        if page.title then</p><p>            if type(page.title) == "string" then</p><p>                BriefingSystem.ShowBriefingTitle(page.title);</p><p>            elseif page.title[player] or page.title.default then</p><p>                BriefingSystem.ShowBriefingTitle(page.title[player] or page.title.default);</p><p>            end</p><p>        end</p><p>        -- Multiple Choice</p><p>        if page.mc then</p><p>            BriefingSystem.Briefing_MultipleChoice();</p><p>        end</p><p>        -- Splashscreen UV</p><p>        local UV0, UV1;</p><p>        if type(page.splashscreen) == "table" then</p><p>            if page.splashscreen.uv then</p><p>                UV0 = {page.splashscreen.uv[1], page.splashscreen.uv[2]};</p><p>                UV1 = {page.splashscreen.uv[3], page.splashscreen.uv[4]};</p><p>            end</p><p>        end</p><p>        if not _prepareBriefingStart then</p><p>            if page.faderAlpha then</p><p>                if type(page.faderAlpha) == "table" then</p><p>                    g_Fade.To = page.faderAlpha[player] or page.faderAlpha.default or 0;</p><p>                else</p><p>                    g_Fade.To = page.faderAlpha;</p><p>                end</p><p>                g_Fade.Duration = 0;</p><p>            end</p><p>            if page.fadeIn then</p><p>                local fadeIn = page.fadeIn;</p><p>                if type(fadeIn) == "table" then</p><p>                    fadeIn = fadeIn[player] or fadeIn.default;</p><p>                end</p><p>                if type(fadeIn) ~= "number" then</p><p>                    fadeIn = page.duration;</p><p>                    if not fadeIn then</p><p>                        fadeIn = BriefingSystem.timer;</p><p>                    end</p><p>                end</p><p>                if fadeIn < 0 then</p><p>                    BriefingSystem.faderJob = Trigger.RequestTrigger(Events.LOGIC_EVENT_EVERY_TURN, nil, "BriefingSystem_CheckFader", 1, {}, { 1, math.abs(fadeOut) });</p><p>                else</p><p>                    FadeIn(fadeIn);</p><p>                end</p><p>            end</p><p>            if page.fadeOut then</p><p>                local fadeOut = page.fadeOut;</p><p>                if type(fadeOut) == "table" then</p><p>                    fadeOut = fadeOut[player] or fadeOut.default;</p><p>                end</p><p>                if type(fadeOut) ~= "number" then</p><p>                    fadeOut = page.duration;</p><p>                    if not fadeOut then</p><p>                        fadeOut = BriefingSystem.timer;</p><p>                    end</p><p>                end</p><p>                if fadeOut < 0 then</p><p>                    BriefingSystem.faderJob = Trigger.RequestTrigger(Events.LOGIC_EVENT_EVERY_TURN, nil, "BriefingSystem_CheckFader", 1, {}, { 0, math.abs(fadeOut) });</p><p>                else</p><p>                    FadeOut(fadeOut);</p><p>                end</p><p>            end</p><p>        else</p><p>            local faderValue = (page.fadeOut and 0) or (page.fadeIn and 1) or page.faderValue;</p><p>            if faderValue then</p><p>                g_Fade.To = faderValue;</p><p>                g_Fade.Duration = 0;</p><p>            end</p><p>        end</p><p>        local dialogCamera = page.dialogCamera;</p><p>        if type(dialogCamera) == "table" then</p><p>            dialogCamera = dialogCamera[player];</p><p>            if dialogCamera == nil then</p><p>                dialogCamera = page.dialogCamera.default;</p><p>            end</p><p>        end</p><p>        dialogCamera = dialogCamera and "DLG" or "";</p><p>        local rotation = page.rotation or BriefingSystem.GlobalSystem["BRIEFING_" .. dialogCamera .. "CAMERA_ROTATIONDEFAULT"];</p><p>        if type(rotation) == "table" then</p><p>            rotation = rotation[player] or rotation.default;</p><p>        end</p><p>        local angle = page.angle or BriefingSystem.GlobalSystem["BRIEFING_" .. dialogCamera .. "CAMERA_ANGLEDEFAULT"];</p><p>        if type(angle) == "table" then</p><p>            angle = angle[player] or angle.default;</p><p>        end</p><p>        local zoom = page.zoom or BriefingSystem.GlobalSystem["BRIEFING_" .. dialogCamera .. "CAMERA_ZOOMDEFAULT"];</p><p>        if type(zoom) == "table" then</p><p>            zoom = zoom[player] or zoom.default;</p><p>        end</p><p>        local FOV = page.FOV or BriefingSystem.GlobalSystem["BRIEFING_" .. dialogCamera .. "CAMERA_FOVDEFAULT"];</p><p>        BriefingSystem.CutsceneStopFlight();</p><p>        BriefingSystem.StopFlight();</p><p>        -- Initialisierung der Kameraanimation</p><p>        if page.cutscene then</p><p>            -- Flight speichern</p><p>            if BriefingSystem.GlobalSystem.page == 1 then</p><p>                BriefingSystem.CutsceneSaveFlight(page.cutscene.Position, page.cutscene.LookAt, FOV);</p><p>            end</p><p>            -- Kamera bewegen</p><p>            BriefingSystem.CutsceneFlyTo(page.cutscene.Position,</p><p>                                         page.cutscene.LookAt,</p><p>                                         FOV,</p><p>                                         page.flyTime or 0);</p><p>        elseif page.position then</p><p>            local position = page.position;</p><p>            if type(position) == "table" and (position[player] or position.default or position.playerPositions) then</p><p>                position = position[player] or position.default;</p><p>            end</p><p>            if position then</p><p>                local ttype = type(position);</p><p>                if ttype == "string" or ttype == "number" then</p><p>                    position = GetPosition(position);</p><p>                elseif ttype == "table" then</p><p>                    position = { X = position.X, Y = position.Y, Z = position.Z};</p><p>                end</p><p>                -- Z-Achsen-Fix</p><p>                local height = position.Z or Display.GetTerrainHeight(position.X,position.Y);</p><p>                if page.zOffset then</p><p>                    height = height + page.zOffset;</p><p>                end</p><p>                position.Z = height;</p><p>                Display.SetCameraLookAtEntity(0);</p><p>                if BriefingSystem.GlobalSystem.page == 1 then</p><p>                    BriefingSystem.SaveFlight(position, rotation, angle, zoom, FOV, UV0, UV1);</p><p>                end</p><p>                BriefingSystem.FlyTo(position, rotation, angle, zoom, FOV, page.flyTime or BriefingSystem.GlobalSystem.BRIEFING_FLYTIME, UV0, UV1);</p><p>            end</p><p>        elseif page.followEntity then</p><p>            local followEntity = page.followEntity;</p><p>            if type(followEntity) == "table" then</p><p>                followEntity = followEntity[player] or followEntity.default;</p><p>            end</p><p>            followEntity = GetEntityId(followEntity);</p><p>            Display.SetCameraLookAtEntity(followEntity);</p><p>            local pos = GetPosition(followEntity);</p><p>            pos.Z = pos.Z or nil;</p><p>            local height = Display.GetTerrainHeight(pos.X,pos.Y);</p><p>            if page.zOffset then</p><p>                height = height + page.zOffset;</p><p>            end</p><p>            pos.Z = height;</p><p>            if BriefingSystem.GlobalSystem.page == 1 then</p><p>                BriefingSystem.SaveFlight(pos, rotation, angle, zoom, FOV, UV0, UV1);</p><p>            end</p><p>            BriefingSystem.FollowFlight(followEntity, rotation, angle, zoom, FOV, page.flyTime or 0, height, UV0, UV1);</p><p>        end</p><p>        if not _prepareBriefingStart then</p><p>            if page.marker then</p><p>                local marker = page.marker;</p><p>                if type(marker) == "table" then</p><p>                    if #marker > 0 then</p><p>                        for _, v in ipairs(marker) do</p><p>                            if not v.player or v.player == GUI.GetPlayerID() then</p><p>                                BriefingSystem.CreateMarker(v, v.type, page.markerList, v.display, v.R, v.G, v.B, v.Alpha);</p><p>                            else</p><p>                                table.insert(BriefingSystem.listOfMarkers[page.markerList], {});</p><p>                            end</p><p>                        end</p><p>                    else</p><p>                        if not v.player or v.player == GUI.GetPlayerID() then</p><p>                            BriefingSystem.CreateMarker(marker, marker.type, page.markerList, marker.display, marker.R, marker.G, marker.B, marker.Alpha);</p><p>                        else</p><p>                            table.insert(BriefingSystem.listOfMarkers[page.markerList], {});</p><p>                        end</p><p>                    end</p><p>                else</p><p>                    BriefingSystem.CreateMarker(page, marker, page.markerList);</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>    ---</p><p>    -- Callback: Überspringen wurde geklickt.</p><p>    --</p><p>    -- @local</p><p>    --</p><p>    function OnSkipButtonPressed()</p><p>        local index = BriefingSystem.GlobalSystem.page;</p><p>        if BriefingSystem.currBriefing[index] and not BriefingSystem.currBriefing[index].mc then</p><p>            GUI.SendScriptCommand("BriefingSystem.SkipBriefing(" .. GUI.GetPlayerID() .. ")");</p><p>        end</p><p>    end</p><p>    ---</p><p>    -- Überspringt eine Briefing-Seite.</p><p>    --</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem.SkipBriefingPage()</p><p>        local index = BriefingSystem.GlobalSystem.page;</p><p>        if BriefingSystem.currBriefing[index] and not BriefingSystem.currBriefing[index].mc then</p><p>            GUI.SendScriptCommand("BriefingSystem.SkipBriefingPage(" .. GUI.GetPlayerID() .. ")");</p><p>        end</p><p>    end</p><p>    ---</p><p>    -- Zeigt die Rahmen an. Dabei gibt es schmale Rahmen, breite Rahmen</p><p>    -- und jeweils noch transparente Versionen. Es kann auch gar kein</p><p>    -- Rahmen angezeigt werden.</p><p>    --</p><p>    -- @param _type	Typ der Bar</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem.ShowBriefingBar(_type)</p><p>        _type = _type or "big";</p><p>        -- set overwrite</p><p>        if _type == nil then</p><p>            _type = BriefingSystem.currBriefing.barStyle;</p><p>        end</p><p>        assert(_type == 'big' or _type == 'small' or _type == 'nobar' or _type == 'transbig' or _type == 'transsmall');</p><p>        -- set bars</p><p>        local flag_big = (_type == "big" or _type == "transbig") and 1 or 0;</p><p>        local flag_small = (_type == "small" or _type == "transsmall") and 1 or 0;</p><p>        local alpha = (_type == "transsmall" or _type == "transbig") and 100 or 255;</p><p>        if _type == 'nobar' then</p><p>            flag_small = 0;</p><p>            flag_big = 0;</p><p>        end</p><p>        XGUIEng.ShowWidget("/InGame/ThroneRoomBars", flag_big);</p><p>        XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2", flag_small);</p><p>        XGUIEng.ShowWidget("/InGame/ThroneRoomBars_Dodge", flag_big);</p><p>        XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2_Dodge", flag_small);</p><p>        XGUIEng.SetMaterialAlpha("/InGame/ThroneRoomBars/BarBottom", 1, alpha);</p><p>        XGUIEng.SetMaterialAlpha("/InGame/ThroneRoomBars/BarTop", 1, alpha);</p><p>        XGUIEng.SetMaterialAlpha("/InGame/ThroneRoomBars_2/BarBottom", 1, alpha);</p><p>        XGUIEng.SetMaterialAlpha("/InGame/ThroneRoomBars_2/BarTop", 1, alpha);</p><p>        BriefingSystem.barType = _type;</p><p>    end</p><p>    ---</p><p>    -- Zeigt den Text einer Briefingseite an und berechnet ggf. die Dauer</p><p>    -- der Anzeige.</p><p>    --</p><p>    -- @param _text      Anzuzeigender Text</p><p>    -- @param _doNotCalc Anzeigedauer nicht berechnen</p><p>    -- @param _smallBar  Die schmalen bars werden benutzt</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem.ShowBriefingText(_text, _doNotCalc, _smallBar)</p><p>        local text = XGUIEng.GetStringTableText(_text);</p><p>        if text == "" then</p><p>            text = _text;</p><p>        end</p><p>        if not _doNotCalc then</p><p>            GUI.SendScriptCommand("BriefingSystem.timer = " .. (BriefingSystem.GlobalSystem.STANDARDTIME_PER_PAGE + BriefingSystem.GlobalSystem.SECONDS_PER_CHAR * string.len(text)) .. ";");</p><p>        end</p><p>        if _smallBar then</p><p>            text = "{cr}{cr}{cr}" .. text;</p><p>        end</p><p>        XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/MissionBriefing/Text", 1);</p><p>        XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Text", "{center}"..text);</p><p>    end</p><p>    ---</p><p>    -- Zeigt den Titel aka Sprecher der Seite an.</p><p>    --</p><p>    -- @param _title Anzuzeigender Titel</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem.ShowBriefingTitle(_title)</p><p>        local title = XGUIEng.GetStringTableText(_title);</p><p>        if title == "" then</p><p>            title = _title;</p><p>        end</p><p>        if BriefingSystem.GlobalSystem and string.sub(title, 1, 1) ~= "{" then</p><p>            title = BriefingSystem.GlobalSystem.COLOR1 .. "{center}{darkshadow}" .. title;</p><p>        end</p><p>        XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogTopChooseKnight/ChooseYourKnight", 1);</p><p>        XGUIEng.SetText("/InGame/ThroneRoom/Main/DialogTopChooseKnight/ChooseYourKnight", title);</p><p>    end</p><p>    ---</p><p>    -- Zeigt den Multiple Choice Dialog mit den Verzweigungen an.</p><p>    --</p><p>    -- @param _page Briefing-Seite</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem.SchowBriefingOptionDialog(_page)</p><p>        local Screen = {GUI.GetScreenSize()};</p><p>        local Widget = "/InGame/SoundOptionsMain/RightContainer/SoundProviderComboBoxContainer";</p><p>        BriefingSystem.OriginalBoxPosition = {</p><p>            XGUIEng.GetWidgetScreenPosition(Widget)</p><p>        };</p><p>        local listbox = XGUIEng.GetWidgetID(Widget .. "/ListBox");</p><p>        XGUIEng.ListBoxPopAll(listbox);</p><p>        for i=1, _page.mc.amount, 1 do</p><p>            if _page.mc.answers[i] then</p><p>                XGUIEng.ListBoxPushItem(listbox, _page.mc.answers[i][1]);</p><p>            end</p><p>        end</p><p>        XGUIEng.ListBoxSetSelectedIndex(listbox, 0);</p><p>        local wSize = {XGUIEng.GetWidgetScreenSize(Widget)};</p><p>        local xFactor = (Screen[1]/1920);</p><p>        local xFix = math.ceil((Screen[1]/2) - (wSize[1] /2));</p><p>        local yFix = math.ceil(Screen[2] - (wSize[2]-20));</p><p>        XGUIEng.SetWidgetScreenPosition(Widget, xFix, yFix);</p><p>        XGUIEng.PushPage(Widget, false);</p><p>        XGUIEng.ShowWidget(Widget, 1);</p><p>        BriefingSystem.MCSelectionIsShown = true;</p><p>    end</p><p>    ---</p><p>    -- Setzt den Text, den Titel und die Antworten einer Multiple Choice</p><p>    -- Seite. Setzt außerdem die Dauer der Seite auf 11 1/2 Tage (in</p><p>    -- der echten Welt). Leider ist es ohne größeren Änderungen nicht</p><p>    -- möglich die Anzeigezeit einer Seite auf unendlich zu setzen.</p><p>    -- Es ist aber allgemein unwahrscheinlich, dass der Spieler 11,5</p><p>    -- Tage vor dem Briefing sitzt, ohne etwas zu tun.</p><p>    -- Das Fehlverhalten in diesem Fall ist unerforscht. Es würde dann</p><p>    -- wahrscheinlich die 1 Antwort selektiert.</p><p>    --</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem.Briefing_MultipleChoice()</p><p>        local page = BriefingSystem.currBriefing[BriefingSystem.GlobalSystem.page];</p><p>        if page and page.mc then</p><p>            -- set title</p><p>            if page.mc.title then</p><p>                BriefingSystem.ShowBriefingTitle(page.mc.title);</p><p>            end</p><p>            -- set text</p><p>            if page.mc.text then</p><p>                BriefingSystem.ShowBriefingText(page.mc.text, true);</p><p>            end</p><p>            -- set answers</p><p>            if page.mc.answers then</p><p>                BriefingSystem.SchowBriefingOptionDialog(page);</p><p>            end</p><p>            -- set page length</p><p>            GUI.SendScriptCommand("BriefingSystem.currBriefing[BriefingSystem.page].dusation = 999999");</p><p>        end</p><p>    end</p><p>    ----</p><p>    -- Eine Antwort wurde ausgewählt (lokales Skript). Die Auswahl wird</p><p>    -- gepopt und ein Event an das globale Skript gesendet. Das Event</p><p>    -- erhält die Page ID, den Index der selektierten Antwort in der</p><p>    -- Listbox und die reale ID der Antwort in der Table.</p><p>    --</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem.OnConfirmed()</p><p>        local Widget = "/InGame/SoundOptionsMain/RightContainer/SoundProviderComboBoxContainer";</p><p>        local Position = BriefingSystem.OriginalBoxPosition;</p><p>        XGUIEng.SetWidgetScreenPosition(Widget, Position[1], Position[2]);</p><p>        XGUIEng.ShowWidget(Widget, 0);</p><p>        XGUIEng.PopPage();</p><p>        local page = BriefingSystem.currBriefing[BriefingSystem.GlobalSystem.page];</p><p>        if page.mc then</p><p>            local index  = BriefingSystem.GlobalSystem.page;</p><p>            local listboxidx = XGUIEng.ListBoxGetSelectedIndex(Widget .. "/ListBox")+1;</p><p>            BriefingSystem.currBriefing[index].mc.current = listboxidx;</p><p>            local answer = BriefingSystem.currBriefing[index].mc.current;</p><p>            local pageID = BriefingSystem.currBriefing[index].mc.answers[answer].ID;</p><p>            GUI.SendScriptCommand([[BriefingSystem.OnConfirmed(]]..pageID..[[,]]..page.mc.current..[[,]]..answer..[[)]]);</p><p>        end</p><p>    end</p><p>    ---</p><p>    -- Erzeugt eine Markierung auf der Minikarte.</p><p>    --</p><p>    -- @param _t          Aktuelle Seite</p><p>    -- @param _markerType Typ der Markierung</p><p>    -- @param _markerList Liste der Markierungen</p><p>    -- @param _r          Magenta-Wert</p><p>    -- @param _g          Yellow-Wert</p><p>    -- @param _b          Cyan-Wert</p><p>    -- @param _alpha      Alpha-Wert</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem.CreateMarker(_t, _markerType, _markerList, _r, _g, _b, _alpha)</p><p>        local position = _t.position;</p><p>        if position then</p><p>            if type(position) == "table" then</p><p>                if position[GUI.GetPlayerID()] or position.default or position.playerPositions then</p><p>                    position = position[GUI.GetPlayerID()] or position.default;</p><p>                end</p><p>            end</p><p>        end</p><p>        if not position then</p><p>            position = _t.followEntity;</p><p>            if type(position) == "table" then</p><p>                position = position[GUI.GetPlayerID()] or position.default;</p><p>            end</p><p>        end</p><p>        assert(position);</p><p>        if type(position) ~= "table" then</p><p>            position = GetPosition(position);</p><p>        end</p><p>        if _markerList and not BriefingSystem.listOfMarkers[_markerList] then</p><p>            BriefingSystem.listOfMarkers[_markerList] = {};</p><p>        end</p><p>        while GUI.IsMinimapSignalExisting(BriefingSystem.markerUniqueID) == 1 do</p><p>            BriefingSystem.markerUniqueID = BriefingSystem.markerUniqueID + 1;</p><p>        end</p><p>        assert(type(_markerType) == "number" and _markerType > 0);</p><p>        _r = _r or 32;</p><p>        _g = _g or 245;</p><p>        _b = _b or 110;</p><p>        _alpha = _alpha or 255;</p><p>        GUI.CreateMinimapSignalRGBA(BriefingSystem.markerUniqueID, position.X, position.Y, _r, _g, _b, _alpha, _markerType);</p><p>        if _markerList then</p><p>            table.insert(BriefingSystem.listOfMarkers[_markerList], { ID = BriefingSystem.markerUniqueID, X = position.X, Y = position.Y, R = _r, G = _g, B = _b, Alpha = _alpha, type = _markerType });</p><p>        end</p><p>        BriefingSystem.markerUniqueID = BriefingSystem.markerUniqueID + 1;</p><p>    end</p><p>    ---</p><p>    -- Zerstört eine Liste von Markern auf der Minimap.</p><p>    --</p><p>    -- @param _index Index der Liste</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem.DestroyMarkerList(_index)</p><p>        if BriefingSystem.listOfMarkers[_index] then</p><p>            for _, v in ipairs(BriefingSystem.listOfMarkers[_index]) do</p><p>                if v.ID and GUI.IsMinimapSignalExisting(v.ID) == 1 then</p><p>                    GUI.DestroyMinimapSignal(v.ID);</p><p>                end</p><p>            end</p><p>            BriefingSystem.listOfMarkers[_index] = nil;</p><p>        end</p><p>    end</p><p>    ---</p><p>    -- Zerstört einen Marker innerhalb einer Liste.</p><p>    --</p><p>    -- @param _index  Index der Liste</p><p>    -- @param _marker ID des Marker</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem.DestroyMarkerOfList(_index, _marker)</p><p>        if BriefingSystem.listOfMarkers[_index] then</p><p>            local marker = BriefingSystem.listOfMarkers[_index][_marker];</p><p>            if marker and marker.ID and GUI.IsMinimapSignalExisting(marker.ID) == 1 then</p><p>                GUI.DestroyMinimapSignal(marker.ID);</p><p>                marker.ID = nil;</p><p>            end</p><p>        end</p><p>    end</p><p>    ---</p><p>    -- Aktualisiert die Position aller marker in der Liste oder erstellt sie</p><p>    -- neu, falls er nicht existiert.</p><p>    --</p><p>    -- @param _index Index der Marker-List</p><p>    -- @param _x     X-Position</p><p>    -- @param _y     Y-Position</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem.RedeployMarkerList(_index, _x, _y)</p><p>        if BriefingSystem.listOfMarkers[_index] then</p><p>            for _, v in ipairs(BriefingSystem.listOfMarkers[_index]) do</p><p>                if v.ID then</p><p>                    v.X = _x;</p><p>                    v.Y = _y;</p><p>                    if GUI.IsMinimapSignalExisting(v.ID) == 1 then</p><p>                        GUI.RedeployMinimapSignal(v.ID, _x, _y);</p><p>                    else</p><p>                        GUI.CreateMinimapSignalRGBA(v.ID, _x, _y, v.R, v.G, v.B, v.Alpha, v.type);</p><p>                    end</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>    ---</p><p>    -- Aktualisiert einen Marker aus einer Liste von Markern. Existiert der</p><p>    -- Marker nicht, wird er erstellt.</p><p>    --</p><p>    -- @param _index  Index der Marker-List</p><p>    -- @param _marker ID des Markers</p><p>    -- @param _x      X-Position</p><p>    -- @param _y      Y-Position</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem.RedeployMarkerOfList(_index, _marker, _x, _y)</p><p>        if BriefingSystem.listOfMarkers[_index] then</p><p>            local marker = BriefingSystem.listOfMarkers[_index][_marker];</p><p>            if marker and marker.ID then</p><p>                marker.X = _x;</p><p>                marker.Y = _y;</p><p>                if GUI.IsMinimapSignalExisting(marker.ID) == 1 then</p><p>                    GUI.RedeployMinimapSignal(marker.ID, _x, _y);</p><p>                else</p><p>                    GUI.CreateMinimapSignalRGBA(marker.ID, _x, _y, marker.R, marker.G, marker.B, marker.Alpha, marker.type);</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>    ---</p><p>    -- Aktualisiert die Position aller marker in der Liste oder erstellt sie</p><p>    -- neu, falls er nicht existiert.</p><p>    --</p><p>    -- @param _index  Index der Marker-List</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem.RefreshMarkerList(_index)</p><p>        if BriefingSystem.listOfMarkers[_index] then</p><p>            for _, v in ipairs(BriefingSystem.listOfMarkers[_index]) do</p><p>                if v.ID then</p><p>                    if GUI.IsMinimapSignalExisting(v.ID) == 1 then</p><p>                        GUI.RedeployMinimapSignal(v.ID, v.X, v.Y);</p><p>                    else</p><p>                        GUI.CreateMinimapSignalRGBA(v.ID, v.X, v.Y, v.R, v.G, v.B, v.Alpha, v.type);</p><p>                    end</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>    ---</p><p>    -- Aktualisiert einen Marker aus einer Liste von Markern. Existiert der</p><p>    -- Marker nicht, wird er erstellt.</p><p>    --</p><p>    -- @param _index  Index der Marker-List</p><p>    -- @param _marker ID des Markers</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem.RefreshMarkerOfList(_index, _marker)</p><p>        if BriefingSystem.listOfMarkers[_index] then</p><p>            local marker = BriefingSystem.listOfMarkers[_index][_marker];</p><p>            if marker and marker.ID then</p><p>                if GUI.IsMinimapSignalExisting(marker.ID) == 1 then</p><p>                    GUI.RedeployMinimapSignal(marker.ID, marker.X, marker.Y);</p><p>                else</p><p>                    GUI.CreateMinimapSignalRGBA(marker.ID, marker.X, marker.Y, marker.R, marker.G, marker.B, marker.Alpha, marker.type);</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>    ---</p><p>    -- Macht den Skip-Button sichtbar oder versteckt ihn.</p><p>    --</p><p>    -- @param _player Spieler</p><p>    -- @param _flag   Sichtbarkeit</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem.EnableBriefingSkipButton(_player, _flag)</p><p>        if _player == nil or _player == GUI.GetPlayerID() then</p><p>            XGUIEng.DisableButton("/InGame/ThroneRoom/Main/Skip", _flag and 0 or 1);</p><p>        end</p><p>    end</p><p>    ---</p><p>    -- Steuert die schwarze Maske, die für Übergänge genutzt wird.</p><p>    --</p><p>    -- @param _fadeIn     Einblenden verwenden</p><p>    -- @param _timerValue Dauer des Blendvorgangs</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem_CheckFader(_fadeIn, _timerValue)</p><p>        if BriefingSystem.GlobalSystem.timer < _timerValue then</p><p>            if _fadeIn == 1 then</p><p>                FadeIn(_timerValue);</p><p>            else</p><p>                FadeOut(_timerValue);</p><p>            end</p><p>            BriefingSystem.faderJob = nil;</p><p>            return true;</p><p>        end</p><p>    end</p><p>    ---</p><p>    -- Steuert die Kamera während eines Briefings. Es wird entweder das alte</p><p>    -- System von OldMacDonald oder das neue von totalwarANGEL genutzt.</p><p>    --</p><p>    -- @within Originalfunktionen</p><p>    -- @local</p><p>    --</p><p>    function ThroneRoomCameraControl()</p><p>        if Camera.GetCameraBehaviour(5) == 5 and BriefingSystem.GlobalSystem.isActive == true then</p><p>            local flight = BriefingSystem.Flight;</p><p>            -- -------------------------------------------------------------- --</p><p>            -- Briefing Notation von OldMacDonald</p><p>            -- -------------------------------------------------------------- --</p><p>            -- Dies steuert die altbekannte Notation, entwickelt von OMD.</p><p>            -- Bis auf wenige Erweiterungen von totalwarANGEL ist es wie</p><p>            -- zum ursürunglichen Release der letzten Version.</p><p>            if flight.systemEnabled then</p><p>                -- Kameraanimation</p><p>                local startTime = flight.StartTime;</p><p>                local flyTime = flight.FlyTime;</p><p>                local startPosition = flight.StartPosition or flight.EndPosition;</p><p>                local endPosition = flight.EndPosition;</p><p>                local startRotation = flight.StartRotation or flight.EndRotation;</p><p>                local endRotation = flight.EndRotation;</p><p>                local startZoomAngle = flight.StartZoomAngle or flight.EndZoomAngle;</p><p>                local endZoomAngle = flight.EndZoomAngle;</p><p>                local startZoomDistance = flight.StartZoomDistance or flight.EndZoomDistance;</p><p>                local endZoomDistance = flight.EndZoomDistance;</p><p>                local startFOV = flight.StartFOV or flight.EndFOV;</p><p>                local endFOV = flight.EndFOV;</p><p>                -- Splashscreen-Animation</p><p>                local startUV0 = flight.StartUV0 or flight.EndUV0;</p><p>                local endUV0 = flight.EndUV0;</p><p>                local startUV1 = flight.StartUV1 or flight.EndUV1;</p><p>                local endUV1 = flight.EndUV1;</p><p>                local currTime = Logic.GetTimeMs() / 1000;</p><p>                local math = math;</p><p>                if flight.Follow then</p><p>                    local currentPosition = GetPosition(flight.Follow);</p><p>                    if endPosition.X ~= currentPosition.X and endPosition.Y ~= currentPosition.Y then</p><p>                        flight.StartPosition = endPosition;</p><p>                        flight.EndPosition = currentPosition;</p><p>                    end</p><p>                    if flight.StartPosition and Logic.IsEntityMoving(GetEntityId(flight.Follow)) then</p><p>                        local orientation = math.rad(Logic.GetEntityOrientation(GetEntityId(flight.Follow)));</p><p>                        local x1, y1, x2, y2 = flight.StartPosition.X, flight.StartPosition.Y, currentPosition.X, currentPosition.Y;</p><p>                        x1 = x1 - x2;</p><p>                        y1 = y1 - y2;</p><p>                        local distance = math.sqrt( x1 * x1 + y1 * y1 ) * 10;</p><p>                        local disttoend = distance * (flyTime - currTime + startTime);</p><p>                        local disttostart = distance * (currTime + startTime);</p><p>                        endPosition = { X = currentPosition.X + math.cos(orientation) * distance, Y = currentPosition.Y + math.sin(orientation) * distance }</p><p>                        flight.FollowTemp = flight.FollowTemp or {};</p><p>                        local factor = BriefingSystem.InterpolationFactor(currTime, currTime, 1, flight.FollowTemp);</p><p>                        x1, y1, z1 = BriefingSystem.GetCameraPosition(currentPosition, endPosition, factor);</p><p>                        startPosition = { X = x1, Y = y1, Z = z1 };</p><p>                    else</p><p>                        startPosition = currentPosition;</p><p>                    end</p><p>                    endPosition = startPosition;</p><p>                end</p><p>                -- Interpolationsfaktor</p><p>                local factor = BriefingSystem.InterpolationFactor(startTime, currTime, flyTime, flight);</p><p>                -- Kamera</p><p>                local lookAtX, lookAtY, lookAtZ = BriefingSystem.GetCameraPosition(startPosition, endPosition, factor);</p><p>                local zoomDistance = startZoomDistance + (endZoomDistance - startZoomDistance) * factor;</p><p>                local zoomAngle = startZoomAngle + (endZoomAngle - startZoomAngle) * factor;</p><p>                local rotation = startRotation + (endRotation - startRotation) * factor;</p><p>                local line = zoomDistance * math.cos(math.rad(zoomAngle));</p><p>                Camera.ThroneRoom_SetLookAt(lookAtX, lookAtY, lookAtZ);</p><p>                Camera.ThroneRoom_SetPosition(</p><p>                    lookAtX + math.cos(math.rad(rotation - 90)) * line,</p><p>                    lookAtY + math.sin(math.rad(rotation - 90)) * line,</p><p>                    lookAtZ + (zoomDistance) * math.sin(math.rad(zoomAngle))</p><p>                );</p><p>                Camera.ThroneRoom_SetFOV(startFOV + (endFOV - startFOV) * factor);</p><p>                -- Splashscreen</p><p>                BriefingSystem.SetBriefingSplashscreenUV(startUV0, endUV0, startUV1, endUV1, factor);</p><p>            -- -------------------------------------------------------------- --</p><p>            -- Cutscene notation by totalwarANGEL</p><p>            -- -------------------------------------------------------------- --</p><p>            -- Die Cutscene Notation von totalwarANGEL ermöglicht es viele</p><p>            -- Kameraeffekte einfacher umzusetzen, da man die Kamera über</p><p>            -- eine Position und eine Blickrichtung steuert.</p><p>            -- Es KANN vorkommen, dass die Bewegung flüssiger wird.</p><p>            else</p><p>                local cutscene = BriefingSystem.Flight.Cutscene;</p><p>                if cutscene then</p><p>                    -- Kamera</p><p>                    local StartPosition = cutscene.StartPosition or cutscene.EndPosition;</p><p>                    local EndPosition = cutscene.EndPosition;</p><p>                    local StartLookAt = cutscene.StartLookAt or cutscene.EndLookAt;</p><p>                    local EndLookAt = cutscene.EndLookAt;</p><p>                    local StartFOV = cutscene.StartFOV or cutscene.EndFOV;</p><p>                    local EndFOV = cutscene.EndFOV;</p><p>                    local StartTime = cutscene.StartTime;</p><p>                    local FlyTime = cutscene.FlyTime;</p><p>                    local CurrTime = Logic.GetTimeMs()/1000;</p><p>                    -- Splashscreen-Animation</p><p>                    local startUV0 = cutscene.StartUV0 or cutscene.EndUV0;</p><p>                    local endUV0 = cutscene.EndUV0;</p><p>                    local startUV1 = cutscene.StartUV1 or cutscene.EndUV1;</p><p>                    local endUV1 = cutscene.EndUV1;</p><p>                    local Factor = BriefingSystem.InterpolationFactor(StartTime, CurrTime, FlyTime, cutscene);</p><p>                    -- Setzt das Blickziel der Kamera zum Animationsbeginn</p><p>                    if not StartLookAt.X then</p><p>                        local CamPos = GetPosition(StartLookAt[1], (StartLookAt[2] or 0));</p><p>                        if StartLookAt[3] then</p><p>                            CamPos.X = CamPos.X + StartLookAt[3] * math.cos( math.rad(StartLookAt[4]) );</p><p>                            CamPos.Y = CamPos.Y + StartLookAt[3] * math.sin( math.rad(StartLookAt[4]) );</p><p>                        end</p><p>                        StartLookAt = CamPos;</p><p>                    end</p><p>                    -- Setzt das Blickziel der Kamera zum Animationsende</p><p>                    if not EndLookAt.X then</p><p>                        local CamPos = GetPosition(EndLookAt[1], (EndLookAt[2] or 0));</p><p>                        if EndLookAt[3] then</p><p>                            CamPos.X = CamPos.X + EndLookAt[3] * math.cos( math.rad(EndLookAt[4]) );</p><p>                            CamPos.Y = CamPos.Y + EndLookAt[3] * math.sin( math.rad(EndLookAt[4]) );</p><p>                        end</p><p>                        EndLookAt = CamPos;</p><p>                    end</p><p>                    local lookAtX, lookAtY, lookAtZ = BriefingSystem.CutsceneGetPosition(StartLookAt, EndLookAt, Factor);</p><p>                    Camera.ThroneRoom_SetLookAt(lookAtX, lookAtY, lookAtZ);</p><p>                    -- Setzt die Startposition der Kamera</p><p>                    -- Positionstabelle {X= x, Y= y, Z= z}</p><p>                    if not StartPosition.X then</p><p>                        local CamPos = GetPosition(StartPosition[1], (StartPosition[2] or 0));</p><p>                        if StartPosition[3] then</p><p>                            CamPos.X = CamPos.X + StartPosition[3] * math.cos( math.rad(StartPosition[4]) );</p><p>                            CamPos.Y = CamPos.Y + StartPosition[3] * math.sin( math.rad(StartPosition[4]) );</p><p>                        end</p><p>                        StartPosition = CamPos;</p><p>                    end</p><p>                    -- Setzt die Endposition der Kamera</p><p>                    -- Positionstabelle {X= x, Y= y, Z= z}</p><p>                    if not EndPosition.X then</p><p>                        local CamPos = GetPosition(EndPosition[1], (EndPosition[2] or 0));</p><p>                        if EndPosition[3] then</p><p>                            CamPos.X = CamPos.X + EndPosition[3] * math.cos( math.rad(EndPosition[4]) );</p><p>                            CamPos.Y = CamPos.Y + EndPosition[3] * math.sin( math.rad(EndPosition[4]) );</p><p>                        end</p><p>                        EndPosition = CamPos;</p><p>                    end</p><p>                    local posX, posY, posZ = BriefingSystem.CutsceneGetPosition(StartPosition, EndPosition, Factor);</p><p>                    Camera.ThroneRoom_SetPosition(posX, posY, posZ);</p><p>                    -- Setzt den Bildschirmausschnitt</p><p>                    Camera.ThroneRoom_SetFOV(StartFOV + (EndFOV - StartFOV) * Factor);</p><p>                    -- Splashscreen</p><p>                    BriefingSystem.SetBriefingSplashscreenUV(startUV0, endUV0, startUV1, endUV1, factor);</p><p>                end</p><p>            end</p><p>            -- -------------------------------------------------------------- --</p><p>            -- Notizen im Briefing</p><p>            -- Blendet zusätzlichen Text während eines Briefings ein. Siehe</p><p>            -- dazu Kommentar bei der Funktion.</p><p>            -- Multiple Choice ist bestätigt, wenn das Auswahlfeld</p><p>            -- verschwindet. In diesem Fall hat der Spieler geklickt.</p><p>            if BriefingSystem.MCSelectionIsShown then</p><p>                local Widget = "/InGame/SoundOptionsMain/RightContainer/SoundProviderComboBoxContainer";</p><p>                if XGUIEng.IsWidgetShown(Widget) == 0 then</p><p>                    BriefingSystem.MCSelectionIsShown = false;</p><p>                    BriefingSystem.OnConfirmed();</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>    ---</p><p>    -- Wird immer dann aufgerufen, wenn der Spieler innerhalb des Throneroom</p><p>    -- Mode links klickt.</p><p>    --</p><p>    -- @within Originalfunktionen</p><p>    -- @local</p><p>    --</p><p>    function ThroneRoomLeftClick()</p><p>        local EntityID = GUI.GetMouseOverEntity();</p><p>        API.Bridge("BriefingSystem.LeftClickOnEntity(" ..tostring(EntityID).. ")");</p><p>        local x,y = GUI.Debug_GetMapPositionUnderMouse();</p><p>        API.Bridge("BriefingSystem.LeftClickOnPosition(" ..tostring(x).. ", " ..tostring(y).. ")");</p><p>        local x,y = GUI.GetMousePosition();</p><p>        API.Bridge("BriefingSystem.LeftClickOnScreen(" ..tostring(x).. ", " ..tostring(y).. ")");</p><p>    end</p><p>    -- ---------------------------------------------------------------------- --</p><p>    -- Cutscene Functions by totalwarANGEL</p><p>    -- ---------------------------------------------------------------------- --</p><p>    ---</p><p>    -- Berechnet die Kameraposition wärhend eines Cutscene Flights.</p><p>    --</p><p>    -- @param _Start  [table] Startposition des Flight</p><p>    -- @param _End    [table] Endposition des Flight</p><p>    -- @param _Factor [number] Interpolation Factor</p><p>    -- @return [number] X-Position</p><p>    -- @return [number] Y-Position</p><p>    -- @return [number] Z-Position</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem.CutsceneGetPosition(_Start, _End, _Factor)</p><p>        local X = _Start.X + (_End.X - _Start.X) * _Factor;</p><p>        local Y = _Start.Y + (_End.Y - _Start.Y) * _Factor;</p><p>        local Z = _Start.Z + (_End.Z - _Start.Z) * _Factor;</p><p>        return X, Y, Z;</p><p>    end</p><p>    ---</p><p>    -- Speichert die Startposition der nächsten Kameraanimation.</p><p>    --</p><p>    -- @param _cameraPosition [table] Position der Kamera</p><p>    -- @param _cameraLookAt [table] Blickziel der Kamera</p><p>    -- @param _FOV [number] Field of View</p><p>    -- @param _UV0 [number] UV0 des Splashscreen</p><p>    -- @param _UV1 [number] UV1 des Splashscreen</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem.CutsceneSaveFlight(_cameraPosition, _cameraLookAt, _FOV, _UV0, _UV1)</p><p>        BriefingSystem.Flight.Cutscene = BriefingSystem.Flight.Cutscene or {};</p><p>        BriefingSystem.Flight.Cutscene.StartPosition = _cameraPosition;</p><p>        BriefingSystem.Flight.Cutscene.StartLookAt = _cameraLookAt;</p><p>        BriefingSystem.Flight.Cutscene.StartFOV = _FOV;</p><p>        BriefingSystem.Flight.Cutscene.StartTime = Logic.GetTimeMs()/1000;</p><p>        BriefingSystem.Flight.Cutscene.FlyTime = 0;</p><p>        BriefingSystem.Flight.Cutscene.StartUV0 = _UV0;</p><p>        BriefingSystem.Flight.Cutscene.StartUV1 = _UV1;</p><p>    end</p><p>    ---</p><p>    -- Initalisiert den Flug der Kamera zu einer Position auf der Welt.</p><p>    --</p><p>    -- @param _cameraPosition [table] Position der Kamera</p><p>    -- @param _cameraLookAt [table] Blickziel der Kamera</p><p>    -- @param _FOV [number] Field of View</p><p>    -- @param _Time [number] Dauer</p><p>    -- @param _UV0 [number] UV0 des Splashscreen</p><p>    -- @param _UV1 [number] UV1 des Splashscreen</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem.CutsceneFlyTo(_cameraPosition, _cameraLookAt, _FOV, _Time, _UV0, _UV1)</p><p>        BriefingSystem.Flight.Cutscene = BriefingSystem.Flight.Cutscene or {};</p><p>        BriefingSystem.Flight.Cutscene.StartTime = Logic.GetTimeMs()/1000;</p><p>        BriefingSystem.Flight.Cutscene.FlyTime = _Time;</p><p>        BriefingSystem.Flight.Cutscene.EndPosition = _cameraPosition;</p><p>        BriefingSystem.Flight.Cutscene.EndLookAt = _cameraLookAt;</p><p>        BriefingSystem.Flight.Cutscene.EndFOV = _FOV;</p><p>        BriefingSystem.Flight.Cutscene.EndUV0 = _UV0;</p><p>        BriefingSystem.Flight.Cutscene.EndUV1 = _UV1;</p><p>    end</p><p>    ---</p><p>    -- Unterbricht eine Kamerabewegung der laufenden Cutscene.</p><p>    --</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem.CutsceneStopFlight()</p><p>        BriefingSystem.Flight.Cutscene = BriefingSystem.Flight.Cutscene or {};</p><p>        BriefingSystem.Flight.Cutscene.StartPosition = BriefingSystem.Flight.Cutscene.EndPosition;</p><p>        BriefingSystem.Flight.Cutscene.StartLookAt = BriefingSystem.Flight.Cutscene.EndLookAt;</p><p>        BriefingSystem.Flight.Cutscene.StartFOV = BriefingSystem.Flight.Cutscene.EndFOV;</p><p>    end</p><p>    -- ---------------------------------------------------------------------- --</p><p>    ---</p><p>    -- Errechnet den Interpolation Factor für den aktuellen Flight.</p><p>    --</p><p>    -- @param _start         Startzeit</p><p>    -- @param _curr          Aktuelle Zeit</p><p>    -- @param _total         Absolute Zeit</p><p>    -- @param _dataContainer Game Tame Backup</p><p>    -- @return number: Interpolation Factor</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem.InterpolationFactor(_start, _curr, _total, _dataContainer)</p><p>        local factor = 1;</p><p>        if _start + _total > _curr then</p><p>            factor = (_curr - _start) / _total;</p><p>            if _dataContainer and _curr == _dataContainer.TempLastLogicTime then</p><p>                factor = factor + (Framework.GetTimeMs() - _dataContainer.TempLastFrameworkTime) / _total / 1000 * Game.GameTimeGetFactor(GUI.GetPlayerID());</p><p>            else</p><p>                _dataContainer.TempLastLogicTime = _curr;</p><p>                _dataContainer.TempLastFrameworkTime = Framework.GetTimeMs();</p><p>            end</p><p>        end</p><p>        if factor > 1 then</p><p>            factor = 1;</p><p>        end</p><p>        return factor;</p><p>    end</p><p>    ---</p><p>    -- Berechnet die aktuelle Position der Kamera für den aktuellen Flight.</p><p>    --</p><p>    -- Der Interpolation Factor wird für eine Vektormultiplikation des</p><p>    -- Richtungsvektors zwischen S(x,y,z) und E(x,y,z) verwendet.</p><p>    --</p><p>    -- @param _start  Startposition des Flight</p><p>    -- @param _end    Endposition des Flight</p><p>    -- @param _factor Interpolation Factor</p><p>    -- @return number: X-Position</p><p>    -- @return number: Y-Position</p><p>    -- @return number: Z-Position</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem.GetCameraPosition(_start, _end, _factor)</p><p>        local lookAtX = _start.X + (_end.X - _start.X) * _factor;</p><p>        local lookAtY = _start.Y + (_end.Y - _start.Y) * _factor;</p><p>        local lookAtZ;</p><p>        if _start.Z or _end.Z then</p><p>            lookAtZ = (_start.Z or Display.GetTerrainHeight(_start.X, _start.Y)) + ((_end.Z or Display.GetTerrainHeight(_end.X, _end.Y)) - (_start.Z or Display.GetTerrainHeight(_start.X, _start.Y))) * _factor;</p><p>        else</p><p>            lookAtZ = Display.GetTerrainHeight(lookAtX, lookAtY) * ((_start.ZRelative or 1) + ((_end.ZRelative or 1) - (_start.ZRelative or 1)) * _factor) + ((_start.ZAdd or 0) + ((_end.ZAdd or 0) - (_start.ZAdd or 0))) * _factor;</p><p>        end</p><p>        return lookAtX, lookAtY, lookAtZ;</p><p>    end</p><p>    ---</p><p>    -- Speichert die Startposition der nächsten Kameraanimation.</p><p>    --</p><p>    -- @param _position Blickziel der Kamera</p><p>    -- @param _rotation Rotation der Kamera</p><p>    -- @param _angle    Winkel der Kamera</p><p>    -- @param _distance Entfernung der Kamera</p><p>    -- @param _FOV      Field of View</p><p>    -- @param _UV0      UV0 des Splashscreen</p><p>    -- @param _UV1      UV1 des Splashscreen</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem.SaveFlight(_position, _rotation, _angle, _distance, _FOV, _UV0, _UV1)</p><p>        BriefingSystem.Flight.StartZoomAngle = _angle;</p><p>        BriefingSystem.Flight.StartZoomDistance = _distance;</p><p>        BriefingSystem.Flight.StartRotation = _rotation;</p><p>        BriefingSystem.Flight.StartPosition = _position;</p><p>        BriefingSystem.Flight.StartFOV = _FOV;</p><p>        BriefingSystem.Flight.StartUV0 = _UV0;</p><p>        BriefingSystem.Flight.StartUV1 = _UV1;</p><p>    end</p><p>    ---</p><p>    -- Initalisiert den Flug der Kamera zu einem Entity.</p><p>    --</p><p>    -- @param _position Blickziel der Kamera</p><p>    -- @param _rotation Rotation der Kamera</p><p>    -- @param _angle    Winkel der Kamera</p><p>    -- @param _distance Entfernung der Kamera</p><p>    -- @param _FOV      Field of View</p><p>    -- @param _time     Animationszeit</p><p>    -- @param _UV0      UV0 des Splashscreen</p><p>    -- @param _UV1      UV1 des Splashscreen</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem.FlyTo(_position, _rotation, _angle, _distance, _FOV, _time, _UV0, _UV1)</p><p>        local flight = BriefingSystem.Flight;</p><p>        flight.StartTime = Logic.GetTimeMs()/1000;</p><p>        flight.FlyTime = _time;</p><p>        flight.EndPosition = _position;</p><p>        flight.EndRotation = _rotation;</p><p>        flight.EndZoomAngle = _angle;</p><p>        flight.EndZoomDistance = _distance;</p><p>        flight.EndFOV = _FOV;</p><p>        flight.EndUV0 = _UV0;</p><p>        flight.EndUV1 = _UV1;</p><p>    end</p><p>    ---</p><p>    -- Stoppt die aktuelle Kameraanimation des Briefings.</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem.StopFlight()</p><p>        local flight = BriefingSystem.Flight;</p><p>        flight.StartZoomAngle = flight.EndZoomAngle;</p><p>        flight.StartZoomDistance = flight.EndZoomDistance;</p><p>        flight.StartRotation = flight.EndRotation;</p><p>        flight.StartPosition = flight.EndPosition;</p><p>        flight.StartFOV = flight.EndFOV;</p><p>        flight.StartUV0 = flight.EndUV0;</p><p>        flight.StartUV1 = flight.EndUV1;</p><p>        if flight.Follow then</p><p>            flight.StartPosition = GetPosition(flight.Follow);</p><p>            flight.Follow = nil;</p><p>        end</p><p>    end</p><p>    ---</p><p>    -- Initalisiert die Verfolgung eines Entities durch die Kamera.</p><p>    --</p><p>    -- @param _follow   Blickziel der Kamera</p><p>    -- @param _rotation Rotation der Kamera</p><p>    -- @param _angle    Winkel der Kamera</p><p>    -- @param _distance Entfernung der Kamera</p><p>    -- @param _FOV      Field of View</p><p>    -- @param _time     Animationszeit</p><p>    -- @param _Z        Z-Offset des Blickziels</p><p>    -- @param _UV0      UV0 des Splashscreen</p><p>    -- @param _UV1      UV1 des Splashscreen</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem.FollowFlight(_follow, _rotation, _angle, _distance, _FOV, _time, _Z, _UV0, _UV1)</p><p>        local pos = GetPosition(_follow); pos.Z = _Z or 0;</p><p>        BriefingSystem.FlyTo(pos, _rotation, _angle, _distance, _FOV, _time, _UV0, _UV1);</p><p>        BriefingSystem.Flight.StartPosition = nil;</p><p>        BriefingSystem.Flight.Follow = _follow;</p><p>    end</p><p>    --</p><p>    -- Prüft, ob ein Briefing aktiv ist.</p><p>    --</p><p>    -- <b>Alias:</b> IsBriefingActive</p><p>    --</p><p>    -- @return boolean: Briefing aktiv</p><p>    -- @within BriefingSystem</p><p>    --</p><p>    function BriefingSystem.IsBriefingActive()</p><p>        return BriefingSystem.GlobalSystem ~= nil and BriefingSystem.GlobalSystem.isActive;</p><p>    end</p><p>    IsBriefingActive = BriefingSystem.IsBriefingActive;</p><p>    ---</p><p>    -- Setzt die Position des Textes und des Titels einer Briefing-Seite.</p><p>    -- @param _page Briefing-Seite</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem.SetBriefingPageTextPosition(_page)</p><p>        local size = {GUI.GetScreenSize()};</p><p>        -- set title position</p><p>        local x,y = XGUIEng.GetWidgetScreenPosition("/InGame/ThroneRoom/Main/DialogTopChooseKnight/ChooseYourKnight");</p><p>        XGUIEng.SetWidgetScreenPosition("/InGame/ThroneRoom/Main/DialogTopChooseKnight/ChooseYourKnight", x, 65);</p><p>        -- reset widget position with backup</p><p>        if not _page.mc then</p><p>            if BriefingSystem.BriefingTextPositionBackup then</p><p>                local pos = BriefingSystem.BriefingTextPositionBackup;</p><p>                XGUIEng.SetWidgetScreenPosition("/InGame/ThroneRoom/Main/MissionBriefing/Text", pos[1], pos[2]);</p><p>            end</p><p>            -- text at the mittle</p><p>            if _page.splashscreen then</p><p>                if _page.centered then</p><p>                    local Height = 0;</p><p>                    if _page.text then</p><p>                        -- Textlänge</p><p>                        local Length = string.len(_page.text);</p><p>                        Height = Height + math.ceil((Length/80));</p><p>                        -- Zeilenumbrüche</p><p>                        local CarriageReturn = 0;</p><p>                        local s,e = string.find(_page.text, "{cr}");</p><p>                        while (e) do</p><p>                            CarriageReturn = CarriageReturn + 1;</p><p>                            s,e = string.find(_page.text, "{cr}", e+1);</p><p>                        end</p><p>                        Height = Height + math.floor((CarriageReturn/2));</p><p>                        -- Relativ</p><p>                        local Screen = {GUI.GetScreenSize()};</p><p>                        Height = (Screen[2]/2) - (Height*15);</p><p>                    end</p><p>                    XGUIEng.SetWidgetScreenPosition("/InGame/ThroneRoom/Main/DialogTopChooseKnight/ChooseYourKnight", x, 0 + Height);</p><p>                    local x,y = XGUIEng.GetWidgetScreenPosition("/InGame/ThroneRoom/Main/MissionBriefing/Text");</p><p>                    if not BriefingSystem.BriefingTextPositionBackup then</p><p>                        BriefingSystem.BriefingTextPositionBackup = {x, y};</p><p>                    end</p><p>                    XGUIEng.SetWidgetScreenPosition("/InGame/ThroneRoom/Main/MissionBriefing/Text", x, 38 + Height);</p><p>                end</p><p>            end</p><p>            return;</p><p>        end</p><p>        -- move title to very top if mc page contains text</p><p>        local x,y = XGUIEng.GetWidgetScreenPosition("/InGame/ThroneRoom/Main/DialogTopChooseKnight/ChooseYourKnight");</p><p>        if _page.mc.text and _page.mc.text ~= "" then</p><p>            XGUIEng.SetWidgetScreenPosition("/InGame/ThroneRoom/Main/DialogTopChooseKnight/ChooseYourKnight",x,5);</p><p>        end</p><p>        -- move the text up to the top</p><p>        local x,y = XGUIEng.GetWidgetScreenPosition("/InGame/ThroneRoom/Main/MissionBriefing/Text");</p><p>        if not BriefingSystem.BriefingTextPositionBackup then</p><p>            BriefingSystem.BriefingTextPositionBackup = {x, y};</p><p>        end</p><p>        XGUIEng.SetWidgetScreenPosition("/InGame/ThroneRoom/Main/MissionBriefing/Text",x,42);</p><p>    end</p><p>    ---</p><p>    -- Steuert die Scrollanimation des Splashscreen.</p><p>    --</p><p>    -- @param _StartUV0 Startposition UV0</p><p>    -- @param _EndUV0   Endposition UV0</p><p>    -- @param _StartUV1 Startposition UV1</p><p>    -- @param _EndUV1   Endposition UV1</p><p>    -- @param _Factor   Interpolation Factor</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem.SetBriefingSplashscreenUV(_StartUV0, _EndUV0, _StartUV1, _EndUV1, _Factor)</p><p>        if not _StartUV0 or not _EndUV0 or not _StartUV1 or not _EndUV1 then</p><p>            return;</p><p>        end</p><p>        local BG     = "/InGame/ThroneRoomBars_2/BarTop";</p><p>        local BB     = "/InGame/ThroneRoomBars_2/BarBottom";</p><p>        local size   = {GUI.GetScreenSize()};</p><p>        local is4To3 = math.floor((size[1]/size[2]) * 10) == 13;</p><p>        local u0 = _StartUV0[1] + (_EndUV0[1] - _StartUV0[1]) * _Factor;</p><p>        local v0 = _StartUV0[2] + (_EndUV0[2] - _StartUV0[2]) * _Factor;</p><p>        local u1 = _StartUV1[1] + (_EndUV1[1] - _StartUV1[1]) * _Factor;</p><p>        local v1 = _StartUV1[2] + (_EndUV1[2] - _StartUV1[2]) * _Factor;</p><p>        -- Fix für 4:3</p><p>        if is4To3 then</p><p>            u0 = u0 + (u0 * 0.125);</p><p>            u1 = u1 - (u1 * 0.125);</p><p>        end</p><p>        XGUIEng.SetMaterialUV(BG, 1, u0, v0, u1, v1);</p><p>    end</p><p>    ---</p><p>    -- Blendet das Character Sprite ein, wenn angegeben.</p><p>    --</p><p>    -- @param _page  Aktuelle Briefing-Seite</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem.SetBriefingPagePortrait(_page)</p><p>        if _page.portrait then</p><p>            XGUIEng.SetMaterialAlpha("/InGame/ThroneRoom/KnightInfo/KnightBG", 1, 255);</p><p>            XGUIEng.SetMaterialTexture("/InGame/ThroneRoom/KnightInfo/KnightBG", 1, _page.portrait);</p><p>            XGUIEng.SetMaterialUV("/InGame/ThroneRoom/KnightInfo/KnightBG", 1, 0, 0, 1, 1);</p><p>        else</p><p>            XGUIEng.SetMaterialAlpha("/InGame/ThroneRoom/KnightInfo/KnightBG", 1, 0);</p><p>        end</p><p>    end</p><p>    ---</p><p>    -- Schaltet zwischen Bars und Splashscreen um.</p><p>    --</p><p>    -- @param _page  Aktuelle Briefing-Seite</p><p>    -- @param _style Bar-Style</p><p>    -- @within BriefingSystem</p><p>    -- @local</p><p>    --</p><p>    function BriefingSystem.SetBriefingPageOrSplashscreen(_page, _style)</p><p>        local BG = "/InGame/ThroneRoomBars_2/BarTop";</p><p>        local BB = "/InGame/ThroneRoomBars_2/BarBottom";</p><p>        local size = {GUI.GetScreenSize()};</p><p>        if not _page.splashscreen then</p><p>            XGUIEng.SetMaterialTexture(BG, 1, "");</p><p>            XGUIEng.SetMaterialTexture(BB, 1, "");</p><p>            XGUIEng.SetMaterialColor(BG, 1, 0, 0, 0, 255);</p><p>            XGUIEng.SetMaterialColor(BB, 1, 0, 0, 0, 255);</p><p>            if BriefingSystem.BriefingBarSizeBackup then</p><p>                local pos = BriefingSystem.BriefingBarSizeBackup;</p><p>                XGUIEng.SetWidgetSize(BG, pos[1], pos[2]);</p><p>                BriefingSystem.BriefingBarSizeBackup = nil;</p><p>            end</p><p>            BriefingSystem.ShowBriefingBar(_style);</p><p>            return;</p><p>        end</p><p>        if _page.splashscreen == true then</p><p>            XGUIEng.SetMaterialTexture(BG, 1, "");</p><p>            XGUIEng.SetMaterialColor(BG, 1, 0, 0, 0, 255);</p><p>            XGUIEng.SetMaterialUV(BG, 1, 0, 0, 1, 1);</p><p>        else</p><p>            XGUIEng.SetMaterialColor(BB, 1, 0, 0, 0, 0);</p><p>            if _page.splashscreen.color then</p><p>                XGUIEng.SetMaterialColor(BG, 1, unpack(_page.splashscreen.color));</p><p>            else</p><p>                XGUIEng.SetMaterialColor(BG, 1, 255, 255, 255, 255);</p><p>            end</p><p>            XGUIEng.SetMaterialTexture(BG, 1, _page.splashscreen.image);</p><p>        end</p><p>        if not BriefingSystem.BriefingBarSizeBackup then</p><p>            local x,y = XGUIEng.GetWidgetSize(BG);</p><p>            BriefingSystem.BriefingBarSizeBackup = {x, y};</p><p>        end</p><p>        local BarX    = BriefingSystem.BriefingBarSizeBackup[1];</p><p>        local _, BarY = XGUIEng.GetWidgetSize("/InGame/ThroneRoomBars");</p><p>        XGUIEng.SetWidgetSize(BG, BarX, BarY);</p><p>        XGUIEng.ShowWidget("/InGame/ThroneRoomBars", 0);</p><p>        XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2", 1);</p><p>        XGUIEng.ShowWidget("/InGame/ThroneRoomBars_Dodge", 0);</p><p>        XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2_Dodge", 0);</p><p>        XGUIEng.ShowWidget(BG, 1);</p><p>    end</p><p>    BundleBriefingSystem:OverwriteGetPosition();</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Überschreibt GetPosition um auch eine Z-Koordinate zurückzugeben.</p><p>-- @within Internal</p><p>-- @local</p><p>    GetPosition = function(_input, _offsetZ)</p><p>        _offsetZ = _offsetZ or 0;</p><p>        if type(_input) == "table" then</p><p>            return _input;</p><p>        else</p><p>            if not IsExisting(_input) then</p><p>                return {X=0, Y=0, Z=0+_offsetZ};</p><p>            else</p><p>                local eID = GetID(_input);</p><p>                local x,y,z = Logic.EntityGetPos(eID);</p><p>                return {X=x, Y=y, Z=z+_offsetZ};</p><p>            end</p><p>        end</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ruft die Lua-Funktion mit dem angegebenen Namen auf und spielt das Briefing</p><p>-- in ihr ab. Die Funktion muss eine Briefing-ID zurückgeben.</p><p>-- Das Brieifng wird an den Quest gebunden und kann mit Trigger_Briefing</p><p>-- überwacht werden. Es kann pro Quest nur ein Briefing gebunden werden!</p><p>-- @param _Briefing [string] Funktionsname als String</p><p>-- @within Reward</p><p>    return b_Reward_Briefing:new(...);</p><p>Reward_Briefing</p><p>    Name = "Reward_Briefing",</p><p>    Description = {</p><p>        en = "Reward: Calls a function that creates a briefing and saves the returned briefing ID into the quest.",</p><p>        de = "Lohn: Ruft eine Funktion auf, die ein Briefing erzeugt und die zurueckgegebene ID in der Quest speichert.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Default, en = "Briefing function", de = "Funktion mit Briefing" },</p><p>    },</p><p>    return { Reward.Custom,{self, self.CustomFunction} }</p><p>    if (__index_ == 0) then</p><p>        self.Function = __parameter_;</p><p>    end</p><p>    local BriefingID = _G[self.Function](self, __quest_);</p><p>    local QuestID = GetQuestID(__quest_.Identifier);</p><p>    Quests[QuestID].EmbeddedBriefing = BriefingID;</p><p>    if not BriefingID and QSB.DEBUG_CheckWhileRuntime then</p><p>        local Text = __quest_.Identifier..": "..self.Name..": '"..self.Function.."' has not returned anything!"</p><p>        if IsBriefingActive() then</p><p>            GUI_Note(Text);</p><p>        end</p><p>        dbg(Text);</p><p>    end</p><p>    if not type(_G[self.Function]) == "function" then</p><p>        dbg(__quest_.Identifier..": "..self.Name..": '"..self.Function.."' was not found!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>    local QuestID = GetQuestID(__quest_.Identifier);</p><p>    Quests[QuestID].EmbeddedBriefing = nil;</p><p>-- Ruft die Lua-Funktion mit dem angegebenen Namen auf und spielt das Briefing</p><p>-- in ihr ab. Die Funktion muss eine Briefing-ID zurückgeben.</p><p>-- Das Brieifng wird an den Quest gebunden und kann mit Trigger_Briefing</p><p>-- überwacht werden. Es kann pro Quest nur ein Briefing gebunden werden!</p><p>-- @param _Briefing [string] Funktionsname als String</p><p>-- @within Reprisal</p><p>    return b_Reprisal_Briefing:new(...);</p><p>Reprisal_Briefing</p><p>    Name = "Reprisal_Briefing",</p><p>    Description = {</p><p>        en = "Reprisal: Calls a function that creates a briefing and saves the returned briefing ID into the quest.",</p><p>        de = "Vergeltung: Ruft eine Funktion auf, die ein Briefing erzeugt und die zurueckgegebene ID in der Quest speichert.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Default, en = "Briefing function", de = "Funktion mit Briefing" },</p><p>    },</p><p>    return { Reprisal.Custom,{self, self.CustomFunction} }</p><p>    if (__index_ == 0) then</p><p>        self.Function = __parameter_;</p><p>    end</p><p>    local BriefingID = _G[self.Function](self, __quest_);</p><p>    local QuestID = GetQuestID(__quest_.Identifier);</p><p>    Quests[QuestID].EmbeddedBriefing = BriefingID;</p><p>    if not BriefingID and QSB.DEBUG_CheckWhileRuntime then</p><p>        local Text = __quest_.Identifier..": "..self.Name..": '"..self.Function.."' has not returned anything!"</p><p>        if IsBriefingActive() then</p><p>            GUI_Note(Text);</p><p>        end</p><p>        dbg(Text);</p><p>    end</p><p>    if not type(_G[self.Function]) == "function" then</p><p>        dbg(__quest_.Identifier..": "..self.Name..": '"..self.Function.."' was not found!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>    local QuestID = GetQuestID(__quest_.Identifier);</p><p>    Quests[QuestID].EmbeddedBriefing = nil;</p><p>-- Startet einen Quest, nachdem das Briefing, das an einen anderen Quest</p><p>-- angehangen ist, beendet ist.</p><p>-- @param _QuestName [string] Name des Quest</p><p>-- @param _Waittime  [number] Wartezeit in Sekunden</p><p>-- @within Trigger</p><p>    return b_Trigger_Briefing:new(...);</p><p>Trigger_Briefing</p><p>    Name = "Trigger_Briefing",</p><p>    Description = {</p><p>        en = "Trigger: after an embedded briefing of another quest has finished.",</p><p>        de = "Ausloeser: wenn das eingebettete Briefing der angegebenen Quest beendet ist.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.QuestName, en = "Quest name", de = "Questname" },</p><p>        { ParameterType.Number,  en = "Wait time",  de = "Wartezeit" },</p><p>    },</p><p>    return { Triggers.Custom2,{self, self.CustomFunction} }</p><p>    if (__index_ == 0) then</p><p>        self.Quest = __parameter_;</p><p>    elseif (__index_ == 1) then</p><p>        self.WaitTime = tonumber(__parameter_) or 0</p><p>    end</p><p>    local QuestID = GetQuestID(self.Quest);</p><p>    if IsBriefingFinished(Quests[QuestID].EmbeddedBriefing) then</p><p>        if self.WaitTime and self.WaitTime > 0 then</p><p>            self.WaitTimeTimer = self.WaitTimeTimer or Logic.GetTime();</p><p>            if Logic.GetTime() >= self.WaitTimeTimer + self.WaitTime then</p><p>                return true;</p><p>            end</p><p>        else</p><p>            return true;</p><p>        end</p><p>    end</p><p>    return false;</p><p>    local QuestID = GetQuestID(self.Quest);</p><p>    Quests[QuestID].EmbeddedBriefing = nil;</p><p>    self.WaitTimeTimer = nil</p><p>    local QuestID = GetQuestID(self.Quest);</p><p>    Quests[QuestID].EmbeddedBriefing = nil;</p><p>    self.WaitTimeTimer = nil</p><p>    if (self.WaitTime and (type(self.WaitTime) ~= "number" or self.WaitTime < 0)) then</p><p>        dbg(__quest_.Identifier.." "..self.Name..": waittime is nil or below 0!");</p><p>        return true;</p><p>    elseif not IsValidQuest(self.Quest) then</p><p>        dbg(__quest_.Identifier.." "..self.Name..": '"..self.Quest.."' is not a valid quest!");</p><p>        return true;</p><p>    end</p><p>    return false;</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundlebuildingbuttons.lua.html">
            <div class='doclink'>
                <div>BundleBuildingButtons</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia BundleBuildingButtons                                        # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Dieses Bundle erweitert das Gebäudemenü für verschiedene Gebäude um weitere</p><p>-- Funktionen. Es ist bspw. möglich ungenutzte Schalter frei zu programmieren.</p><p>-- Bekannte Funktionen sind natürlich auch wieder mit dabei.</p><p>-- Das wichtigste auf einen Blick:</p><p>-- <ul></p><p>-- <li>Viehzucht: Hernzüchten von Kühen und Schafen in Gattern</p><p>-- <br>Kühe züchten:<br><a href="#API.UseBreedCattle">Zucht aktivieren</a>,</p><p>-- <a href="#API.SetCattleNeeded">Mindestanzahl Tiere festlegen</a>,</p><p>-- <a href="#API.SetCattleGrainCost">Getreidekosten festlegen</a></p><p>-- <br>Schafe züchten:<br><a href="#API.UseBreedSheeps">Zucht aktivieren</a>,</p><p>-- <a href="#API.SetSheepNeeded">Mindestanzahl Tiere festlegen</a>,</p><p>-- <a href="#API.SetSheepGrainCost">Getreidekosten festlegen</a></p><p>-- </li></p><p>-- <li>Single Stop: Anhalten der Produktion von einzelnen Gebäuden</p><p>-- <br><a href="#API.ActivateSingleStop">aktivieren</a>,</p><p>-- <a href="#API.ActivateSingleStop">deaktivieren</a></p><p>-- </li></p><p>-- <li>Downgrade: Rückbau von Stadt- und Rohstoffgebäuden</p><p>-- <br><a href="#API.ActivateDowngrade">aktivieren</a>,</p><p>-- <a href="#API.DeactivateDowngrade">deaktivieren</a></p><p>-- </li></p><p>-- </ul></p><p>-- @within Modulbeschreibung</p><p>-- @set sort=false</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Aktiviert die Single Stop Buttons. Single Stop ermöglicht das Anhalten</p><p>-- eines einzelnen Betriebes, anstelle des Anhaltens aller Betriebe des</p><p>-- gleichen Typs.</p><p>-- Im Gegensatz zur Viehzucht und zum Rückbau, welche feste eigeständige</p><p>-- Buttons sind, handelt es sich hierbei um einen Custom Button. Single</p><p>-- Stop belegt Index 1.</p><p>-- <p><b>Alias:</b> ActivateSingleStop</p></p><p>-- @within Anwenderfunktionen</p><p>-- @see API.AddCustomBuildingButton</p><p>function API.ActivateSingleStop()</p><p>    if not GUI then</p><p>        API.Bridge("API.ActivateSingleStop()");</p><p>        return;</p><p>    end</p><p>    BundleBuildingButtons.Local:AddOptionalButton(</p><p>        2,</p><p>        BundleBuildingButtons.Local.ButtonDefaultSingleStop_Action,</p><p>        BundleBuildingButtons.Local.ButtonDefaultSingleStop_Tooltip,</p><p>        BundleBuildingButtons.Local.ButtonDefaultSingleStop_Update</p><p>    );</p><p>-- Deaktiviert die Single Stop Buttons.</p><p>-- <p><b>Alias:</b> DeactivateSingleStop</p></p><p>-- @within Anwenderfunktionen</p><p>function API.DeactivateSingleStop()</p><p>    if not GUI then</p><p>        API.Bridge("API.DeactivateSingleStop()");</p><p>        return;</p><p>    end</p><p>    BundleBuildingButtons.Local:DeleteOptionalButton(2);</p><p>-- Aktiviere Rückbau bei Stadt- und Rohstoffgebäuden. Die Rückbaufunktion</p><p>-- erlaubt es dem Spieler bei Stadt- und Rohstoffgebäude der Stufe 2 und 3</p><p>-- jeweils eine Stufe zu zerstören. Der überflüssige Arbeiter wird entlassen.</p><p>-- <p><b>Alias:</b> UseDowngrade</p></p><p>-- @within Anwenderfunktionen</p><p>function API.ActivateDowngrade()</p><p>    if not GUI then</p><p>        API.Bridge("API.ActivateDowngrade()");</p><p>        return;</p><p>    end</p><p>    BundleBuildingButtons.Local.Data.Downgrade = true;</p><p>-- Deaktiviert den Rückbau von Gebäuden.</p><p>-- <p><b>Alias:</b> DeactivateDowngrade</p></p><p>-- @within Anwenderfunktionen</p><p>function API.DeactivateDowngrade()</p><p>    if not GUI then</p><p>        API.Bridge("API.DeactivateDowngrade()");</p><p>        return;</p><p>    end</p><p>    BundleBuildingButtons.Local.Data.Downgrade = false;</p><p>-- Erlaube oder verbiete dem Spieler Schafe zu züchten.</p><p>-- <p><b>Alias:</b> UseBreedSheeps</p></p><p>-- @param _flag [boolean] Schafzucht aktiv/inaktiv</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- -- Schafsaufzucht ist erlaubt</p><p>-- API.UseBreedSheeps(true);</p><p>function API.UseBreedSheeps(_flag)</p><p>    if not GUI then</p><p>        API.Bridge("API.UseBreedSheeps(" ..tostring(_flag).. ")");</p><p>        return;</p><p>    end</p><p>    BundleBuildingButtons.Local.Data.BreedSheeps = _flag == true;</p><p>    if _flag == true then</p><p>        local Price = MerchantSystem.BasePricesOrigBundleBuildingButtons[Goods.G_Sheep]</p><p>        MerchantSystem.BasePrices[Goods.G_Sheep] = Price;</p><p>        API.Bridge("MerchantSystem.BasePrices[Goods.G_Sheep] = " ..Price);</p><p>    else</p><p>        local Price = BundleBuildingButtons.Local.Data.SheepMoneyCost;</p><p>        MerchantSystem.BasePrices[Goods.G_Sheep] = Price;</p><p>        API.Bridge("MerchantSystem.BasePrices[Goods.G_Sheep] = " ..Price);</p><p>    end</p><p>-- Erlaube oder verbiete dem Spieler Kühe zu züchten.</p><p>-- <p><b>Alias:</b> UseBreedCattle</p></p><p>-- @param _flag [boolean] Kuhzucht aktiv/inaktiv</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- -- Es können keine Kühe gezüchtet werden</p><p>-- API.UseBreedCattle(false);</p><p>function API.UseBreedCattle(_flag)</p><p>    if not GUI then</p><p>        API.Bridge("API.UseBreedCattle(" ..tostring(_flag).. ")");</p><p>        return;</p><p>    end</p><p>    BundleBuildingButtons.Local.Data.BreedCattle = _flag == true;</p><p>    if _flag == true then</p><p>        local Price = MerchantSystem.BasePricesOrigBundleBuildingButtons[Goods.G_Cow];</p><p>        MerchantSystem.BasePrices[Goods.G_Cow] = Price;</p><p>        API.Bridge("MerchantSystem.BasePrices[Goods.G_Cow] = " ..Price);</p><p>    else</p><p>        local Price = BundleBuildingButtons.Local.Data.CattleMoneyCost;</p><p>        MerchantSystem.BasePrices[Goods.G_Cow] = Price;</p><p>        API.Bridge("MerchantSystem.BasePrices[Goods.G_Cow] = " ..Price);</p><p>    end</p><p>-- Setzt die Menge an Getreide, das zur Zucht eines Tieres benötigt wird.</p><p>-- <p><b>Alias:</b> SetSheepGrainCost</p></p><p>-- @param _Amount [number] Getreidekosten</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- -- Wucherpreise zum Züchten!</p><p>-- API.SetSheepGrainCost(50);</p><p>function API.SetSheepGrainCost(_Amount)</p><p>    if not GUI then</p><p>        API.Bridge("API.SetSheepGrainCost(" .._Amount.. ")");</p><p>        return;</p><p>    end</p><p>    BundleBuildingButtons.Local.Data.SheepCosts = _Amount;</p><p>-- Setzt die Menge an Getreide, das zur Zucht eines Tieres benötigt wird.</p><p>-- <p><b>Alias:</b> SetCattleGrainCost</p></p><p>-- @param _Amount [number] Getreidekosten</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- -- Wucherpreise zum Züchten!</p><p>-- API.SetCattleGrainCost(50);</p><p>function API.SetCattleGrainCost(_Amount)</p><p>    if not GUI then</p><p>        API.Bridge("API.SetCattleGrainCost(" .._Amount.. ")");</p><p>        return;</p><p>    end</p><p>    BundleBuildingButtons.Local.Data.CattleCosts = _Amount;</p><p>-- Setzt die zur Zucht benötigte Menge an benötigten Tieren in einem Gatter.</p><p>-- <p><b>Alias:</b> SetSheepNeeded</p></p><p>-- @param _Amount [number] Benötigte Menge</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- -- Es wird ein volles Gatter zur Zucht benötigt:</p><p>-- API.SetSheepNeeded(5);</p><p>function API.SetSheepNeeded(_Amount)</p><p>    if not GUI then</p><p>        API.Bridge("API.SetSheepNeeded(" .._Amount.. ")");</p><p>        return;</p><p>    end</p><p>    if type(_Amount) ~= "number" or _Amount < 0 or _Amount > 5 then</p><p>        API.Fatal("API.SetSheepNeeded: Needed amount is invalid!");</p><p>    end</p><p>    BundleBuildingButtons.Local.Data.SheepNeeded = _Amount;</p><p>-- Setzt die zur Zucht benötigte Menge an benötigten Tieren in einem Gatter.</p><p>-- <p><b>Alias:</b> SetCattleNeeded</p></p><p>-- @param _Amount [number] Benötigte Menge</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- -- Es werden keine Kühe zur Zucht benötigt:</p><p>-- API.SetCattleNeeded(0);</p><p>function API.SetCattleNeeded(_Amount)</p><p>    if not GUI then</p><p>        API.Bridge("API.SetCattleNeeded(" .._Amount.. ")");</p><p>        return;</p><p>    end</p><p>    if type(_Amount) ~= "number" or _Amount < 0 or _Amount > 5 then</p><p>        API.Fatal("API.SetCattleNeeded: Needed amount is invalid!");</p><p>    end</p><p>    BundleBuildingButtons.Local.Data.CattleNeeded = _Amount;</p><p>-- Fügt einen optionalen Gebäudeschalter hinzu. Der Index bestimmt, welcher</p><p>-- der beiden möglichen Buttons verwendet wird.</p><p>-- Mit dieser Funktion können zwei ungenutzte Buttons im Gebäudemenu mit einer</p><p>-- Funktionalität versehen werden. Es obliegt dem Mapper für welche Gebäude</p><p>-- der Button angezeigt wird und welche Funktion er hat. Es ist nicht möglich</p><p>-- Kosten im Tooltip anzuzeigen.</p><p>-- Jeder Button kann immer nur mit einer Aktion versehen werden. Soll die</p><p>-- Aktion für verschiedene Gebäudetypen unterschiedlich sein, muss in der</p><p>-- Aktion eine Fallunterscheidung durchgeführt werden.</p><p>-- Ein optionaler Button benötigt immer drei Funktionen:</p><p>-- <ul></p><p>-- <li>Action: Steuert, was der Button tut.</li></p><p>-- <li>Tooltip: Steuert, welcher Beschreibungstext angezeigt wird.</li></p><p>-- <li>Update: Steuert, wann und wie der Button angezeigt wird.</li></p><p>-- </ul></p><p>-- Alle drei Funktionen erhalten die ID des Buttons und die ID des Gebäudes,</p><p>-- das gerade selektiert ist.</p><p>-- <b>Achtung:</b> Wenn die Funktion aus dem globalen Skript ausgeführt wird,</p><p>-- müssen sich die Buttonfunktionen im lokalen Skript befinden. Die Namen der</p><p>-- Funktionen sind in diesem Fall als Zeichenkette zu übergeben!</p><p>-- <p><b>Alias:</b> AddBuildingButton</p></p><p>-- @param _Index   [number] Index des Buttons</p><p>-- @param _Action  [function] Aktion des Buttons</p><p>-- @param _Tooltip [function] Tooltip Control</p><p>-- @param _Update  [function] Button Update</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- -- Aktion</p><p>-- function ExampleButtonAction(_WidgetID, _BuildingID)</p><p>--     GUI.AddNote("Hier passiert etwas!");</p><p>-- end</p><p>-- -- Tooltip</p><p>-- function ExampleButtonTooltip(_WidgetID, _BuildingID)</p><p>--     UserSetTextNormal("Beschreibung", "Das ist die Beschreibung!");</p><p>-- end</p><p>-- -- Update</p><p>-- function ExampleButtonUpdate(_WidgetID, _BuildingID)</p><p>--     SetIcon(_WidgetID, {1, 1});</p><p>-- end</p><p>-- -- Beispiel für einen einfachen Button, der immer angezeigt wird, das Bild</p><p>-- -- eines Apfels trägt und eine Nachricht anzeigt.</p><p>-- API.AddCustomBuildingButton(1, ExampleButtonAction, ExampleButtonTooltip, ExampleButtonUpdate);</p><p>function API.AddCustomBuildingButton(_Index, _Action, _Tooltip, _Update)</p><p>    if not GUI then</p><p>        API.Bridge("API.AddCustomBuildingButton("..tostring(_Index)..","..tostring(_Action)..","..tostring(_Tooltip)..","..tostring(_Update)..",)");</p><p>        return;</p><p>    end</p><p>    if (type(_Index) ~= "number" or (_Index < 1 or _Index > 2)) then</p><p>        API.Fatal("API.AddCustomBuildingButton: Index must be 1 or 2!");</p><p>        return;</p><p>    end</p><p>    if (type(_Action) ~= "function" or type(_Tooltip) ~= "function" or type(_Update) ~= "function") then</p><p>        API.Fatal("API.AddCustomBuildingButton: Action, tooltip and update must be functions!");</p><p>        return;</p><p>    end</p><p>    return BundleBuildingButtons.Local:AddOptionalButton(</p><p>        _Index, _Action, _Tooltip, _Update</p><p>    );</p><p>-- Entfernt den optionalen Gebäudeschalter mit dem angegebenen Index.</p><p>-- <p><b>Alias:</b> DeleteBuildingButton</p></p><p>-- @param _Index   [number] Index des Buttons</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- -- Entfernt die Konfiguration für Button 1</p><p>-- API.RemoveCustomBuildingButton(1);</p><p>function API.RemoveCustomBuildingButton(_Index)</p><p>    if not GUI then</p><p>        API.Fatal("API.RemoveCustomBuildingButton("..tostring(_Index)..")");</p><p>        return;</p><p>    end</p><p>    if (type(_Index) ~= "number" or (_Index < 1 or _Index > 2)) then</p><p>        API.Fatal("API.RemoveCustomBuildingButton: Index must be 1 or 2!");</p><p>        return;</p><p>    end</p><p>    return BundleBuildingButtons.Local:DeleteOptionalButton(_Index);</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {</p><p>        Data = {}</p><p>    },</p><p>    Local = {</p><p>        Data = {</p><p>            OptionalButton1 = {</p><p>                UseButton = false,</p><p>            },</p><p>            OptionalButton2 = {</p><p>                UseButton = false,</p><p>            },</p><p>            StoppedBuildings = {},</p><p>            Downgrade = true,</p><p>            BreedCattle = true,</p><p>            CattleCosts = 10,</p><p>            CattleNeeded = 3,</p><p>            CattleKnightTitle = 0,</p><p>            CattleMoneyCost = 300,</p><p>            BreedSheeps = true,</p><p>            SheepCosts = 10,</p><p>            SheepNeeded = 3,</p><p>            SheepKnightTitle = 0,</p><p>            SheepMoneyCost = 300,</p><p>        },</p><p>        Description = {</p><p>            Downgrade = {</p><p>                Title = {</p><p>                    de = "Rückbau",</p><p>                    en = "Downgrade",</p><p>                },</p><p>                Text = {</p><p>                    de = "- Reißt eine Stufe des Geb?udes ein {cr}- Der überschüssige Arbeiter wird entlassen",</p><p>                    en = "- Destroy one level of this building {cr}- The surplus worker will be dismissed",</p><p>                },</p><p>                Disabled = {</p><p>                    de = "Kann nicht zurückgebaut werden!",</p><p>                    en = "Can not be downgraded yet!",</p><p>                },</p><p>            },</p><p>            BuyCattle = {</p><p>                Title = {</p><p>                    de = "Nutztier kaufen",</p><p>                    en = "Buy Farm animal",</p><p>                },</p><p>                Text = {</p><p>                    de = "- Kauft ein Nutztier {cr}- Nutztiere produzieren Rohstoffe",</p><p>                    en = "- Buy a farm animal {cr}- Farm animals produce resources",</p><p>                },</p><p>                Disabled = {</p><p>                    de = "Kauf ist nicht möglich!",</p><p>                    en = "Buy not possible!",</p><p>                },</p><p>            },</p><p>            SingleStop = {</p><p>                Title = {</p><p>                    de = "Arbeit anhalten/aufnehmen",</p><p>                    en = "Start/Stop Work",</p><p>                },</p><p>                Text = {</p><p>                    de = "- Startet oder stoppe die Arbeit in diesem Betrieb",</p><p>                    en = "- Continue or stop work for this building",</p><p>                },</p><p>            },</p><p>        },</p><p>    },</p><p>-- Global Script ---------------------------------------------------------------</p><p>-- Initalisiert das Bundle im globalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>-- Local Script ----------------------------------------------------------------</p><p>-- Initalisiert das Bundle im lokalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    MerchantSystem.BasePricesOrigBundleBuildingButtons                = {};</p><p>    MerchantSystem.BasePricesOrigBundleBuildingButtons[Goods.G_Sheep] = MerchantSystem.BasePrices[Goods.G_Sheep];</p><p>    MerchantSystem.BasePricesOrigBundleBuildingButtons[Goods.G_Cow]   = MerchantSystem.BasePrices[Goods.G_Cow];</p><p>    MerchantSystem.BasePrices[Goods.G_Sheep] = BundleBuildingButtons.Local.Data.SheepMoneyCost;</p><p>    MerchantSystem.BasePrices[Goods.G_Cow]   = BundleBuildingButtons.Local.Data.CattleMoneyCost;</p><p>    self:OverwriteHouseMenuButtons();</p><p>    self:OverwriteBuySiegeEngine();</p><p>    self:OverwriteToggleTrap();</p><p>    self:OverwriteGateOpenClose();</p><p>    self:OverwriteAutoToggle();</p><p>    Core:AppendFunction("GameCallback_GUI_SelectionChanged", self.OnSelectionChanged);</p><p>-- Diese Funktion erzeugt ein Nutztier und entfernt das Getreide vom Spieler.</p><p>-- @within Internal</p><p>-- @local</p><p>    Sound.FXPlay2DSound("ui\\menu_click");</p><p>    local eType = Logic.GetEntityType(_eID);</p><p>    if eType == Entities.B_CattlePasture then</p><p>        local Cost = BundleBuildingButtons.Local.Data.CattleCosts * (-1);</p><p>        GUI.SendScriptCommand([[</p><p>            local pID = Logic.EntityGetPlayer(]].._eID..[[)</p><p>            local x, y = Logic.GetBuildingApproachPosition(]].._eID..[[)</p><p>            Logic.CreateEntity(Entities.A_X_Cow01, x, y, 0, pID)</p><p>            AddGood(Goods.G_Grain, ]] ..Cost.. [[, pID)</p><p>        ]]);</p><p>    elseif eType == Entities.B_SheepPasture then</p><p>        local Cost = BundleBuildingButtons.Local.Data.SheepCosts * (-1);</p><p>        GUI.SendScriptCommand([[</p><p>            local pID = Logic.EntityGetPlayer(]].._eID..[[)</p><p>            local x, y = Logic.GetBuildingApproachPosition(]].._eID..[[)</p><p>            Logic.CreateEntity(Entities.A_X_Sheep01, x, y, 0, pID)</p><p>            AddGood(Goods.G_Grain, ]] ..Cost.. [[, pID)</p><p>        ]]);</p><p>    end</p><p>-- Das aktuell selektierte Gebäude wird um eine Stufe zurückgebaut.</p><p>-- Ein Gebäude der Stufe 1 wird zerstört. Aktuell ist dies aber inaktiv.</p><p>-- @within Internal</p><p>-- @local</p><p>    Sound.FXPlay2DSound("ui\\menu_click");</p><p>    local Selected = GUI.GetSelectedEntity();</p><p>    GUI.DeselectEntity(Selected);</p><p>    if Logic.GetUpgradeLevel(Selected) > 0 then</p><p>        local AmountToHurt = math.ceil(Logic.GetEntityMaxHealth(Selected) / 2);</p><p>        if Logic.GetEntityHealth(Selected) >= AmountToHurt then</p><p>            GUI.SendScriptCommand([[Logic.HurtEntity(]] ..Selected.. [[, ]] ..AmountToHurt.. [[)]]);</p><p>        end</p><p>    else</p><p>        local AmountToHurt = Logic.GetEntityMaxHealth(Selected);</p><p>        GUI.SendScriptCommand([[Logic.HurtEntity(]] ..Selected.. [[, ]] ..AmountToHurt.. [[)]]);</p><p>    end</p><p>-- Fügt einen Button dem Hausmenü hinzu. Es können nur 2 Buttons</p><p>-- hinzugefügt werden. Buttons brauchen immer eine Action-, eine</p><p>-- Tooltip- und eine Update-Funktion.</p><p>-- @param _idx              Indexposition des Button (1 oder 2)</p><p>-- @param _actionFunction   Action-Funktion (String in Global)</p><p>-- @param _tooltipFunction  Tooltip-Funktion (String in Global)</p><p>-- @param _updateFunction   Update-Funktion (String in Global)</p><p>-- @within Internal</p><p>-- @local</p><p>-- @see API.AddCustomBuildingButton</p><p>    assert(_idx == 1 or _idx == 2);</p><p>    local wID = {</p><p>        XGUIEng.GetWidgetID("/InGame/Root/Normal/BuildingButtons/GateAutoToggle"),</p><p>        XGUIEng.GetWidgetID("/InGame/Root/Normal/BuildingButtons/GateOpenClose"),</p><p>    };</p><p>    BundleBuildingButtons.Local.Data["OptionalButton".._idx].WidgetID = wID[_idx];</p><p>    BundleBuildingButtons.Local.Data["OptionalButton".._idx].UseButton = true;</p><p>    BundleBuildingButtons.Local.Data["OptionalButton".._idx].ActionFunction = _actionFunction;</p><p>    BundleBuildingButtons.Local.Data["OptionalButton".._idx].TooltipFunction = _tooltipFunction;</p><p>    BundleBuildingButtons.Local.Data["OptionalButton".._idx].UpdateFunction = _updateFunction;</p><p>-- Entfernt den Zusatz-Button auf dem Index.</p><p>-- @param _idx Indexposition des Button (1 oder 2)</p><p>-- @within Internal</p><p>-- @local</p><p>    assert(_idx == 1 or _idx == 2);</p><p>    local wID = {</p><p>        XGUIEng.GetWidgetID("/InGame/Root/Normal/BuildingButtons/GateAutoToggle"),</p><p>        XGUIEng.GetWidgetID("/InGame/Root/Normal/BuildingButtons/GateOpenClose"),</p><p>    };</p><p>    BundleBuildingButtons.Local.Data["OptionalButton".._idx].WidgetID = wID[_idx];</p><p>    BundleBuildingButtons.Local.Data["OptionalButton".._idx].UseButton = false;</p><p>    BundleBuildingButtons.Local.Data["OptionalButton".._idx].ActionFunction = nil;</p><p>    BundleBuildingButtons.Local.Data["OptionalButton".._idx].TooltipFunction = nil;</p><p>    BundleBuildingButtons.Local.Data["OptionalButton".._idx].UpdateFunction = nil;</p><p>-- Überschreibt die GUI-Funktionen des inaktiven Schalters für automatisches</p><p>-- Umschalten von Torsperren.</p><p>-- Diese Funktion implementiert den optionalen Schalter #1.</p><p>-- @within Internal</p><p>-- @local</p><p>    GUI_BuildingButtons.GateAutoToggleClicked = function()</p><p>        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();</p><p>        local EntityID = GUI.GetSelectedEntity();</p><p>        if not BundleBuildingButtons.Local.Data.OptionalButton1.ActionFunction then</p><p>            return;</p><p>        end</p><p>        BundleBuildingButtons.Local.Data.OptionalButton1.ActionFunction(CurrentWidgetID, EntityID);</p><p>    end</p><p>    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</p><p>    GUI_BuildingButtons.GateAutoToggleMouseOver = function()</p><p>        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();</p><p>        local EntityID = GUI.GetSelectedEntity();</p><p>        if not BundleBuildingButtons.Local.Data.OptionalButton1.TooltipFunction then</p><p>            return;</p><p>        end</p><p>        BundleBuildingButtons.Local.Data.OptionalButton1.TooltipFunction(CurrentWidgetID, EntityID);</p><p>    end</p><p>    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</p><p>    GUI_BuildingButtons.GateAutoToggleUpdate = function()</p><p>        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();</p><p>        local EntityID = GUI.GetSelectedEntity();</p><p>        local MaxHealth = Logic.GetEntityMaxHealth(EntityID);</p><p>        local Health = Logic.GetEntityHealth(EntityID);</p><p>        SetIcon(CurrentWidgetID, {8,16});</p><p>        if EntityID == nil</p><p>        or Logic.IsBuilding(EntityID) == 0</p><p>        or not BundleBuildingButtons.Local.Data.OptionalButton1.UpdateFunction</p><p>        or not BundleBuildingButtons.Local.Data.OptionalButton1.UseButton</p><p>        or Logic.IsConstructionComplete(EntityID) == 0 then</p><p>            XGUIEng.ShowWidget(CurrentWidgetID, 0);</p><p>            return;</p><p>        end</p><p>        if Logic.BuildingDoWorkersStrike(EntityID) == true</p><p>        or Logic.IsBuildingBeingUpgraded(EntityID) == true</p><p>        or Logic.IsBuildingBeingKnockedDown(EntityID) == true</p><p>        or Logic.IsBurning(EntityID) == true</p><p>        or MaxHealth-Health > 0 then</p><p>            XGUIEng.ShowWidget(CurrentWidgetID, 0);</p><p>            return;</p><p>        end</p><p>        BundleBuildingButtons.Local.Data.OptionalButton1.UpdateFunction(CurrentWidgetID, EntityID);</p><p>    end</p><p>-- Überschreibt den inaktiven Button zum öffnen/schließen von Toren.</p><p>-- Diese Funktion implementiert den optionalen Schalter #2.</p><p>-- @within Internal</p><p>-- @local</p><p>    GUI_BuildingButtons.GateOpenCloseClicked = function()</p><p>        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();</p><p>        local EntityID = GUI.GetSelectedEntity();</p><p>        if not BundleBuildingButtons.Local.Data.OptionalButton2.ActionFunction then</p><p>            return;</p><p>        end</p><p>        BundleBuildingButtons.Local.Data.OptionalButton2.ActionFunction(CurrentWidgetID, EntityID);</p><p>    end</p><p>    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</p><p>    GUI_BuildingButtons.GateOpenCloseMouseOver = function()</p><p>        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();</p><p>        local EntityID = GUI.GetSelectedEntity();</p><p>        if not BundleBuildingButtons.Local.Data.OptionalButton2.TooltipFunction then</p><p>            return;</p><p>        end</p><p>        BundleBuildingButtons.Local.Data.OptionalButton2.TooltipFunction(CurrentWidgetID, EntityID);</p><p>    end</p><p>    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</p><p>    GUI_BuildingButtons.GateOpenCloseUpdate = function()</p><p>        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();</p><p>        local EntityID = GUI.GetSelectedEntity();</p><p>        local MaxHealth = Logic.GetEntityMaxHealth(EntityID);</p><p>        local Health = Logic.GetEntityHealth(EntityID);</p><p>        SetIcon(CurrentWidgetID, {8,16});</p><p>        if EntityID == nil</p><p>        or Logic.IsBuilding(EntityID) == 0</p><p>        or not BundleBuildingButtons.Local.Data.OptionalButton2.UpdateFunction</p><p>        or not BundleBuildingButtons.Local.Data.OptionalButton2.UseButton</p><p>        or Logic.IsConstructionComplete(EntityID) == 0</p><p>        or Logic.IsBuilding(EntityID) == 0 then</p><p>            XGUIEng.ShowWidget(CurrentWidgetID, 0);</p><p>            return;</p><p>        end</p><p>        if Logic.BuildingDoWorkersStrike(EntityID) == true</p><p>        or Logic.IsBuildingBeingUpgraded(EntityID) == true</p><p>        or Logic.IsBuildingBeingKnockedDown(EntityID) == true</p><p>        or Logic.IsBurning(EntityID) == true</p><p>        or MaxHealth-Health > 0 then</p><p>            XGUIEng.ShowWidget(CurrentWidgetID, 0);</p><p>            return;</p><p>        end</p><p>        BundleBuildingButtons.Local.Data.OptionalButton2.UpdateFunction(CurrentWidgetID, EntityID);</p><p>    end</p><p>-- Überschreibt den inaktiven Button zum umschalten der Torhausfallen.</p><p>-- Diese Funktion implementiert den Rückbau.</p><p>-- @within Internal</p><p>-- @local</p><p>    GUI_BuildingButtons.TrapToggleClicked = function()</p><p>        BundleBuildingButtons.Local:DowngradeBuilding();</p><p>    end</p><p>    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</p><p>    GUI_BuildingButtons.TrapToggleMouseOver = function()</p><p>        local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>        BundleBuildingButtons.Local:TextNormal(</p><p>            BundleBuildingButtons.Local.Description.Downgrade.Title[lang],</p><p>            BundleBuildingButtons.Local.Description.Downgrade.Text[lang],</p><p>            BundleBuildingButtons.Local.Description.Downgrade.Disabled[lang]</p><p>        );</p><p>    end</p><p>    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</p><p>    GUI_BuildingButtons.TrapToggleUpdate = function()</p><p>        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();</p><p>        local EntityID = GUI.GetSelectedEntity();</p><p>        local eName = Logic.GetEntityName(EntityID);</p><p>        local eType = Logic.GetEntityType(EntityID);</p><p>        local tID = GetTerritoryUnderEntity(EntityID);</p><p>        local MaxHealth = Logic.GetEntityMaxHealth(EntityID);</p><p>        local Health = Logic.GetEntityHealth(EntityID);</p><p>        local Level = Logic.GetUpgradeLevel(EntityID);</p><p>        local x,y = XGUIEng.GetWidgetLocalPosition("/InGame/Root/Normal/BuildingButtons/Upgrade");</p><p>        SetIcon(CurrentWidgetID, {3,15});</p><p>        XGUIEng.SetWidgetLocalPosition(CurrentWidgetID, x+64, y);</p><p>        if EntityID == nil or Logic.IsBuilding(EntityID) == 0 then</p><p>            XGUIEng.ShowWidget(CurrentWidgetID, 0);</p><p>            return;</p><p>        end</p><p>        -- Protection - Submodul</p><p>        if BundleDestructionControl then</p><p>            -- Prüfe auf Namen</p><p>            if Inside(eName, BundleDestructionControl.Local.Data.Entities) then</p><p>                XGUIEng.ShowWidget(CurrentWidgetID, 0);</p><p>                return;</p><p>            end</p><p>            -- Prüfe auf Typen</p><p>            if Inside(eType, BundleDestructionControl.Local.Data.EntityTypes) then</p><p>                XGUIEng.ShowWidget(CurrentWidgetID, 0);</p><p>                return;</p><p>            end</p><p>            -- Prüfe auf Territorien</p><p>            if Inside(tID, BundleDestructionControl.Local.Data.OnTerritory) then</p><p>                XGUIEng.ShowWidget(CurrentWidgetID, 0);</p><p>                return;</p><p>            end</p><p>            -- Prüfe auf Category</p><p>            for k,v in pairs(BundleDestructionControl.Local.Data.EntityCategories) do</p><p>                if Logic.IsEntityInCategory(_BuildingID, v) == 1 then</p><p>                    XGUIEng.ShowWidget(CurrentWidgetID, 0);</p><p>                    return;</p><p>                end</p><p>            end</p><p>        end</p><p>        if Logic.IsConstructionComplete(EntityID) == 0</p><p>        or (Logic.IsEntityInCategory(EntityID, EntityCategories.OuterRimBuilding) == 0</p><p>        and Logic.IsEntityInCategory(EntityID, EntityCategories.CityBuilding) == 0)</p><p>        or not BundleBuildingButtons.Local.Data.Downgrade</p><p>        or Level == 0 then</p><p>            XGUIEng.ShowWidget(CurrentWidgetID, 0);</p><p>            return;</p><p>        end</p><p>        if Logic.BuildingDoWorkersStrike(EntityID) == true</p><p>        or Logic.IsBuildingBeingUpgraded(EntityID) == true</p><p>        or Logic.IsBuildingBeingKnockedDown(EntityID) == true</p><p>        or Logic.IsBurning(EntityID) == true</p><p>        or MaxHealth-Health > 0 then</p><p>            XGUIEng.DisableButton(CurrentWidgetID, 1);</p><p>        else</p><p>            XGUIEng.DisableButton(CurrentWidgetID, 0);</p><p>        end</p><p>    end</p><p>-- Diese Funktion überschreibt die Belagerungswaffenwerkstattsteuerung. Dabei</p><p>-- wird die Nutztierzucht implementiert.</p><p>-- @within Internal</p><p>-- @local</p><p>    GUI_BuildingButtons.BuySiegeEngineCartMouseOver = function(_EntityType,_TechnologyType)</p><p>        local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();</p><p>        local BarrackID = GUI.GetSelectedEntity();</p><p>        local BuildingEntityType = Logic.GetEntityType(BarrackID);</p><p>        if  BuildingEntityType ~= Entities.B_SiegeEngineWorkshop</p><p>        and BuildingEntityType ~= Entities.B_CattlePasture</p><p>        and BuildingEntityType ~= Entities.B_SheepPasture then</p><p>            return;</p><p>        end</p><p>        local Costs = {Logic.GetUnitCost(BarrackID, _EntityType)}</p><p>        if BuildingEntityType == Entities.B_CattlePasture then</p><p>            BundleBuildingButtons.Local:TextCosts(</p><p>                BundleBuildingButtons.Local.Description.BuyCattle.Title[lang],</p><p>                BundleBuildingButtons.Local.Description.BuyCattle.Text[lang],</p><p>                BundleBuildingButtons.Local.Description.BuyCattle.Disabled[lang],</p><p>                {Goods.G_Grain, BundleBuildingButtons.Local.Data.CattleCosts},</p><p>                false</p><p>            );</p><p>        elseif BuildingEntityType == Entities.B_SheepPasture then</p><p>            BundleBuildingButtons.Local:TextCosts(</p><p>                BundleBuildingButtons.Local.Description.BuyCattle.Title[lang],</p><p>                BundleBuildingButtons.Local.Description.BuyCattle.Text[lang],</p><p>                BundleBuildingButtons.Local.Description.BuyCattle.Disabled[lang],</p><p>                {Goods.G_Grain, BundleBuildingButtons.Local.Data.SheepCosts},</p><p>                false</p><p>            );</p><p>        else</p><p>            GUI_Tooltip.TooltipBuy(Costs,nil,nil,_TechnologyType);</p><p>        end</p><p>    end</p><p>    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</p><p>    GUI_BuildingButtons.BuySiegeEngineCartClicked_OrigTHEA_Buildings = GUI_BuildingButtons.BuySiegeEngineCartClicked</p><p>    GUI_BuildingButtons.BuySiegeEngineCartClicked = function(_EntityType)</p><p>        local BarrackID = GUI.GetSelectedEntity()</p><p>        local PlayerID = GUI.GetPlayerID()</p><p>        local eType = Logic.GetEntityType(BarrackID)</p><p>        if eType == Entities.B_CattlePasture or eType == Entities.B_SheepPasture then</p><p>            BundleBuildingButtons.Local:BuyAnimal(BarrackID);</p><p>        else</p><p>            GUI_BuildingButtons.BuySiegeEngineCartClicked_OrigTHEA_Buildings(_EntityType)</p><p>        end</p><p>    end</p><p>    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</p><p>    GUI_BuildingButtons.BuySiegeEngineCartUpdate = function(_Technology)</p><p>        local PlayerID = GUI.GetPlayerID();</p><p>        local KnightTitle = Logic.GetKnightTitle(PlayerID);</p><p>        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();</p><p>        local EntityID = GUI.GetSelectedEntity();</p><p>        local EntityType = Logic.GetEntityType(EntityID);</p><p>        local grain = GetPlayerResources(Goods.G_Grain,PlayerID);</p><p>        local pos = GetPosition(EntityID);</p><p>        if EntityType == Entities.B_SiegeEngineWorkshop then</p><p>            XGUIEng.ShowWidget(CurrentWidgetID,1);</p><p>            if _Technology == Technologies.R_BatteringRam then</p><p>                SetIcon(CurrentWidgetID, {9,5});</p><p>            elseif _Technology == Technologies.R_SiegeTower then</p><p>                SetIcon(CurrentWidgetID, {9,6});</p><p>            elseif _Technology == Technologies.R_Catapult then</p><p>                SetIcon(CurrentWidgetID, {9,4});</p><p>            end</p><p>        elseif EntityType == Entities.B_CattlePasture then</p><p>            local CattlePasture = GetPlayerEntities(PlayerID,Entities.B_CattlePasture);</p><p>            local cows          = {Logic.GetPlayerEntitiesInArea(PlayerID,Entities.A_X_Cow01,pos.X,pos.Y,800,16)};</p><p>            local curAnimal     = Logic.GetNumberOfPlayerEntitiesInCategory(PlayerID,EntityCategories.CattlePasture);</p><p>            local maxAnimal     = #CattlePasture*5;</p><p>            SetIcon(CurrentWidgetID, {3,16})</p><p>            if _Technology == Technologies.R_Catapult then</p><p>                if BundleBuildingButtons.Local.Data.BreedCattle then</p><p>                    XGUIEng.ShowWidget("/InGame/Root/Normal/BuildingButtons",1);</p><p>                    XGUIEng.ShowWidget("/InGame/Root/Normal/BuildingButtons/BuyCatapultCart",1);</p><p>                    if curAnimal >= maxAnimal then</p><p>                        XGUIEng.DisableButton(CurrentWidgetID, 1);</p><p>                    elseif grain < BundleBuildingButtons.Local.Data.CattleCosts then</p><p>                        XGUIEng.DisableButton(CurrentWidgetID, 1);</p><p>                    elseif KnightTitle < BundleBuildingButtons.Local.Data.CattleKnightTitle then</p><p>                        XGUIEng.DisableButton(CurrentWidgetID, 1);</p><p>                    elseif cows[1] < BundleBuildingButtons.Local.Data.CattleNeeded then</p><p>                        XGUIEng.DisableButton(CurrentWidgetID, 1);</p><p>                    else</p><p>                        XGUIEng.DisableButton(CurrentWidgetID, 0);</p><p>                    end</p><p>                end</p><p>            else</p><p>                XGUIEng.ShowWidget(CurrentWidgetID,0);</p><p>            end</p><p>        elseif EntityType == Entities.B_SheepPasture then</p><p>            local SheepPasture     = GetPlayerEntities(PlayerID,Entities.B_SheepPasture);</p><p>            local sheeps        = {Logic.GetPlayerEntitiesInArea(PlayerID,Entities.A_X_Sheep01,pos.X,pos.Y,800,16)};</p><p>            table.remove(sheeps, 1);</p><p>            local sheeps2        = {Logic.GetPlayerEntitiesInArea(PlayerID,Entities.A_X_Sheep02,pos.X,pos.Y,800,16)};</p><p>            table.remove(sheeps2, 1);</p><p>            local curAnimal     = Logic.GetNumberOfPlayerEntitiesInCategory(PlayerID,EntityCategories.SheepPasture);</p><p>            local maxAnimal     = #SheepPasture*5;</p><p>            sheeps = Array_Append(sheeps,sheeps2)</p><p>            SetIcon(CurrentWidgetID, {4,1})</p><p>            if _Technology == Technologies.R_Catapult then</p><p>                if BundleBuildingButtons.Local.Data.BreedSheeps then</p><p>                    XGUIEng.ShowWidget("/InGame/Root/Normal/BuildingButtons",1);</p><p>                    XGUIEng.ShowWidget("/InGame/Root/Normal/BuildingButtons/BuyCatapultCart",1);</p><p>                    if curAnimal >= maxAnimal then</p><p>                        XGUIEng.DisableButton(CurrentWidgetID, 1);</p><p>                    elseif grain < BundleBuildingButtons.Local.Data.SheepCosts then</p><p>                        XGUIEng.DisableButton(CurrentWidgetID, 1);</p><p>                    elseif #sheeps < BundleBuildingButtons.Local.Data.SheepKnightTitle then</p><p>                        XGUIEng.DisableButton(CurrentWidgetID, 1);</p><p>                    elseif #sheeps < BundleBuildingButtons.Local.Data.SheepNeeded then</p><p>                        XGUIEng.DisableButton(CurrentWidgetID, 1);</p><p>                    else</p><p>                        XGUIEng.DisableButton(CurrentWidgetID, 0);</p><p>                    end</p><p>                end</p><p>            else</p><p>                XGUIEng.ShowWidget(CurrentWidgetID,0);</p><p>            end</p><p>        else</p><p>            XGUIEng.ShowWidget(CurrentWidgetID,0);</p><p>            return;</p><p>        end</p><p>        if Logic.IsConstructionComplete(GUI.GetSelectedEntity()) == 0 then</p><p>            XGUIEng.ShowWidget(CurrentWidgetID,0);</p><p>            return;</p><p>        end</p><p>        if EntityType ~= Entities.B_SheepPasture and EntityType ~= Entities.B_CattlePasture then</p><p>            local TechnologyState = Logic.TechnologyGetState(PlayerID, _Technology);</p><p>            if EnableRights == nil or EnableRights == false then</p><p>                XGUIEng.DisableButton(CurrentWidgetID,0);</p><p>                return</p><p>            end</p><p>            if TechnologyState == TechnologyStates.Researched then</p><p>                XGUIEng.DisableButton(CurrentWidgetID,0);</p><p>            else</p><p>                XGUIEng.DisableButton(CurrentWidgetID,1);</p><p>            end</p><p>        end</p><p>    end</p><p>-- Diese Funktion überschreibt das House Menu, sodass Single stop fehlerfrei</p><p>-- funktioniert.</p><p>-- @within Internal</p><p>-- @local</p><p>    HouseMenuStopProductionClicked_Orig_tHEA_SingleStop = HouseMenuStopProductionClicked;</p><p>    HouseMenuStopProductionClicked = function()</p><p>        HouseMenuStopProductionClicked_Orig_tHEA_SingleStop();</p><p>        local WidgetName = HouseMenu.Widget.CurrentBuilding;</p><p>        local EntityType = Entities[WidgetName];</p><p>        local PlayerID = GUI.GetPlayerID();</p><p>        local Buildings = GetPlayerEntities(PlayerID, EntityType);</p><p>        for i=1, #Buildings, 1 do</p><p>            if BundleBuildingButtons.Local.Data.StoppedBuildings[Buildings[i]] ~= HouseMenu.StopProductionBool then</p><p>                BundleBuildingButtons.Local.Data.StoppedBuildings[Buildings[i]] = HouseMenu.StopProductionBool;</p><p>                GUI.SetStoppedState(Buildings[i], HouseMenu.StopProductionBool);</p><p>            end</p><p>        end</p><p>    end</p><p>-- Ändert die Textur eines Icons im House Menu.</p><p>-- @param _Widget Icon Widget</p><p>-- @param _Icon   Icon Textur</p><p>-- @within BundleBuildingButtons</p><p>-- @local</p><p>    if type(_Icon) == "table" then</p><p>        if type(_Icon[3]) == "string" then</p><p>            local ButtonState = 1;</p><p>            if XGUIEng.IsButton(_Widget) == 1 then</p><p>                ButtonState = 7;</p><p>            end</p><p>            local u0, u1, v0, v1;</p><p>            u0 = (_Coordinates[1] - 1) * 64;</p><p>            v0 = (_Coordinates[2] - 1) * 64;</p><p>            u1 = (_Coordinates[1]) * 64;</p><p>            v1 = (_Coordinates[2]) * 64;</p><p>            XGUIEng.SetMaterialAlpha(_Widget, ButtonState, 255);</p><p>            XGUIEng.SetMaterialTexture(_Widget, ButtonState, _Icon[3].. "big.png");</p><p>            XGUIEng.SetMaterialUV(_Widget, ButtonState, u0, v0, u1, v1);</p><p>        else</p><p>            SetIcon(_Widget, _Icon);</p><p>        end</p><p>    else</p><p>        local screenSize = {GUI.GetScreenSize()};</p><p>        local Scale = 330;</p><p>        if screenSize[2] >= 800 then</p><p>            Scale = 260;</p><p>        end</p><p>        if screenSize[2] >= 1000 then</p><p>            Scale = 210;</p><p>        end</p><p>        XGUIEng.SetMaterialAlpha(_Widget, 1, 255);</p><p>        XGUIEng.SetMaterialTexture(_Widget, 1, _file);</p><p>        XGUIEng.SetMaterialUV(_Widget, 1, 0, 0, Scale, Scale);</p><p>    end</p><p>-- Setzt einen für den Tooltip des aktuellen Widget einen neuen Text.</p><p>-- @param _Title        Titel des Tooltip</p><p>-- @param _Text         Text des Tooltip</p><p>-- @param _DisabledText Textzusatz wenn inaktiv</p><p>-- @within BundleBuildingButtons</p><p>-- @local</p><p>    local TooltipContainerPath = "/InGame/Root/Normal/TooltipNormal";</p><p>    local TooltipContainer = XGUIEng.GetWidgetID(TooltipContainerPath);</p><p>    local TooltipNameWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Name");</p><p>    local TooltipDescriptionWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Text");</p><p>    local TooltipBGWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/BG");</p><p>    local TooltipFadeInContainer = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn");</p><p>    local PositionWidget = XGUIEng.GetCurrentWidgetID();</p><p>    GUI_Tooltip.ResizeBG(TooltipBGWidget, TooltipDescriptionWidget);</p><p>    local TooltipContainerSizeWidgets = {TooltipBGWidget};</p><p>    GUI_Tooltip.SetPosition(TooltipContainer, TooltipContainerSizeWidgets, PositionWidget);</p><p>    GUI_Tooltip.FadeInTooltip(TooltipFadeInContainer);</p><p>    _DisabledText = _DisabledText or "";</p><p>    local disabled = ""</p><p>    if XGUIEng.IsButtonDisabled(PositionWidget) == 1 and _DisabledText ~= "" and _Text ~= "" then</p><p>        disabled = disabled .. "{cr}{@color:255,32,32,255}" .. _DisabledText</p><p>    end</p><p>    XGUIEng.SetText(TooltipNameWidget, "{center}" .. _Title);</p><p>    XGUIEng.SetText(TooltipDescriptionWidget, _Text .. disabled);</p><p>    local Height = XGUIEng.GetTextHeight(TooltipDescriptionWidget, true);</p><p>    local W, H = XGUIEng.GetWidgetSize(TooltipDescriptionWidget);</p><p>    XGUIEng.SetWidgetSize(TooltipDescriptionWidget, W, Height);</p><p>-- Setzt den Kostentooltip des aktuellen Widgets.</p><p>-- @param _Title        Titel des Tooltip</p><p>-- @param _Text         Text des Tooltip</p><p>-- @param _DisabledText Textzusatz wenn inaktiv</p><p>-- @param _Costs        Kostentabelle</p><p>-- @param _InSettlement Kosten in Siedlung suchen</p><p>-- @within Internal</p><p>-- @local</p><p>    local TooltipContainerPath = "/InGame/Root/Normal/TooltipBuy"</p><p>    local TooltipContainer = XGUIEng.GetWidgetID(TooltipContainerPath)</p><p>    local TooltipNameWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Name")</p><p>    local TooltipDescriptionWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Text")</p><p>    local TooltipBGWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/BG")</p><p>    local TooltipFadeInContainer = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn")</p><p>    local TooltipCostsContainer = XGUIEng.GetWidgetID(TooltipContainerPath .. "/Costs")</p><p>    local PositionWidget = XGUIEng.GetCurrentWidgetID()</p><p>    GUI_Tooltip.ResizeBG(TooltipBGWidget, TooltipDescriptionWidget)</p><p>    GUI_Tooltip.SetCosts(TooltipCostsContainer, _Costs, _InSettlement)</p><p>    local TooltipContainerSizeWidgets = {TooltipContainer, TooltipCostsContainer, TooltipBGWidget}</p><p>    GUI_Tooltip.SetPosition(TooltipContainer, TooltipContainerSizeWidgets, PositionWidget, nil, true)</p><p>    GUI_Tooltip.OrderTooltip(TooltipContainerSizeWidgets, TooltipFadeInContainer, TooltipCostsContainer, PositionWidget, TooltipBGWidget)</p><p>    GUI_Tooltip.FadeInTooltip(TooltipFadeInContainer)</p><p>    _DisabledText = _DisabledText or "";</p><p>    local disabled = ""</p><p>    if XGUIEng.IsButtonDisabled(PositionWidget) == 1 and _DisabledText ~= "" and _Text ~= "" then</p><p>        disabled = disabled .. "{cr}{@color:255,32,32,255}" .. _DisabledText</p><p>    end</p><p>    XGUIEng.SetText(TooltipNameWidget, "{center}" .. _Title)</p><p>    XGUIEng.SetText(TooltipDescriptionWidget, _Text .. disabled)</p><p>    local Height = XGUIEng.GetTextHeight(TooltipDescriptionWidget, true)</p><p>    local W, H = XGUIEng.GetWidgetSize(TooltipDescriptionWidget)</p><p>    XGUIEng.SetWidgetSize(TooltipDescriptionWidget, W, Height)</p><p>-- Diese Funktion ist die Action von Single Stop.</p><p>-- @within Internal</p><p>-- @local</p><p>    local StoppedState = BundleBuildingButtons.Local.Data.StoppedBuildings[EntityID] == true;</p><p>    GUI.SetStoppedState(EntityID, not StoppedState);</p><p>    BundleBuildingButtons.Local.Data.StoppedBuildings[EntityID] = not StoppedState;</p><p>-- Diese Funktion steuert den Tooltip von Single Stop.</p><p>-- @within Internal</p><p>-- @local</p><p>    local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>    BundleBuildingButtons.Local:TextNormal(</p><p>        BundleBuildingButtons.Local.Description.SingleStop.Title[lang],</p><p>        BundleBuildingButtons.Local.Description.SingleStop.Text[lang]</p><p>    );</p><p>-- Diese Funktion ist der Update Job von Single Stop.</p><p>-- @within Internal</p><p>-- @local</p><p>    local IsOuterRimBuilding = Logic.IsEntityInCategory(_EntityID, EntityCategories.OuterRimBuilding) == 1;</p><p>    local IsCityBuilding = Logic.IsEntityInCategory(_EntityID, EntityCategories.CityBuilding) == 1;</p><p>    if IsOuterRimBuilding == false and IsCityBuilding == false then</p><p>        XGUIEng.ShowWidget(_WidgetID, 0);</p><p>    end</p><p>    if BundleBuildingButtons.Local.Data.StoppedBuildings[_EntityID] == true then</p><p>        SetIcon(_WidgetID, {4, 12});</p><p>    else</p><p>        SetIcon(_WidgetID, {4, 13});</p><p>    end</p><p>-- Diese Funktion wird aufgerufen, sobald sich die Selektion ändert.</p><p>-- Hier werden die ausgeblendeten ungenutzten Gebäudeschalter eingeblendet.</p><p>-- @param _Source Quelle der Änderung</p><p>-- @within Internal</p><p>-- @local</p><p>    local eID = GUI.GetSelectedEntity();</p><p>    local eType = Logic.GetEntityType(eID);</p><p>    XGUIEng.ShowWidget("/InGame/Root/Normal/BuildingButtons/GateAutoToggle",1);</p><p>    XGUIEng.ShowWidget("/InGame/Root/Normal/BuildingButtons/GateOpenClose",1);</p><p>    XGUIEng.ShowWidget("/InGame/Root/Normal/BuildingButtons/TrapToggle",1);</p><p>-- -------------------------------------------------------------------------- --</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundleclassicbehaviors.lua.html">
            <div class='doclink'>
                <div>BundleClassicBehaviors</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia BundleClassicBehaviors                                       # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Dieses Bundle enthält alle Behavior, die aus der QSB 3.9 PlusB bekannt sind.</p><p>-- Die Behavior sind weitesgehend unverändert und es dürfte keine Probleme mit</p><p>-- Inkompatibelität geben, wenn die QSB ausgetauscht wird.</p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Gibt das im Quest gespeicherte Resultat von Goal_InputDialog als Text zurück.</p><p>-- <b>Hinweis</b>: Es wird nur die letzte Eingabe zurückgegeben.</p><p>-- @param _QuestName [string] Name des Quest</p><p>-- @return [string] Eingabe des Spielers</p><p>-- @within Anwenderfunktionen</p><p>function API.GetInputStringFromQuest(_QuestName)</p><p>    if GUI then</p><p>        API.Fatal("API.GetInputStringFromQuest: Quests can not be checked from local script!");</p><p>        return;</p><p>    end</p><p>    local Quest = Quests[GetQuestID(_QuestName)];</p><p>    if not Quest then</p><p>        API.Fatal("API.GetInputStringFromQuest: Quest '" ..tostring(_QuestName).. "' not found!");</p><p>        return;</p><p>    end</p><p>    return BundleClassicBehaviors.Global:GetInputFromQuest(_QuestName);</p><p>-- Gibt das im Quest gespeicherte Resultat von Goal_InputDialog Als Zahl zurück.</p><p>-- <b>Hinweis</b>: Es wird nur die letzte Eingabe zurückgegeben.</p><p>-- @param _QuestName [string] Name des Quest</p><p>-- @return [number] Eingabe des Spielers</p><p>-- @within Anwenderfunktionen</p><p>function API.GetInputNumberFromQuest(_QuestName)</p><p>    return tonumber(API.GetInputStringFromQuest(_QuestName));</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Goals                                                                      --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ein Interaktives Objekt muss benutzt werden.</p><p>-- @param _ScriptName Skriptname des interaktiven Objektes</p><p>-- @within Goal</p><p>    return b_Goal_ActivateObject:new(...);</p><p>Goal_ActivateObject</p><p>    Name = "Goal_ActivateObject",</p><p>    Description = {</p><p>        en = "Goal: Activate an interactive object",</p><p>        de = "Ziel: Aktiviere ein interaktives Objekt",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Object name", de = "Skriptname" },</p><p>    },</p><p>    return {Objective.Object, { self.ScriptName } }</p><p>   if _Index == 0 then</p><p>        self.ScriptName = _Parameter</p><p>   end</p><p>    return "Quest_Object_Activate"</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Einem Spieler müssen Rohstoffe oder Waren gesendet werden.</p><p>-- In der Regel wird zum Auftraggeber gesendet. Es ist aber möglich auch zu</p><p>-- einem anderen Zielspieler schicken zu lassen. Wird ein Wagen gefangen</p><p>-- genommen, dann muss erneut geschickt werden. Optional kann dem Spieler</p><p>-- auch erlaubt werden, den Karren zurückzuerobern.</p><p>-- @param _GoodType      Typ der Ware</p><p>-- @param _GoodAmount    Menga der Ware</p><p>-- @param _OtherTarget   Anderes Ziel als Auftraggeber</p><p>-- @param _IgnoreCapture Wagen kann zurückerobert werden</p><p>-- @within Goal</p><p>    return b_Goal_Deliver:new(...)</p><p>Goal_Deliver</p><p>    Name = "Goal_Deliver",</p><p>    Description = {</p><p>        en = "Goal: Deliver goods to quest giver or to another player.",</p><p>        de = "Ziel: Liefere Waren zum Auftraggeber oder zu einem anderen Spieler.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Custom, en = "Type of good", de = "Ressourcentyp" },</p><p>        { ParameterType.Number, en = "Amount of good", de = "Ressourcenmenge" },</p><p>        { ParameterType.Custom, en = "To different player", de = "Anderer Empfänger" },</p><p>        { ParameterType.Custom, en = "Ignore capture", de = "Abfangen ignorieren" },</p><p>    },</p><p>    local GoodType = Logic.GetGoodTypeID(self.GoodTypeName)</p><p>    return { Objective.Deliver, GoodType, self.GoodAmount, self.OverrideTarget, self.IgnoreCapture }</p><p>    if (_Index == 0) then</p><p>        self.GoodTypeName = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.GoodAmount = _Parameter * 1</p><p>    elseif (_Index == 2) then</p><p>        self.OverrideTarget = tonumber(_Parameter)</p><p>    elseif (_Index == 3) then</p><p>        self.IgnoreCapture = AcceptAlternativeBoolean(_Parameter)</p><p>    end</p><p>    local Data = {}</p><p>    if _Index == 0 then</p><p>        for k, v in pairs( Goods ) do</p><p>            if string.find( k, "^G_" ) then</p><p>                table.insert( Data, k )</p><p>            end</p><p>        end</p><p>        table.sort( Data )</p><p>    elseif _Index == 2 then</p><p>        table.insert( Data, "-" )</p><p>        for i = 1, 8 do</p><p>            table.insert( Data, i )</p><p>        end</p><p>    elseif _Index == 3 then</p><p>        table.insert( Data, "true" )</p><p>        table.insert( Data, "false" )</p><p>    else</p><p>        assert( false )</p><p>    end</p><p>    return Data</p><p>    local GoodType = Logic.GetGoodTypeID(self.GoodTypeName)</p><p>    local GC = Logic.GetGoodCategoryForGoodType( GoodType )</p><p>    local tMapping = {</p><p>        [GoodCategories.GC_Clothes] = "Quest_Deliver_GC_Clothes",</p><p>        [GoodCategories.GC_Entertainment] = "Quest_Deliver_GC_Entertainment",</p><p>        [GoodCategories.GC_Food] = "Quest_Deliver_GC_Food",</p><p>        [GoodCategories.GC_Gold] = "Quest_Deliver_GC_Gold",</p><p>        [GoodCategories.GC_Hygiene] = "Quest_Deliver_GC_Hygiene",</p><p>        [GoodCategories.GC_Medicine] = "Quest_Deliver_GC_Medicine",</p><p>        [GoodCategories.GC_Water] = "Quest_Deliver_GC_Water",</p><p>        [GoodCategories.GC_Weapon] = "Quest_Deliver_GC_Weapon",</p><p>        [GoodCategories.GC_Resource] = "Quest_Deliver_Resources",</p><p>    }</p><p>    if GC then</p><p>        local Key = tMapping[GC]</p><p>        if Key then</p><p>            return Key</p><p>        end</p><p>    end</p><p>    return "Quest_Deliver_Goods"</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Es muss ein bestimmter Diplomatiestatus zu einer anderen Datei erreicht</p><p>-- werden. Der Status kann eine Verbesserung oder eine Verschlechterung zum</p><p>-- aktuellen Status sein.</p><p>-- @param _PlayerID Partei, die Entdeckt werden muss</p><p>-- @param _State    Diplomatiestatus</p><p>-- @within Goal</p><p>    return b_Goal_Diplomacy:new(...);</p><p>Goal_Diplomacy</p><p>    Name = "Goal_Diplomacy",</p><p>    Description = {</p><p>        en = "Goal: A diplomatic state must b reached. Can be lower than current state or higher.",</p><p>        de = "Ziel: Die Beziehungen zu einem Spieler müssen entweder verbessert oder verschlechtert werden.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.PlayerID, en = "Party", de = "Partei" },</p><p>        { ParameterType.Custom,   en = "Diplomacy state", de = "Diplomatische Beziehung" },</p><p>        { ParameterType.Custom,   en = "Relation", de = "Relation" },</p><p>    },</p><p>    DiploNameMap = {</p><p>        [DiplomacyStates.Allied]             = {de = "Verbündeter",    en = "Allied"},</p><p>        [DiplomacyStates.TradeContact]       = {de = "Handelspartner", en = "Trade Contact"},</p><p>        [DiplomacyStates.EstablishedContact] = {de = "Bekannt",        en = "Established Contact"},</p><p>        [DiplomacyStates.Undecided]          = {de = "Unbekannt",      en = "Undecided"},</p><p>        [DiplomacyStates.Enemy]              = {de = "Feind",          en = "Enemy"},</p><p>    },</p><p>    TextPattern = {</p><p>        de = "DIPLOMATIESTATUS ERREICHEN {cr}{cr}Status: s{cr}Zur Partei: s",</p><p>        en = "DIPLOMATIC STATE {cr}{cr}State: s{cr}To player: s",</p><p>    },</p><p>    return { Objective.Custom2, {self, self.CustomFunction}};</p><p>    local PlayerName = GetPlayerName(self.PlayerID) or "";</p><p>    local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>    local Text = string.format(self.TextPattern[lang], self.DiploNameMap[self.DiplState][lang], PlayerName);</p><p>    Core:ChangeCustomQuestCaptionText(Text, _Quest);</p><p>    self:ChangeCaption(_Quest);</p><p>    if self.BeSmallerThan then</p><p>        if GetDiplomacyState(_Quest.ReceivingPlayer, self.PlayerID) < self.DiplState then</p><p>            return true;</p><p>        end</p><p>    else</p><p>        if GetDiplomacyState(_Quest.ReceivingPlayer, self.PlayerID) >= self.DiplState then</p><p>            return true;</p><p>        end</p><p>    end</p><p>    if (_Index == 0) then</p><p>        self.PlayerID = _Parameter * 1</p><p>    elseif (_Index == 1) then</p><p>        self.DiplState = DiplomacyStates[_Parameter];</p><p>    elseif (_Index == 2) then</p><p>        self.BeSmallerThan = _Parameter == "<";</p><p>    end</p><p>    return {6, 3};</p><p>    if _Index == 1 then</p><p>        return {"Allied", "TradeContact", "EstablishedContact", "Undecided", "Enemy"};</p><p>    elseif _Index == 2 then</p><p>        return {">=", "<"};</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Das Heimatterritorium des Spielers muss entdeckt werden.</p><p>-- Das Heimatterritorium ist immer das, wo sich Burg oder Lagerhaus der</p><p>-- zu entdeckenden Partei befinden.</p><p>-- @param _PlayerID ID der zu entdeckenden Partei</p><p>-- @within Goal</p><p>    return b_Goal_DiscoverPlayer:new(...);</p><p>Goal_DiscoverPlayer</p><p>    Name = "Goal_DiscoverPlayer",</p><p>    Description = {</p><p>        en = "Goal: Discover the home territory of another player.",</p><p>        de = "Ziel: Entdecke das Heimatterritorium eines Spielers.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.PlayerID, en = "Player", de = "Spieler" },</p><p>    },</p><p>    return {Objective.Discover, 2, { self.PlayerID } }</p><p>    if (_Index == 0) then</p><p>        self.PlayerID = _Parameter * 1</p><p>    end</p><p>    local tMapping = {</p><p>        [PlayerCategories.BanditsCamp] = "Quest_Discover",</p><p>        [PlayerCategories.City] = "Quest_Discover_City",</p><p>        [PlayerCategories.Cloister] = "Quest_Discover_Cloister",</p><p>        [PlayerCategories.Harbour] = "Quest_Discover",</p><p>        [PlayerCategories.Village] = "Quest_Discover_Village",</p><p>    }</p><p>    local PlayerCategory = GetPlayerCategoryType(self.PlayerID)</p><p>    if PlayerCategory then</p><p>        local Key = tMapping[PlayerCategory]</p><p>        if Key then</p><p>            return Key</p><p>        end</p><p>    end</p><p>    return "Quest_Discover"</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ein Territorium muss erstmalig vom Auftragnehmer betreten werden.</p><p>-- @param _Territory Name oder ID des Territorium</p><p>-- @within Goal</p><p>    return b_Goal_DiscoverTerritory:new(...);</p><p>Goal_DiscoverTerritory</p><p>    Name = "Goal_DiscoverTerritory",</p><p>    Description = {</p><p>        en = "Goal: Discover a territory",</p><p>        de = "Ziel: Entdecke ein Territorium",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.TerritoryName, en = "Territory", de = "Territorium" },</p><p>    },</p><p>    return { Objective.Discover, 1, { self.TerritoryID  } }</p><p>    if (_Index == 0) then</p><p>        self.TerritoryID = tonumber(_Parameter)</p><p>        if not self.TerritoryID then</p><p>            self.TerritoryID = GetTerritoryIDByName(_Parameter)</p><p>        end</p><p>        assert( self.TerritoryID > 0 )</p><p>    end</p><p>    return "Quest_Discover_Territory"</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Eine andere Partei muss besiegt werden.</p><p>-- Die Partei gilt als besiegt, wenn ein Hauptgebäude (Burg, Kirche, Lager)</p><p>-- zerstört wurde. <b>Achtung:</b> Funktioniert nicht bei Banditen!</p><p>-- @param _PlayerID ID des Spielers</p><p>-- @within Goal</p><p>    return b_Goal_DestroyPlayer:new(...);</p><p>Goal_DestroyPlayer</p><p>    Name = "Goal_DestroyPlayer",</p><p>    Description = {</p><p>        en = "Goal: Destroy a player (destroy a main building)",</p><p>        de = "Ziel: Zerstöre einen Spieler (ein Hauptgebäude muss zerstört werden).",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.PlayerID, en = "Player", de = "Spieler" },</p><p>    },</p><p>    assert( self.PlayerID <= 8 and self.PlayerID >= 1, "Error in " .. self.Name .. ": GetGoalTable: PlayerID is invalid")</p><p>    return { Objective.DestroyPlayers, self.PlayerID }</p><p>    if (_Index == 0) then</p><p>        self.PlayerID = _Parameter * 1</p><p>    end</p><p>    local tMapping = {</p><p>        [PlayerCategories.BanditsCamp] = "Quest_DestroyPlayers_Bandits",</p><p>        [PlayerCategories.City] = "Quest_DestroyPlayers_City",</p><p>        [PlayerCategories.Cloister] = "Quest_DestroyPlayers_Cloister",</p><p>        [PlayerCategories.Harbour] = "Quest_DestroyEntities_Building",</p><p>        [PlayerCategories.Village] = "Quest_DestroyPlayers_Village",</p><p>    }</p><p>    local PlayerCategory = GetPlayerCategoryType(self.PlayerID)</p><p>    if PlayerCategory then</p><p>        local Key = tMapping[PlayerCategory]</p><p>        if Key then</p><p>            return Key</p><p>        end</p><p>    end</p><p>    return "Quest_DestroyEntities_Building"</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Es sollen Informationen aus der Burg gestohlen werden.</p><p>-- Der Spieler muss einen Dieb entsenden um Informationen aus der Burg zu</p><p>-- stehlen. <b>Achtung:</b> Das ist nur bei Feinden möglich!</p><p>-- @param _PlayerID ID der Partei</p><p>-- @within Goal</p><p>    return b_Goal_StealInformation:new(...);</p><p>Goal_StealInformation</p><p>    Name = "Goal_StealInformation",</p><p>    Description = {</p><p>        en = "Goal: Steal information from another players castle",</p><p>        de = "Ziel: Stehle Informationen aus der Burg eines Spielers",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.PlayerID, en = "Player", de = "Spieler" },</p><p>    },</p><p>    local Target = Logic.GetHeadquarters(self.PlayerID)</p><p>    if not Target or Target == 0 then</p><p>        Target = Logic.GetStoreHouse(self.PlayerID)</p><p>    end</p><p>    assert( Target and Target ~= 0 )</p><p>    return {Objective.Steal, 1, { Target } }</p><p>    if (_Index == 0) then</p><p>        self.PlayerID = _Parameter * 1</p><p>    end</p><p>    return "Quest_Steal_Info"</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Alle Einheiten des Spielers müssen zerstört werden.</p><p>-- @param _PlayerID ID des Spielers</p><p>-- @within Goal</p><p>    return b_Goal_DestroyAllPlayerUnits:new(...);</p><p>Goal_DestroyAllPlayerUnits</p><p>    Name = "Goal_DestroyAllPlayerUnits",</p><p>    Description = {</p><p>        en = "Goal: Destroy all units owned by player (be careful with script entities)",</p><p>        de = "Ziel: Zerstöre alle Einheiten eines Spielers (vorsicht mit Script-Entities)",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.PlayerID, en = "Player", de = "Spieler" },</p><p>    },</p><p>    return { Objective.DestroyAllPlayerUnits, self.PlayerID }</p><p>    if (_Index == 0) then</p><p>        self.PlayerID = _Parameter * 1</p><p>    end</p><p>    local tMapping = {</p><p>        [PlayerCategories.BanditsCamp] = "Quest_DestroyPlayers_Bandits",</p><p>        [PlayerCategories.City] = "Quest_DestroyPlayers_City",</p><p>        [PlayerCategories.Cloister] = "Quest_DestroyPlayers_Cloister",</p><p>        [PlayerCategories.Harbour] = "Quest_DestroyEntities_Building",</p><p>        [PlayerCategories.Village] = "Quest_DestroyPlayers_Village",</p><p>    }</p><p>    local PlayerCategory = GetPlayerCategoryType(self.PlayerID)</p><p>    if PlayerCategory then</p><p>        local Key = tMapping[PlayerCategory]</p><p>        if Key then</p><p>            return Key</p><p>        end</p><p>    end</p><p>    return "Quest_DestroyEntities"</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ein benanntes Entity muss zerstört werden.</p><p>-- @param _ScriptName Skriptname des Ziels</p><p>-- @within Goal</p><p>    return b_Goal_DestroyScriptEntity:new(...);</p><p>Goal_DestroyScriptEntity</p><p>    Name = "Goal_DestroyScriptEntity",</p><p>    Description = {</p><p>        en = "Goal: Destroy an entity",</p><p>        de = "Ziel: Zerstöre eine Entität",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Script name", de = "Skriptname" },</p><p>    },</p><p>    return {Objective.DestroyEntities, 1, { self.ScriptName } }</p><p>    if (_Index == 0) then</p><p>        self.ScriptName = _Parameter</p><p>    end</p><p>    if Logic.IsEntityAlive(self.ScriptName) then</p><p>        local ID = GetID(self.ScriptName)</p><p>        if ID and ID ~= 0 then</p><p>            ID = Logic.GetEntityType( ID )</p><p>            if ID and ID ~= 0 then</p><p>                if Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableBuilding ) == 1 then</p><p>                    return "Quest_DestroyEntities_Building"</p><p>                elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableAnimal ) == 1 then</p><p>                    return "Quest_DestroyEntities_Predators"</p><p>                elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.Hero ) == 1 then</p><p>                    return "Quest_Destroy_Leader"</p><p>                elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.Military ) == 1</p><p>                    or Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableSettler ) == 1</p><p>                    or Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableMerchant ) == 1  then</p><p>                    return "Quest_DestroyEntities_Unit"</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>    return "Quest_DestroyEntities"</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Eine Menge an Entities eines Typs müssen zerstört werden.</p><p>-- Wenn Raubtiere zerstört werden sollen, muss Spieler 0 als Besitzer</p><p>-- angegeben werden.</p><p>-- @param _EntityType Typ des Entity</p><p>-- @param _Amount     Menge an Entities des Typs</p><p>-- @param _PlayerID   Besitzer des Entity</p><p>-- @within Goal</p><p>    return b_Goal_DestroyType:new(...);</p><p>Goal_DestroyType</p><p>    Name = "Goal_DestroyType",</p><p>    Description = {</p><p>        en = "Goal: Destroy entity types",</p><p>        de = "Ziel: Zerstöre Entitätstypen",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Custom, en = "Type name", de = "Typbezeichnung" },</p><p>        { ParameterType.Number, en = "Amount", de = "Anzahl" },</p><p>        { ParameterType.Custom, en = "Player", de = "Spieler" },</p><p>    },</p><p>    return {Objective.DestroyEntities, 2, Entities[self.EntityName], self.Amount, self.PlayerID }</p><p>    if (_Index == 0) then</p><p>        self.EntityName = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.Amount = _Parameter * 1</p><p>        self.DestroyTypeAmount = self.Amount</p><p>    elseif (_Index == 2) then</p><p>        self.PlayerID = _Parameter * 1</p><p>    end</p><p>    local Data = {}</p><p>    if _Index == 0 then</p><p>        for k, v in pairs( Entities ) do</p><p>            if string.find( k, "^[ABU]_" ) then</p><p>                table.insert( Data, k )</p><p>            end</p><p>        end</p><p>        table.sort( Data )</p><p>    elseif _Index == 2 then</p><p>        for i = 0, 8 do</p><p>            table.insert( Data, i )</p><p>        end</p><p>    else</p><p>        assert( false )</p><p>    end</p><p>    return Data</p><p>    local ID = self.EntityName</p><p>    if Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableBuilding ) == 1 then</p><p>        return "Quest_DestroyEntities_Building"</p><p>    elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableAnimal ) == 1 then</p><p>        return "Quest_DestroyEntities_Predators"</p><p>    elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.Hero ) == 1 then</p><p>        return "Quest_Destroy_Leader"</p><p>    elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.Military ) == 1</p><p>        or Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableSettler ) == 1</p><p>        or Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableMerchant ) == 1  then</p><p>        return "Quest_DestroyEntities_Unit"</p><p>    end</p><p>    return "Quest_DestroyEntities"</p><p>-- -------------------------------------------------------------------------- --</p><p>    GameCallback_EntityKilled_Orig_QSB_Goal_DestroySoldiers = GameCallback_EntityKilled;</p><p>    GameCallback_EntityKilled = function(_AttackedEntityID, _AttackedPlayerID, _AttackingEntityID, _AttackingPlayerID, _AttackedEntityType, _AttackingEntityType)</p><p>        if _AttackedPlayerID ~= 0 and _AttackingPlayerID ~= 0 then</p><p>            QSB.DestroyedSoldiers[_AttackingPlayerID] = QSB.DestroyedSoldiers[_AttackingPlayerID] or {}</p><p>            QSB.DestroyedSoldiers[_AttackingPlayerID][_AttackedPlayerID] = QSB.DestroyedSoldiers[_AttackingPlayerID][_AttackedPlayerID] or 0</p><p>            if Logic.IsEntityTypeInCategory( _AttackedEntityType, EntityCategories.Military ) == 1</p><p>            and Logic.IsEntityInCategory( _AttackedEntityID, EntityCategories.HeavyWeapon) == 0 then</p><p>                QSB.DestroyedSoldiers[_AttackingPlayerID][_AttackedPlayerID] = QSB.DestroyedSoldiers[_AttackingPlayerID][_AttackedPlayerID] +1</p><p>            end</p><p>        end</p><p>        GameCallback_EntityKilled_Orig_QSB_Goal_DestroySoldiers(_AttackedEntityID, _AttackedPlayerID, _AttackingEntityID, _AttackingPlayerID, _AttackedEntityType, _AttackingEntityType)</p><p>    end</p><p>-- Spieler A muss Soldaten von Spieler B zerstören.</p><p>-- @param _PlayerA Angreifende Partei</p><p>-- @param _PlayerB Zielpartei</p><p>-- @param _Amount Menga an Soldaten</p><p>-- @within Goal</p><p>    return b_Goal_DestroySoldiers:new(...);</p><p>Goal_DestroySoldiers</p><p>    Name = "Goal_DestroySoldiers",</p><p>    Description = {</p><p>        en = "Goal: Destroy a given amount of enemy soldiers",</p><p>        de = "Ziel: Zerstöre eine Anzahl gegnerischer Soldaten",</p><p>                },</p><p>    Parameter = {</p><p>        {ParameterType.PlayerID, en = "Attacking Player", de = "Angreifer", },</p><p>        {ParameterType.PlayerID, en = "Defending Player", de = "Verteidiger", },</p><p>        {ParameterType.Number, en = "Amount", de = "Anzahl", },</p><p>    },</p><p>    return {Objective.Custom2, {self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.AttackingPlayer = _Parameter * 1</p><p>    elseif (_Index == 1) then</p><p>        self.AttackedPlayer = _Parameter * 1</p><p>    elseif (_Index == 2) then</p><p>        self.KillsNeeded = _Parameter * 1</p><p>    end</p><p>    if not _Quest.QuestDescription or _Quest.QuestDescription == "" then</p><p>        local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en"</p><p>        local caption = (lang == "de" and "SOLDATEN ZERSTÖREN {cr}{cr}von der Partei: ") or</p><p>                         "DESTROY SOLDIERS {cr}{cr}from faction: "</p><p>        local amount  = (lang == "de" and "Anzahl: ") or "Amount: "</p><p>        local party = GetPlayerName(self.AttackedPlayer) or "";</p><p>        local text = "{center}" .. caption .. party .. "{cr}{cr}" .. amount .. " "..self.KillsNeeded;</p><p>        Core:ChangeCustomQuestCaptionText(text, _Quest);</p><p>    end</p><p>    local currentKills = 0;</p><p>    if QSB.DestroyedSoldiers[self.AttackingPlayer] and QSB.DestroyedSoldiers[self.AttackingPlayer][self.AttackedPlayer] then</p><p>        currentKills = QSB.DestroyedSoldiers[self.AttackingPlayer][self.AttackedPlayer]</p><p>    end</p><p>    self.SaveAmount = self.SaveAmount or currentKills</p><p>    return self.KillsNeeded <= currentKills - self.SaveAmount or nil</p><p>    if Logic.GetStoreHouse(self.AttackingPlayer) == 0 then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": Player " .. self.AttackinPlayer .. " is dead :-(")</p><p>        return true</p><p>    elseif Logic.GetStoreHouse(self.AttackedPlayer) == 0 then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": Player " .. self.AttackedPlayer .. " is dead :-(")</p><p>        return true</p><p>    elseif self.KillsNeeded < 0 then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": Amount negative")</p><p>        return true</p><p>    end</p><p>    return {7,12}</p><p>    self.SaveAmount = nil</p><p>-- Eine Entfernung zwischen zwei Entities muss erreicht werden.</p><p>-- Je nach angegebener Relation muss die Entfernung unter- oder überschritten</p><p>-- werden um den Quest zu gewinnen.</p><p>-- @param _ScriptName1  Erstes Entity</p><p>-- @param _ScriptName2  Zweites Entity</p><p>-- @param _Relation     Relation</p><p>-- @param _Distance     Entfernung</p><p>-- @within Goal</p><p>    return b_Goal_EntityDistance:new(...);</p><p>Goal_EntityDistance</p><p>    Name = "Goal_EntityDistance",</p><p>    Description = {</p><p>        en = "Goal: Distance between two entities",</p><p>        de = "Ziel: Zwei Entities sollen zueinander eine Entfernung über- oder unterschreiten.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Entity 1", de = "Entity 1" },</p><p>        { ParameterType.ScriptName, en = "Entity 2", de = "Entity 2" },</p><p>        { ParameterType.Custom, en = "Relation", de = "Relation" },</p><p>        { ParameterType.Number, en = "Distance", de = "Entfernung" },</p><p>    },</p><p>    return { Objective.Custom2, {self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.Entity1 = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.Entity2 = _Parameter</p><p>    elseif (_Index == 2) then</p><p>        self.bRelSmallerThan = _Parameter == "<"</p><p>    elseif (_Index == 3) then</p><p>        self.Distance = _Parameter * 1</p><p>    end</p><p>    if Logic.IsEntityDestroyed( self.Entity1 ) or Logic.IsEntityDestroyed( self.Entity2 ) then</p><p>        return false</p><p>    end</p><p>    local ID1 = GetID( self.Entity1 )</p><p>    local ID2 = GetID( self.Entity2 )</p><p>    local InRange = Logic.CheckEntitiesDistance( ID1, ID2, self.Distance )</p><p>    if ( self.bRelSmallerThan and InRange ) or ( not self.bRelSmallerThan and not InRange ) then</p><p>        return true</p><p>    end</p><p>    local Data = {}</p><p>    if _Index == 2 then</p><p>        table.insert( Data, ">" )</p><p>        table.insert( Data, "<" )</p><p>    else</p><p>        assert( false )</p><p>    end</p><p>    return Data</p><p>    if not IsExisting(self.Entity1) or not IsExisting(self.Entity2) then</p><p>        dbg("".._Quest.Identifier.." "..self.Name..": At least 1 of the entities for distance check don't exist!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der Primary Knight des angegebenen Spielers muss sich dem Ziel nähern.</p><p>-- @param _PlayerID   PlayerID des Helden</p><p>-- @param _ScriptName Skriptname des Ziels</p><p>-- @within Goal</p><p>    return b_Goal_KnightDistance:new(...);</p><p>Goal_KnightDistance</p><p>    Name = "Goal_KnightDistance",</p><p>    Description = {</p><p>        en = "Goal: Bring the knight close to a given entity",</p><p>        de = "Ziel: Bringe den Ritter nah an eine bestimmte Entität",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.PlayerID,     en = "Player", de = "Spieler" },</p><p>        { ParameterType.ScriptName, en = "Target", de = "Ziel" },</p><p>    },</p><p>    return {Objective.Distance, Logic.GetKnightID(self.PlayerID), self.Target, 2500, true}</p><p>    if (_Index == 0) then</p><p>        self.PlayerID = _Parameter * 1</p><p>    elseif (_Index == 1) then</p><p>        self.Target = _Parameter</p><p>    end</p><p>-- Eine bestimmte Anzahl an Einheiten einer Kategorie muss sich auf dem</p><p>-- Territorium befinden.</p><p>-- Die gegenebe Anzahl kann entweder als Mindestwert oder als Maximalwert</p><p>-- gesucht werden.</p><p>-- @param _Territory  TerritoryID oder TerritoryName</p><p>-- @param _PlayerID   PlayerID der Einheiten</p><p>-- @param _Category   Kategorie der Einheiten</p><p>-- @param _Relation   Mengenrelation (< oder >=)</p><p>-- @param _Amount     Menge an Einheiten</p><p>-- @within Goal</p><p>    return b_Goal_UnitsOnTerritory:new(...);</p><p>Goal_UnitsOnTerritory</p><p>    Name = "Goal_UnitsOnTerritory",</p><p>    Description = {</p><p>        en = "Goal: Place a certain amount of units on a territory",</p><p>        de = "Ziel: Platziere eine bestimmte Anzahl Einheiten auf einem Gebiet",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.TerritoryNameWithUnknown, en = "Territory", de = "Territorium" },</p><p>        { ParameterType.Custom,  en = "Player", de = "Spieler" },</p><p>        { ParameterType.Custom,  en = "Category", de = "Kategorie" },</p><p>        { ParameterType.Custom,  en = "Relation", de = "Relation" },</p><p>        { ParameterType.Number,  en = "Number of units", de = "Anzahl Einheiten" },</p><p>    },</p><p>    return { Objective.Custom2, {self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.TerritoryID = tonumber(_Parameter)</p><p>        if self.TerritoryID == nil then</p><p>            self.TerritoryID = GetTerritoryIDByName(_Parameter)</p><p>        end</p><p>    elseif (_Index == 1) then</p><p>        self.PlayerID = tonumber(_Parameter) * 1</p><p>    elseif (_Index == 2) then</p><p>        self.Category = _Parameter</p><p>    elseif (_Index == 3) then</p><p>        self.bRelSmallerThan = (tostring(_Parameter) == "true" or tostring(_Parameter) == "<")</p><p>    elseif (_Index == 4) then</p><p>        self.NumberOfUnits = _Parameter * 1</p><p>    end</p><p>    local Units = GetEntitiesOfCategoryInTerritory(self.PlayerID, EntityCategories[self.Category], self.TerritoryID);</p><p>    if self.bRelSmallerThan == false and #Units >= self.NumberOfUnits then</p><p>        return true;</p><p>    elseif self.bRelSmallerThan == true and #Units < self.NumberOfUnits then</p><p>        return true;</p><p>    end</p><p>    local Data = {}</p><p>    if _Index == 1 then</p><p>        table.insert( Data, -1 )</p><p>        for i = 1, 8 do</p><p>            table.insert( Data, i )</p><p>        end</p><p>    elseif _Index == 2 then</p><p>        for k, v in pairs( EntityCategories ) do</p><p>            if not string.find( k, "^G_" ) and k ~= "SheepPasture" then</p><p>                table.insert( Data, k )</p><p>            end</p><p>        end</p><p>        table.sort( Data );</p><p>    elseif _Index == 3 then</p><p>        table.insert( Data, ">=" )</p><p>        table.insert( Data, "<" )</p><p>    else</p><p>        assert( false )</p><p>    end</p><p>    return Data</p><p>    local territories = {Logic.GetTerritories()}</p><p>    if tonumber(self.TerritoryID) == nil or self.TerritoryID < 0 or not Inside(self.TerritoryID,territories) then</p><p>        dbg("".._Quest.Identifier.." "..self.Name..": got an invalid territoryID!");</p><p>        return true;</p><p>    elseif tonumber(self.PlayerID) == nil or self.PlayerID < 0 or self.PlayerID > 8 then</p><p>        dbg("".._Quest.Identifier.." "..self.Name..": got an invalid playerID!");</p><p>        return true;</p><p>    elseif not EntityCategories[self.Category] then</p><p>        dbg("".._Quest.Identifier.." "..self.Name..": got an invalid entity category!");</p><p>        return true;</p><p>    elseif tonumber(self.NumberOfUnits) == nil or self.NumberOfUnits < 0 then</p><p>        dbg("".._Quest.Identifier.." "..self.Name..": amount is negative or nil!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der angegebene Spieler muss einen Buff aktivieren.</p><p>-- <u>Buffs</u></p><p>-- <li>Buff_Spice: Salz</li></p><p>-- <li>Buff_Colour: Farben</li></p><p>-- <li>Buff_Entertainers: Entertainer anheuern</li></p><p>-- <li>Buff_FoodDiversity: Vielfältige Nahrung</li></p><p>-- <li>Buff_ClothesDiversity: Vielfältige Kleidung</li></p><p>-- <li>Buff_HygieneDiversity: Vielfältige Hygiene</li></p><p>-- <li>Buff_EntertainmentDiversity: Vielfältige Unterhaltung</li></p><p>-- <li>Buff_Sermon: Predigt halten</li></p><p>-- <li>Buff_Festival: Fest veranstalten</li></p><p>-- <li>Buff_ExtraPayment: Bonussold auszahlen</li></p><p>-- <li>Buff_HighTaxes: Hohe Steuern verlangen</li></p><p>-- <li>Buff_NoPayment: Sold streichen</li></p><p>-- <li>Buff_NoTaxes: Keine Steuern verlangen</li></p><p>-- <br/></p><p>-- <u>RdO Buffs</u></p><p>-- <li>Buff_Gems: Edelsteine</li></p><p>-- <li>Buff_MusicalInstrument: Musikinstrumente</li></p><p>-- <li>Buff_Olibanum: Weihrauch</li></p><p>-- @param _PlayerID Spieler, der den Buff aktivieren muss</p><p>-- @param _Buff     Buff, der aktiviert werden soll</p><p>-- @within Goal</p><p>    return b_Goal_ActivateBuff:new(...);</p><p>Goal_ActivateBuff</p><p>    Name = "Goal_ActivateBuff",</p><p>    Description = {</p><p>        en = "Goal: Activate a buff",</p><p>        de = "Ziel: Aktiviere einen Buff",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.PlayerID, en = "Player", de = "Spieler" },</p><p>        { ParameterType.Custom, en = "Buff", de = "Buff" },</p><p>    },</p><p>    return { Objective.Custom2, {self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.PlayerID = _Parameter * 1</p><p>    elseif (_Index == 1) then</p><p>        self.BuffName = _Parameter</p><p>        self.Buff = Buffs[_Parameter]</p><p>    end</p><p>   if not _Quest.QuestDescription or _Quest.QuestDescription == "" then</p><p>        local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en"</p><p>        local caption = (lang == "de" and "BONUS AKTIVIEREN{cr}{cr}") or "ACTIVATE BUFF{cr}{cr}"</p><p>        local tMapping = {</p><p>            ["Buff_Spice"]                        = {de = "Salz", en = "Salt"},</p><p>            ["Buff_Colour"]                        = {de = "Farben", en = "Color"},</p><p>            ["Buff_Entertainers"]                = {de = "Entertainer", en = "Entertainer"},</p><p>            ["Buff_FoodDiversity"]                = {de = "Vielfältige Nahrung", en = "Food diversity"},</p><p>            ["Buff_ClothesDiversity"]            = {de = "Vielfältige Kleidung", en = "Clothes diversity"},</p><p>            ["Buff_HygieneDiversity"]            = {de = "Vielfältige Reinigung", en = "Hygiene diversity"},</p><p>            ["Buff_EntertainmentDiversity"]        = {de = "Vielfältige Unterhaltung", en = "Entertainment diversity"},</p><p>            ["Buff_Sermon"]                        = {de = "Predigt", en = "Sermon"},</p><p>            ["Buff_Festival"]                    = {de = "Fest", en = "Festival"},</p><p>            ["Buff_ExtraPayment"]                = {de = "Sonderzahlung", en = "Extra payment"},</p><p>            ["Buff_HighTaxes"]                    = {de = "Hohe Steuern", en = "High taxes"},</p><p>            ["Buff_NoPayment"]                    = {de = "Kein Sold", en = "No payment"},</p><p>            ["Buff_NoTaxes"]                    = {de = "Keine Steuern", en = "No taxes"},</p><p>        }</p><p>        if g_GameExtraNo >= 1 then</p><p>            tMapping["Buff_Gems"]                = {de = "Edelsteine", en = "Gems"}</p><p>            tMapping["Buff_MusicalInstrument"]  = {de = "Musikinstrumente", en = "Musical instruments"}</p><p>            tMapping["Buff_Olibanum"]            = {de = "Weihrauch", en = "Olibanum"}</p><p>        end</p><p>        local text = "{center}" .. caption .. tMapping[self.BuffName][lang]</p><p>        Core:ChangeCustomQuestCaptionText(text, _Quest)</p><p>    end</p><p>    local Buff = Logic.GetBuff( self.PlayerID, self.Buff )</p><p>    if Buff and Buff ~= 0 then</p><p>        return true</p><p>    end</p><p>    local Data = {}</p><p>    if _Index == 1 then</p><p>        Data = {</p><p>            "Buff_Spice",</p><p>            "Buff_Colour",</p><p>            "Buff_Entertainers",</p><p>            "Buff_FoodDiversity",</p><p>            "Buff_ClothesDiversity",</p><p>            "Buff_HygieneDiversity",</p><p>            "Buff_EntertainmentDiversity",</p><p>            "Buff_Sermon",</p><p>            "Buff_Festival",</p><p>            "Buff_ExtraPayment",</p><p>            "Buff_HighTaxes",</p><p>            "Buff_NoPayment",</p><p>            "Buff_NoTaxes"</p><p>        }</p><p>        if g_GameExtraNo >= 1 then</p><p>            table.insert(Data, "Buff_Gems")</p><p>            table.insert(Data, "Buff_MusicalInstrument")</p><p>            table.insert(Data, "Buff_Olibanum")</p><p>        end</p><p>        table.sort( Data )</p><p>    else</p><p>        assert( false )</p><p>    end</p><p>    return Data</p><p>    local tMapping = {</p><p>        [Buffs.Buff_Spice] = "Goods.G_Salt",</p><p>        [Buffs.Buff_Colour] = "Goods.G_Dye",</p><p>        [Buffs.Buff_Entertainers] = "Entities.U_Entertainer_NA_FireEater", --{5, 12},</p><p>        [Buffs.Buff_FoodDiversity] = "Needs.Nutrition", --{1, 1},</p><p>        [Buffs.Buff_ClothesDiversity] = "Needs.Clothes", --{1, 2},</p><p>        [Buffs.Buff_HygieneDiversity] = "Needs.Hygiene", --{16, 1},</p><p>        [Buffs.Buff_EntertainmentDiversity] = "Needs.Entertainment", --{1, 4},</p><p>        [Buffs.Buff_Sermon] = "Technologies.R_Sermon", --{4, 14},</p><p>        [Buffs.Buff_Festival] = "Technologies.R_Festival", --{4, 15},</p><p>        [Buffs.Buff_ExtraPayment]    = {1,8},</p><p>        [Buffs.Buff_HighTaxes] = {1,6},</p><p>        [Buffs.Buff_NoPayment] = {1,8},</p><p>        [Buffs.Buff_NoTaxes]    = {1,6},</p><p>    }</p><p>    if g_GameExtraNo and g_GameExtraNo >= 1 then</p><p>        tMapping[Buffs.Buff_Gems] = "Goods.G_Gems"</p><p>        tMapping[Buffs.Buff_MusicalInstrument] = "Goods.G_MusicalInstrument"</p><p>        tMapping[Buffs.Buff_Olibanum] = "Goods.G_Olibanum"</p><p>    end</p><p>    return tMapping[self.Buff]</p><p>    if not self.Buff then</p><p>        dbg("".._Quest.Identifier.." "..self.Name..": buff '" ..self.BuffName.. "' does not exist!");</p><p>        return true;</p><p>    elseif not tonumber(self.PlayerID) or self.PlayerID < 1 or self.PlayerID > 8 then</p><p>        dbg("".._Quest.Identifier.." "..self.Name..": got an invalid playerID!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Zwei Punkte auf der Spielwelt müssen mit einer Straße verbunden werden.</p><p>-- @param _Position1 Erster Endpunkt der Straße</p><p>-- @param _Position2 Zweiter Endpunkt der Straße</p><p>-- @param _OnlyRoads Keine Wege akzeptieren</p><p>-- @within Goal</p><p>    return b_Goal_BuildRoad:new(...)</p><p>Goal_BuildRoad</p><p>    Name = "Goal_BuildRoad",</p><p>    Description = {</p><p>        en = "Goal: Connect two points with a street or a road",</p><p>        de = "Ziel: Verbinde zwei Punkte mit einer Strasse oder einem Weg.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Entity 1",     de = "Entity 1" },</p><p>        { ParameterType.ScriptName, en = "Entity 2",     de = "Entity 2" },</p><p>        { ParameterType.Custom,     en = "Only roads",     de = "Nur Strassen" },</p><p>    },</p><p>    return { Objective.BuildRoad, { GetID( self.Entity1 ),</p><p>                                     GetID( self.Entity2 ),</p><p>                                     false,</p><p>                                     0,</p><p>                                     self.bRoadsOnly } }</p><p>    if (_Index == 0) then</p><p>        self.Entity1 = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.Entity2 = _Parameter</p><p>    elseif (_Index == 2) then</p><p>        self.bRoadsOnly = AcceptAlternativeBoolean(_Parameter)</p><p>    end</p><p>    local Data</p><p>    if _Index == 2 then</p><p>        Data = {"true","false"}</p><p>    end</p><p>    return Data</p><p>    if not IsExisting(self.Entity1) or not IsExisting(self.Entity2) then</p><p>        dbg("".._Quest.Identifier.." "..self.Name..": first or second entity does not exist!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Eine Mauer muss die Bewegung eines Spielers zwischen 2 Punkten einschränken.</p><p>-- <b>Achtung:</b> Bei Monsun kann dieses Ziel fälschlicher Weise als erfüllt gewertet</p><p>-- werden, wenn der Weg durch Wasser blockiert wird!</p><p>-- @param _PlayerID  PlayerID, die blockiert wird</p><p>-- @param _Position1 Erste Position</p><p>-- @param _Position2 Zweite Position</p><p>-- @within Goal</p><p>    return b_Goal_BuildWall:new(...)</p><p>Goal_BuildWall</p><p>    Name = "Goal_BuildWall",</p><p>    Description = {</p><p>        en = "Goal: Build a wall between 2 positions bo stop the movement of an (hostile) player.",</p><p>        de = "Ziel: Baue eine Mauer zwischen 2 Punkten, die die Bewegung eines (feindlichen) Spielers zwischen den Punkten verhindert.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.PlayerID, en = "Enemy", de = "Feind" },</p><p>        { ParameterType.ScriptName, en = "Entity 1", de = "Entity 1" },</p><p>        { ParameterType.ScriptName, en = "Entity 2", de = "Entity 2" },</p><p>    },</p><p>    return { Objective.Custom2, {self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.PlayerID = _Parameter * 1</p><p>    elseif (_Index == 1) then</p><p>        self.EntityName1 = _Parameter</p><p>    elseif (_Index == 2) then</p><p>        self.EntityName2 = _Parameter</p><p>    end</p><p>    local eID1 = GetID(self.EntityName1)</p><p>    local eID2 = GetID(self.EntityName2)</p><p>    if not IsExisting(eID1) then</p><p>        return false</p><p>    end</p><p>    if not IsExisting(eID2) then</p><p>        return false</p><p>    end</p><p>    local x,y,z = Logic.EntityGetPos(eID1)</p><p>    if Logic.IsBuilding(eID1) == 1 then</p><p>        x,y = Logic.GetBuildingApproachPosition(eID1)</p><p>    end</p><p>    local Sector1 = Logic.GetPlayerSectorAtPosition(self.PlayerID, x, y)</p><p>    local x,y,z = Logic.EntityGetPos(eID2)</p><p>    if Logic.IsBuilding(eID2) == 1 then</p><p>        x,y = Logic.GetBuildingApproachPosition(eID2)</p><p>    end</p><p>    local Sector2 = Logic.GetPlayerSectorAtPosition(self.PlayerID, x, y)</p><p>    if Sector1 ~= Sector2 then</p><p>        return true</p><p>    end</p><p>    return nil</p><p>    return "Quest_Create_Wall"</p><p>    return {3,9}</p><p>    if not IsExisting(self.EntityName1) or not IsExisting(self.EntityName2) then</p><p>        dbg("".._Quest.Identifier.." "..self.Name..": first or second entity does not exist!");</p><p>        return true;</p><p>    elseif not tonumber(self.PlayerID) or self.PlayerID < 1 or self.PlayerID > 8 then</p><p>        dbg("".._Quest.Identifier.." "..self.Name..": got an invalid playerID!");</p><p>        return true;</p><p>    end</p><p>    if GetDiplomacyState(_Quest.ReceivingPlayer, self.PlayerID) > -1 and not self.WarningPrinted then</p><p>        warn("".._Quest.Identifier.." "..self.Name..": player d is neighter enemy or unknown to quest receiver!");</p><p>        self.WarningPrinted = true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ein bestimmtes Territorium muss vom Auftragnehmer eingenommen werden.</p><p>-- @param _Territory Territorium-ID oder Territoriumname</p><p>-- @within Goal</p><p>    return b_Goal_Claim:new(...)</p><p>Goal_Claim</p><p>    Name = "Goal_Claim",</p><p>    Description = {</p><p>        en = "Goal: Claim a territory",</p><p>        de = "Ziel: Erobere ein Territorium",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.TerritoryName, en = "Territory", de = "Territorium" },</p><p>    },</p><p>    return { Objective.Claim, 1, self.TerritoryID }</p><p>    if (_Index == 0) then</p><p>        self.TerritoryID = tonumber(_Parameter)</p><p>        if not self.TerritoryID then</p><p>            self.TerritoryID = GetTerritoryIDByName(_Parameter)</p><p>        end</p><p>    end</p><p>    return "Quest_Claim_Territory"</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der Auftragnehmer muss eine Menge an Territorien besitzen.</p><p>-- Das Heimatterritorium des Spielers wird mitgezählt!</p><p>-- @param _Amount Anzahl Territorien</p><p>-- @within Goal</p><p>    return b_Goal_ClaimXTerritories:new(...)</p><p>Goal_ClaimXTerritories</p><p>    Name = "Goal_ClaimXTerritories",</p><p>    Description = {</p><p>        en = "Goal: Claim the given number of territories, all player territories are counted",</p><p>        de = "Ziel: Erobere die angegebene Anzahl Territorien, alle spielereigenen Territorien werden gezählt",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Number, en = "Territories" , de = "Territorien" }</p><p>    },</p><p>    return { Objective.Claim, 2, self.TerritoriesToClaim }</p><p>    if (_Index == 0) then</p><p>        self.TerritoriesToClaim = _Parameter * 1</p><p>    end</p><p>    return "Quest_Claim_Territory"</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der Auftragnehmer muss auf dem Territorium einen Entitytyp erstellen.</p><p>-- @param _Type      Typ des Entity</p><p>-- @param _Amount    Menge an Entities</p><p>-- @param _Territory Territorium</p><p>-- @within Goal</p><p>    return b_Goal_Create:new(...);</p><p>Goal_Create</p><p>    Name = "Goal_Create",</p><p>    Description = {</p><p>        en = "Goal: Create Buildings/Units on a specified territory",</p><p>        de = "Ziel: Erstelle Einheiten/Gebäude auf einem bestimmten Territorium.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Entity, en = "Type name", de = "Typbezeichnung" },</p><p>        { ParameterType.Number, en = "Amount", de = "Anzahl" },</p><p>        { ParameterType.TerritoryNameWithUnknown, en = "Territory", de = "Territorium" },</p><p>    },</p><p>    return { Objective.Create, assert( Entities[self.EntityName] ), self.Amount, self.TerritoryID  }</p><p>    if (_Index == 0) then</p><p>        self.EntityName = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.Amount = _Parameter * 1</p><p>    elseif (_Index == 2) then</p><p>        self.TerritoryID = tonumber(_Parameter)</p><p>        if not self.TerritoryID then</p><p>            self.TerritoryID = GetTerritoryIDByName(_Parameter)</p><p>        end</p><p>    end</p><p>    return Logic.IsEntityTypeInCategory( Entities[self.EntityName], EntityCategories.AttackableBuilding ) == 1 and "Quest_Create_Building" or "Quest_Create_Unit"</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der Auftragnehmer muss eine Menge von Rohstoffen produzieren.</p><p>-- @param _Type   Typ des Rohstoffs</p><p>-- @param _Amount Menge an Rohstoffen</p><p>-- @within Goal</p><p>    return b_Goal_Produce:new(...);</p><p>Goal_Produce</p><p>    Name = "Goal_Produce",</p><p>    Description = {</p><p>        en = "Goal: Produce an amount of goods",</p><p>        de = "Ziel: Produziere eine Anzahl einer bestimmten Ware.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.RawGoods, en = "Type of good", de = "Ressourcentyp" },</p><p>        { ParameterType.Number, en = "Amount of good", de = "Anzahl der Ressource" },</p><p>    },</p><p>    local GoodType = Logic.GetGoodTypeID(self.GoodTypeName)</p><p>    return { Objective.Produce, GoodType, self.GoodAmount }</p><p>    if (_Index == 0) then</p><p>        self.GoodTypeName = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.GoodAmount = _Parameter * 1</p><p>    end</p><p>    return "Quest_Produce"</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der Spieler muss eine bestimmte Menge einer Ware erreichen.</p><p>-- @param _Type     Typ der Ware</p><p>-- @param _Amount   Menge an Waren</p><p>-- @param _Relation Mengenrelation</p><p>-- @within Goal</p><p>    return b_Goal_GoodAmount:new(...);</p><p>Goal_GoodAmount</p><p>    Name = "Goal_GoodAmount",</p><p>    Description = {</p><p>        en = "Goal: Obtain an amount of goods - either by trading or producing them",</p><p>        de = "Ziel: Beschaffe eine Anzahl Waren - entweder durch Handel oder durch eigene Produktion.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Custom, en = "Type of good", de = "Warentyp" },</p><p>        { ParameterType.Number, en = "Amount", de = "Anzahl" },</p><p>        { ParameterType.Custom, en = "Relation", de = "Relation" },</p><p>    },</p><p>    local GoodType = Logic.GetGoodTypeID(self.GoodTypeName)</p><p>    return { Objective.Produce, GoodType, self.GoodAmount, self.bRelSmallerThan }</p><p>    if (_Index == 0) then</p><p>        self.GoodTypeName = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.GoodAmount = _Parameter * 1</p><p>    elseif  (_Index == 2) then</p><p>        self.bRelSmallerThan = _Parameter == "<" or tostring(_Parameter) == "true"</p><p>    end</p><p>    local Data = {}</p><p>    if _Index == 0 then</p><p>        for k, v in pairs( Goods ) do</p><p>            if string.find( k, "^G_" ) then</p><p>                table.insert( Data, k )</p><p>            end</p><p>        end</p><p>        table.sort( Data )</p><p>    elseif _Index == 2 then</p><p>        table.insert( Data, ">=" )</p><p>        table.insert( Data, "<" )</p><p>    else</p><p>        assert( false )</p><p>    end</p><p>    return Data</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Die Siedler des Spielers dürfen nicht aufgrund des Bedürfnisses streiken.</p><p>-- <u>Bedürfnisse</u></p><p>-- <ul></p><p>-- <li>Clothes: Kleidung</li></p><p>-- <li>Entertainment: Unterhaltung</li></p><p>-- <li>Nutrition: Nahrung</li></p><p>-- <li>Hygiene: Hygiene</li></p><p>-- <li>Medicine: Medizin</li></p><p>-- </ul></p><p>-- @param _PlayerID ID des Spielers</p><p>-- @param _Need     Bedürfnis</p><p>-- @within Goal</p><p>    return b_Goal_SatisfyNeed:new(...);</p><p>Goal_SatisfyNeed</p><p>    Name = "Goal_SatisfyNeed",</p><p>    Description = {</p><p>        en = "Goal: Satisfy a need",</p><p>        de = "Ziel: Erfuelle ein Beduerfnis",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.PlayerID, en = "Player", de = "Spieler" },</p><p>        { ParameterType.Need, en = "Need", de = "Beduerfnis" },</p><p>    },</p><p>    return { Objective.SatisfyNeed, self.PlayerID, assert( Needs[self.Need] ) }</p><p>    if (_Index == 0) then</p><p>        self.PlayerID = _Parameter * 1</p><p>    elseif (_Index == 1) then</p><p>        self.Need = _Parameter</p><p>    end</p><p>    local tMapping = {</p><p>        [Needs.Clothes] = "Quest_SatisfyNeed_Clothes",</p><p>        [Needs.Entertainment] = "Quest_SatisfyNeed_Entertainment",</p><p>        [Needs.Nutrition] = "Quest_SatisfyNeed_Food",</p><p>        [Needs.Hygiene] = "Quest_SatisfyNeed_Hygiene",</p><p>        [Needs.Medicine] = "Quest_SatisfyNeed_Medicine",</p><p>    }</p><p>    local Key = tMapping[Needs[self.Need]]</p><p>    if Key then</p><p>        return Key</p><p>    end</p><p>    -- No default message</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der Auftragnehmer muss eine Menge an Siedlern in der Stadt haben.</p><p>-- @param _Amount Menge an Siedlern</p><p>-- @within Goal</p><p>    return b_Goal_SettlersNumber:new(...);</p><p>Goal_SettlersNumber</p><p>    Name = "Goal_SettlersNumber",</p><p>    Description = {</p><p>        en = "Goal: Get a given amount of settlers",</p><p>        de = "Ziel: Erreiche eine bestimmte Anzahl Siedler.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Number, en = "Amount", de = "Anzahl" },</p><p>    },</p><p>    return {Objective.SettlersNumber, 1, self.SettlersAmount }</p><p>    if (_Index == 0) then</p><p>        self.SettlersAmount = _Parameter * 1</p><p>    end</p><p>    return "Quest_NumberSettlers"</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der Auftragnehmer muss eine Menge von Ehefrauen in der Stadt haben.</p><p>-- @param _Amount Menge an Ehefrauen</p><p>-- @within Goal</p><p>    return b_Goal_Spouses:new(...);</p><p>Goal_Spouses</p><p>    Name = "Goal_Spouses",</p><p>    Description = {</p><p>        en = "Goal: Get a given amount of spouses",</p><p>        de = "Ziel: Erreiche eine bestimmte Ehefrauenanzahl",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Number, en = "Amount", de = "Anzahl" },</p><p>    },</p><p>    return {Objective.Spouses, self.SpousesAmount }</p><p>    if (_Index == 0) then</p><p>        self.SpousesAmount = _Parameter * 1</p><p>    end</p><p>    return "Quest_NumberSpouses"</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ein Spieler muss eine Menge an Soldaten haben.</p><p>-- <u>Relationen</u></p><p>-- <ul></p><p>-- <li>>= - Anzahl als Mindestmenge</li></p><p>-- <li>< - Weniger als Anzahl</li></p><p>-- </ul></p><p>-- @param _PlayerID ID des Spielers</p><p>-- @param _Relation Mengenrelation</p><p>-- @param _Amount   Menge an Soldaten</p><p>-- @within Goal</p><p>    return b_Goal_SoldierCount:new(...);</p><p>Goal_SoldierCount</p><p>    Name = "Goal_SoldierCount",</p><p>    Description = {</p><p>        en = "Goal: Create a specified number of soldiers",</p><p>        de = "Ziel: Erreiche eine Anzahl grösser oder kleiner der angegebenen Menge Soldaten.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.PlayerID, en = "Player", de = "Spieler" },</p><p>        { ParameterType.Custom, en = "Relation", de = "Relation" },</p><p>        { ParameterType.Number, en = "Number of soldiers", de = "Anzahl Soldaten" },</p><p>    },</p><p>    return { Objective.Custom2, {self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.PlayerID = _Parameter * 1</p><p>    elseif (_Index == 1) then</p><p>        self.bRelSmallerThan = tostring(_Parameter) == "true" or tostring(_Parameter) == "<"</p><p>    elseif (_Index == 2) then</p><p>        self.NumberOfUnits = _Parameter * 1</p><p>    end</p><p>    if not _Quest.QuestDescription or _Quest.QuestDescription == "" then</p><p>        local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en"</p><p>        local caption = (lang == "de" and "SOLDATENANZAHL {cr}Partei: ") or</p><p>                            "SOLDIERS {cr}faction: "</p><p>        local relation = tostring(self.bRelSmallerThan);</p><p>        local relationText = {</p><p>            ["true"]  = {de = "Weniger als", en = "Less than"},</p><p>            ["false"] = {de = "Mindestens", en = "At least"},</p><p>        };</p><p>        local party = GetPlayerName(self.PlayerID) or "";</p><p>        local text = "{center}" .. caption .. party .. "{cr}{cr}" .. relationText[relation][lang] .. " "..self.NumberOfUnits;</p><p>        Core:ChangeCustomQuestCaptionText(text, _Quest);</p><p>    end</p><p>    local NumSoldiers = Logic.GetCurrentSoldierCount( self.PlayerID )</p><p>    if ( self.bRelSmallerThan and NumSoldiers < self.NumberOfUnits ) then</p><p>        return true</p><p>    elseif ( not self.bRelSmallerThan and NumSoldiers >= self.NumberOfUnits ) then</p><p>        return true</p><p>    end</p><p>    return nil</p><p>    local Data = {}</p><p>    if _Index == 1 then</p><p>        table.insert( Data, ">=" )</p><p>        table.insert( Data, "<" )</p><p>    else</p><p>        assert( false )</p><p>    end</p><p>    return Data</p><p>    return {7,11}</p><p>    return "Quest_Create_Unit"</p><p>    if tonumber(self.NumberOfUnits) == nil or self.NumberOfUnits < 0 then</p><p>        dbg("".._Quest.Identifier.." "..self.Name..": amount can not be below 0!");</p><p>        return true;</p><p>    elseif tonumber(self.PlayerID) == nil or self.PlayerID < 1 or self.PlayerID > 8 then</p><p>        dbg("".._Quest.Identifier.." "..self.Name..": got an invalid playerID!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der Auftragnehmer muss wenigstens einen bestimmten Titel erreichen.</p><p>-- Folgende Titel können verwendet werden:</p><p>-- <table></p><p>-- <tr></p><p>-- <td><b>Titel</b></td></p><p>-- <td><b>Übersetzung</b></td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>Knight</td></p><p>-- <td>Ritter</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>Mayor</td></p><p>-- <td>Landvogt</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>Baron</td></p><p>-- <td>Baron</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>Earl</td></p><p>-- <td>Graf</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>Marquees</td></p><p>-- <td>Marktgraf</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>Duke</td></p><p>-- <td>Herzog</td></p><p>-- </tr></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>Archduke</td></p><p>-- <td>Erzherzog</td></p><p>-- </tr></p><p>-- <table></p><p>-- @param _Title Titel, der erreicht werden muss</p><p>-- @within Goal</p><p>    return b_Goal_KnightTitle:new(...);</p><p>Goal_KnightTitle</p><p>    Name = "Goal_KnightTitle",</p><p>    Description = {</p><p>        en = "Goal: Reach a specified knight title",</p><p>        de = "Ziel: Erreiche einen vorgegebenen Titel",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Custom, en = "Knight title", de = "Titel" },</p><p>    },</p><p>    return {Objective.KnightTitle, assert( KnightTitles[self.KnightTitle] ) }</p><p>    if (_Index == 0) then</p><p>        self.KnightTitle = _Parameter</p><p>    end</p><p>    return "Quest_KnightTitle"</p><p>    return {"Knight", "Mayor", "Baron", "Earl", "Marquees", "Duke", "Archduke"}</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der angegebene Spieler muss mindestens die Menge an Festen feiern.</p><p>-- @param _PlayerID ID des Spielers</p><p>-- @param _Amount   Menge an Festen</p><p>-- @within Goal</p><p>    return b_Goal_Festivals:new(...);</p><p>Goal_Festivals</p><p>    Name = "Goal_Festivals",</p><p>    Description = {</p><p>        en = "Goal: The player has to start the given number of festivals.",</p><p>        de = "Ziel: Der Spieler muss eine gewisse Anzahl Feste gestartet haben.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.PlayerID, en = "Player", de = "Spieler" },</p><p>        { ParameterType.Number, en = "Number of festivals", de = "Anzahl Feste" }</p><p>    }</p><p>    return { Objective.Custom2, {self, self.CustomFunction} };</p><p>    if _Index == 0 then</p><p>        self.PlayerID = tonumber(_Parameter);</p><p>    else</p><p>        assert(_Index == 1, "Error in " .. self.Name .. ": AddParameter: Index is invalid.");</p><p>        self.NeededFestivals = tonumber(_Parameter);</p><p>    end</p><p>    if not _Quest.QuestDescription or _Quest.QuestDescription == "" then</p><p>        local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en"</p><p>        local caption = (lang == "de" and "FESTE FEIERN {cr}{cr}Partei: ") or</p><p>                            "HOLD PARTIES {cr}{cr}faction: "</p><p>        local amount  = (lang == "de" and "Anzahl: ") or "Amount: "</p><p>        local party = GetPlayerName(self.PlayerID) or "";</p><p>        local text = "{center}" .. caption .. party .. "{cr}{cr}" .. amount .. " "..self.NeededFestivals;</p><p>        Core:ChangeCustomQuestCaptionText(text, _Quest);</p><p>    end</p><p>    if Logic.GetStoreHouse( self.PlayerID ) == 0  then</p><p>        return false</p><p>    end</p><p>    local tablesOnFestival = {Logic.GetPlayerEntities(self.PlayerID, Entities.B_TableBeer, 5,0)}</p><p>    local amount = 0</p><p>    for k=2, #tablesOnFestival do</p><p>        local tableID = tablesOnFestival[k]</p><p>        if Logic.GetIndexOnOutStockByGoodType(tableID, Goods.G_Beer) ~= -1 then</p><p>            local goodAmountOnMarketplace = Logic.GetAmountOnOutStockByGoodType(tableID, Goods.G_Beer)</p><p>            amount = amount + goodAmountOnMarketplace</p><p>        end</p><p>    end</p><p>    if not self.FestivalStarted and amount > 0 then</p><p>        self.FestivalStarted = true</p><p>        self.FestivalCounter = (self.FestivalCounter and self.FestivalCounter + 1) or 1</p><p>        if self.FestivalCounter >= self.NeededFestivals then</p><p>            self.FestivalCounter = nil</p><p>            return true</p><p>        end</p><p>    elseif amount == 0 then</p><p>        self.FestivalStarted = false</p><p>    end</p><p>    if Logic.GetStoreHouse( self.PlayerID ) == 0 then</p><p>        dbg(_Quest.Identifier .. ": Error in " .. self.Name .. ": Player " .. self.PlayerID .. " is dead :-(")</p><p>        return true</p><p>    elseif GetPlayerCategoryType(self.PlayerID) ~= PlayerCategories.City then</p><p>        dbg(_Quest.Identifier .. ": Error in " .. self.Name .. ":  Player "..  self.PlayerID .. " is no city")</p><p>        return true</p><p>    elseif self.NeededFestivals < 0 then</p><p>        dbg(_Quest.Identifier .. ": Error in " .. self.Name .. ": Number of Festivals is negative")</p><p>        return true</p><p>    end</p><p>    return false</p><p>    self.FestivalCounter = nil</p><p>    self.FestivalStarted = nil</p><p>    return {4,15}</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der Auftragnehmer muss eine Einheit gefangen nehmen.</p><p>-- @param _ScriptName Ziel</p><p>-- @within Goal</p><p>    return b_Goal_Capture:new(...)</p><p>Goal_Capture</p><p>    Name = "Goal_Capture",</p><p>    Description = {</p><p>        en = "Goal: Capture a cart.",</p><p>        de = "Ziel: Ein Karren muss erobert werden.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Script name", de = "Skriptname" },</p><p>    },</p><p>    return { Objective.Capture, 1, { self.ScriptName } }</p><p>    if (_Index == 0) then</p><p>        self.ScriptName = _Parameter</p><p>    end</p><p>   local ID = GetID(self.ScriptName)</p><p>   if Logic.IsEntityAlive(ID) then</p><p>        ID = Logic.GetEntityType( ID )</p><p>        if ID and ID ~= 0 then</p><p>            if Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableMerchant ) == 1 then</p><p>                return "Quest_Capture_Cart"</p><p>            elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.SiegeEngine ) == 1 then</p><p>                return "Quest_Capture_SiegeEngine"</p><p>            elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.Worker ) == 1</p><p>                or Logic.IsEntityTypeInCategory( ID, EntityCategories.Spouse ) == 1</p><p>                or Logic.IsEntityTypeInCategory( ID, EntityCategories.Hero ) == 1 then</p><p>                return "Quest_Capture_VIPOfPlayer"</p><p>            end</p><p>        end</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der Auftragnehmer muss eine Menge von Einheiten eines Typs von einem</p><p>-- Spieler gefangen nehmen.</p><p>-- @param _Typ      Typ, der gefangen werden soll</p><p>-- @param _Amount   Menge an Einheiten</p><p>-- @param _PlayerID Besitzer der Einheiten</p><p>-- @within Goal</p><p>    return b_Goal_CaptureType:new(...)</p><p>Goal_CaptureType</p><p>    Name = "Goal_CaptureType",</p><p>    Description = {</p><p>        en = "Goal: Capture specified entity types",</p><p>        de = "Ziel: Nimm bestimmte Entitätstypen gefangen",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Custom,     en = "Type name", de = "Typbezeichnung" },</p><p>        { ParameterType.Number,     en = "Amount", de = "Anzahl" },</p><p>        { ParameterType.PlayerID,     en = "Player", de = "Spieler" },</p><p>    },</p><p>    return { Objective.Capture, 2, Entities[self.EntityName], self.Amount, self.PlayerID }</p><p>    if (_Index == 0) then</p><p>        self.EntityName = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.Amount = _Parameter * 1</p><p>    elseif (_Index == 2) then</p><p>        self.PlayerID = _Parameter * 1</p><p>    end</p><p>    local Data = {}</p><p>    if _Index == 0 then</p><p>        for k, v in pairs( Entities ) do</p><p>            if string.find( k, "^U_.+Cart" ) or Logic.IsEntityTypeInCategory( v, EntityCategories.AttackableMerchant ) == 1 then</p><p>                table.insert( Data, k )</p><p>            end</p><p>        end</p><p>        table.sort( Data )</p><p>    elseif _Index == 2 then</p><p>        for i = 0, 8 do</p><p>            table.insert( Data, i )</p><p>        end</p><p>    else</p><p>        assert( false )</p><p>    end</p><p>    return Data</p><p>    local ID = self.EntityName</p><p>    if Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableMerchant ) == 1 then</p><p>        return "Quest_Capture_Cart"</p><p>    elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.SiegeEngine ) == 1 then</p><p>        return "Quest_Capture_SiegeEngine"</p><p>    elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.Worker ) == 1</p><p>        or Logic.IsEntityTypeInCategory( ID, EntityCategories.Spouse ) == 1</p><p>        or Logic.IsEntityTypeInCategory( ID, EntityCategories.Hero ) == 1 then</p><p>        return "Quest_Capture_VIPOfPlayer"</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der Auftragnehmer muss das angegebene Entity beschützen.</p><p>-- Wird ein Wagen zerstört oder in das Lagerhaus / die Burg eines Feindes</p><p>-- gebracht, schlägt das Ziel fehl.</p><p>-- @param _ScriptName</p><p>-- @within Goal</p><p>    return b_Goal_Protect:new(...)</p><p>Goal_Protect</p><p>    Name = "Goal_Protect",</p><p>    Description = {</p><p>        en = "Goal: Protect an entity (entity needs a script name",</p><p>        de = "Ziel: Beschütze eine Entität (Entität benötigt einen Skriptnamen)",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Script name", de = "Skriptname" },</p><p>    },</p><p>    return {Objective.Protect, { self.ScriptName }}</p><p>    if (_Index == 0) then</p><p>        self.ScriptName = _Parameter</p><p>    end</p><p>    if Logic.IsEntityAlive(self.ScriptName) then</p><p>        local ID = GetID(self.ScriptName)</p><p>        if ID and ID ~= 0 then</p><p>            ID = Logic.GetEntityType( ID )</p><p>            if ID and ID ~= 0 then</p><p>                if Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableBuilding ) == 1 then</p><p>                    return "Quest_Protect_Building"</p><p>                elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.SpecialBuilding ) == 1 then</p><p>                    local tMapping = {</p><p>                        [PlayerCategories.City]        = "Quest_Protect_City",</p><p>                        [PlayerCategories.Cloister]    = "Quest_Protect_Cloister",</p><p>                        [PlayerCategories.Village]    = "Quest_Protect_Village",</p><p>                    }</p><p>                    local PlayerCategory = GetPlayerCategoryType( Logic.EntityGetPlayer(GetID(self.ScriptName)) )</p><p>                    if PlayerCategory then</p><p>                        local Key = tMapping[PlayerCategory]</p><p>                        if Key then</p><p>                            return Key</p><p>                        end</p><p>                    end</p><p>                    return "Quest_Protect_Building"</p><p>                elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.Hero ) == 1 then</p><p>                    return "Quest_Protect_Knight"</p><p>                elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableMerchant ) == 1 then</p><p>                    return "Quest_Protect_Cart"</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>    return "Quest_Protect"</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der AUftragnehmer muss eine Mine mit einem Geologen wieder auffüllen.</p><p>-- @param _ScriptName Skriptname der Mine</p><p>-- @within Goal</p><p>    return b_Goal_Refill:new(...)</p><p>Goal_Refill</p><p>    Name = "Goal_Refill",</p><p>    Description = {</p><p>        en = "Goal: Refill an object using a geologist",</p><p>        de = "Ziel: Eine Mine soll durch einen Geologen wieder aufgefuellt werden.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Script name", de = "Skriptname" },</p><p>    },</p><p>   RequiresExtraNo = 1,</p><p>    return { Objective.Refill, { GetID(self.ScriptName) } }</p><p>    return {8,1,1}</p><p>    if (_Index == 0) then</p><p>        self.ScriptName = _Parameter</p><p>    end</p><p>    Core:RegisterBehavior(b_Goal_Refill);</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der Auftragnehmer muss eine Menge an Rohstoffen in einer Mine erreichen.</p><p>-- <u>Relationen</u></p><p>-- <ul></p><p>-- <li>> - Mehr als Anzahl</li></p><p>-- <li>< - Weniger als Anzahl</li></p><p>-- </ul></p><p>-- @param _ScriptName Skriptname der Mine</p><p>-- @param _Relation   Mengenrelation</p><p>-- @param _Amount     Menge an Rohstoffen</p><p>-- @within Goal</p><p>    return b_Goal_ResourceAmount:new(...)</p><p>Goal_ResourceAmount</p><p>    Name = "Goal_ResourceAmount",</p><p>    Description = {</p><p>        en = "Goal: Reach a specified amount of resources in a doodad",</p><p>        de = "Ziel: In einer Mine soll weniger oder mehr als eine angegebene Anzahl an Rohstoffen sein.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Script name", de = "Skriptname" },</p><p>        { ParameterType.Custom, en = "Relation", de = "Relation" },</p><p>        { ParameterType.Number, en = "Amount", de = "Menge" },</p><p>    },</p><p>    return { Objective.Custom2, {self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.ScriptName = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.bRelSmallerThan = _Parameter == "<"</p><p>    elseif (_Index == 2) then</p><p>        self.Amount = _Parameter * 1</p><p>    end</p><p>    local ID = GetID(self.ScriptName)</p><p>    if ID and ID ~= 0 and Logic.GetResourceDoodadGoodType(ID) ~= 0 then</p><p>        local HaveAmount = Logic.GetResourceDoodadGoodAmount(ID)</p><p>        if ( self.bRelSmallerThan and HaveAmount < self.Amount ) or ( not self.bRelSmallerThan and HaveAmount >= self.Amount ) then</p><p>            return true</p><p>        end</p><p>    end</p><p>    return nil</p><p>    local Data = {}</p><p>    if _Index == 1 then</p><p>        table.insert( Data, ">=" )</p><p>        table.insert( Data, "<" )</p><p>    else</p><p>        assert( false )</p><p>    end</p><p>    return Data</p><p>    if not IsExisting(self.ScriptName) then</p><p>        dbg("".._Quest.Identifier.." "..self.Name..": entity '" ..self.ScriptName.. "' does not exist!");</p><p>        return true;</p><p>    elseif tonumber(self.Amount) == nil or self.Amount < 0 then</p><p>        dbg("".._Quest.Identifier.." "..self.Name..": error at amount! (nil or below 0)");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der Quest schlägt sofort fehl.</p><p>-- @within Goal</p><p>    return b_Goal_InstantFailure:new()</p><p>Goal_InstantFailure</p><p>    Name = "Goal_InstantFailure",</p><p>    Description = {</p><p>        en = "Instant failure, the goal returns false.",</p><p>        de = "Direkter Misserfolg, das Goal sendet false.",</p><p>    },</p><p>    return {Objective.DummyFail};</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der Quest wird sofort erfüllt.</p><p>-- @within Goal</p><p>    return b_Goal_InstantSuccess:new()</p><p>Goal_InstantSuccess</p><p>    Name = "Goal_InstantSuccess",</p><p>    Description = {</p><p>        en = "Instant success, the goal returns true.",</p><p>        de = "Direkter Erfolg, das Goal sendet true.",</p><p>    },</p><p>    return {Objective.Dummy};</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der Zustand des Quests ändert sich niemals</p><p>-- @within Goal</p><p>    return b_Goal_NoChange:new()</p><p>Goal_NoChange</p><p>    Name = "Goal_NoChange",</p><p>    Description = {</p><p>        en = "The quest state doesn't change. Use reward functions of other quests to change the state of this quest.",</p><p>        de = "Der Questzustand wird nicht verändert. Ein Reward einer anderen Quest sollte den Zustand dieser Quest verändern.",</p><p>    },</p><p>    return { Objective.NoChange }</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Führt eine Funktion im Skript als Goal aus.</p><p>-- Die Funktion muss entweder true, false oder nichts zurückgeben.</p><p>-- <ul></p><p>-- <li>true: Erfolgreich abgeschlossen</li></p><p>-- <li>false: Fehlschlag</li></p><p>-- <li>nichts: Zustand unbestimmt</li></p><p>-- </ul></p><p>-- @param _FunctionName Name der Funktion</p><p>-- @within Goal</p><p>    return b_Goal_MapScriptFunction:new(...);</p><p>Goal_MapScriptFunction</p><p>    Name = "Goal_MapScriptFunction",</p><p>    Description = {</p><p>        en = "Goal: Calls a function within the global map script. Return 'true' means success, 'false' means failure and 'nil' doesn't change anything.",</p><p>        de = "Ziel: Ruft eine Funktion im globalen Skript auf, die einen Wahrheitswert zurueckgibt. Rueckgabe 'true' gilt als erfuellt, 'false' als gescheitert und 'nil' ändert nichts.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Default, en = "Function name", de = "Funktionsname" },</p><p>    },</p><p>    return {Objective.Custom2, {self, self.CustomFunction}};</p><p>    if (_Index == 0) then</p><p>        self.FuncName = _Parameter</p><p>    end</p><p>    return _G[self.FuncName](self, _Quest);</p><p>    if not self.FuncName or not _G[self.FuncName] then</p><p>        dbg("".._Quest.Identifier.." "..self.Name..": function '" ..self.FuncName.. "' does not exist!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Eine benutzerdefinierte Variable muss einen bestimmten Wert haben.</p><p>-- Custom Variables können ausschließlich Zahlen enthalten.</p><p>-- <p>Vergleichsoperatoren</p></p><p>-- <ul></p><p>-- <li>== - Werte müssen gleich sein</li></p><p>-- <li>~= - Werte müssen ungleich sein</li></p><p>-- <li>> - Variablenwert größer Vergleichswert</li></p><p>-- <li>>= - Variablenwert größer oder gleich Vergleichswert</li></p><p>-- <li>< - Variablenwert kleiner Vergleichswert</li></p><p>-- <li><= - Variablenwert kleiner oder gleich Vergleichswert</li></p><p>-- </ul></p><p>-- @param _Name     Name der Variable</p><p>-- @param _Relation Vergleichsoperator</p><p>-- @param _Value    Wert oder andere Custom Variable mit wert.</p><p>-- @within Goal</p><p>    return b_Goal_CustomVariables:new(...);</p><p>Goal_CustomVariables</p><p>    Name = "Goal_CustomVariables",</p><p>    Description = {</p><p>        en = "Goal: A customised variable has to assume a certain value.",</p><p>        de = "Ziel: Eine benutzerdefinierte Variable muss einen bestimmten Wert annehmen.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Default, en = "Name of Variable", de = "Variablenname" },</p><p>        { ParameterType.Custom,  en = "Relation", de = "Relation" },</p><p>        { ParameterType.Default, en = "Value or variable", de = "Wert oder Variable" }</p><p>    }</p><p>    return { Objective.Custom2, {self, self.CustomFunction} };</p><p>    if _Index == 0 then</p><p>        self.VariableName = _Parameter</p><p>    elseif _Index == 1 then</p><p>        self.Relation = _Parameter</p><p>    elseif _Index == 2 then</p><p>        local value = tonumber(_Parameter);</p><p>        value = (value ~= nil and value) or tostring(_Parameter);</p><p>        self.Value = value</p><p>    end</p><p>    if _G["QSB_CustomVariables_"..self.VariableName] then</p><p>        local Value = (type(self.Value) ~= "string" and self.Value) or _G["QSB_CustomVariables_"..self.Value];</p><p>        if self.Relation == "==" then</p><p>            if _G["QSB_CustomVariables_"..self.VariableName] == Value then</p><p>                return true;</p><p>            end</p><p>        elseif self.Relation == "~=" then</p><p>            if _G["QSB_CustomVariables_"..self.VariableName] == Value then</p><p>                return true;</p><p>            end</p><p>        elseif self.Relation == "<" then</p><p>            if _G["QSB_CustomVariables_"..self.VariableName] < Value then</p><p>                return true;</p><p>            end</p><p>        elseif self.Relation == "<=" then</p><p>            if _G["QSB_CustomVariables_"..self.VariableName] <= Value then</p><p>                return true;</p><p>            end</p><p>        elseif self.Relation == ">=" then</p><p>            if _G["QSB_CustomVariables_"..self.VariableName] >= Value then</p><p>                return true;</p><p>            end</p><p>        else</p><p>            if _G["QSB_CustomVariables_"..self.VariableName] > Value then</p><p>                return true;</p><p>            end</p><p>        end</p><p>    end</p><p>    return nil;</p><p>    return {"==", "~=", "<=", "<", ">", ">="};</p><p>    local relations = {"==", "~=", "<=", "<", ">", ">="}</p><p>    local results    = {true, false, nil}</p><p>    if not _G["QSB_CustomVariables_"..self.VariableName] then</p><p>        dbg(_Quest.Identifier.." "..self.Name..": variable '"..self.VariableName.."' do not exist!");</p><p>        return true;</p><p>    elseif not Inside(self.Relation,relations) then</p><p>        dbg(_Quest.Identifier.." "..self.Name..": '"..self.Relation.."' is an invalid relation!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- <p>Lässt den Spieler zwischen zwei Antworten wählen.</p></p><p>-- <p>Dabei kann zwischen den Labels Ja/Nein und Ok/Abbrechen gewählt werden.</p><p>-- </p></p><p>-- <p><b>Hinweis:</b> Es können nur geschlossene Fragen gestellt werden. Dialoge</p><p>-- müssen also immer mit Ja oder Nein beantwortbar sein oder auf Okay und</p><p>-- Abbrechen passen.</p></p><p>-- @param _Title  Fenstertitel</p><p>-- @param _Text   Fenstertext</p><p>-- @param _Labels Label der Buttons</p><p>-- @within Goal</p><p>    return b_Goal_Decide:new(...);</p><p>Goal_Decide</p><p>    Name = "Goal_Decide",</p><p>    Description = {</p><p>        en = "Opens a Yes/No Dialog. Decision = Quest Result",</p><p>        de = "Oeffnet einen Ja/Nein-Dialog. Die Entscheidung bestimmt das Quest-Ergebnis (ja=true, nein=false).",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Default, en = "Text", de = "Text", },</p><p>        { ParameterType.Default, en = "Title", de = "Titel", },</p><p>        { ParameterType.Custom, en = "Button labels", de = "Button Beschriftung", },</p><p>    },</p><p>    return { Objective.Custom2, { self, self.CustomFunction } }</p><p>    if (_Index == 0) then</p><p>        self.Text = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.Title = _Parameter</p><p>    elseif (_Index == 2) then</p><p>        self.Buttons = (_Parameter == "Ok/Cancel")</p><p>    end</p><p>    if not IsBriefingActive or (IsBriefingActive and IsBriefingActive() == false) then</p><p>        if not self.LocalExecuted then</p><p>            if QSB.DialogActive then</p><p>                return;</p><p>            end</p><p>            QSB.DialogActive = true</p><p>            local buttons = (self.Buttons and "true") or "nil"</p><p>            self.LocalExecuted = true</p><p>            local commandString = [[</p><p>                Game.GameTimeSetFactor( GUI.GetPlayerID(), 0 )</p><p>                OpenRequesterDialog(q,</p><p>                                    q,</p><p>                                    "Game.GameTimeSetFactor( GUI.GetPlayerID(), 1 ); GUI.SendScriptCommand( 'QSB.DecisionWindowResult = true ')",</p><p>                                    s ,</p><p>                                    "Game.GameTimeSetFactor( GUI.GetPlayerID(), 1 ); GUI.SendScriptCommand( 'QSB.DecisionWindowResult = false ')")</p><p>            ]];</p><p>            local commandString = string.format(commandString, self.Text, "{center} " .. self.Title, buttons)</p><p>            Logic.ExecuteInLuaLocalState(commandString);</p><p>        end</p><p>        local result = QSB.DecisionWindowResult</p><p>        if result ~= nil then</p><p>            QSB.DecisionWindowResult = nil</p><p>            QSB.DialogActive = false;</p><p>            return result</p><p>        end</p><p>    end</p><p>    self.LocalExecuted = nil;</p><p>    return {4,12}</p><p>    if _Index == 2 then</p><p>        return { "Yes/No", "Ok/Cancel" }</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der Spieler kann durch regelmäßiges Begleichen eines Tributes bessere</p><p>-- Diplomatie zu einen Spieler erreichen.</p><p>-- Die Zeit zum Bezahlen des Tributes muss immer kleiner sein als die</p><p>-- Wiederholungsperiode.</p><p>-- @param _GoldAmount Menge an Gold</p><p>-- @param _Periode    Zahlungsperiode in Sekunden</p><p>-- @param _Time       Zeitbegrenzung in Sekunden</p><p>-- @param _StartMsg   Vorschlagnachricht</p><p>-- @param _SuccessMsg Erfolgsnachricht</p><p>-- @param _FailureMsg Fehlschlagnachricht</p><p>-- @param _Restart    Nach nichtbezahlen neu starten</p><p>-- @within Goal</p><p>    return b_Goal_TributeDiplomacy:new(...);</p><p>Goal_TributeDiplomacy</p><p>    Name = "Goal_TributeDiplomacy",</p><p>    Description = {</p><p>        en = "Goal: AI requests periodical tribute for better Diplomacy",</p><p>        de = "Ziel: Die KI fordert einen regelmässigen Tribut fuer bessere Diplomatie. Der Questgeber ist der fordernde Spieler.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Number, en = "Amount", de = "Menge", },</p><p>        { ParameterType.Number, en = "Time till next peyment in seconds", de = "Zeit bis zur Forderung in Sekunden", },</p><p>        { ParameterType.Number, en = "Time to pay tribute in seconds", de = "Zeit bis zur Zahlung in Sekunden", },</p><p>        { ParameterType.Default, en = "Start Message for TributQuest", de = "Startnachricht der Tributquest", },</p><p>        { ParameterType.Default, en = "Success Message for TributQuest", de = "Erfolgsnachricht der Tributquest", },</p><p>        { ParameterType.Default, en = "Failure Message for TributQuest", de = "Niederlagenachricht der Tributquest", },</p><p>        { ParameterType.Custom, en = "Restart if failed to pay", de = "Nicht-bezahlen beendet die Quest", },</p><p>    },</p><p>    return {Objective.Custom2, {self, self.CustomFunction} };</p><p>    if (_Index == 0) then</p><p>        self.Amount = _Parameter * 1;</p><p>    elseif (_Index == 1) then</p><p>        self.PeriodLength = _Parameter * 1;</p><p>    elseif (_Index == 2) then</p><p>        self.TributTime = _Parameter * 1;</p><p>    elseif (_Index == 3) then</p><p>        self.StartMsg = _Parameter;</p><p>    elseif (_Index == 4) then</p><p>        self.SuccessMsg = _Parameter;</p><p>    elseif (_Index == 5) then</p><p>        self.FailureMsg = _Parameter;</p><p>    elseif (_Index == 6) then</p><p>        self.RestartAtFailure = AcceptAlternativeBoolean(_Parameter);</p><p>    end</p><p>    if not self.QuestStarted then</p><p>        Quest = QuestTemplate:New (</p><p>            _Quest.Identifier.."_TributeDiplomacyQuest" , _Quest.SendingPlayer, _Quest.ReceivingPlayer,</p><p>            {{ Objective.Deliver, {Goods.G_Gold, self.Amount}}},</p><p>            {{ Triggers.Time, 0 }},</p><p>            self.TributTime, nil, nil, nil, nil, true, true, nil,</p><p>            self.StartMsg,</p><p>            self.SuccessMsg,</p><p>            self.FailureMsg</p><p>        );</p><p>        self.QuestStarted = Quest;</p><p>        self.Time = Logic.GetTime();</p><p>    end</p><p>    local TributeQuest = Quests[self.QuestStarted];</p><p>    if self.QuestStarted and TributeQuest.State == QuestState.Over and not self.RestartQuest then</p><p>        if TributeQuest.Result ~= QuestResult.Success then</p><p>            SetDiplomacyState( _Quest.ReceivingPlayer, _Quest.SendingPlayer, DiplomacyStates.Enemy);</p><p>            if not self.RestartAtFailure then</p><p>                return false;</p><p>            end</p><p>        else</p><p>            SetDiplomacyState( _Quest.ReceivingPlayer, _Quest.SendingPlayer, DiplomacyStates.TradeContact);</p><p>        end</p><p>        self.RestartQuest = true;</p><p>    end</p><p>    local storeHouse = Logic.GetStoreHouse(_Quest.SendingPlayer);</p><p>    if (storeHouse == 0 or Logic.IsEntityDestroyed(storeHouse)) then</p><p>        if self.QuestStarted and Quests[self.QuestStarted].State == QuestState.Active then</p><p>            Quests[self.QuestStarted]:Interrupt();</p><p>        end</p><p>        return true;</p><p>    end</p><p>    local TributeQuest = Quests[self.QuestStarted];</p><p>    if self.QuestStarted and self.RestartQuest and ((Logic.GetTime() - self.Time) >= self.PeriodLength) then</p><p>        TributeQuest.Objectives[1].Completed = nil;</p><p>        TributeQuest.Objectives[1].Data[3] = nil;</p><p>        TributeQuest.Objectives[1].Data[4] = nil;</p><p>        TributeQuest.Objectives[1].Data[5] = nil;</p><p>        TributeQuest.Result = nil;</p><p>        TributeQuest.State = QuestState.NotTriggered;</p><p>        Logic.ExecuteInLuaLocalState("LocalScriptCallback_OnQuestStatusChanged("..TributeQuest.Index..")");</p><p>        Trigger.RequestTrigger(Events.LOGIC_EVENT_EVERY_SECOND, "", QuestTemplate.Loop, 1, 0, { TributeQuest.QueueID });</p><p>        self.Time = Logic.GetTime();</p><p>        self.RestartQuest = nil;</p><p>    end</p><p>    -- Tribut Quest erzeugen</p><p>    self:GetTributeQuest(_Quest);</p><p>    -- Status des Tributes prüfen.</p><p>    if self:CheckTributeQuest(_Quest) == false then</p><p>        return false;</p><p>    end</p><p>    -- Status des fordernden Spielers prüfen.</p><p>    if self:CheckTributePlayer(_Quest) == true then</p><p>        return true;</p><p>    end</p><p>    -- Quest neu starten, falls nötig.</p><p>    self:TributQuestRestarter(_Quest);</p><p>    if self.Amount < 0 then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": Amount is negative!");</p><p>        return true;</p><p>    end</p><p>    if self.PeriodLength < self.TributTime then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": TributTime too long!");</p><p>        return true;</p><p>    end</p><p>    self.Time = nil;</p><p>    self.QuestStarted = nil;</p><p>    self.RestartQuest = nil;</p><p>    if self.QuestStarted and Quests[self.QuestStarted] ~= nil then</p><p>        if Quests[self.QuestStarted].State == QuestState.Active then</p><p>            Quests[self.QuestStarted]:Interrupt()</p><p>        end</p><p>    end</p><p>    if (_index == 6) then</p><p>        return {"true", "false"};</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Erlaubt es dem Spieler ein Territorium zu mieten.</p><p>-- Zerstört der Spieler den Außenposten, schlägt der Quest fehl und das</p><p>-- Territorium wird an den Vermieter übergeben.</p><p>-- Die Zeit zum Bezahlen des Tributes muss immer kleiner sein als die</p><p>-- Wiederholungsperiode.</p><p>-- @param _Territory  Name des Territorium</p><p>-- @param _PlayerID   PlayerID des Zahlungsanforderer</p><p>-- @param _Cost       Menge an Gold</p><p>-- @param _Periode    Zahlungsperiode in Sekunden</p><p>-- @param _Time       Zeitbegrenzung in Sekunden</p><p>-- @param _StartMsg   Vorschlagnachricht</p><p>-- @param _SuccessMsg Erfolgsnachricht</p><p>-- @param _FailMsg    Fehlschlagnachricht</p><p>-- @param _HowOften   Anzahl an Zahlungen (0 = endlos)</p><p>-- @param _OtherOwner Eroberung durch Dritte beendet Quest</p><p>-- @param _Abort      Nach nichtbezahlen abbrechen</p><p>-- @within Goal</p><p>    return b_Goal_TributeClaim:new(...);</p><p>Goal_TributeClaim</p><p>    Name = "Goal_TributeClaim",</p><p>    Description = {</p><p>        en = "Goal: AI requests periodical tribute for a specified territory. The quest sender is the demanding player.",</p><p>        de = "Ziel: Die KI fordert einen regelmässigen Tribut fuer ein Territorium. Der Questgeber ist der fordernde Spieler.",</p><p>                },</p><p>    Parameter = {</p><p>        { ParameterType.TerritoryName, en = "Territory", de = "Territorium", },</p><p>        { ParameterType.PlayerID, en = "PlayerID", de = "PlayerID", },</p><p>        { ParameterType.Number, en = "Amount", de = "Menge", },</p><p>        { ParameterType.Number, en = "Length of Period in seconds", de = "Sekunden bis zur nächsten Forderung", },</p><p>        { ParameterType.Number, en = "Time to pay Tribut in seconds", de = "Zeit bis zur Zahlung in Sekunden", },</p><p>        { ParameterType.Default, en = "Start Message for TributQuest", de = "Startnachricht der Tributquest", },</p><p>        { ParameterType.Default, en = "Success Message for TributQuest", de = "Erfolgsnachricht der Tributquest", },</p><p>        { ParameterType.Default, en = "Failure Message for TributQuest", de = "Niederlagenachricht der Tributquest", },</p><p>        { ParameterType.Number, en = "How often to pay (0 = forerver)", de = "Anzahl der Tributquests (0 = unendlich)", },</p><p>        { ParameterType.Custom, en = "Other Owner cancels the Quest", de = "Anderer Spieler kann Quest beenden", },</p><p>        { ParameterType.Custom, en = "About if a rate is not payed", de = "Nicht-bezahlen beendet die Quest", },</p><p>    },</p><p>    return {Objective.Custom2, {self, self.CustomFunction} };</p><p>    if (_Index == 0) then</p><p>        self.TerritoryID = GetTerritoryIDByName(_Parameter);</p><p>    elseif (_Index == 1) then</p><p>        self.PlayerID = _Parameter * 1;</p><p>    elseif (_Index == 2) then</p><p>        self.Amount = _Parameter * 1;</p><p>    elseif (_Index == 3) then</p><p>        self.PeriodLength = _Parameter * 1;</p><p>    elseif (_Index == 4) then</p><p>        self.TributTime = _Parameter * 1;</p><p>    elseif (_Index == 5) then</p><p>        self.StartMsg = _Parameter;</p><p>    elseif (_Index == 6) then</p><p>        self.SuccessMsg = _Parameter;</p><p>    elseif (_Index == 7) then</p><p>        self.FailureMsg = _Parameter;</p><p>    elseif (_Index == 8) then</p><p>        self.HowOften = _Parameter * 1;</p><p>    elseif (_Index == 9) then</p><p>        self.OtherOwnerCancels = AcceptAlternativeBoolean(_Parameter);</p><p>    elseif (_Index == 10) then</p><p>        self.DontPayCancels = AcceptAlternativeBoolean(_Parameter);</p><p>    end</p><p>    local Outpost = Logic.GetTerritoryAcquiringBuildingID(self.TerritoryID);</p><p>    if IsExisting(Outpost) and GetHealth(Outpost) < 25 and Logic.IsBuildingBeingKnockedDown(Outpost) == false then</p><p>        while (Logic.GetEntityHealth(Outpost) < Logic.GetEntityMaxHealth(Outpost) * 0.6) do</p><p>            Logic.HealEntity(Outpost, 1);</p><p>        end</p><p>    end</p><p>    self.Time = Logic.GetTime();</p><p>    self.Quest.Objectives[1].Completed = nil;</p><p>    self.Quest.Objectives[1].Data[3] = nil;</p><p>    self.Quest.Objectives[1].Data[4] = nil;</p><p>    self.Quest.Objectives[1].Data[5] = nil;</p><p>    self.Quest.Result = nil;</p><p>    self.Quest.State = QuestState.NotTriggered;</p><p>    Logic.ExecuteInLuaLocalState("LocalScriptCallback_OnQuestStatusChanged("..self.Quest.Index..")");</p><p>    Trigger.RequestTrigger(Events.LOGIC_EVENT_EVERY_SECOND, "", QuestTemplate.Loop, 1, 0, { self.Quest.QueueID });</p><p>    if not self.Quest then</p><p>        local QuestID = QuestTemplate:New(</p><p>            _Quest.Identifier.."_TributeClaimQuest", self.PlayerID, _Quest.ReceivingPlayer,</p><p>            {{ Objective.Deliver, {Goods.G_Gold, self.Amount}}},</p><p>            {{ Triggers.Time, 0 }},</p><p>            self.TributTime, nil, nil, nil, nil, true, true, nil,</p><p>            self.StartMsg,</p><p>            self.SuccessMsg,</p><p>            self.FailureMsg</p><p>        );</p><p>        self.Quest = Quests[QuestID];</p><p>        self.Time = Logic.GetTime();</p><p>    end</p><p>    local Outpost = Logic.GetTerritoryAcquiringBuildingID(self.TerritoryID);</p><p>    if IsExisting(Outpost) then</p><p>        Logic.ChangeEntityPlayerID(Outpost, self.PlayerID);</p><p>    end</p><p>    Logic.SetTerritoryPlayerID(self.TerritoryID, self.PlayerID);</p><p>    self.Time = Logic.GetTime();</p><p>    self.Quest.State = false;</p><p>    if self.DontPayCancels then</p><p>        _Quest:Interrupt();</p><p>    end</p><p>    local Outpost = Logic.GetTerritoryAcquiringBuildingID(self.TerritoryID);</p><p>    if self.Quest.Result == QuestResult.Success then</p><p>        if Logic.GetTerritoryPlayerID(self.TerritoryID) == self.PlayerID then</p><p>            if IsExisting(Outpost) then</p><p>                Logic.ChangeEntityPlayerID(Outpost, _Quest.ReceivingPlayer);</p><p>            end</p><p>            Logic.SetTerritoryPlayerID(self.TerritoryID, _Quest.ReceivingPlayer);</p><p>        end</p><p>    end</p><p>    if Logic.GetTime() >= self.Time + self.PeriodLength then</p><p>        if self.HowOften and self.HowOften ~= 0 then</p><p>            self.TributeCounter = (self.TributeCounter or 0) +1;</p><p>            if self.TributeCounter >= self.HowOften then</p><p>                return false;</p><p>            end</p><p>        end</p><p>        self:RestartTributeQuest();</p><p>    end</p><p>    -- Außenposten heilen, falls nötig.</p><p>    self:CureOutpost(_Quest);</p><p>    if Logic.GetTerritoryPlayerID(self.TerritoryID) == _Quest.ReceivingPlayer</p><p>    or Logic.GetTerritoryPlayerID(self.TerritoryID) == self.PlayerID then</p><p>        if self.OtherOwner then</p><p>            self:RestartTributeQuest();</p><p>            self.OtherOwner = nil;</p><p>        end</p><p>        self:CreateTributeQuest(_Quest);</p><p>        -- Quest abgeschlossen</p><p>        if self.Quest.State == QuestState.Over then</p><p>            if self.Quest.Result == QuestResult.Failure then</p><p>                self:OnTributeFailed(_Quest);</p><p>            else</p><p>                self:OnTributePaid(_Quest);</p><p>            end</p><p>        elseif self.Quest.State == false then</p><p>            if Logic.GetTime() >= self.Time + self.PeriodLength then</p><p>                self:RestartTributeQuest(_Quest);</p><p>            end</p><p>        end</p><p>    -- Keiner besitzt das Territorium -> Abbruch</p><p>    elseif Logic.GetTerritoryPlayerID(self.TerritoryID) == 0 and self.Quest then</p><p>        if self.Quest.State == QuestState.Active then</p><p>            self.Quest:Interrupt();</p><p>        end</p><p>    -- Anderer Besitzer -> Abbruch</p><p>    elseif Logic.GetTerritoryPlayerID(self.TerritoryID) ~= self.PlayerID then</p><p>        if self.Quest.State == QuestState.Active then</p><p>            self.Quest:Interrupt();</p><p>        end</p><p>        if self.OtherOwnerCancels then</p><p>            _Quest:Interrupt();</p><p>        end</p><p>        self.OtherOwner = true;</p><p>    end</p><p>    --Fordernder Spieler existiert nicht -> Abbruch</p><p>    local storeHouse = Logic.GetStoreHouse(self.PlayerID);</p><p>    if (storeHouse == 0 or Logic.IsEntityDestroyed(storeHouse)) then</p><p>        if self.Quest and self.Quest.State == QuestState.Active then</p><p>            self.Quest:Interrupt();</p><p>        end</p><p>        return true;</p><p>    end</p><p>    if self.TerritoryID == 0 then</p><p>        dbg(_Quest.Identifier .. ": " .. self.Name .. ": Unknown Territory");</p><p>        return true;</p><p>    end</p><p>    if not self.Quest and Logic.GetStoreHouse(self.PlayerID) == 0 then</p><p>        dbg(_Quest.Identifier .. ": " .. self.Name .. ": Player " .. self.PlayerID .. " is dead. :-(");</p><p>        return true;</p><p>    end</p><p>    if self.Amount < 0 then</p><p>        dbg(_Quest.Identifier .. ": " .. self.Name .. ": Amount is negative");</p><p>        return true;</p><p>    end</p><p>    if self.PeriodLength < self.TributTime or self.PeriodLength < 1 then</p><p>        dbg(_Quest.Identifier .. ": " .. self.Name .. ": Period Length is wrong");</p><p>        return true;</p><p>    end</p><p>    if self.HowOften < 0 then</p><p>        dbg(_Quest.Identifier .. ": " .. self.Name .. ": HowOften is negative");</p><p>        return true;</p><p>    end</p><p>    self.Quest = nil;</p><p>    self.Time = nil;</p><p>    self.OtherOwner = nil;</p><p>    if type(self.Quest) == "table" then</p><p>        if self.Quest.State == QuestState.Active then</p><p>            self.Quest:Interrupt();</p><p>        end</p><p>    end</p><p>    if (_index == 9) or (_index == 10) then</p><p>        return {"false", "true"};</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Reprisal                                                                   --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Deaktiviert ein interaktives Objekt</p><p>-- @param _ScriptName Skriptname des interaktiven Objektes</p><p>-- @within Reprisal</p><p>    return b_Reprisal_ObjectDeactivate:new(...);</p><p>Reprisal_ObjectDeactivate</p><p>    Name = "Reprisal_ObjectDeactivate",</p><p>    Description = {</p><p>        en = "Reprisal: Deactivates an interactive object",</p><p>        de = "Vergeltung: Deaktiviert ein interaktives Objekt",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Interactive object", de = "Interaktives Objekt" },</p><p>    },</p><p>    return { Reprisal.Custom,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.ScriptName = _Parameter</p><p>    end</p><p>    InteractiveObjectDeactivate(self.ScriptName);</p><p>    if not Logic.IsInteractiveObject(GetID(self.ScriptName)) then</p><p>        warn("".._Quest.Identifier.." "..self.Name..": '" ..self.ScriptName.. "' is not a interactive object!");</p><p>        self.WarningPrinted = true;</p><p>    end</p><p>    local eID = GetID(self.ScriptName);</p><p>    if QSB.InitalizedObjekts[eID] and QSB.InitalizedObjekts[eID] == _Quest.Identifier then</p><p>        dbg("".._Quest.Identifier.." "..self.Name..": you can not deactivate in the same quest the object is initalized!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Aktiviert ein interaktives Objekt.</p><p>-- Der Status bestimmt, wie das objekt aktiviert wird.</p><p>-- <ul></p><p>-- <li>0: Kann nur mit Helden aktiviert werden</li></p><p>-- <li>1: Kann immer aktiviert werden</li></p><p>-- </ul></p><p>-- @param _ScriptName Skriptname des interaktiven Objektes</p><p>-- @param _State Status des Objektes</p><p>-- @within Reprisal</p><p>    return b_Reprisal_ObjectActivate:new(...);</p><p>Reprisal_ObjectActivate</p><p>    Name = "Reprisal_ObjectActivate",</p><p>    Description = {</p><p>        en = "Reprisal: Activates an interactive object",</p><p>        de = "Vergeltung: Aktiviert ein interaktives Objekt",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Interactive object",  de = "Interaktives Objekt" },</p><p>        { ParameterType.Custom,     en = "Availability",         de = "Nutzbarkeit" },</p><p>    },</p><p>    return { Reprisal.Custom,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.ScriptName = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        local parameter = 0</p><p>        if _Parameter == "Always" or 1 then</p><p>            parameter = 1</p><p>        end</p><p>        self.UsingState = parameter * 1</p><p>    end</p><p>    InteractiveObjectActivate(self.ScriptName, self.UsingState);</p><p>    if _Index == 1 then</p><p>        return {"Knight only", "Always"}</p><p>    end</p><p>    if not Logic.IsInteractiveObject(GetID(self.ScriptName)) then</p><p>        warn("".._Quest.Identifier.." "..self.Name..": '" ..self.ScriptName.. "' is not a interactive object!");</p><p>        self.WarningPrinted = true;</p><p>    end</p><p>    local eID = GetID(self.ScriptName);</p><p>    if QSB.InitalizedObjekts[eID] and QSB.InitalizedObjekts[eID] == _Quest.Identifier then</p><p>        dbg("".._Quest.Identifier.." "..self.Name..": you can not activate in the same quest the object is initalized!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der diplomatische Status zwischen Sender und Empfänger verschlechtert sich</p><p>-- um eine Stufe.</p><p>-- @within Reprisal</p><p>    return b_Reprisal_DiplomacyDecrease:new();</p><p>Reprisal_DiplomacyDecrease</p><p>    Name = "Reprisal_DiplomacyDecrease",</p><p>    Description = {</p><p>        en = "Reprisal: Diplomacy decreases slightly to another player.",</p><p>        de = "Vergeltung: Der Diplomatiestatus zum Auftraggeber wird um eine Stufe verringert.",</p><p>    },</p><p>    return { Reprisal.Custom,{self, self.CustomFunction} }</p><p>    local Sender = _Quest.SendingPlayer;</p><p>    local Receiver = _Quest.ReceivingPlayer;</p><p>    local State = GetDiplomacyState(Receiver, Sender);</p><p>    if State > -2 then</p><p>        SetDiplomacyState(Receiver, Sender, State-1);</p><p>    end</p><p>    if (_Index == 0) then</p><p>        self.PlayerID = _Parameter * 1</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Änder den Diplomatiestatus zwischen zwei Spielern.</p><p>-- @param _Party1   ID der ersten Partei</p><p>-- @param _Party2   ID der zweiten Partei</p><p>-- @param _State    Neuer Diplomatiestatus</p><p>-- @within Reprisal</p><p>    return b_Reprisal_Diplomacy:new(...);</p><p>Reprisal_Diplomacy</p><p>    Name = "Reprisal_Diplomacy",</p><p>    Description = {</p><p>        en = "Reprisal: Sets Diplomacy state of two Players to a stated value.",</p><p>        de = "Vergeltung: Setzt den Diplomatiestatus zweier Spieler auf den angegebenen Wert.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.PlayerID,         en = "PlayerID 1", de = "Spieler 1" },</p><p>        { ParameterType.PlayerID,         en = "PlayerID 2", de = "Spieler 2" },</p><p>        { ParameterType.DiplomacyState,   en = "Relation",   de = "Beziehung" },</p><p>    },</p><p>    return { Reprisal.Custom,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.PlayerID1 = _Parameter * 1</p><p>    elseif (_Index == 1) then</p><p>        self.PlayerID2 = _Parameter * 1</p><p>    elseif (_Index == 2) then</p><p>        self.Relation = DiplomacyStates[_Parameter]</p><p>    end</p><p>    SetDiplomacyState(self.PlayerID1, self.PlayerID2, self.Relation);</p><p>    if not tonumber(self.PlayerID1) or self.PlayerID1 < 1 or self.PlayerID1 > 8 then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": PlayerID 1 is invalid!");</p><p>        return true;</p><p>    elseif not tonumber(self.PlayerID2) or self.PlayerID2 < 1 or self.PlayerID2 > 8 then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": PlayerID 2 is invalid!");</p><p>        return true;</p><p>    elseif not tonumber(self.Relation) or self.Relation < -2 or self.Relation > 2 then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": '"..self.Relation.."' is a invalid diplomacy state!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ein benanntes Entity wird zerstört.</p><p>-- @param _ScriptName Skriptname des Entity</p><p>-- @within Reprisal</p><p>    return b_Reprisal_DestroyEntity:new(...);</p><p>Reprisal_DestroyEntity</p><p>    Name = "Reprisal_DestroyEntity",</p><p>    Description = {</p><p>        en = "Reprisal: Replaces an entity with an invisible script entity, which retains the entities name.",</p><p>        de = "Vergeltung: Ersetzt eine Entity mit einer unsichtbaren Script-Entity, die den Namen übernimmt.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Entity", de = "Entity" },</p><p>    },</p><p>    return { Reprisal.Custom,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.ScriptName = _Parameter</p><p>    end</p><p>    ReplaceEntity(self.ScriptName, Entities.XD_ScriptEntity);</p><p>    if not IsExisting(self.ScriptName) then</p><p>        warn(_Quest.Identifier.." " ..self.Name..": '" ..self.ScriptName.. "' is already destroyed!");</p><p>        self.WarningPrinted = true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Zerstört einen über die QSB erzeugten Effekt.</p><p>-- @param _EffectName Name des Effekts</p><p>-- @within Reprisal</p><p>    return b_Reprisal_DestroyEffect:new(...);</p><p>Reprisal_DestroyEffect</p><p>    Name = "Reprisal_DestroyEffect",</p><p>    Description = {</p><p>        en = "Reprisal: Destroys an effect",</p><p>        de = "Vergeltung: Zerstört einen Effekt",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Default, en = "Effect name", de = "Effektname" },</p><p>    }</p><p>    if _Index == 0 then</p><p>        self.EffectName = _Parameter;</p><p>    end</p><p>    return { Reprisal.Custom, { self, self.CustomFunction } };</p><p>    if not QSB.EffectNameToID[self.EffectName] or not Logic.IsEffectRegistered(QSB.EffectNameToID[self.EffectName]) then</p><p>        return;</p><p>    end</p><p>    Logic.DestroyEffect(QSB.EffectNameToID[self.EffectName]);</p><p>    if not QSB.EffectNameToID[self.EffectName] then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": Effect " .. self.EffectName .. " never created")</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der Spieler verliert das Spiel.</p><p>-- @within Reprisal</p><p>    return b_Reprisal_Defeat:new()</p><p>Reprisal_Defeat</p><p>    Name = "Reprisal_Defeat",</p><p>    Description = {</p><p>        en = "Reprisal: The player loses the game.",</p><p>        de = "Vergeltung: Der Spieler verliert das Spiel.",</p><p>    },</p><p>    return {Reprisal.Defeat};</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Zeigt die Niederlagedekoration am Quest an.</p><p>-- Es handelt sich dabei um reine Optik! Der Spieler wird nicht verlieren.</p><p>-- @within Reprisal</p><p>    return b_Reprisal_FakeDefeat:new();</p><p>Reprisal_FakeDefeat</p><p>    Name = "Reprisal_FakeDefeat",</p><p>    Description = {</p><p>        en = "Reprisal: Displays a defeat icon for a quest",</p><p>        de = "Vergeltung: Zeigt ein Niederlage Icon fuer eine Quest an",</p><p>    },</p><p>    return { Reprisal.FakeDefeat }</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ein Entity wird durch ein neues anderen Typs ersetzt.</p><p>-- Das neue Entity übernimmt Skriptname und Ausrichtung des alten Entity.</p><p>-- @param _Entity Skriptname oder ID des Entity</p><p>-- @param _Type   Neuer Typ des Entity</p><p>-- @param _Owner  Besitzer des Entity</p><p>-- @within Reprisal</p><p>    return b_Reprisal_ReplaceEntity:new(...);</p><p>Reprisal_ReplaceEntity</p><p>    Name = "Reprisal_ReplaceEntity",</p><p>    Description = {</p><p>        en = "Reprisal: Replaces an entity with a new one of a different type. The playerID can be changed too.",</p><p>        de = "Vergeltung: Ersetzt eine Entity durch eine neue anderen Typs. Es kann auch die Spielerzugehörigkeit geändert werden.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Target", de = "Ziel" },</p><p>        { ParameterType.Custom, en = "New Type", de = "Neuer Typ" },</p><p>        { ParameterType.Custom, en = "New playerID", de = "Neue Spieler ID" },</p><p>    },</p><p>    return { Reprisal.Custom,{self, self.CustomFunction} }</p><p>   if (_Index == 0) then</p><p>        self.ScriptName = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.NewType = _Parameter</p><p>    elseif (_Index == 2) then</p><p>        self.PlayerID = tonumber(_Parameter);</p><p>    end</p><p>    local eID = GetID(self.ScriptName);</p><p>    local pID = self.PlayerID;</p><p>    if pID == Logic.EntityGetPlayer(eID) then</p><p>        pID = nil;</p><p>    end</p><p>    ReplaceEntity(self.ScriptName, Entities[self.NewType], pID);</p><p>    local Data = {}</p><p>    if _Index == 1 then</p><p>        for k, v in pairs( Entities ) do</p><p>            local name = {"^M_","^XS_","^X_","^XT_","^Z_", "^XB_"}</p><p>            local found = false;</p><p>            for i=1,#name do</p><p>                if k:find(name[i]) then</p><p>                    found = true;</p><p>                    break;</p><p>                end</p><p>            end</p><p>            if not found then</p><p>                table.insert( Data, k );</p><p>            end</p><p>        end</p><p>        table.sort( Data )</p><p>    elseif _Index == 2 then</p><p>        Data = {"-","0","1","2","3","4","5","6","7","8",}</p><p>    end</p><p>    return Data</p><p>    if not Entities[self.NewType] then</p><p>        dbg(_Quest.Identifier.." "..self.Name..": got an invalid entity type!");</p><p>        return true;</p><p>    elseif self.PlayerID ~= nil and (self.PlayerID < 1 or self.PlayerID > 8) then</p><p>        dbg(_Quest.Identifier.." "..self.Name..": got an invalid playerID!");</p><p>        return true;</p><p>    end</p><p>    if not IsExisting(self.ScriptName) then</p><p>        self.WarningPrinted = true;</p><p>        warn(_Quest.Identifier.." "..self.Name..": '" ..self.ScriptName.. "' does not exist!");</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet einen Quest neu.</p><p>-- @param _QuestName Name des Quest</p><p>-- @within Reprisal</p><p>    return b_Reprisal_QuestRestart(...)</p><p>Reprisal_QuestRestart</p><p>    Name = "Reprisal_QuestRestart",</p><p>    Description = {</p><p>        en = "Reprisal: Restarts a (completed) quest so it can be triggered and completed again",</p><p>        de = "Vergeltung: Startet eine (beendete) Quest neu, damit diese neu ausgelöst und beendet werden kann",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.QuestName, en = "Quest name", de = "Questname" },</p><p>    },</p><p>    return { Reprisal.Custom,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.QuestName = _Parameter</p><p>    end</p><p>    RestartQuestByName(self.QuestName, true);</p><p>    if not Quests[GetQuestID(self.QuestName)] then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": quest "..  self.QuestName .. " does not exist!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Lässt einen Quest fehlschlagen.</p><p>-- @param _QuestName Name des Quest</p><p>-- @within Reprisal</p><p>    return b_Reprisal_QuestFailure(...)</p><p>Reprisal_QuestFailure</p><p>    Name = "Reprisal_QuestFailure",</p><p>    Description = {</p><p>        en = "Reprisal: Lets another active quest fail",</p><p>        de = "Vergeltung: Lässt eine andere aktive Quest fehlschlagen",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.QuestName, en = "Quest name", de = "Questname" },</p><p>    },</p><p>    return { Reprisal.Custom,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.QuestName = _Parameter</p><p>    end</p><p>    FailQuestByName(self.QuestName, true);</p><p>    if not Quests[GetQuestID(self.QuestName)] then</p><p>        dbg("".._Quest.Identifier.." "..self.Name..": got an invalid quest!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Wertet einen Quest als erfolgreich.</p><p>-- @param _QuestName Name des Quest</p><p>-- @within Reprisal</p><p>    return b_Reprisal_QuestSuccess(...)</p><p>Reprisal_QuestSuccess</p><p>    Name = "Reprisal_QuestSuccess",</p><p>    Description = {</p><p>        en = "Reprisal: Completes another active quest successfully",</p><p>        de = "Vergeltung: Beendet eine andere aktive Quest erfolgreich",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.QuestName, en = "Quest name", de = "Questname" },</p><p>    },</p><p>    return { Reprisal.Custom,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.QuestName = _Parameter</p><p>    end</p><p>    WinQuestByName(self.QuestName, true);</p><p>    if not Quests[GetQuestID(self.QuestName)] then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": quest "..  self.QuestName .. " does not exist!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Triggert einen Quest.</p><p>-- @param _QuestName Name des Quest</p><p>-- @within Reprisal</p><p>    return b_Reprisal_QuestActivate(...)</p><p>Reprisal_QuestActivate</p><p>    Name = "Reprisal_QuestActivate",</p><p>    Description = {</p><p>        en = "Reprisal: Activates another quest that is not triggered yet.",</p><p>        de = "Vergeltung: Aktiviert eine andere Quest die noch nicht ausgelöst wurde.",</p><p>                },</p><p>    Parameter = {</p><p>        {ParameterType.QuestName, en = "Quest name", de = "Questname", },</p><p>    },</p><p>    return {Reprisal.Custom, {self, self.CustomFunction} }</p><p>    if (_Index==0) then</p><p>        self.QuestName = _Parameter</p><p>    else</p><p>        assert(false, "Error in " .. self.Name .. ": AddParameter: Index is invalid")</p><p>    end</p><p>    StartQuestByName(self.QuestName, true);</p><p>    if not IsValidQuest(self.QuestName) then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": Quest: "..  self.QuestName .. " does not exist");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Unterbricht einen Quest.</p><p>-- @param _QuestName Name des Quest</p><p>-- @within Reprisal</p><p>    return b_Reprisal_QuestInterrupt(...)</p><p>Reprisal_QuestInterrupt</p><p>    Name = "Reprisal_QuestInterrupt",</p><p>    Description = {</p><p>        en = "Reprisal: Interrupts another active quest without success or failure",</p><p>        de = "Vergeltung: Beendet eine andere aktive Quest ohne Erfolg oder Misserfolg",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.QuestName, en = "Quest name", de = "Questname" },</p><p>    },</p><p>    return { Reprisal.Custom,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.QuestName = _Parameter</p><p>    end</p><p>    if (GetQuestID(self.QuestName) ~= nil) then</p><p>        local QuestID = GetQuestID(self.QuestName)</p><p>        local Quest = Quests[QuestID]</p><p>        if Quest.State == QuestState.Active then</p><p>            StopQuestByName(self.QuestName, true);</p><p>        end</p><p>    end</p><p>    if not Quests[GetQuestID(self.QuestName)] then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": quest "..  self.QuestName .. " does not exist!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Unterbricht einen Quest, selbst wenn dieser noch nicht ausgelöst wurde.</p><p>-- @param _QuestName   Name des Quest</p><p>-- @param _EndetQuests Bereits beendete unterbrechen</p><p>-- @within Reprisal</p><p>    return b_Reprisal_QuestForceInterrupt(...)</p><p>Reprisal_QuestForceInterrupt</p><p>    Name = "Reprisal_QuestForceInterrupt",</p><p>    Description = {</p><p>        en = "Reprisal: Interrupts another quest (even when it isn't active yet) without success or failure",</p><p>        de = "Vergeltung: Beendet eine andere Quest, auch wenn diese noch nicht aktiv ist ohne Erfolg oder Misserfolg",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.QuestName, en = "Quest name", de = "Questname" },</p><p>        { ParameterType.Custom, en = "Ended quests", de = "Beendete Quests" },</p><p>    },</p><p>    return { Reprisal.Custom,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.QuestName = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.InterruptEnded = AcceptAlternativeBoolean(_Parameter)</p><p>    end</p><p>    local Data = {}</p><p>    if _Index == 1 then</p><p>        table.insert( Data, "false" )</p><p>        table.insert( Data, "true" )</p><p>    else</p><p>        assert( false )</p><p>    end</p><p>    return Data</p><p>    if (GetQuestID(self.QuestName) ~= nil) then</p><p>        local QuestID = GetQuestID(self.QuestName)</p><p>        local Quest = Quests[QuestID]</p><p>        if self.InterruptEnded or Quest.State ~= QuestState.Over then</p><p>            Quest:Interrupt()</p><p>        end</p><p>    end</p><p>    if not Quests[GetQuestID(self.QuestName)] then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": quest "..  self.QuestName .. " does not exist!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ändert den Wert einer benutzerdefinierten Variable.</p><p>-- Benutzerdefinierte Variablen können ausschließlich Zahlen sein.</p><p>---- <p>Operatoren</p></p><p>-- <ul></p><p>-- <li>= - Variablenwert wird auf den Wert gesetzt</li></p><p>-- <li>- - Variablenwert mit Wert Subtrahieren</li></p><p>-- <li>+ - Variablenwert mit Wert addieren</li></p><p>-- <li>* - Variablenwert mit Wert multiplizieren</li></p><p>-- <li>/ - Variablenwert mit Wert dividieren</li></p><p>-- <li>^ - Variablenwert mit Wert potenzieren</li></p><p>-- </ul></p><p>-- @param _Name     Name der Variable</p><p>-- @param _Operator Rechen- oder Zuweisungsoperator</p><p>-- @param _Value    Wert oder andere Custom Variable</p><p>-- @within Reprisal</p><p>    return b_Reprisal_CustomVariables:new(...);</p><p>Reprisal_CustomVariables</p><p>    Name = "Reprisal_CustomVariables",</p><p>    Description = {</p><p>        en = "Reprisal: Executes a mathematical operation with this variable. The other operand can be a number or another custom variable.",</p><p>        de = "Vergeltung: Fuehrt eine mathematische Operation mit der Variable aus. Der andere Operand kann eine Zahl oder eine Custom-Varible sein.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Default, en = "Name of variable", de = "Variablenname" },</p><p>        { ParameterType.Custom,  en = "Operator", de = "Operator" },</p><p>        { ParameterType.Default,  en = "Value or variable", de = "Wert oder Variable" }</p><p>    }</p><p>    return { Reprisal.Custom, {self, self.CustomFunction} };</p><p>    if _Index == 0 then</p><p>        self.VariableName = _Parameter</p><p>    elseif _Index == 1 then</p><p>        self.Operator = _Parameter</p><p>    elseif _Index == 2 then</p><p>        local value = tonumber(_Parameter);</p><p>        value = (value ~= nil and value) or tostring(_Parameter);</p><p>        self.Value = value</p><p>    end</p><p>    _G["QSB_CustomVariables_"..self.VariableName] = _G["QSB_CustomVariables_"..self.VariableName] or 0;</p><p>    local oldValue = _G["QSB_CustomVariables_"..self.VariableName];</p><p>    if self.Operator == "=" then</p><p>        _G["QSB_CustomVariables_"..self.VariableName] = (type(self.Value) ~= "string" and self.Value) or _G["QSB_CustomVariables_"..self.Value];</p><p>    elseif self.Operator == "+" then</p><p>        _G["QSB_CustomVariables_"..self.VariableName] = oldValue + (type(self.Value) ~= "string" and self.Value) or _G["QSB_CustomVariables_"..self.Value];</p><p>    elseif self.Operator == "-" then</p><p>        _G["QSB_CustomVariables_"..self.VariableName] = oldValue - (type(self.Value) ~= "string" and self.Value) or _G["QSB_CustomVariables_"..self.Value];</p><p>    elseif self.Operator == "*" then</p><p>        _G["QSB_CustomVariables_"..self.VariableName] = oldValue * (type(self.Value) ~= "string" and self.Value) or _G["QSB_CustomVariables_"..self.Value];</p><p>    elseif self.Operator == "/" then</p><p>        _G["QSB_CustomVariables_"..self.VariableName] = oldValue / (type(self.Value) ~= "string" and self.Value) or _G["QSB_CustomVariables_"..self.Value];</p><p>    elseif self.Operator == "^" then</p><p>        _G["QSB_CustomVariables_"..self.VariableName] = oldValue ^ (type(self.Value) ~= "string" and self.Value) or _G["QSB_CustomVariables_"..self.Value];</p><p>    end</p><p>    return {"=", "+", "-", "*", "/", "^"};</p><p>    local operators = {"=", "+", "-", "*", "/", "^"};</p><p>    if not Inside(self.Operator,operators) then</p><p>        dbg(_Quest.Identifier.." "..self.Name..": got an invalid operator!");</p><p>        return true;</p><p>    elseif self.VariableName == "" then</p><p>        dbg(_Quest.Identifier.." "..self.Name..": missing name for variable!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Führt eine Funktion im Skript als Reprisal aus.</p><p>-- @param _FunctionName Name der Funktion</p><p>-- @within Reprisal</p><p>    return b_Reprisal_MapScriptFunction:new(...);</p><p>Reprisal_MapScriptFunction</p><p>    Name = "Reprisal_MapScriptFunction",</p><p>    Description = {</p><p>        en = "Reprisal: Calls a function within the global map script if the quest has failed.",</p><p>        de = "Vergeltung: Ruft eine Funktion im globalen Kartenskript auf, wenn die Quest fehlschlägt.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Default, en = "Function name", de = "Funktionsname" },</p><p>    },</p><p>    return {Reprisal.Custom, {self, self.CustomFunction}};</p><p>    if (_Index == 0) then</p><p>        self.FuncName = _Parameter</p><p>    end</p><p>    return _G[self.FuncName](self, _Quest);</p><p>    if not self.FuncName or not _G[self.FuncName] then</p><p>        dbg("".._Quest.Identifier.." "..self.Name..": function '" ..self.FuncName.. "' does not exist!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Erlaubt oder verbietet einem Spieler eine Technologie.</p><p>-- @param _PlayerID   ID des Spielers</p><p>-- @param _Lock       Sperren/Entsperren</p><p>-- @param _Technology Name der Technologie</p><p>-- @within Reprisal</p><p>    return b_Reprisal_Technology:new(...);</p><p>Reprisal_Technology</p><p>    Name = "Reprisal_Technology",</p><p>    Description = {</p><p>        en = "Reprisal: Locks or unlocks a technology for the given player",</p><p>        de = "Vergeltung: Sperrt oder erlaubt eine Technolgie fuer den angegebenen Player",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.PlayerID, en = "PlayerID", de = "SpielerID" },</p><p>        { ParameterType.Custom,   en = "Un / Lock", de = "Sperren/Erlauben" },</p><p>        { ParameterType.Custom,   en = "Technology", de = "Technologie" },</p><p>    },</p><p>    return { Reprisal.Custom, {self, self.CustomFunction} }</p><p>    if (_Index ==0) then</p><p>        self.PlayerID = _Parameter*1</p><p>    elseif (_Index == 1) then</p><p>        self.LockType = _Parameter == "Lock"</p><p>    elseif (_Index == 2) then</p><p>        self.Technology = _Parameter</p><p>    end</p><p>    if self.PlayerID</p><p>    and Logic.GetStoreHouse(self.PlayerID) ~= 0</p><p>    and Technologies[self.Technology]</p><p>    then</p><p>        if self.LockType  then</p><p>            LockFeaturesForPlayer(self.PlayerID, Technologies[self.Technology])</p><p>        else</p><p>            UnLockFeaturesForPlayer(self.PlayerID, Technologies[self.Technology])</p><p>        end</p><p>    else</p><p>        return false</p><p>    end</p><p>    local Data = {}</p><p>    if (_Index == 1) then</p><p>        Data[1] = "Lock"</p><p>        Data[2] = "UnLock"</p><p>    elseif (_Index == 2) then</p><p>        for k, v in pairs( Technologies ) do</p><p>            table.insert( Data, k )</p><p>        end</p><p>    end</p><p>    return Data</p><p>    if not Technologies[self.Technology] then</p><p>        dbg("".._Quest.Identifier.." "..self.Name..": got an invalid technology type!");</p><p>        return true;</p><p>    elseif tonumber(self.PlayerID) == nil or self.PlayerID < 1 or self.PlayerID > 8 then</p><p>        dbg("".._Quest.Identifier.." "..self.Name..": got an invalid playerID!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Rewards                                                                    --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Deaktiviert ein interaktives Objekt</p><p>-- @param _ScriptName Skriptname des interaktiven Objektes</p><p>-- @within Reward</p><p>    return b_Reward_ObjectDeactivate:new(...);</p><p>Reward_ObjectDeactivate = API.InstanceTable(b_Reprisal_ObjectDeactiva</p><p>Reward_ObjectDeactivate.Name             = "Reward_ObjectDeactiva</p><p>Reward_ObjectDeactivate.Description.de   = "Reward: Deactivates an interactive obje</p><p>Reward_ObjectDeactivate.Description.en   = "Lohn: Deaktiviert ein interaktives Obje</p><p>Reward_ObjectDeactivate.GetReprisalTable = </p><p>Reward_ObjectDeactivate.GetRewardTable = function(self, _Qu</p><p>    return { Reward.Custom,{self, self.CustomFunction} }</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Aktiviert ein interaktives Objekt.</p><p>-- Der Status bestimmt, wie das objekt aktiviert wird.</p><p>-- <ul></p><p>-- <li>0: Kann nur mit Helden aktiviert werden</li></p><p>-- <li>1: Kann immer aktiviert werden</li></p><p>-- </ul></p><p>-- @param _ScriptName Skriptname des interaktiven Objektes</p><p>-- @param _State Status des Objektes</p><p>-- @within Reward</p><p>    return b_Reward_ObjectActivate:new(...);</p><p>Reward_ObjectActivate = API.InstanceTable(b_Reprisal_ObjectActiva</p><p>Reward_ObjectActivate.Name             = "Reward_ObjectActiva</p><p>Reward_ObjectActivate.Description.de   = "Reward: Activates an interactive obje</p><p>Reward_ObjectActivate.Description.en   = "Lohn: Aktiviert ein interaktives Obje</p><p>Reward_ObjectActivate.GetReprisalTable = </p><p>Reward_ObjectActivate.GetRewardTable = function(self, _Qu</p><p>    return { Reward.Custom,{self, self.CustomFunction} };</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Initialisiert ein interaktives Objekt.</p><p>-- Interaktive Objekte können Kosten und Belohnungen enthalten, müssen sie</p><p>-- jedoch nicht. Ist eine Wartezeit angegeben, kann das Objekt erst nach</p><p>-- Ablauf eines Cooldowns benutzt werden.</p><p>-- @param _ScriptName Skriptname des interaktiven Objektes</p><p>-- @param _Distance   Entfernung zur Aktivierung</p><p>-- @param _Time       Wartezeit bis zur Aktivierung</p><p>-- @param _RType1     Warentyp der Belohnung</p><p>-- @param _RAmount    Menge der Belohnung</p><p>-- @param _CType1     Typ der 1. Ware</p><p>-- @param _CAmount1   Menge der 1. Ware</p><p>-- @param _CType2     Typ der 2. Ware</p><p>-- @param _CAmount2   Menge der 2. Ware</p><p>-- @param _Status     Aktivierung (0: Held, 1: immer, 2: niemals)</p><p>-- @within Reward</p><p>    return b_Reward_ObjectInit:new(...);</p><p>Reward_ObjectInit</p><p>    Name = "Reward_ObjectInit",</p><p>    Description = {</p><p>        en = "Reward: Setup an interactive object with costs and rewards.",</p><p>        de = "Lohn: Initialisiert ein interaktives Objekt mit seinen Kosten und Schätzen.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Interactive object",     de = "Interaktives Objekt" },</p><p>        { ParameterType.Number,     en = "Distance to use",     de = "Nutzungsentfernung" },</p><p>        { ParameterType.Number,     en = "Waittime",             de = "Wartezeit" },</p><p>        { ParameterType.Custom,     en = "Reward good",         de = "Belohnungsware" },</p><p>        { ParameterType.Number,     en = "Reward amount",         de = "Anzahl" },</p><p>        { ParameterType.Custom,     en = "Cost good 1",         de = "Kostenware 1" },</p><p>        { ParameterType.Number,     en = "Cost amount 1",         de = "Anzahl 1" },</p><p>        { ParameterType.Custom,     en = "Cost good 2",         de = "Kostenware 2" },</p><p>        { ParameterType.Number,     en = "Cost amount 2",         de = "Anzahl 2" },</p><p>        { ParameterType.Custom,     en = "Availability",         de = "Verfï¿½gbarkeit" },</p><p>    },</p><p>    return { Reward.Custom,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.ScriptName = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.Distance = _Parameter * 1</p><p>    elseif (_Index == 2) then</p><p>        self.Waittime = _Parameter * 1</p><p>    elseif (_Index == 3) then</p><p>        self.RewardType = _Parameter</p><p>    elseif (_Index == 4) then</p><p>        self.RewardAmount = _Parameter * 1</p><p>    elseif (_Index == 5) then</p><p>        self.FirstCostType = _Parameter</p><p>    elseif (_Index == 6) then</p><p>        self.FirstCostAmount = _Parameter * 1</p><p>    elseif (_Index == 7) then</p><p>        self.SecondCostType = _Parameter</p><p>    elseif (_Index == 8) then</p><p>        self.SecondCostAmount = _Parameter * 1</p><p>    elseif (_Index == 9) then</p><p>        local parameter = nil</p><p>        if _Parameter == "Always" or _Parameter == 1 then</p><p>            parameter = 1</p><p>        elseif _Parameter == "Never" or _Parameter == 2 then</p><p>            parameter = 2</p><p>        elseif _Parameter == "Knight only" or _Parameter == 0 then</p><p>            parameter = 0</p><p>        end</p><p>        self.UsingState = parameter</p><p>    end</p><p>    local eID = GetID(self.ScriptName);</p><p>    if eID == 0 then</p><p>        return;</p><p>    end</p><p>    QSB.InitalizedObjekts[eID] = _Quest.Identifier;</p><p>    Logic.InteractiveObjectClearCosts(eID);</p><p>    Logic.InteractiveObjectClearRewards(eID);</p><p>    Logic.InteractiveObjectSetInteractionDistance(eID, self.Distance);</p><p>    Logic.InteractiveObjectSetTimeToOpen(eID, self.Waittime);</p><p>    if self.RewardType and self.RewardType ~= "disabled" then</p><p>        Logic.InteractiveObjectAddRewards(eID, Goods[self.RewardType], self.RewardAmount);</p><p>    end</p><p>    if self.FirstCostType and self.FirstCostType ~= "disabled" then</p><p>        Logic.InteractiveObjectAddCosts(eID, Goods[self.FirstCostType], self.FirstCostAmount);</p><p>    end</p><p>    if self.SecondCostType and self.SecondCostType ~= "disabled" then</p><p>        Logic.InteractiveObjectAddCosts(eID, Goods[self.SecondCostType], self.SecondCostAmount);</p><p>    end</p><p>    Logic.InteractiveObjectSetAvailability(eID,true);</p><p>    if self.UsingState then</p><p>        for i=1, 8 do</p><p>            Logic.InteractiveObjectSetPlayerState(eID,i, self.UsingState);</p><p>        end</p><p>    end</p><p>    Logic.InteractiveObjectSetRewardResourceCartType(eID,Entities.U_ResourceMerchant);</p><p>    Logic.InteractiveObjectSetRewardGoldCartType(eID,Entities.U_GoldCart);</p><p>    Logic.InteractiveObjectSetCostResourceCartType(eID,Entities.U_ResourceMerchant);</p><p>    Logic.InteractiveObjectSetCostGoldCartType(eID, Entities.U_GoldCart);</p><p>    RemoveInteractiveObjectFromOpenedList(eID);</p><p>    table.insert(HiddenTreasures,eID);</p><p>    if _Index == 3 or _Index == 5 or _Index == 7 then</p><p>        local Data = {</p><p>            "-",</p><p>            "G_Beer",</p><p>            "G_Bread",</p><p>            "G_Broom",</p><p>            "G_Carcass",</p><p>            "G_Cheese",</p><p>            "G_Clothes",</p><p>            "G_Dye",</p><p>            "G_Gold",</p><p>            "G_Grain",</p><p>            "G_Herb",</p><p>            "G_Honeycomb",</p><p>            "G_Iron",</p><p>            "G_Leather",</p><p>            "G_Medicine",</p><p>            "G_Milk",</p><p>            "G_RawFish",</p><p>            "G_Salt",</p><p>            "G_Sausage",</p><p>            "G_SmokedFish",</p><p>            "G_Soap",</p><p>            "G_Stone",</p><p>            "G_Water",</p><p>            "G_Wood",</p><p>            "G_Wool",</p><p>        }</p><p>        if g_GameExtraNo >= 1 then</p><p>            Data[#Data+1] = "G_Gems"</p><p>            Data[#Data+1] = "G_MusicalInstrument"</p><p>            Data[#Data+1] = "G_Olibanum"</p><p>        end</p><p>        return Data</p><p>    elseif _Index == 9 then</p><p>        return {"-", "Knight only", "Always", "Never",}</p><p>    end</p><p>    if Logic.IsInteractiveObject(GetID(self.ScriptName)) == false then</p><p>        dbg("".._Quest.Identifier.." "..self.Name..": '"..self.ScriptName.."' is not a interactive object!");</p><p>        return true;</p><p>    end</p><p>    if self.UsingState ~= 1 and self.Distance < 50 then</p><p>        warn("".._Quest.Identifier.." "..self.Name..": distance is maybe too short!");</p><p>    end</p><p>    if self.Waittime < 0 then</p><p>        dbg("".._Quest.Identifier.." "..self.Name..": waittime must be equal or greater than 0!");</p><p>        return true;</p><p>    end</p><p>    if self.RewardType and self.RewardType ~= "-" then</p><p>        if not Goods[self.RewardType] then</p><p>            dbg("".._Quest.Identifier.." "..self.Name..": '"..self.RewardType.."' is invalid good type!");</p><p>            return true;</p><p>        elseif self.RewardAmount < 1 then</p><p>            dbg("".._Quest.Identifier.." "..self.Name..": amount can not be 0 or negative!");</p><p>            return true;</p><p>        end</p><p>    end</p><p>    if self.FirstCostType and self.FirstCostType ~= "-" then</p><p>        if not Goods[self.FirstCostType] then</p><p>            dbg("".._Quest.Identifier.." "..self.Name..": '"..self.FirstCostType.."' is invalid good type!");</p><p>            return true;</p><p>        elseif self.FirstCostAmount < 1 then</p><p>            dbg("".._Quest.Identifier.." "..self.Name..": amount can not be 0 or negative!");</p><p>            return true;</p><p>        end</p><p>    end</p><p>    if self.SecondCostType and self.SecondCostType ~= "-" then</p><p>        if not Goods[self.SecondCostType] then</p><p>            dbg("".._Quest.Identifier.." "..self.Name..": '"..self.SecondCostType.."' is invalid good type!");</p><p>            return true;</p><p>        elseif self.SecondCostAmount < 1 then</p><p>            dbg("".._Quest.Identifier.." "..self.Name..": amount can not be 0 or negative!");</p><p>            return true;</p><p>        end</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Änder den Diplomatiestatus zwischen zwei Spielern.</p><p>-- @param _Party1   ID der ersten Partei</p><p>-- @param _Party2   ID der zweiten Partei</p><p>-- @param _State    Neuer Diplomatiestatus</p><p>-- @within Reward</p><p>    return b_Reward_Diplomacy:new(...);</p><p>Reward_Diplomacy = API.InstanceTable(b_Reprisal_Diploma</p><p>Reward_Diplomacy.Name             = "Reward_Diploma</p><p>Reward_Diplomacy.Description.de   = "Reward: Sets Diplomacy state of two Players to a stated valu</p><p>Reward_Diplomacy.Description.en   = "Lohn: Setzt den Diplomatiestatus zweier Spieler auf den angegebenen Wer</p><p>Reward_Diplomacy.GetReprisalTable = </p><p>Reward_Diplomacy.GetRewardTable = function(self, _Qu</p><p>    return { Reward.Custom,{self, self.CustomFunction} }</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Verbessert die diplomatischen Beziehungen zwischen Sender und Empfänger</p><p>-- um einen Grad.</p><p>-- @within Reward</p><p>    return b_Reward_DiplomacyIncrease:new();</p><p>Reward_DiplomacyIncrease</p><p>    Name = "Reward_DiplomacyIncrease",</p><p>    Description = {</p><p>        en = "Reward: Diplomacy increases slightly to another player",</p><p>        de = "Lohn: Verbesserug des Diplomatiestatus zu einem anderen Spieler",</p><p>    },</p><p>    return { Reward.Custom,{self, self.CustomFunction} }</p><p>    local Sender = _Quest.SendingPlayer;</p><p>    local Receiver = _Quest.ReceivingPlayer;</p><p>    local State = GetDiplomacyState(Receiver, Sender);</p><p>    if State < 2 then</p><p>        SetDiplomacyState(Receiver, Sender, State+1);</p><p>    end</p><p>    if (_Index == 0) then</p><p>        self.PlayerID = _Parameter * 1</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Erzeugt Handelsangebote im Lagerhaus des angegebenen Spielers.</p><p>-- Sollen Angebote gelöscht werden, muss "-" als Ware ausgewählt werden.</p><p>-- <b>Achtung:</b> Stadtlagerhäuser können keine Söldner anbieten!</p><p>-- @param _PlayerID Partei, die Anbietet</p><p>-- @param _Amount1  Menge des 1. Angebot</p><p>-- @param _Type1    Ware oder Typ des 1. Angebot</p><p>-- @param _Amount2  Menge des 2. Angebot</p><p>-- @param _Type2    Ware oder Typ des 2. Angebot</p><p>-- @param _Amount3  Menge des 3. Angebot</p><p>-- @param _Type3    Ware oder Typ des 3. Angebot</p><p>-- @param _Amount4  Menge des 4. Angebot</p><p>-- @param _Type4    Ware oder Typ des 4. Angebot</p><p>-- @within Reward</p><p>    return b_Reward_TradeOffers:new(...);</p><p>Reward_TradeOffers</p><p>    Name = "Reward_TradeOffers",</p><p>    Description = {</p><p>        en = "Reward: Deletes all existing offers for a merchant and sets new offers, if given",</p><p>        de = "Lohn: Löscht alle Angebote eines Händlers und setzt neue, wenn angegeben",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Custom, en = "PlayerID", de = "PlayerID" },</p><p>        { ParameterType.Custom, en = "Amount 1", de = "Menge 1" },</p><p>        { ParameterType.Custom, en = "Offer 1", de = "Angebot 1" },</p><p>        { ParameterType.Custom, en = "Amount 2", de = "Menge 2" },</p><p>        { ParameterType.Custom, en = "Offer 2", de = "Angebot 2" },</p><p>        { ParameterType.Custom, en = "Amount 3", de = "Menge 3" },</p><p>        { ParameterType.Custom, en = "Offer 3", de = "Angebot 3" },</p><p>        { ParameterType.Custom, en = "Amount 4", de = "Menge 4" },</p><p>        { ParameterType.Custom, en = "Offer 4", de = "Angebot 4" },</p><p>    },</p><p>    return { Reward.Custom,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.PlayerID = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.AmountOffer1 = tonumber(_Parameter)</p><p>    elseif (_Index == 2) then</p><p>        self.Offer1 = _Parameter</p><p>    elseif (_Index == 3) then</p><p>        self.AmountOffer2 = tonumber(_Parameter)</p><p>    elseif (_Index == 4) then</p><p>        self.Offer2 = _Parameter</p><p>    elseif (_Index == 5) then</p><p>        self.AmountOffer3 = tonumber(_Parameter)</p><p>    elseif (_Index == 6) then</p><p>        self.Offer3 = _Parameter</p><p>    elseif (_Index == 7) then</p><p>        self.AmountOffer4 = tonumber(_Parameter)</p><p>    elseif (_Index == 8) then</p><p>        self.Offer4 = _Parameter</p><p>    end</p><p>    if (self.PlayerID > 1) and (self.PlayerID < 9) then</p><p>        local Storehouse = Logic.GetStoreHouse(self.PlayerID)</p><p>        Logic.RemoveAllOffers(Storehouse)</p><p>        for i =  1,4 do</p><p>            if self["Offer"..i] and self["Offer"..i] ~= "-" then</p><p>                if Goods[self["Offer"..i]] then</p><p>                    AddOffer(Storehouse, self["AmountOffer"..i], Goods[self["Offer"..i]])</p><p>                elseif Logic.IsEntityTypeInCategory(Entities[self["Offer"..i]], EntityCategories.Military) == 1 then</p><p>                    AddMercenaryOffer(Storehouse, self["AmountOffer"..i], Entities[self["Offer"..i]])</p><p>                else</p><p>                    AddEntertainerOffer (Storehouse , Entities[self["Offer"..i]])</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>    if Logic.GetStoreHouse(self.PlayerID ) == 0 then</p><p>        dbg(_Quest.Identifier .. ": Error in " .. self.Name .. ": Player " .. self.PlayerID .. " is dead. :-(")</p><p>        return true</p><p>    end</p><p>    local Players = { "2", "3", "4", "5", "6", "7", "8" }</p><p>    local Amount = { "1", "2", "3", "4", "5", "6", "7", "8", "9" }</p><p>    local Offers = {"-",</p><p>                    "G_Beer",</p><p>                    "G_Bow",</p><p>                    "G_Bread",</p><p>                    "G_Broom",</p><p>                    "G_Candle",</p><p>                    "G_Carcass",</p><p>                    "G_Cheese",</p><p>                    "G_Clothes",</p><p>                    "G_Cow",</p><p>                    "G_Grain",</p><p>                    "G_Herb",</p><p>                    "G_Honeycomb",</p><p>                    "G_Iron",</p><p>                    "G_Leather",</p><p>                    "G_Medicine",</p><p>                    "G_Milk",</p><p>                    "G_RawFish",</p><p>                    "G_Sausage",</p><p>                    "G_Sheep",</p><p>                    "G_SmokedFish",</p><p>                    "G_Soap",</p><p>                    "G_Stone",</p><p>                    "G_Sword",</p><p>                    "G_Wood",</p><p>                    "G_Wool",</p><p>                    "G_Salt",</p><p>                    "G_Dye",</p><p>                    "U_AmmunitionCart",</p><p>                    "U_BatteringRamCart",</p><p>                    "U_CatapultCart",</p><p>                    "U_SiegeTowerCart",</p><p>                    "U_MilitaryBandit_Melee_ME",</p><p>                    "U_MilitaryBandit_Melee_SE",</p><p>                    "U_MilitaryBandit_Melee_NA",</p><p>                    "U_MilitaryBandit_Melee_NE",</p><p>                    "U_MilitaryBandit_Ranged_ME",</p><p>                    "U_MilitaryBandit_Ranged_NA",</p><p>                    "U_MilitaryBandit_Ranged_NE",</p><p>                    "U_MilitaryBandit_Ranged_SE",</p><p>                    "U_MilitaryBow_RedPrince",</p><p>                    "U_MilitaryBow",</p><p>                    "U_MilitarySword_RedPrince",</p><p>                    "U_MilitarySword",</p><p>                    "U_Entertainer_NA_FireEater",</p><p>                    "U_Entertainer_NA_StiltWalker",</p><p>                    "U_Entertainer_NE_StrongestMan_Barrel",</p><p>                    "U_Entertainer_NE_StrongestMan_Stone",</p><p>                    }</p><p>    if g_GameExtraNo and g_GameExtraNo >= 1 then</p><p>        table.insert(Offers, "G_Gems")</p><p>        table.insert(Offers, "G_Olibanum")</p><p>        table.insert(Offers, "G_MusicalInstrument")</p><p>        table.insert(Offers, "G_MilitaryBandit_Ranged_AS")</p><p>        table.insert(Offers, "G_MilitaryBandit_Melee_AS")</p><p>        table.insert(Offers, "U_MilitarySword_Khana")</p><p>        table.insert(Offers, "U_MilitaryBow_Khana")</p><p>    end</p><p>    if (_Index == 0) then</p><p>        return Players</p><p>    elseif (_Index == 1) or (_Index == 3) or (_Index == 5) or (_Index == 7) then</p><p>        return Amount</p><p>    elseif (_Index == 2) or (_Index == 4) or (_Index == 6) or (_Index == 8) then</p><p>        return Offers</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ein benanntes Entity wird zerstört.</p><p>-- @param _ScriptName Skriptname des Entity</p><p>-- @within Reward</p><p>    return b_Reward_DestroyEntity:new(...);</p><p>Reward_DestroyEntity = API.InstanceTable(b_Reprisal_DestroyEnti</p><p>Reward_DestroyEntity.Name = "Reward_DestroyEnti</p><p>Reward_DestroyEntity.Description.en = "Reward: Replaces an entity with an invisible script entity, which retains the entities nam</p><p>Reward_DestroyEntity.Description.de = "Lohn: Ersetzt eine Entity mit einer unsichtbaren Script-Entity, die den Namen übernimm</p><p>Reward_DestroyEntity.GetReprisalTable = </p><p>Reward_DestroyEntity.GetRewardTable = function(self, _Qu</p><p>    return { Reward.Custom,{self, self.CustomFunction} }</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Zerstört einen über die QSB erzeugten Effekt.</p><p>-- @param _EffectName Name des Effekts</p><p>-- @within Reward</p><p>    return b_Reward_DestroyEffect:new(...);</p><p>Reward_DestroyEffect = API.InstanceTable(b_Reprisal_DestroyEffe</p><p>Reward_DestroyEffect.Name = "Reward_DestroyEffe</p><p>Reward_DestroyEffect.Description.en = "Reward: Destroys an effec</p><p>Reward_DestroyEffect.Description.de = "Lohn: Zerstört einen Effek</p><p>Reward_DestroyEffect.GetReprisalTable = </p><p>Reward_DestroyEffect.GetRewardTable = function(self, _Qu</p><p>    return { Reward.Custom, { self, self.CustomFunction } };</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ersetzt ein Entity mit einem Batallion.</p><p>-- Ist die Position ein Gebäude, werden die Battalione am Eingang erzeugt und</p><p>-- Das Entity wird nicht ersetzt.</p><p>-- @param _Position    Skriptname des Entity</p><p>-- @param _PlayerID    PlayerID des Battalion</p><p>-- @param _UnitType    Einheitentyp der Soldaten</p><p>-- @param _Orientation Ausrichtung in °</p><p>-- @param _Soldiers    Anzahl an Soldaten</p><p>-- @param _HideFromAI  Vor KI verstecken</p><p>-- @within Reward</p><p>    return b_Reward_CreateBattalion:new(...);</p><p>Reward_CreateBattalion</p><p>    Name = "Reward_CreateBattalion",</p><p>    Description = {</p><p>        en = "Reward: Replaces a script entity with a battalion, which retains the entities name",</p><p>        de = "Lohn: Ersetzt eine Script-Entity durch ein Bataillon, welches den Namen der Script-Entity übernimmt",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Script entity", de = "Script Entity" },</p><p>        { ParameterType.PlayerID, en = "Player", de = "Spieler" },</p><p>        { ParameterType.Custom, en = "Type name", de = "Typbezeichnung" },</p><p>        { ParameterType.Number, en = "Orientation (in degrees)", de = "Ausrichtung (in Grad)" },</p><p>        { ParameterType.Number, en = "Number of soldiers", de = "Anzahl Soldaten" },</p><p>        { ParameterType.Custom, en = "Hide from AI", de = "Vor KI verstecken" },</p><p>    },</p><p>    return { Reward.Custom,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.ScriptNameEntity = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.PlayerID = _Parameter * 1</p><p>    elseif (_Index == 2) then</p><p>        self.UnitKey = _Parameter</p><p>    elseif (_Index == 3) then</p><p>        self.Orientation = _Parameter * 1</p><p>    elseif (_Index == 4) then</p><p>        self.SoldierCount = _Parameter * 1</p><p>    elseif (_Index == 5) then</p><p>        self.HideFromAI = AcceptAlternativeBoolean(_Parameter)</p><p>    end</p><p>    if not IsExisting( self.ScriptNameEntity ) then</p><p>        return false</p><p>    end</p><p>    local pos = GetPosition(self.ScriptNameEntity)</p><p>    local NewID = Logic.CreateBattalionOnUnblockedLand( Entities[self.UnitKey], pos.X, pos.Y, self.Orientation, self.PlayerID, self.SoldierCount )</p><p>    local posID = GetID(self.ScriptNameEntity)</p><p>    if Logic.IsBuilding(posID) == 0 then</p><p>        DestroyEntity(self.ScriptNameEntity)</p><p>        Logic.SetEntityName( NewID, self.ScriptNameEntity )</p><p>    end</p><p>    if self.HideFromAI then</p><p>        AICore.HideEntityFromAI( self.PlayerID, NewID, true )</p><p>    end</p><p>    local Data = {}</p><p>    if _Index == 2 then</p><p>        for k, v in pairs( Entities ) do</p><p>            if Logic.IsEntityTypeInCategory( v, EntityCategories.Soldier ) == 1 then</p><p>                table.insert( Data, k )</p><p>            end</p><p>        end</p><p>        table.sort( Data )</p><p>    elseif _Index == 5 then</p><p>        table.insert( Data, "false" )</p><p>        table.insert( Data, "true" )</p><p>    else</p><p>        assert( false )</p><p>    end</p><p>    return Data</p><p>    if not Entities[self.UnitKey] then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": got an invalid entity type!");</p><p>        return true;</p><p>    elseif not IsExisting(self.ScriptNameEntity) then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": spawnpoint does not exist!");</p><p>        return true;</p><p>    elseif tonumber(self.PlayerID) == nil or self.PlayerID < 1 or self.PlayerID > 8 then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": playerID is wrong!");</p><p>        return true;</p><p>    elseif tonumber(self.Orientation) == nil then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": orientation must be a number!");</p><p>        return true;</p><p>    elseif tonumber(self.SoldierCount) == nil or self.SoldierCount < 1 then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": you can not create a empty batallion!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Erzeugt eine Menga von Battalionen an der Position.</p><p>-- @param _Amount      Anzahl erzeugter Battalione</p><p>-- @param _Position    Skriptname des Entity</p><p>-- @param _PlayerID    PlayerID des Battalion</p><p>-- @param _UnitType    Einheitentyp der Soldaten</p><p>-- @param _Orientation Ausrichtung in °</p><p>-- @param _Soldiers    Anzahl an Soldaten</p><p>-- @param _HideFromAI  Vor KI verstecken</p><p>-- @within Reward</p><p>    return b_Reward_CreateSeveralBattalions:new(...);</p><p>Reward_CreateSeveralBattalions</p><p>    Name = "Reward_CreateSeveralBattalions",</p><p>    Description = {</p><p>        en = "Reward: Creates a given amount of battalions",</p><p>        de = "Lohn: Erstellt eine gegebene Anzahl Bataillone",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Number, en = "Amount", de = "Anzahl" },</p><p>        { ParameterType.ScriptName, en = "Script entity", de = "Script Entity" },</p><p>        { ParameterType.PlayerID, en = "Player", de = "Spieler" },</p><p>        { ParameterType.Custom, en = "Type name", de = "Typbezeichnung" },</p><p>        { ParameterType.Number, en = "Orientation (in degrees)", de = "Ausrichtung (in Grad)" },</p><p>        { ParameterType.Number, en = "Number of soldiers", de = "Anzahl Soldaten" },</p><p>        { ParameterType.Custom, en = "Hide from AI", de = "Vor KI verstecken" },</p><p>    },</p><p>    return { Reward.Custom,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.Amount = _Parameter * 1</p><p>    elseif (_Index == 1) then</p><p>        self.ScriptNameEntity = _Parameter</p><p>    elseif (_Index == 2) then</p><p>        self.PlayerID = _Parameter * 1</p><p>    elseif (_Index == 3) then</p><p>        self.UnitKey = _Parameter</p><p>    elseif (_Index == 4) then</p><p>        self.Orientation = _Parameter * 1</p><p>    elseif (_Index == 5) then</p><p>        self.SoldierCount = _Parameter * 1</p><p>    elseif (_Index == 6) then</p><p>        self.HideFromAI = AcceptAlternativeBoolean(_Parameter)</p><p>    end</p><p>    if not IsExisting( self.ScriptNameEntity ) then</p><p>        return false</p><p>    end</p><p>    local tID = GetID(self.ScriptNameEntity)</p><p>    local x,y,z = Logic.EntityGetPos(tID);</p><p>    if Logic.IsBuilding(tID) == 1 then</p><p>        x,y = Logic.GetBuildingApproachPosition(tID)</p><p>    end</p><p>    for i=1, self.Amount do</p><p>        local NewID = Logic.CreateBattalionOnUnblockedLand( Entities[self.UnitKey], x, y, self.Orientation, self.PlayerID, self.SoldierCount )</p><p>        Logic.SetEntityName( NewID, self.ScriptNameEntity .. "_" .. i )</p><p>        if self.HideFromAI then</p><p>            AICore.HideEntityFromAI( self.PlayerID, NewID, true )</p><p>        end</p><p>    end</p><p>    local Data = {}</p><p>    if _Index == 3 then</p><p>        for k, v in pairs( Entities ) do</p><p>            if Logic.IsEntityTypeInCategory( v, EntityCategories.Soldier ) == 1 then</p><p>                table.insert( Data, k )</p><p>            end</p><p>        end</p><p>        table.sort( Data )</p><p>    elseif _Index == 6 then</p><p>        table.insert( Data, "false" )</p><p>        table.insert( Data, "true" )</p><p>    else</p><p>        assert( false )</p><p>    end</p><p>    return Data</p><p>    if not Entities[self.UnitKey] then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": got an invalid entity type!");</p><p>        return true;</p><p>    elseif not IsExisting(self.ScriptNameEntity) then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": spawnpoint does not exist!");</p><p>        return true;</p><p>    elseif tonumber(self.PlayerID) == nil or self.PlayerID < 1 or self.PlayerID > 8 then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": playerDI is wrong!");</p><p>        return true;</p><p>    elseif tonumber(self.Orientation) == nil then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": orientation must be a number!");</p><p>        return true;</p><p>    elseif tonumber(self.SoldierCount) == nil or self.SoldierCount < 1 then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": you can not create a empty batallion!");</p><p>        return true;</p><p>    elseif tonumber(self.Amount) == nil or self.Amount < 0 then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": amount can not be negative!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Erzeugt einen Effekt an der angegebenen Position.</p><p>-- @param _EffectName  Einzigartiger Effektname</p><p>-- @param _TypeName    Typ des Effekt</p><p>-- @param _PlayerID    PlayerID des Effekt</p><p>-- @param _Location    Position des Effekt</p><p>-- @param _Orientation Ausrichtung in °</p><p>-- @within Reward</p><p>    return b_Reward_CreateEffect:new(...);</p><p>Reward_CreateEffect</p><p>    Name = "Reward_CreateEffect",</p><p>    Description = {</p><p>        en = "Reward: Creates an effect at a specified position",</p><p>        de = "Lohn: Erstellt einen Effekt an der angegebenen Position",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Default,    en = "Effect name", de = "Effektname" },</p><p>        { ParameterType.Custom,     en = "Type name", de = "Typbezeichnung" },</p><p>        { ParameterType.PlayerID,   en = "Player", de = "Spieler" },</p><p>        { ParameterType.ScriptName, en = "Location", de = "Ort" },</p><p>        { ParameterType.Number,     en = "Orientation (in degrees)(-1: from locating entity)", de = "Ausrichtung (in Grad)(-1: von Positionseinheit)" },</p><p>    }</p><p>    if _Index == 0 then</p><p>        self.EffectName = _Parameter;</p><p>    elseif _Index == 1 then</p><p>        self.Type = EGL_Effects[_Parameter];</p><p>    elseif _Index == 2 then</p><p>        self.PlayerID = _Parameter * 1;</p><p>    elseif _Index == 3 then</p><p>        self.Location = _Parameter;</p><p>    elseif _Index == 4 then</p><p>        self.Orientation = _Parameter * 1;</p><p>    end</p><p>    return { Reward.Custom, { self, self.CustomFunction } };</p><p>    if Logic.IsEntityDestroyed(self.Location) then</p><p>        return;</p><p>    end</p><p>    local entity = assert(GetID(self.Location), _Quest.Identifier .. "Error in " .. self.Name .. ": CustomFunction: Entity is invalid");</p><p>    if QSB.EffectNameToID[self.EffectName] and Logic.IsEffectRegistered(QSB.EffectNameToID[self.EffectName]) then</p><p>        return;</p><p>    end</p><p>    local posX, posY = Logic.GetEntityPosition(entity);</p><p>    local orientation = tonumber(self.Orientation);</p><p>    local effect = Logic.CreateEffectWithOrientation(self.Type, posX, posY, orientation, self.PlayerID);</p><p>    if self.EffectName ~= "" then</p><p>        QSB.EffectNameToID[self.EffectName] = effect;</p><p>    end</p><p>    if QSB.EffectNameToID[self.EffectName] and Logic.IsEffectRegistered(QSB.EffectNameToID[self.EffectName]) then</p><p>        dbg("".._Quest.Identifier.." "..self.Name..": effect already exists!");</p><p>        return true;</p><p>    elseif not IsExisting(self.Location) then</p><p>        dbg("".._Quest.Identifier.." "..self.Name..": location '" ..self.Location.. "' is missing!");</p><p>        return true;</p><p>    elseif self.PlayerID and (self.PlayerID < 0 or self.PlayerID > 8) then</p><p>        dbg("".._Quest.Identifier.." "..self.Name..": invalid playerID!");</p><p>        return true;</p><p>    elseif tonumber(self.Orientation) == nil then</p><p>        dbg("".._Quest.Identifier.." "..self.Name..": invalid orientation!");</p><p>        return true;</p><p>    end</p><p>    assert(_Index == 1, "Error in " .. self.Name .. ": GetCustomData: Index is invalid.");</p><p>    local types = {};</p><p>    for k, v in pairs(EGL_Effects) do</p><p>        table.insert(types, k);</p><p>    end</p><p>    table.sort(types);</p><p>    return types;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ersetzt ein Entity mit dem Skriptnamen durch ein neues Entity.</p><p>-- Ist die Position ein Gebäude, werden die Entities am Eingang erzeugt und</p><p>-- die Position wird nicht ersetzt.</p><p>-- @param _ScriptName  Skriptname des Entity</p><p>-- @param _PlayerID    PlayerID des Effekt</p><p>-- @param _TypeName    Typname des Entity</p><p>-- @param _Orientation Ausrichtung in °</p><p>-- @param _HideFromAI  Vor KI verstecken</p><p>-- @within Reward</p><p>    return b_Reward_CreateEntity:new(...);</p><p>Reward_CreateEntity</p><p>    Name = "Reward_CreateEntity",</p><p>    Description = {</p><p>        en = "Reward: Replaces an entity by a new one of a given type",</p><p>        de = "Lohn: Ersetzt eine Entity durch eine neue gegebenen Typs",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Script entity", de = "Script Entity" },</p><p>        { ParameterType.PlayerID, en = "Player", de = "Spieler" },</p><p>        { ParameterType.Custom, en = "Type name", de = "Typbezeichnung" },</p><p>        { ParameterType.Number, en = "Orientation (in degrees)", de = "Ausrichtung (in Grad)" },</p><p>        { ParameterType.Custom, en = "Hide from AI", de = "Vor KI verstecken" },</p><p>    },</p><p>    return { Reward.Custom,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.ScriptNameEntity = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.PlayerID = _Parameter * 1</p><p>    elseif (_Index == 2) then</p><p>        self.UnitKey = _Parameter</p><p>    elseif (_Index == 3) then</p><p>        self.Orientation = _Parameter * 1</p><p>    elseif (_Index == 4) then</p><p>        self.HideFromAI = AcceptAlternativeBoolean(_Parameter)</p><p>    end</p><p>    if not IsExisting( self.ScriptNameEntity ) then</p><p>        return false</p><p>    end</p><p>    local pos = GetPosition(self.ScriptNameEntity)</p><p>    local NewID;</p><p>    if Logic.IsEntityTypeInCategory( self.UnitKey, EntityCategories.Soldier ) == 1 then</p><p>        NewID       = Logic.CreateBattalionOnUnblockedLand( Entities[self.UnitKey], pos.X, pos.Y, self.Orientation, self.PlayerID, 1 )</p><p>        local l,s = {Logic.GetSoldiersAttachedToLeader(NewID)}</p><p>        Logic.SetOrientation(s,self.Orientation)</p><p>    else</p><p>        NewID = Logic.CreateEntityOnUnblockedLand( Entities[self.UnitKey], pos.X, pos.Y, self.Orientation, self.PlayerID )</p><p>    end</p><p>    local posID = GetID(self.ScriptNameEntity)</p><p>    if Logic.IsBuilding(posID) == 0 then</p><p>        DestroyEntity(self.ScriptNameEntity)</p><p>        Logic.SetEntityName( NewID, self.ScriptNameEntity )</p><p>    end</p><p>    if self.HideFromAI then</p><p>        AICore.HideEntityFromAI( self.PlayerID, NewID, true )</p><p>    end</p><p>    local Data = {}</p><p>    if _Index == 2 then</p><p>        for k, v in pairs( Entities ) do</p><p>            local name = {"^M_*","^XS_*","^X_*","^XT_*","^Z_*"}</p><p>            local found = false;</p><p>            for i=1,#name do</p><p>                if k:find(name[i]) then</p><p>                    found = true;</p><p>                    break;</p><p>                end</p><p>            end</p><p>            if not found then</p><p>                table.insert( Data, k );</p><p>            end</p><p>        end</p><p>        table.sort( Data )</p><p>    elseif _Index == 4 or _Index == 5 then</p><p>        table.insert( Data, "false" )</p><p>        table.insert( Data, "true" )</p><p>    else</p><p>        assert( false )</p><p>    end</p><p>    return Data</p><p>    if not Entities[self.UnitKey] then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": got an invalid entity type!");</p><p>        return true;</p><p>    elseif not IsExisting(self.ScriptNameEntity) then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": spawnpoint does not exist!");</p><p>        return true;</p><p>    elseif tonumber(self.PlayerID) == nil or self.PlayerID < 0 or self.PlayerID > 8 then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": playerID is not valid!");</p><p>        return true;</p><p>    elseif tonumber(self.Orientation) == nil then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": orientation must be a number!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Erzeugt mehrere Entities an der angegebenen Position</p><p>-- @param _Amount      Anzahl an Entities</p><p>-- @param _ScriptName  Skriptname des Entity</p><p>-- @param _PlayerID    PlayerID des Effekt</p><p>-- @param _TypeName    Einzigartiger Effektname</p><p>-- @param _Orientation Ausrichtung in °</p><p>-- @param _HideFromAI  Vor KI verstecken</p><p>-- @within Reward</p><p>    return b_Reward_CreateSeveralEntities:new(...);</p><p>Reward_CreateSeveralEntities</p><p>    Name = "Reward_CreateSeveralEntities",</p><p>    Description = {</p><p>        en = "Reward: Creating serveral battalions at the position of a entity. They retains the entities name and a _[index] suffix",</p><p>        de = "Lohn: Erzeugt mehrere Entities an der Position der Entity. Sie übernimmt den Namen der Script Entity und den Suffix _[index]",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Number, en = "Amount", de = "Anzahl" },</p><p>        { ParameterType.ScriptName, en = "Script entity", de = "Script Entity" },</p><p>        { ParameterType.PlayerID, en = "Player", de = "Spieler" },</p><p>        { ParameterType.Custom, en = "Type name", de = "Typbezeichnung" },</p><p>        { ParameterType.Number, en = "Orientation (in degrees)", de = "Ausrichtung (in Grad)" },</p><p>        { ParameterType.Custom, en = "Hide from AI", de = "Vor KI verstecken" },</p><p>    },</p><p>    return { Reward.Custom,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.Amount = _Parameter * 1</p><p>    elseif (_Index == 1) then</p><p>        self.ScriptNameEntity = _Parameter</p><p>    elseif (_Index == 2) then</p><p>        self.PlayerID = _Parameter * 1</p><p>    elseif (_Index == 3) then</p><p>        self.UnitKey = _Parameter</p><p>    elseif (_Index == 4) then</p><p>        self.Orientation = _Parameter * 1</p><p>    elseif (_Index == 5) then</p><p>        self.HideFromAI = AcceptAlternativeBoolean(_Parameter)</p><p>    end</p><p>    if not IsExisting( self.ScriptNameEntity ) then</p><p>        return false</p><p>    end</p><p>    local pos = GetPosition(self.ScriptNameEntity)</p><p>    local NewID;</p><p>    for i=1, self.Amount do</p><p>        if Logic.IsEntityTypeInCategory( self.UnitKey, EntityCategories.Soldier ) == 1 then</p><p>            NewID       = Logic.CreateBattalionOnUnblockedLand( Entities[self.UnitKey], pos.X, pos.Y, self.Orientation, self.PlayerID, 1 )</p><p>            local l,s = {Logic.GetSoldiersAttachedToLeader(NewID)}</p><p>            Logic.SetOrientation(s,self.Orientation)</p><p>        else</p><p>            NewID = Logic.CreateEntityOnUnblockedLand( Entities[self.UnitKey], pos.X, pos.Y, self.Orientation, self.PlayerID )</p><p>        end</p><p>        Logic.SetEntityName( NewID, self.ScriptNameEntity .. "_" .. i )</p><p>        if self.HideFromAI then</p><p>            AICore.HideEntityFromAI( self.PlayerID, NewID, true )</p><p>        end</p><p>    end</p><p>    local Data = {}</p><p>    if _Index == 3 then</p><p>        for k, v in pairs( Entities ) do</p><p>            local name = {"^M_*","^XS_*","^X_*","^XT_*","^Z_*"}</p><p>            local found = false;</p><p>            for i=1,#name do</p><p>                if k:find(name[i]) then</p><p>                    found = true;</p><p>                    break;</p><p>                end</p><p>            end</p><p>            if not found then</p><p>                table.insert( Data, k );</p><p>            end</p><p>        end</p><p>        table.sort( Data )</p><p>    elseif _Index == 5 or _Index == 6 then</p><p>        table.insert( Data, "false" )</p><p>        table.insert( Data, "true" )</p><p>    else</p><p>        assert( false )</p><p>    end</p><p>    return Data</p><p>    if not Entities[self.UnitKey] then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": got an invalid entity type!");</p><p>        return true;</p><p>    elseif not IsExisting(self.ScriptNameEntity) then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": spawnpoint does not exist!");</p><p>        return true;</p><p>    elseif tonumber(self.PlayerID) == nil or self.PlayerID < 1 or self.PlayerID > 8 then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": spawnpoint does not exist!");</p><p>        return true;</p><p>    elseif tonumber(self.Orientation) == nil then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": orientation must be a number!");</p><p>        return true;</p><p>    elseif tonumber(self.Amount) == nil or self.Amount < 0 then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": amount can not be negative!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Bewegt einen Siedler oder ein Battalion zum angegebenen Zielort.</p><p>-- @param _Settler     Einheit, die bewegt wird</p><p>-- @param _Destination Bewegungsziel</p><p>-- @within Reward</p><p>    return b_Reward_MoveSettler:new(...);</p><p>Reward_MoveSettler</p><p>    Name = "Reward_MoveSettler",</p><p>    Description = {</p><p>        en = "Reward: Moves a (NPC) settler to a destination. Must not be AI controlled, or it won't move",</p><p>        de = "Lohn: Bewegt einen (NPC) Siedler zu einem Zielort. Darf keinem KI Spieler gehören, ansonsten wird sich der Siedler nicht bewegen",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Settler", de = "Siedler" },</p><p>        { ParameterType.ScriptName, en = "Destination", de = "Ziel" },</p><p>    },</p><p>    return { Reward.Custom,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.ScriptNameUnit = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.ScriptNameDest = _Parameter</p><p>    end</p><p>    if Logic.IsEntityDestroyed( self.ScriptNameUnit ) or Logic.IsEntityDestroyed( self.ScriptNameDest ) then</p><p>        return false</p><p>    end</p><p>    local DestID = GetID( self.ScriptNameDest )</p><p>    local DestX, DestY = Logic.GetEntityPosition( DestID )</p><p>    if Logic.IsBuilding( DestID ) == 1 then</p><p>        DestX, DestY = Logic.GetBuildingApproachPosition( DestID )</p><p>    end</p><p>    Logic.MoveSettler( GetID( self.ScriptNameUnit ), DestX, DestY )</p><p>    if not IsExisting(self.ScriptNameUnit) then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": mover entity does not exist!");</p><p>        return true;</p><p>    elseif not IsExisting(self.ScriptNameDest) then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": destination does not exist!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der Spieler gewinnt das Spiel.</p><p>-- @within Reward</p><p>    return b_Reward_Victory:new()</p><p>Reward_Victory</p><p>    Name = "Reward_Victory",</p><p>    Description = {</p><p>        en = "Reward: The player wins the game.",</p><p>        de = "Lohn: Der Spieler gewinnt das Spiel.",</p><p>    },</p><p>    return {Reward.Victory};</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der Spieler verliert das Spiel.</p><p>-- @within Reward</p><p>    return b_Reward_Defeat:new()</p><p>Reward_Defeat</p><p>    Name = "Reward_Defeat",</p><p>    Description = {</p><p>        en = "Reward: The player loses the game.",</p><p>        de = "Lohn: Der Spieler verliert das Spiel.",</p><p>    },</p><p>    return { Reward.Custom, {self, self.CustomFunction} }</p><p>    _Quest:TerminateEventsAndStuff()</p><p>    Logic.ExecuteInLuaLocalState("GUI_Window.MissionEndScreenSetVictoryReasonText(".. g_VictoryAndDefeatType.DefeatMissionFailed ..")")</p><p>    Defeated(_Quest.ReceivingPlayer)</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Zeigt die Siegdekoration an dem Quest an.</p><p>-- Dies ist reine Optik! Der Spieler wird dadurch nicht das Spiel gewinnen.</p><p>-- @within Reward</p><p>    return b_Reward_FakeVictory:new();</p><p>Reward_FakeVictory</p><p>    Name = "Reward_FakeVictory",</p><p>    Description = {</p><p>        en = "Reward: Display a victory icon for a quest",</p><p>        de = "Lohn: Zeigt ein Siegesicon fuer diese Quest",</p><p>    },</p><p>    return { Reward.FakeVictory }</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Erzeugt eine Armee, die das angegebene Territorium angreift.</p><p>-- Die Armee wird versuchen Gebäude auf dem Territrium zu zerstören.</p><p>-- <ul></p><p>-- <li>Außenposten: Die Armee versucht den Außenposten zu zerstören</li></p><p>-- <li>Stadt: Die Armee versucht das Lagerhaus zu zerstören</li></p><p>-- </ul></p><p>-- @param _PlayerID   PlayerID der Angreifer</p><p>-- @param _SpawnPoint Skriptname des Entstehungspunkt</p><p>-- @param _Territory  Zielterritorium</p><p>-- @param _Sword      Anzahl Schwertkämpfer (Battalion)</p><p>-- @param _Bow        Anzahl Bogenschützen (Battalion)</p><p>-- @param _Cata       Anzahl Katapulte</p><p>-- @param _Towers     Anzahl Belagerungstürme</p><p>-- @param _Rams       Anzahl Rammen</p><p>-- @param _Ammo       Anzahl Munitionswagen</p><p>-- @param _Type       Typ der Soldaten</p><p>-- @param _Reuse      Freie Truppen wiederverwenden</p><p>-- @within Reward</p><p>    return b_Reward_AI_SpawnAndAttackTerritory:new(...);</p><p>Reward_AI_SpawnAndAttackTerritory</p><p>    Name = "Reward_AI_SpawnAndAttackTerritory",</p><p>    Description = {</p><p>        en = "Reward: Spawns AI troops and attacks a territory (Hint: Use for hidden quests as a surprise)",</p><p>        de = "Lohn: Erstellt KI Truppen und greift ein Territorium an (Tipp: Fuer eine versteckte Quest als Ueberraschung verwenden)",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.PlayerID, en = "AI Player", de = "KI Spieler" },</p><p>        { ParameterType.ScriptName, en = "Spawn point", de = "Erstellungsort" },</p><p>        { ParameterType.TerritoryName, en = "Territory", de = "Territorium" },</p><p>        { ParameterType.Number, en = "Sword", de = "Schwert" },</p><p>        { ParameterType.Number, en = "Bow", de = "Bogen" },</p><p>        { ParameterType.Number, en = "Catapults", de = "Katapulte" },</p><p>        { ParameterType.Number, en = "Siege towers", de = "Belagerungstuerme" },</p><p>        { ParameterType.Number, en = "Rams", de = "Rammen" },</p><p>        { ParameterType.Number, en = "Ammo carts", de = "Munitionswagen" },</p><p>        { ParameterType.Custom, en = "Soldier type", de = "Soldatentyp" },</p><p>        { ParameterType.Custom, en = "Reuse troops", de = "Verwende bestehende Truppen" },</p><p>    },</p><p>    return { Reward.Custom,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.AIPlayerID = _Parameter * 1</p><p>    elseif (_Index == 1) then</p><p>        self.Spawnpoint = _Parameter</p><p>    elseif (_Index == 2) then</p><p>        self.TerritoryID = tonumber(_Parameter)</p><p>        if not self.TerritoryID then</p><p>            self.TerritoryID = GetTerritoryIDByName(_Parameter)</p><p>        end</p><p>    elseif (_Index == 3) then</p><p>        self.NumSword = _Parameter * 1</p><p>    elseif (_Index == 4) then</p><p>        self.NumBow = _Parameter * 1</p><p>    elseif (_Index == 5) then</p><p>        self.NumCatapults = _Parameter * 1</p><p>    elseif (_Index == 6) then</p><p>        self.NumSiegeTowers = _Parameter * 1</p><p>    elseif (_Index == 7) then</p><p>        self.NumRams = _Parameter * 1</p><p>    elseif (_Index == 8) then</p><p>        self.NumAmmoCarts = _Parameter * 1</p><p>    elseif (_Index == 9) then</p><p>        if _Parameter == "Normal" or _Parameter == false then</p><p>            self.TroopType = false</p><p>        elseif _Parameter == "RedPrince" or _Parameter == true then</p><p>            self.TroopType = true</p><p>        elseif _Parameter == "Bandit" or _Parameter == 2 then</p><p>            self.TroopType = 2</p><p>        elseif _Parameter == "Cultist" or _Parameter == 3 then</p><p>            self.TroopType = 3</p><p>        else</p><p>            assert(false)</p><p>        end</p><p>    elseif (_Index == 10) then</p><p>        self.ReuseTroops = AcceptAlternativeBoolean(_Parameter)</p><p>    end</p><p>    local Data = {}</p><p>    if _Index == 9 then</p><p>        table.insert( Data, "Normal" )</p><p>        table.insert( Data, "RedPrince" )</p><p>        table.insert( Data, "Bandit" )</p><p>        if g_GameExtraNo >= 1 then</p><p>            table.insert( Data, "Cultist" )</p><p>        end</p><p>    elseif _Index == 10 then</p><p>        table.insert( Data, "false" )</p><p>        table.insert( Data, "true" )</p><p>    else</p><p>        assert( false )</p><p>    end</p><p>    return Data</p><p>    local TargetID = Logic.GetTerritoryAcquiringBuildingID( self.TerritoryID )</p><p>    if TargetID ~= 0 then</p><p>        AIScript_SpawnAndAttackCity( self.AIPlayerID, TargetID, self.Spawnpoint, self.NumSword, self.NumBow, self.NumCatapults, self.NumSiegeTowers, self.NumRams, self.NumAmmoCarts, self.TroopType, self.ReuseTroops)</p><p>    end</p><p>    if self.AIPlayerID < 2 then</p><p>        dbg(_Quest.Identifier .. ": Error in " .. self.Name .. ": Player " .. self.AIPlayerID .. " is wrong")</p><p>        return true</p><p>    elseif Logic.IsEntityDestroyed(self.Spawnpoint) then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": Entity " .. self.SpawnPoint .. " is missing")</p><p>        return true</p><p>    elseif self.TerritoryID == 0 then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": Territory unknown")</p><p>        return true</p><p>    elseif self.NumSword < 0 then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": Number of Swords is negative")</p><p>        return true</p><p>    elseif self.NumBow < 0 then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": Number of Bows is negative")</p><p>        return true</p><p>    elseif self.NumBow + self.NumSword < 1 then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": No Soldiers?")</p><p>        return true</p><p>    elseif self.NumCatapults < 0 then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": Catapults is negative")</p><p>        return true</p><p>    elseif self.NumSiegeTowers < 0 then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": SiegeTowers is negative")</p><p>        return true</p><p>    elseif self.NumRams < 0 then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": Rams is negative")</p><p>        return true</p><p>    elseif self.NumAmmoCarts < 0 then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": AmmoCarts is negative")</p><p>        return true</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Erzeugt eine Armee, die sich zum Zielpunkt bewegt und das Gebiet angreift.</p><p>-- Dabei werden die Soldaten alle erreichbaren Gebäude in Brand stecken. Ist</p><p>-- Das Zielgebiet eingemauert, können die Soldaten nicht angreifen und werden</p><p>-- sich zurückziehen.</p><p>-- @param _PlayerID   PlayerID des Angreifers</p><p>-- @param _SpawnPoint Skriptname des Entstehungspunktes</p><p>-- @param _Target     Skriptname des Ziels</p><p>-- @param _Radius     Aktionsradius um das Ziel</p><p>-- @param _Sword      Anzahl Schwertkämpfer (Battalione)</p><p>-- @param _Bow        Anzahl Bogenschützen (Battalione)</p><p>-- @param _Soldier    Typ der Soldaten</p><p>-- @param _Reuse      Freie Truppen wiederverwenden</p><p>-- @within Reward</p><p>    return b_Reward_AI_SpawnAndAttackArea:new(...);</p><p>Reward_AI_SpawnAndAttackArea</p><p>    Name = "Reward_AI_SpawnAndAttackArea",</p><p>    Description = {</p><p>        en = "Reward: Spawns AI troops and attacks everything within the specified area, except the players main buildings",</p><p>        de = "Lohn: Erstellt KI Truppen und greift ein angegebenes Gebiet an, aber nicht die Hauptgebauede eines Spielers",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.PlayerID, en = "AI Player", de = "KI Spieler" },</p><p>        { ParameterType.ScriptName, en = "Spawn point", de = "Erstellungsort" },</p><p>        { ParameterType.ScriptName, en = "Target", de = "Ziel" },</p><p>        { ParameterType.Number, en = "Radius", de = "Radius" },</p><p>        { ParameterType.Number, en = "Sword", de = "Schwert" },</p><p>        { ParameterType.Number, en = "Bow", de = "Bogen" },</p><p>        { ParameterType.Custom, en = "Soldier type", de = "Soldatentyp" },</p><p>        { ParameterType.Custom, en = "Reuse troops", de = "Verwende bestehende Truppen" },</p><p>    },</p><p>    return { Reward.Custom,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.AIPlayerID = _Parameter * 1</p><p>    elseif (_Index == 1) then</p><p>        self.Spawnpoint = _Parameter</p><p>    elseif (_Index == 2) then</p><p>        self.TargetName = _Parameter</p><p>    elseif (_Index == 3) then</p><p>        self.Radius = _Parameter * 1</p><p>    elseif (_Index == 4) then</p><p>        self.NumSword = _Parameter * 1</p><p>    elseif (_Index == 5) then</p><p>        self.NumBow = _Parameter * 1</p><p>    elseif (_Index == 6) then</p><p>        if _Parameter == "Normal" or _Parameter == false then</p><p>            self.TroopType = false</p><p>        elseif _Parameter == "RedPrince" or _Parameter == true then</p><p>            self.TroopType = true</p><p>        elseif _Parameter == "Bandit" or _Parameter == 2 then</p><p>            self.TroopType = 2</p><p>        elseif _Parameter == "Cultist" or _Parameter == 3 then</p><p>            self.TroopType = 3</p><p>        else</p><p>            assert(false)</p><p>        end</p><p>    elseif (_Index == 7) then</p><p>        self.ReuseTroops = AcceptAlternativeBoolean(_Parameter)</p><p>    end</p><p>    local Data = {}</p><p>    if _Index == 6 then</p><p>        table.insert( Data, "Normal" )</p><p>        table.insert( Data, "RedPrince" )</p><p>        table.insert( Data, "Bandit" )</p><p>        if g_GameExtraNo >= 1 then</p><p>            table.insert( Data, "Cultist" )</p><p>        end</p><p>    elseif _Index == 7 then</p><p>        table.insert( Data, "false" )</p><p>        table.insert( Data, "true" )</p><p>    else</p><p>        assert( false )</p><p>    end</p><p>    return Data</p><p>    if Logic.IsEntityAlive( self.TargetName ) and Logic.IsEntityAlive( self.Spawnpoint ) then</p><p>        local TargetID = GetID( self.TargetName )</p><p>        AIScript_SpawnAndRaidSettlement( self.AIPlayerID, TargetID, self.Spawnpoint, self.Radius, self.NumSword, self.NumBow, self.TroopType, self.ReuseTroops )</p><p>    end</p><p>    if self.AIPlayerID < 2 then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": Player " .. self.AIPlayerID .. " is wrong")</p><p>        return true</p><p>    elseif Logic.IsEntityDestroyed(self.Spawnpoint) then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": Entity " .. self.SpawnPoint .. " is missing")</p><p>        return true</p><p>    elseif Logic.IsEntityDestroyed(self.TargetName) then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": Entity " .. self.TargetName .. " is missing")</p><p>        return true</p><p>    elseif self.Radius < 1 then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": Radius is to small or negative")</p><p>        return true</p><p>    elseif self.NumSword < 0 then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": Number of Swords is negative")</p><p>        return true</p><p>    elseif self.NumBow < 0 then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": Number of Bows is negative")</p><p>        return true</p><p>    elseif self.NumBow + self.NumSword < 1 then</p><p>        dbg(_Quest.Identifier .. ": Error in " .. self.Name .. ": No Soldiers?")</p><p>        return true</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Erstellt eine Armee, die das Zielgebiet verteidigt.</p><p>-- @param _PlayerID     PlayerID des Angreifers</p><p>-- @param _SpawnPoint   Skriptname des Entstehungspunktes</p><p>-- @param _Target       Skriptname des Ziels</p><p>-- @param _Radius       Bewachtes Gebiet</p><p>-- @param _Time         Dauer der Bewachung (-1 für unendlich)</p><p>-- @param _Sword        Anzahl Schwertkämpfer (Battalione)</p><p>-- @param _Bow          Anzahl Bogenschützen (Battalione)</p><p>-- @param _CaptureCarts Soldaten greifen Karren an</p><p>-- @param _Type         Typ der Soldaten</p><p>-- @param _Reuse        Freie Truppen wiederverwenden</p><p>-- @within Reward</p><p>    return b_Reward_AI_SpawnAndProtectArea:new(...);</p><p>Reward_AI_SpawnAndProtectArea</p><p>    Name = "Reward_AI_SpawnAndProtectArea",</p><p>    Description = {</p><p>        en = "Reward: Spawns AI troops and defends a specified area",</p><p>        de = "Lohn: Erstellt KI Truppen und verteidigt ein angegebenes Gebiet",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.PlayerID, en = "AI Player", de = "KI Spieler" },</p><p>        { ParameterType.ScriptName, en = "Spawn point", de = "Erstellungsort" },</p><p>        { ParameterType.ScriptName, en = "Target", de = "Ziel" },</p><p>        { ParameterType.Number, en = "Radius", de = "Radius" },</p><p>        { ParameterType.Number, en = "Time (-1 for infinite)", de = "Zeit (-1 fuer unendlich)" },</p><p>        { ParameterType.Number, en = "Sword", de = "Schwert" },</p><p>        { ParameterType.Number, en = "Bow", de = "Bogen" },</p><p>        { ParameterType.Custom, en = "Capture tradecarts", de = "Handelskarren angreifen" },</p><p>        { ParameterType.Custom, en = "Soldier type", de = "Soldatentyp" },</p><p>        { ParameterType.Custom, en = "Reuse troops", de = "Verwende bestehende Truppen" },</p><p>    },</p><p>    return { Reward.Custom,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.AIPlayerID = _Parameter * 1</p><p>    elseif (_Index == 1) then</p><p>        self.Spawnpoint = _Parameter</p><p>    elseif (_Index == 2) then</p><p>        self.TargetName = _Parameter</p><p>    elseif (_Index == 3) then</p><p>        self.Radius = _Parameter * 1</p><p>    elseif (_Index == 4) then</p><p>        self.Time = _Parameter * 1</p><p>    elseif (_Index == 5) then</p><p>        self.NumSword = _Parameter * 1</p><p>    elseif (_Index == 6) then</p><p>        self.NumBow = _Parameter * 1</p><p>    elseif (_Index == 7) then</p><p>        self.CaptureTradeCarts = AcceptAlternativeBoolean(_Parameter)</p><p>    elseif (_Index == 8) then</p><p>        if _Parameter == "Normal" or _Parameter == true then</p><p>            self.TroopType = false</p><p>        elseif _Parameter == "RedPrince" or _Parameter == false then</p><p>            self.TroopType = true</p><p>        elseif _Parameter == "Bandit" or _Parameter == 2 then</p><p>            self.TroopType = 2</p><p>        elseif _Parameter == "Cultist" or _Parameter == 3 then</p><p>            self.TroopType = 3</p><p>        else</p><p>            assert(false)</p><p>        end</p><p>    elseif (_Index == 9) then</p><p>        self.ReuseTroops = AcceptAlternativeBoolean(_Parameter)</p><p>    end</p><p>    local Data = {}</p><p>    if _Index == 7 then</p><p>        table.insert( Data, "false" )</p><p>        table.insert( Data, "true" )</p><p>    elseif _Index == 8 then</p><p>        table.insert( Data, "Normal" )</p><p>        table.insert( Data, "RedPrince" )</p><p>        table.insert( Data, "Bandit" )</p><p>        if g_GameExtraNo >= 1 then</p><p>            table.insert( Data, "Cultist" )</p><p>        end</p><p>    elseif _Index == 9 then</p><p>        table.insert( Data, "false" )</p><p>        table.insert( Data, "true" )</p><p>    else</p><p>        assert( false )</p><p>    end</p><p>    return Data</p><p>    if Logic.IsEntityAlive( self.TargetName ) and Logic.IsEntityAlive( self.Spawnpoint ) then</p><p>        local TargetID = GetID( self.TargetName )</p><p>        AIScript_SpawnAndProtectArea( self.AIPlayerID, TargetID, self.Spawnpoint, self.Radius, self.NumSword, self.NumBow, self.Time, self.TroopType, self.ReuseTroops, self.CaptureTradeCarts )</p><p>    end</p><p>    if self.AIPlayerID < 2 then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": Player " .. self.AIPlayerID .. " is wrong")</p><p>        return true</p><p>    elseif Logic.IsEntityDestroyed(self.Spawnpoint) then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": Entity " .. self.SpawnPoint .. " is missing")</p><p>        return true</p><p>    elseif Logic.IsEntityDestroyed(self.TargetName) then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": Entity " .. self.TargetName .. " is missing")</p><p>        return true</p><p>    elseif self.Radius < 1 then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": Radius is to small or negative")</p><p>        return true</p><p>    elseif self.Time < -1 then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": Time is smaller than -1")</p><p>        return true</p><p>    elseif self.NumSword < 0 then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": Number of Swords is negative")</p><p>        return true</p><p>    elseif self.NumBow < 0 then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": Number of Bows is negative")</p><p>        return true</p><p>    elseif self.NumBow + self.NumSword < 1 then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": No Soldiers?")</p><p>        return true</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ändert die Konfiguration eines KI-Spielers.</p><p>-- Optionen:</p><p>-- <ul></p><p>-- <li>Courage/FEAR: Angstfaktor (0 bis ?)</li></p><p>-- <li>Reconstruction/BARB: Wiederaufbau von Gebäuden (0 oder 1)</li></p><p>-- <li>Build Order/BPMX: Buildorder ausführen (Nummer der Build Order)</li></p><p>-- <li>Conquer Outposts/FCOP: Außenposten einnehmen (0 oder 1)</li></p><p>-- <li>Mount Outposts/FMOP: Eigene Außenposten bemannen (0 oder 1)</li></p><p>-- <li>max. Bowmen/FMBM: Maximale Anzahl an Bogenschützen (min. 1)</li></p><p>-- <li>max. Swordmen/FMSM: Maximale Anzahl an Schwerkkämpfer (min. 1) </li></p><p>-- <li>max. Rams/FMRA: Maximale Anzahl an Rammen (min. 1)</li></p><p>-- <li>max. Catapults/FMCA: Maximale Anzahl an Katapulten (min. 1)</li></p><p>-- <li>max. Ammunition Carts/FMAC: Maximale Anzahl an Minitionswagen (min. 1)</li></p><p>-- <li>max. Siege Towers/FMST: Maximale Anzahl an Belagerungstürmen (min. 1)</li></p><p>-- <li>max. Wall Catapults/FMBA: Maximale Anzahl an Mauerkatapulten (min. 1)</li></p><p>-- </ul></p><p>-- @param _PlayerID PlayerID des KI</p><p>-- @param _Fact     Konfigurationseintrag</p><p>-- @param _Value    Neuer Wert</p><p>-- @within Reward</p><p>    return b_Reward_AI_SetNumericalFact:new(...);</p><p>Reward_AI_SetNumericalFact</p><p>    Name = "Reward_AI_SetNumericalFact",</p><p>    Description = {</p><p>        en = "Reward: Sets a numerical fact for the AI player",</p><p>        de = "Lohn: Setzt eine Verhaltensregel fuer den KI-Spieler. ",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.PlayerID, en = "AI Player",      de = "KI Spieler" },</p><p>        { ParameterType.Custom,   en = "Numerical Fact", de = "Verhaltensregel" },</p><p>        { ParameterType.Number,   en = "Value",          de = "Wert" },</p><p>    },</p><p>    return { Reward.Custom,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.AIPlayerID = _Parameter * 1</p><p>    elseif (_Index == 1) then</p><p>        -- mapping of numerical facts</p><p>        local fact = {</p><p>            ["Courage"]               = "FEAR",</p><p>            ["Reconstruction"]        = "BARB",</p><p>            ["Build Order"]           = "BPMX",</p><p>            ["Conquer Outposts"]      = "FCOP",</p><p>            ["Mount Outposts"]        = "FMOP",</p><p>            ["max. Bowmen"]           = "FMBM",</p><p>            ["max. Swordmen"]         = "FMSM",</p><p>            ["max. Rams"]             = "FMRA",</p><p>            ["max. Catapults"]        = "FMCA",</p><p>            ["max. Ammunition Carts"] = "FMAC",</p><p>            ["max. Siege Towers"]     = "FMST",</p><p>            ["max. Wall Catapults"]   = "FMBA",</p><p>            ["FEAR"]                  = "FEAR", -- > 0</p><p>            ["BARB"]                  = "BARB", -- 1 or 0</p><p>            ["BPMX"]                  = "BPMX", -- >= 0</p><p>            ["FCOP"]                  = "FCOP", -- 1 or 0</p><p>            ["FMOP"]                  = "FMOP", -- 1 or 0</p><p>            ["FMBM"]                  = "FMBM", -- >= 0</p><p>            ["FMSM"]                  = "FMSM", -- >= 0</p><p>            ["FMRA"]                  = "FMRA", -- >= 0</p><p>            ["FMCA"]                  = "FMCA", -- >= 0</p><p>            ["FMAC"]                  = "FMAC", -- >= 0</p><p>            ["FMST"]                  = "FMST", -- >= 0</p><p>            ["FMBA"]                  = "FMBA", -- >= 0</p><p>        }</p><p>        self.NumericalFact = fact[_Parameter]</p><p>    elseif (_Index == 2) then</p><p>        self.Value = _Parameter * 1</p><p>    end</p><p>    AICore.SetNumericalFact( self.AIPlayerID, self.NumericalFact, self.Value )</p><p>    if (_Index == 1) then</p><p>        return {</p><p>            "Courage",</p><p>            "Reconstruction",</p><p>            "Build Order",</p><p>            "Conquer Outposts",</p><p>            "Mount Outposts",</p><p>            "max. Bowmen",</p><p>            "max. Swordmen",</p><p>            "max. Rams",</p><p>            "max. Catapults",</p><p>            "max. Ammunition Carts",</p><p>            "max. Siege Towers",</p><p>            "max. Wall Catapults",</p><p>        };</p><p>    end</p><p>    if Logic.GetStoreHouse(self.AIPlayerID) == 0 then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": Player " .. self.AIPlayerID .. " is wrong or dead!");</p><p>        return true;</p><p>    elseif not self.NumericalFact then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": invalid numerical fact choosen!");</p><p>        return true;</p><p>    else</p><p>        if self.NumericalFact == "BARB" or self.NumericalFact == "FCOP" or self.NumericalFact == "FMOP" then</p><p>            if self.Value ~= 0 and self.Value ~= 1 then</p><p>                dbg(_Quest.Identifier .. " " .. self.Name .. ": BARB, FCOP, FMOP: value must be 1 or 0!");</p><p>                return true;</p><p>            end</p><p>        elseif self.NumericalFact == "FEAR" then</p><p>            if self.Value <= 0 then</p><p>                dbg(_Quest.Identifier .. " " .. self.Name .. ": FEAR: value must greater than 0!");</p><p>                return true;</p><p>            end</p><p>        else</p><p>            if self.Value < 0 then</p><p>                dbg(_Quest.Identifier .. " " .. self.Name .. ": value must always greater than or equal 0!");</p><p>                return true;</p><p>            end</p><p>        end</p><p>    end</p><p>    return false</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Stellt den Aggressivitätswert des KI-Spielers nachträglich ein.</p><p>-- @param _PlayerID         PlayerID des KI-Spielers</p><p>-- @param _Aggressiveness   Aggressivitätswert (1 bis 3)</p><p>-- @within Reward</p><p>    return b_Reward_AI_Aggressiveness:new(...);</p><p>Reward_AI_Aggressiveness</p><p>    Name = "Reward_AI_Aggressiveness",</p><p>    Description = {</p><p>        en = "Reward: Sets the AI player's aggressiveness.",</p><p>        de = "Lohn: Setzt die Aggressivität des KI-Spielers fest.",</p><p>    },</p><p>    Parameter =</p><p>    {</p><p>        { ParameterType.PlayerID, en = "AI player", de = "KI-Spieler" },</p><p>        { ParameterType.Custom, en = "Aggressiveness (1-3)", de = "Aggressivität (1-3)" }</p><p>    }</p><p>    return {Reward.Custom, {self, self.CustomFunction} };</p><p>    if _Index == 0 then</p><p>        self.AIPlayer = _Parameter * 1;</p><p>    elseif _Index == 1 then</p><p>        self.Aggressiveness = tonumber(_Parameter);</p><p>    end</p><p>    local player = (PlayerAIs[self.AIPlayer]</p><p>        or AIPlayerTable[self.AIPlayer]</p><p>        or AIPlayer:new(self.AIPlayer, AIPlayerProfile_City));</p><p>    PlayerAIs[self.AIPlayer] = player;</p><p>    if self.Aggressiveness >= 2 then</p><p>        player.m_ProfileLoop = AIProfile_Skirmish;</p><p>        player.Skirmish = player.Skirmish or {};</p><p>        player.Skirmish.Claim_MinTime = SkirmishDefault.Claim_MinTime + (self.Aggressiveness - 2) * 390;</p><p>        player.Skirmish.Claim_MaxTime = player.Skirmish.Claim_MinTime * 2;</p><p>    else</p><p>        player.m_ProfileLoop = AIPlayerProfile_City;</p><p>    end</p><p>    if self.AIPlayer < 2 or Logic.GetStoreHouse(self.AIPlayer) == 0 then</p><p>        dbg(_Quest.Identifier .. ": Error in " .. self.Name .. ": Player " .. self.PlayerID .. " is wrong")</p><p>        return true</p><p>    end</p><p>    assert(_Index == 1, "Error in " .. self.Name .. ": GetCustomData: Index is invalid.");</p><p>    return { "1", "2", "3" };</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Stellt den Feind des Skirmish-KI ein.</p><p>-- Der Skirmish-KI (maximale Aggressivität) kann nur einen Spieler als Feind</p><p>-- behandeln. Für gewöhnlich ist dies der menschliche Spieler.</p><p>-- @param _PlayerID      PlayerID des KI</p><p>-- @param _EnemyPlayerID PlayerID des Feindes</p><p>-- @within Reward</p><p>    return b_Reward_AI_SetEnemy:new(...);</p><p>Reward_AI_SetEnemy</p><p>    Name = "Reward_AI_SetEnemy",</p><p>    Description = {</p><p>        en = "Reward:Sets the enemy of an AI player (the AI only handles one enemy properly).",</p><p>        de = "Lohn: Legt den Feind eines KI-Spielers fest (die KI behandelt nur einen Feind korrekt).",</p><p>    },</p><p>    Parameter =</p><p>    {</p><p>        { ParameterType.PlayerID, en = "AI player", de = "KI-Spieler" },</p><p>        { ParameterType.PlayerID, en = "Enemy", de = "Feind" }</p><p>    }</p><p>    return {Reward.Custom, {self, self.CustomFunction} };</p><p>    if _Index == 0 then</p><p>        self.AIPlayer = _Parameter * 1;</p><p>    elseif _Index == 1 then</p><p>        self.Enemy = _Parameter * 1;</p><p>    end</p><p>    local player = PlayerAIs[self.AIPlayer];</p><p>    if player and player.Skirmish then</p><p>        player.Skirmish.Enemy = self.Enemy;</p><p>    end</p><p>    if self.AIPlayer <= 1 or self.AIPlayer >= 8 or Logic.PlayerGetIsHumanFlag(self.AIPlayer) then</p><p>        dbg(_Quest.Identifier .. ": Error in " .. self.Name .. ": Player " .. self.AIPlayer .. " is wrong")</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ein Entity wird durch ein neues anderen Typs ersetzt.</p><p>-- Das neue Entity übernimmt Skriptname und Ausrichtung des alten Entity.</p><p>-- @param _Entity Skriptname oder ID des Entity</p><p>-- @param _Type   Neuer Typ des Entity</p><p>-- @param _Owner  Besitzer des Entity</p><p>-- @within Reward</p><p>    return b_Reward_ReplaceEntity:new(...);</p><p>Reward_ReplaceEntity = API.InstanceTable(b_Reprisal_ReplaceEnti</p><p>Reward_ReplaceEntity.Name = "Reward_ReplaceEnti</p><p>Reward_ReplaceEntity.Description.en = "Reward: Replaces an entity with a new one of a different type. The playerID can be changed to</p><p>Reward_ReplaceEntity.Description.de = "Lohn: Ersetzt eine Entity durch eine neue anderen Typs. Es kann auch die Spielerzugehörigkeit geändert werde</p><p>Reward_ReplaceEntity.GetReprisalTable = </p><p>Reward_ReplaceEntity.GetRewardTable = function(self, _Qu</p><p>    return { Reward.Custom,{self, self.CustomFunction} }</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Setzt die Menge von Rohstoffen in einer Mine.</p><p>-- <b>Achtung:</b> Im Reich des Ostens darf die Mine nicht eingestürzt sein!</p><p>-- @param _ScriptName Skriptname der Mine</p><p>-- @param _Amount     Menge an Rohstoffen</p><p>-- @within Reward</p><p>    return b_Reward_SetResourceAmount:new(...);</p><p>Reward_SetResourceAmount</p><p>    Name = "Reward_SetResourceAmount",</p><p>    Description = {</p><p>        en = "Reward: Set the current and maximum amount of a resource doodad (the amount can also set to 0)",</p><p>        de = "Lohn: Setzt die aktuellen sowie maximalen Resourcen in einem Doodad (auch 0 ist möglich)",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Ressource", de = "Resource" },</p><p>        { ParameterType.Number, en = "Amount", de = "Menge" },</p><p>    },</p><p>    return { Reward.Custom,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.ScriptName = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.Amount = _Parameter * 1</p><p>    end</p><p>    if Logic.IsEntityDestroyed( self.ScriptName ) then</p><p>        return false</p><p>    end</p><p>    local EntityID = GetID( self.ScriptName )</p><p>    if Logic.GetResourceDoodadGoodType( EntityID ) == 0 then</p><p>        return false</p><p>    end</p><p>    Logic.SetResourceDoodadGoodAmount( EntityID, self.Amount )</p><p>    if not IsExisting(self.ScriptName) then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": resource entity does not exist!")</p><p>        return true</p><p>    elseif not type(self.Amount) == "number" or self.Amount < 0 then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": resource amount can not be negative!")</p><p>        return true</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Fügt dem Lagerhaus des Auftragnehmers eine Menge an Rohstoffen hinzu.</p><p>-- @param _Type   Rohstofftyp</p><p>-- @param _Amount Menge an Rohstoffen</p><p>-- @within Reward</p><p>    return b_Reward_Resources:new(...);</p><p>Reward_Resources</p><p>    Name = "Reward_Resources",</p><p>    Description = {</p><p>        en = "Reward: The player receives a given amount of Goods in his store.",</p><p>        de = "Lohn: Legt der Partei die angegebenen Rohstoffe ins Lagerhaus.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.RawGoods, en = "Type of good", de = "Resourcentyp" },</p><p>        { ParameterType.Number, en = "Amount of good", de = "Anzahl der Resource" },</p><p>    },</p><p>    if (_Index == 0) then</p><p>        self.GoodTypeName = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.GoodAmount = _Parameter * 1</p><p>    end</p><p>    local GoodType = Logic.GetGoodTypeID(self.GoodTypeName)</p><p>    return { Reward.Resources, GoodType, self.GoodAmount }</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Entsendet einen Karren zum angegebenen Spieler.</p><p>-- Wenn der Spawnpoint ein Gebäude ist, wird der Wagen am Eingang erstellt.</p><p>-- Andernfalls kann der Spawnpoint gelöscht werden und der Wagen übernimmt</p><p>-- dann den Skriptnamen.</p><p>-- @param _ScriptName    Skriptname des Spawnpoint</p><p>-- @param _Owner         Empfänger der Lieferung</p><p>-- @param _Type          Typ des Wagens</p><p>-- @param _Good          Typ der Ware</p><p>-- @param _Amount        Menge an Waren</p><p>-- @param _OtherPlayer   Anderer Empfänger als Auftraggeber</p><p>-- @param _NoReservation Platzreservation auf dem Markt ignorieren (Sinnvoll?)</p><p>-- @param _Replace       Spawnpoint ersetzen</p><p>-- @within Reward</p><p>    return b_Reward_SendCart:new(...);</p><p>Reward_SendCart</p><p>    Name = "Reward_SendCart",</p><p>    Description = {</p><p>        en = "Reward: Sends a cart to a player. It spawns at a building or by replacing an entity. The cart can replace the entity if it's not a building.",</p><p>        de = "Lohn: Sendet einen Karren zu einem Spieler. Der Karren wird an einem Gebäude oder einer Entity erstellt. Er ersetzt die Entity, wenn diese kein Gebäude ist.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Script entity", de = "Script Entity" },</p><p>        { ParameterType.PlayerID, en = "Owning player", de = "Besitzer" },</p><p>        { ParameterType.Custom, en = "Type name", de = "Typbezeichnung" },</p><p>        { ParameterType.Custom, en = "Good type", de = "Warentyp" },</p><p>        { ParameterType.Number, en = "Amount", de = "Anzahl" },</p><p>        { ParameterType.Custom, en = "Override target player", de = "Anderer Zielspieler" },</p><p>        { ParameterType.Custom, en = "Ignore reservations", de = "Ignoriere Reservierungen" },</p><p>        { ParameterType.Custom, en = "Replace entity", de = "Entity ersetzen" },</p><p>    },</p><p>    return { Reward.Custom,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.ScriptNameEntity = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.PlayerID = _Parameter * 1</p><p>    elseif (_Index == 2) then</p><p>        self.UnitKey = _Parameter</p><p>    elseif (_Index == 3) then</p><p>        self.GoodType = _Parameter</p><p>    elseif (_Index == 4) then</p><p>        self.GoodAmount = _Parameter * 1</p><p>    elseif (_Index == 5) then</p><p>        self.OverrideTargetPlayer = tonumber(_Parameter)</p><p>    elseif (_Index == 6) then</p><p>        self.IgnoreReservation = AcceptAlternativeBoolean(_Parameter)</p><p>    elseif (_Index == 7) then</p><p>        self.ReplaceEntity = AcceptAlternativeBoolean(_Parameter)</p><p>    end</p><p>    if not IsExisting( self.ScriptNameEntity ) then</p><p>        return false;</p><p>    end</p><p>    local ID = SendCart(self.ScriptNameEntity,</p><p>                        self.PlayerID,</p><p>                        Goods[self.GoodType],</p><p>                        self.GoodAmount,</p><p>                        Entities[self.UnitKey],</p><p>                        self.IgnoreReservation    );</p><p>    if self.ReplaceEntity and Logic.IsBuilding(GetID(self.ScriptNameEntity)) == 0 then</p><p>        DestroyEntity(self.ScriptNameEntity);</p><p>        Logic.SetEntityName(ID, self.ScriptNameEntity);</p><p>    end</p><p>    if self.OverrideTargetPlayer then</p><p>        Logic.ResourceMerchant_OverrideTargetPlayerID(ID,self.OverrideTargetPlayer);</p><p>    end</p><p>    local Data = {};</p><p>    if _Index == 2 then</p><p>        Data = { "U_ResourceMerchant", "U_Medicus", "U_Marketer", "U_ThiefCart", "U_GoldCart", "U_Noblemen_Cart", "U_RegaliaCart" };</p><p>    elseif _Index == 3 then</p><p>        for k, v in pairs( Goods ) do</p><p>            if string.find( k, "^G_" ) then</p><p>                table.insert( Data, k );</p><p>            end</p><p>        end</p><p>        table.sort( Data );</p><p>    elseif _Index == 5 then</p><p>        table.insert( Data, "-" );</p><p>        for i = 1, 8 do</p><p>            table.insert( Data, i );</p><p>        end</p><p>    elseif _Index == 6 then</p><p>        table.insert( Data, "false" );</p><p>        table.insert( Data, "true" );</p><p>    elseif _Index == 7 then</p><p>        table.insert( Data, "false" );</p><p>        table.insert( Data, "true" );</p><p>    end</p><p>    return Data;</p><p>    if not IsExisting(self.ScriptNameEntity) then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": spawnpoint does not exist!");</p><p>        return true;</p><p>    elseif not tonumber(self.PlayerID) or self.PlayerID < 1 or self.PlayerID > 8 then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": got a invalid playerID!");</p><p>        return true;</p><p>    elseif not Entities[self.UnitKey] then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": entity type '"..self.UnitKey.."' is invalid!");</p><p>        return true;</p><p>    elseif not Goods[self.GoodType] then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": good type '"..self.GoodType.."' is invalid!");</p><p>        return true;</p><p>    elseif not tonumber(self.GoodAmount) or self.GoodAmount < 1 then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": good amount can not be below 1!");</p><p>        return true;</p><p>    elseif tonumber(self.OverrideTargetPlayer) and (self.OverrideTargetPlayer < 1 or self.OverrideTargetPlayer > 8) then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": overwrite target player with invalid playerID!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Gibt dem Auftragnehmer eine Menge an Einheiten.</p><p>-- Die Einheiten erscheinen an der Burg. Hat der Spieler keine Burg, dann</p><p>-- erscheinen sie vorm Lagerhaus.</p><p>-- @param _Type   Typ der Einheit</p><p>-- @param _Amount Menge an Einheiten</p><p>-- @within Reward</p><p>    return b_Reward_Units:new(...)</p><p>Reward_Units</p><p>    Name = "Reward_Units",</p><p>    Description = {</p><p>        en = "Reward: Units",</p><p>        de = "Lohn: Einheiten",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Entity, en = "Type name", de = "Typbezeichnung" },</p><p>        { ParameterType.Number, en = "Amount", de = "Anzahl" },</p><p>    },</p><p>    if (_Index == 0) then</p><p>        self.EntityName = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.Amount = _Parameter * 1</p><p>    end</p><p>    return { Reward.Units, assert( Entities[self.EntityName] ), self.Amount }</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet einen Quest neu.</p><p>-- @param _QuestName Name des Quest</p><p>-- @within Reward</p><p>    return b_Reward_QuestRestart:new(...)</p><p>Reward_QuestRestart = API.InstanceTable(b_Reprisal_QuestResta</p><p>Reward_QuestRestart.Name = "Reward_QuestResta</p><p>Reward_QuestRestart.Description.en = "Reward: Restarts a (completed) quest so it can be triggered and completed agai</p><p>Reward_QuestRestart.Description.de = "Lohn: Startet eine (beendete) Quest neu, damit diese neu ausgelöst und beendet werden kan</p><p>Reward_QuestRestart.GetReprisalTable = </p><p>Reward_QuestRestart.GetRewardTable = function(self, _Qu</p><p>    return { Reward.Custom,{self, self.CustomFunction} }</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Lässt einen Quest fehlschlagen.</p><p>-- @param _QuestName Name des Quest</p><p>-- @within Reward</p><p>    return b_Reward_QuestFailure:new(...)</p><p>Reward_QuestFailure = API.InstanceTable(b_Reprisal_QuestFailu</p><p>Reward_QuestFailure.Name = "Reward_QuestFailu</p><p>Reward_QuestFailure.Description.en = "Reward: Lets another active quest fai</p><p>Reward_QuestFailure.Description.de = "Lohn: Lässt eine andere aktive Quest fehlschlage</p><p>Reward_QuestFailure.GetReprisalTable = </p><p>Reward_QuestFailure.GetRewardTable = function(self, _Qu</p><p>    return { Reward.Custom,{self, self.CustomFunction} }</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Wertet einen Quest als erfolgreich.</p><p>-- @param _QuestName Name des Quest</p><p>-- @within Reward</p><p>    return b_Reward_QuestSuccess:new(...)</p><p>Reward_QuestSuccess = API.InstanceTable(b_Reprisal_QuestSucce</p><p>Reward_QuestSuccess.Name = "Reward_QuestSucce</p><p>Reward_QuestSuccess.Description.en = "Reward: Completes another active quest successfull</p><p>Reward_QuestSuccess.Description.de = "Lohn: Beendet eine andere aktive Quest erfolgreic</p><p>Reward_QuestSuccess.GetReprisalTable = </p><p>Reward_QuestSuccess.GetRewardTable = function(self, _Qu</p><p>    return { Reward.Custom,{self, self.CustomFunction} }</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Triggert einen Quest.</p><p>-- @param _QuestName Name des Quest</p><p>-- @within Reward</p><p>    return b_Reward_QuestActivate:new(...)</p><p>Reward_QuestActivate = API.InstanceTable(b_Reprisal_QuestActiva</p><p>Reward_QuestActivate.Name = "Reward_QuestActiva</p><p>Reward_QuestActivate.Description.en = "Reward: Activates another quest that is not triggered ye</p><p>Reward_QuestActivate.Description.de = "Lohn: Aktiviert eine andere Quest die noch nicht ausgelöst wurd</p><p>Reward_QuestActivate.GetReprisalTable = </p><p>Reward_QuestActivate.GetRewardTable = function(self, _Qu</p><p>    return {Reward.Custom, {self, self.CustomFunction} }</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Unterbricht einen Quest.</p><p>-- @param _QuestName Name des Quest</p><p>-- @within Reward</p><p>    return b_Reward_QuestInterrupt:new(...)</p><p>Reward_QuestInterrupt = API.InstanceTable(b_Reprisal_QuestInterru</p><p>Reward_QuestInterrupt.Name = "Reward_QuestInterru</p><p>Reward_QuestInterrupt.Description.en = "Reward: Interrupts another active quest without success or failur</p><p>Reward_QuestInterrupt.Description.de = "Lohn: Beendet eine andere aktive Quest ohne Erfolg oder Misserfol</p><p>Reward_QuestInterrupt.GetReprisalTable = </p><p>Reward_QuestInterrupt.GetRewardTable = function(self, _Qu</p><p>    return { Reward.Custom,{self, self.CustomFunction} }</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Unterbricht einen Quest, selbst wenn dieser noch nicht ausgelöst wurde.</p><p>-- @param _QuestName   Name des Quest</p><p>-- @param _EndetQuests Bereits beendete unterbrechen</p><p>-- @within Reward</p><p>    return b_Reward_QuestForceInterrupt:new(...)</p><p>Reward_QuestForceInterrupt = API.InstanceTable(b_Reprisal_QuestForceInterru</p><p>Reward_QuestForceInterrupt.Name = "Reward_QuestForceInterru</p><p>Reward_QuestForceInterrupt.Description.en = "Reward: Interrupts another quest (even when it isn't active yet) without success or failur</p><p>Reward_QuestForceInterrupt.Description.de = "Lohn: Beendet eine andere Quest, auch wenn diese noch nicht aktiv ist ohne Erfolg oder Misserfol</p><p>Reward_QuestForceInterrupt.GetReprisalTable = </p><p>Reward_QuestForceInterrupt.GetRewardTable = function(self, _Qu</p><p>    return { Reward.Custom,{self, self.CustomFunction} }</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ändert den Wert einer benutzerdefinierten Variable.</p><p>-- Benutzerdefinierte Variablen können ausschließlich Zahlen sein.</p><p>---- <p>Operatoren</p></p><p>-- <ul></p><p>-- <li>= - Variablenwert wird auf den Wert gesetzt</li></p><p>-- <li>- - Variablenwert mit Wert Subtrahieren</li></p><p>-- <li>+ - Variablenwert mit Wert addieren</li></p><p>-- <li>* - Variablenwert mit Wert multiplizieren</li></p><p>-- <li>/ - Variablenwert mit Wert dividieren</li></p><p>-- <li>^ - Variablenwert mit Wert potenzieren</li></p><p>-- </ul></p><p>-- @param _Name     Name der Variable</p><p>-- @param _Operator Rechen- oder Zuweisungsoperator</p><p>-- @param _Value    Wert oder andere Custom Variable</p><p>-- @within Reward</p><p>    return b_Reward_CustomVariables:new(...);</p><p>Reward_CustomVariables = API.InstanceTable(b_Reprisal_CustomVariabl</p><p>Reward_CustomVariables.Name = "Reward_CustomVariabl</p><p>Reward_CustomVariables.Description.en = "Reward: Executes a mathematical operation with this variable. The other operand can be a number or another custom variabl</p><p>Reward_CustomVariables.Description.de = "Lohn: Fuehrt eine mathematische Operation mit der Variable aus. Der andere Operand kann eine Zahl oder eine Custom-Varible sei</p><p>Reward_CustomVariables.GetReprisalTable = </p><p>Reward_CustomVariables.GetRewardTable = function(self, _Qu</p><p>    return { Reward.Custom, {self, self.CustomFunction} };</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Führt eine Funktion im Skript als Reward aus.</p><p>-- @param _FunctionName Name der Funktion</p><p>-- @within Reward</p><p>    return b_Reward_MapScriptFunction:new(...);</p><p>Reward_MapScriptFunction = API.InstanceTable(b_Reprisal_MapScriptFuncti</p><p>Reward_MapScriptFunction.Name = "Reward_MapScriptFuncti</p><p>Reward_MapScriptFunction.Description.en = "Reward: Calls a function within the global map script if the quest has faile</p><p>Reward_MapScriptFunction.Description.de = "Lohn: Ruft eine Funktion im globalen Kartenskript auf, wenn die Quest fehlschläg</p><p>Reward_MapScriptFunction.GetReprisalTable = </p><p>Reward_MapScriptFunction.GetRewardTable = function(self, _Qu</p><p>    return {Reward.Custom, {self, self.CustomFunction}};</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Erlaubt oder verbietet einem Spieler eine Technologie.</p><p>-- @param _PlayerID   ID des Spielers</p><p>-- @param _Lock       Sperren/Entsperren</p><p>-- @param _Technology Name der Technologie</p><p>-- @within Reward</p><p>    return b_Reward_Technology:new(...);</p><p>Reward_Technology = API.InstanceTable(b_Reprisal_Technolo</p><p>Reward_Technology.Name = "Reward_Technolo</p><p>Reward_Technology.Description.en = "Reward: Locks or unlocks a technology for the given playe</p><p>Reward_Technology.Description.de = "Lohn: Sperrt oder erlaubt eine Technolgie fuer den angegebenen Playe</p><p>Reward_Technology.GetReprisalTable = </p><p>Reward_Technology.GetRewardTable = function(self, _Qu</p><p>    return { Reward.Custom, {self, self.CustomFunction} }</p><p>-- Gibt dem Auftragnehmer eine Anzahl an Prestigepunkten.</p><p>-- @param _Amount Menge an Prestige</p><p>-- @within Reward</p><p>    return b_Reward_PrestigePoints:mew(...);</p><p>Reward_PrestigePoints </p><p>    Name = "Reward_PrestigePoints",</p><p>    Description = {</p><p>        en = "Reward: Prestige",</p><p>        de = "Lohn: Prestige",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Number, en = "Points", de = "Punkte" },</p><p>    },</p><p>    if (_Index == 0) then</p><p>        self.Points = _Parameter</p><p>    end</p><p>    return { Reward.PrestigePoints, self.Points }</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Besetzt einen Außenposten mit Soldaten.</p><p>-- @param _ScriptName Skriptname des Außenposten</p><p>-- @param _Type       Soldatentyp</p><p>-- @within Reward</p><p>    return b_Reward_AI_MountOutpost:new(...);</p><p>Reward_AI_MountOutpost</p><p>    Name = "Reward_AI_MountOutpost",</p><p>    Description = {</p><p>        en = "Reward: Places a troop of soldiers on a named outpost.",</p><p>        de = "Lohn: Platziert einen Trupp Soldaten auf einem Aussenposten der KI.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Script name", de = "Skriptname" },</p><p>        { ParameterType.Custom,      en = "Soldiers type", de = "Soldatentyp" },</p><p>    },</p><p>    return { Reward.Custom,{self, self.CustomFunction} }</p><p>    if _Index == 0 then</p><p>        self.Scriptname = _Parameter</p><p>    else</p><p>        self.SoldiersType = _Parameter</p><p>    end</p><p>    local outpostID = assert(</p><p>        not Logic.IsEntityDestroyed(self.Scriptname) and GetID(self.Scriptname),</p><p>       _Quest.Identifier .. ": Error in " .. self.Name .. ": CustomFunction: Outpost is invalid"</p><p>    )</p><p>    local AIPlayerID = Logic.EntityGetPlayer(outpostID)</p><p>    local ax, ay = Logic.GetBuildingApproachPosition(outpostID)</p><p>    local TroopID = Logic.CreateBattalionOnUnblockedLand(Entities[self.SoldiersType], ax, ay, 0, AIPlayerID, 0)</p><p>    AICore.HideEntityFromAI(AIPlayerID, TroopID, true)</p><p>    Logic.CommandEntityToMountBuilding(TroopID, outpostID)</p><p>    if _Index == 1 then</p><p>        local Data = {}</p><p>        for k,v in pairs(Entities) do</p><p>            if string.find(k, "U_MilitaryBandit") or string.find(k, "U_MilitarySword") or string.find(k, "U_MilitaryBow") then</p><p>                Data[#Data+1] = k</p><p>            end</p><p>        end</p><p>        return Data</p><p>    end</p><p>    if Logic.IsEntityDestroyed(self.Scriptname) then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": Outpost " .. self.Scriptname .. " is missing")</p><p>        return true</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet einen Quest neu und lößt ihn sofort aus.</p><p>-- @param _QuestName Name des Quest</p><p>-- @within Reward</p><p>    return b_Reward_QuestRestartForceActive:new(...);</p><p>Reward_QuestRestartForceActive</p><p>    Name = "Reward_QuestRestartForceActive",</p><p>    Description = {</p><p>        en = "Reward: Restarts a (completed) quest and triggers it immediately.",</p><p>        de = "Lohn: Startet eine (beendete) Quest neu und triggert sie sofort.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.QuestName, en = "Quest name", de = "Questname" },</p><p>    },</p><p>    return { Reward.Custom,{self, self.CustomFunction} }</p><p>    assert(_Index == 0, "Error in " .. self.Name .. ": AddParameter: Index is invalid.")</p><p>    self.QuestName = _Parameter</p><p>    local QuestID, Quest = self:ResetQuest(_Quest);</p><p>    if QuestID then</p><p>        Quest:SetMsgKeyOverride()</p><p>        Quest:SetIconOverride()</p><p>        Quest:Trigger()</p><p>    end</p><p>Reward_QuestRestartForceActive.ResetQuest = b_Reward_QuestRestart.CustomFunct</p><p>    if not Quests[GetQuestID(self.QuestName)] then</p><p>        dbg(_Quest.Identifier .. ": Error in " .. self.Name .. ": Quest: "..  self.QuestName .. " does not exist");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Baut das angegebene Gabäude um eine Stufe aus.</p><p>-- <b>Achtung:</b> Ein Gebäude muss erst fertig ausgebaut sein, bevor ein</p><p>-- weiterer Ausbau begonnen werden kann!</p><p>-- @param _ScriptName Skriptname des Gebäudes</p><p>-- @within Reward</p><p>    return b_Reward_UpgradeBuilding:new(...);</p><p>Reward_UpgradeBuilding</p><p>    Name = "Reward_UpgradeBuilding",</p><p>    Description = {</p><p>        en = "Reward: Upgrades a building",</p><p>        de = "Lohn: Baut ein Gebäude aus"</p><p>    },</p><p>    Parameter =    {</p><p>        { ParameterType.ScriptName, en = "Building", de = "Gebäude" }</p><p>    }</p><p>    return {Reward.Custom, {self, self.CustomFunction}};</p><p>    if _Index == 0 then</p><p>        self.Building = _Parameter;</p><p>    end</p><p>    local building = GetID(self.Building);</p><p>    if building ~= 0</p><p>    and Logic.IsBuilding(building) == 1</p><p>    and Logic.IsBuildingUpgradable(building, true)</p><p>    and Logic.IsBuildingUpgradable(building, false)</p><p>    then</p><p>        Logic.UpgradeBuilding(building);</p><p>    end</p><p>    local building = GetID(self.Building);</p><p>    if not (building ~= 0</p><p>            and Logic.IsBuilding(building) == 1</p><p>            and Logic.IsBuildingUpgradable(building, true)</p><p>            and Logic.IsBuildingUpgradable(building, false) )</p><p>    then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": Building is wrong")</p><p>        return true</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Trigger                                                                    --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Starte den Quest, wenn ein anderer Spieler entdeckt wurde.</p><p>-- Ein Spieler ist dann entdeckt, wenn sein Heimatterritorium aufgedeckt wird.</p><p>-- @param _PlayerID Zu entdeckender Spieler</p><p>-- @within Trigger</p><p>    return b_Trigger_PlayerDiscovered:new(...);</p><p>Trigger_PlayerDiscovered</p><p>    Name = "Trigger_PlayerDiscovered",</p><p>    Description = {</p><p>        en = "Trigger: if a given player has been discovered",</p><p>        de = "Auslöser: wenn ein angegebener Spieler entdeckt wurde",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.PlayerID, en = "Player", de = "Spieler" },</p><p>    },</p><p>    return {Triggers.PlayerDiscovered, self.PlayerID}</p><p>    if (_Index == 0) then</p><p>        self.PlayerID = _Parameter * 1;</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Starte den Quest, wenn zwischen dem Empfänger und der angegebenen Partei</p><p>-- der geforderte Diplomatiestatus herrscht.</p><p>-- @param _PlayerID ID der Partei</p><p>-- @param _State    Diplomatie-Status</p><p>-- @within Trigger</p><p>    return b_Trigger_OnDiplomacy:new(...);</p><p>Trigger_OnDiplomacy</p><p>    Name = "Trigger_OnDiplomacy",</p><p>    Description = {</p><p>        en = "Trigger: if diplomatic relations have been established with a player",</p><p>        de = "Auslöser: wenn ein angegebener Diplomatie-Status mit einem Spieler erreicht wurde.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.PlayerID, en = "Player", de = "Spieler" },</p><p>        { ParameterType.DiplomacyState, en = "Relation", de = "Beziehung" },</p><p>    },</p><p>    return {Triggers.Diplomacy, self.PlayerID, assert( DiplomacyStates[self.DiplState] ) }</p><p>    if (_Index == 0) then</p><p>        self.PlayerID = _Parameter * 1</p><p>    elseif (_Index == 1) then</p><p>        self.DiplState = _Parameter</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Starte den Quest, sobald ein Bedürfnis nicht erfüllt wird.</p><p>-- @param _PlayerID ID des Spielers</p><p>-- @param _Need     Bedürfnis</p><p>-- @param _Amount   Menge an skreikenden Siedlern</p><p>-- @within Trigger</p><p>    return b_Trigger_OnNeedUnsatisfied:new(...);</p><p>Trigger_OnNeedUnsatisfied</p><p>    Name = "Trigger_OnNeedUnsatisfied",</p><p>    Description = {</p><p>        en = "Trigger: if a specified need is unsatisfied",</p><p>        de = "Auslöser: wenn ein bestimmtes Beduerfnis nicht befriedigt ist.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.PlayerID, en = "Player", de = "Spieler" },</p><p>        { ParameterType.Need, en = "Need", de = "Beduerfnis" },</p><p>        { ParameterType.Number, en = "Workers on strike", de = "Streikende Arbeiter" },</p><p>    },</p><p>    return { Triggers.Custom2,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.PlayerID = _Parameter * 1</p><p>    elseif (_Index == 1) then</p><p>        self.Need = _Parameter</p><p>    elseif (_Index == 2) then</p><p>        self.WorkersOnStrike = _Parameter * 1</p><p>    end</p><p>    return Logic.GetNumberOfStrikingWorkersPerNeed( self.PlayerID, Needs[self.Need] ) >= self.WorkersOnStrike</p><p>    if Logic.GetStoreHouse(self.PlayerID) == 0 then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": " .. self.PlayerID .. " does not exist.")</p><p>        return true</p><p>    elseif not Needs[self.Need] then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": " .. self.Need .. " does not exist.")</p><p>        return true</p><p>    elseif self.WorkersOnStrike < 0 then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": WorkersOnStrike value negative")</p><p>        return true</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet den Quest, wenn die angegebene Mine erschöpft ist.</p><p>-- @param _ScriptName Skriptname der Mine</p><p>-- @within Trigger</p><p>    return b_Trigger_OnResourceDepleted:new(...);</p><p>Trigger_OnResourceDepleted</p><p>    Name = "Trigger_OnResourceDepleted",</p><p>    Description = {</p><p>        en = "Trigger: if a resource is (temporarily) depleted",</p><p>        de = "Auslöser: wenn eine Ressource (zeitweilig) verbraucht ist",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Script name", de = "Skriptname" },</p><p>    },</p><p>    return { Triggers.Custom2,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.ScriptName = _Parameter</p><p>    end</p><p>    local ID = GetID(self.ScriptName)</p><p>    return not ID or ID == 0 or Logic.GetResourceDoodadGoodType(ID) == 0 or Logic.GetResourceDoodadGoodAmount(ID) == 0</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet den Quest, sobald der angegebene Spieler eine Menge an Rohstoffen</p><p>-- im Lagerhaus hat.</p><p>-- @param  _PlayerID ID des Spielers</p><p>-- @param  _Type     Typ des Rohstoffes</p><p>-- @param _Amount    Menge an Rohstoffen</p><p>-- @within Trigger</p><p>    return b_Trigger_OnAmountOfGoods:new(...);</p><p>Trigger_OnAmountOfGoods</p><p>    Name = "Trigger_OnAmountOfGoods",</p><p>    Description = {</p><p>        en = "Trigger: if the player has gathered a given amount of resources in his storehouse",</p><p>        de = "Auslöser: wenn der Spieler eine bestimmte Menge einer Ressource in seinem Lagerhaus hat",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.PlayerID, en = "Player", de = "Spieler" },</p><p>        { ParameterType.RawGoods, en = "Type of good", de = "Resourcentyp" },</p><p>        { ParameterType.Number, en = "Amount of good", de = "Anzahl der Resource" },</p><p>    },</p><p>    return { Triggers.Custom2,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.PlayerID = _Parameter * 1</p><p>    elseif (_Index == 1) then</p><p>        self.GoodTypeName = _Parameter</p><p>    elseif (_Index == 2) then</p><p>        self.GoodAmount = _Parameter * 1</p><p>    end</p><p>    local StoreHouseID = Logic.GetStoreHouse(self.PlayerID)</p><p>    if (StoreHouseID == 0) then</p><p>        return false</p><p>    end</p><p>    local GoodType = Logic.GetGoodTypeID(self.GoodTypeName)</p><p>    local GoodAmount = Logic.GetAmountOnOutStockByGoodType(StoreHouseID, GoodType)</p><p>    if (GoodAmount >= self.GoodAmount)then</p><p>        return true</p><p>    end</p><p>    return false</p><p>    if Logic.GetStoreHouse(self.PlayerID) == 0 then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": " .. self.PlayerID .. " does not exist.")</p><p>        return true</p><p>    elseif not Goods[self.GoodTypeName] then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": Good type is wrong.")</p><p>        return true</p><p>    elseif self.GoodAmount < 0 then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": Good amount is negative.")</p><p>        return true</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet den Quest, sobald ein anderer aktiv ist.</p><p>-- @param _QuestName Name des Quest</p><p>-- @param _Time      Wartezeit</p><p>-- return Table mit Behavior</p><p>-- @within Trigger</p><p>    return b_Trigger_OnQuestActive:new(...);</p><p>Trigger_OnQuestActive</p><p>    Name = "Trigger_OnQuestActive",</p><p>    Description = {</p><p>        en = "Trigger: if a given quest has been activated. Waiting time optional",</p><p>        de = "Auslöser: wenn eine angegebene Quest aktiviert wurde. Optional mit Wartezeit",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.QuestName, en = "Quest name", de = "Questname" },</p><p>        { ParameterType.Number,     en = "Waiting time", de = "Wartezeit"},</p><p>    },</p><p>    return { Triggers.Custom2,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.QuestName = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.WaitTime = (_Parameter ~= nil and tonumber(_Parameter)) or 0</p><p>    end</p><p>    local QuestID = GetQuestID(self.QuestName)</p><p>    if QuestID ~= nil then</p><p>        assert(type(QuestID) == "number");</p><p>        if (Quests[QuestID].State == QuestState.Active) then</p><p>            self.WasActivated = self.WasActivated or true;</p><p>        end</p><p>        if self.WasActivated then</p><p>            if self.WaitTime and self.WaitTime > 0 then</p><p>                self.WaitTimeTimer = self.WaitTimeTimer or Logic.GetTime();</p><p>                if Logic.GetTime() >= self.WaitTimeTimer + self.WaitTime then</p><p>                    return true;</p><p>                end</p><p>            else</p><p>                return true;</p><p>            end</p><p>        end</p><p>    end</p><p>    return false;</p><p>    if type(self.QuestName) ~= "string" then</p><p>        dbg("".._Quest.Identifier.." "..self.Name..": invalid quest name!");</p><p>        return true;</p><p>    elseif self.WaitTime and (type(self.WaitTime) ~= "number" or self.WaitTime < 0) then</p><p>        dbg("".._Quest.Identifier.." "..self.Name..": waitTime must be a number!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>    -- does this realy matter after interrupt?</p><p>    -- self.WaitTimeTimer = nil;</p><p>    -- self.WasActivated = nil;</p><p>    self.WaitTimeTimer = nil;</p><p>    self.WasActivated = nil;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet einen Quest, sobald ein anderer fehlschlägt.</p><p>-- @param _QuestName Name des Quest</p><p>-- @param _Time      Wartezeit</p><p>-- return Table mit Behavior</p><p>-- @within Trigger</p><p>    return b_Trigger_OnQuestFailure:new(...);</p><p>Trigger_OnQuestFailure</p><p>    Name = "Trigger_OnQuestFailure",</p><p>    Description = {</p><p>        en = "Trigger: if a given quest has failed. Waiting time optional",</p><p>        de = "Auslöser: wenn eine angegebene Quest fehlgeschlagen ist. Optional mit Wartezeit",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.QuestName,     en = "Quest name", de = "Questname" },</p><p>        { ParameterType.Number,     en = "Waiting time", de = "Wartezeit"},</p><p>    },</p><p>    return { Triggers.Custom2,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.QuestName = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.WaitTime = (_Parameter ~= nil and tonumber(_Parameter)) or 0</p><p>    end</p><p>    if (GetQuestID(self.QuestName) ~= nil) then</p><p>        local QuestID = GetQuestID(self.QuestName)</p><p>        if (Quests[QuestID].Result == QuestResult.Failure) then</p><p>            if self.WaitTime and self.WaitTime > 0 then</p><p>                self.WaitTimeTimer = self.WaitTimeTimer or Logic.GetTime();</p><p>                if Logic.GetTime() >= self.WaitTimeTimer + self.WaitTime then</p><p>                    return true;</p><p>                end</p><p>            else</p><p>                return true;</p><p>            end</p><p>        end</p><p>    end</p><p>    return false;</p><p>    if type(self.QuestName) ~= "string" then</p><p>        dbg("".._Quest.Identifier.." "..self.Name..": invalid quest name!");</p><p>        return true;</p><p>    elseif self.WaitTime and (type(self.WaitTime) ~= "number" or self.WaitTime < 0) then</p><p>        dbg("".._Quest.Identifier.." "..self.Name..": waitTime must be a number!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>    self.WaitTimeTimer = nil;</p><p>    self.WaitTimeTimer = nil;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet einen Quest, wenn ein anderer noch nicht ausgelöst wurde.</p><p>-- Der Trigger löst auch aus, wenn der Quest bereits beendet wurde, da er</p><p>-- dazu vorher ausgelöst wurden sein muss.</p><p>-- @param _QuestName Name des Quest</p><p>-- @param _Time      Wartezeit</p><p>-- return Table mit Behavior</p><p>-- @within Trigger</p><p>    return b_Trigger_OnQuestNotTriggered:new(...);</p><p>Trigger_OnQuestNotTriggered</p><p>    Name = "Trigger_OnQuestNotTriggered",</p><p>    Description = {</p><p>        en = "Trigger: if a given quest is not yet active. Should be used in combination with other triggers.",</p><p>        de = "Auslöser: wenn eine angegebene Quest noch inaktiv ist. Sollte mit weiteren Triggern kombiniert werden.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.QuestName,     en = "Quest name", de = "Questname" },</p><p>    },</p><p>    return { Triggers.Custom2,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.QuestName = _Parameter</p><p>    end</p><p>    if (GetQuestID(self.QuestName) ~= nil) then</p><p>        local QuestID = GetQuestID(self.QuestName)</p><p>        if (Quests[QuestID].State == QuestState.NotTriggered) then</p><p>            return true;</p><p>        end</p><p>    end</p><p>    return false;</p><p>    if type(self.QuestName) ~= "string" then</p><p>        dbg("".._Quest.Identifier.." "..self.Name..": invalid quest name!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet den Quest, sobald ein anderer unterbrochen wurde.</p><p>-- @param _QuestName Name des Quest</p><p>-- @param _Time      Wartezeit</p><p>-- return Table mit Behavior</p><p>-- @within Trigger</p><p>    return b_Trigger_OnQuestInterrupted:new(...);</p><p>Trigger_OnQuestInterrupted</p><p>    Name = "Trigger_OnQuestInterrupted",</p><p>    Description = {</p><p>        en = "Trigger: if a given quest has been interrupted. Should be used in combination with other triggers.",</p><p>        de = "Auslöser: wenn eine angegebene Quest abgebrochen wurde. Sollte mit weiteren Triggern kombiniert werden.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.QuestName,     en = "Quest name", de = "Questname" },</p><p>        { ParameterType.Number,     en = "Waiting time", de = "Wartezeit"},</p><p>    },</p><p>    return { Triggers.Custom2,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.QuestName = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.WaitTime = (_Parameter ~= nil and tonumber(_Parameter)) or 0</p><p>    end</p><p>    if (GetQuestID(self.QuestName) ~= nil) then</p><p>        local QuestID = GetQuestID(self.QuestName)</p><p>        if (Quests[QuestID].State == QuestState.Over and Quests[QuestID].Result == QuestResult.Interrupted) then</p><p>            if self.WaitTime and self.WaitTime > 0 then</p><p>                self.WaitTimeTimer = self.WaitTimeTimer or Logic.GetTime();</p><p>                if Logic.GetTime() >= self.WaitTimeTimer + self.WaitTime then</p><p>                    return true;</p><p>                end</p><p>            else</p><p>                return true;</p><p>            end</p><p>        end</p><p>    end</p><p>    return false;</p><p>    if type(self.QuestName) ~= "string" then</p><p>        dbg("".._Quest.Identifier.." "..self.Name..": invalid quest name!");</p><p>        return true;</p><p>    elseif self.WaitTime and (type(self.WaitTime) ~= "number" or self.WaitTime < 0) then</p><p>        dbg("".._Quest.Identifier.." "..self.Name..": waitTime must be a number!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>    self.WaitTimeTimer = nil;</p><p>    self.WaitTimeTimer = nil;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet den Quest, sobald ein anderer bendet wurde.</p><p>-- Dabei ist das Resultat egal. Der Quest kann entweder erfolgreich beendet</p><p>-- wurden oder fehlgeschlagen sein.</p><p>-- @param _QuestName Name des Quest</p><p>-- @param _Time      Wartezeit</p><p>-- return Table mit Behavior</p><p>-- @within Trigger</p><p>    return b_Trigger_OnQuestOver:new(...);</p><p>Trigger_OnQuestOver</p><p>    Name = "Trigger_OnQuestOver",</p><p>    Description = {</p><p>        en = "Trigger: if a given quest has been finished, regardless of its result. Waiting time optional",</p><p>        de = "Auslöser: wenn eine angegebene Quest beendet wurde, unabhängig von deren Ergebnis. Wartezeit optional",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.QuestName,     en = "Quest name", de = "Questname" },</p><p>        { ParameterType.Number,     en = "Waiting time", de = "Wartezeit"},</p><p>    },</p><p>    return { Triggers.Custom2,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.QuestName = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.WaitTime = (_Parameter ~= nil and tonumber(_Parameter)) or 0</p><p>    end</p><p>    if (GetQuestID(self.QuestName) ~= nil) then</p><p>        local QuestID = GetQuestID(self.QuestName)</p><p>        if (Quests[QuestID].State == QuestState.Over and Quests[QuestID].Result ~= QuestResult.Interrupted) then</p><p>            if self.WaitTime and self.WaitTime > 0 then</p><p>                self.WaitTimeTimer = self.WaitTimeTimer or Logic.GetTime();</p><p>                if Logic.GetTime() >= self.WaitTimeTimer + self.WaitTime then</p><p>                    return true;</p><p>                end</p><p>            else</p><p>                return true;</p><p>            end</p><p>        end</p><p>    end</p><p>    return false;</p><p>    if type(self.QuestName) ~= "string" then</p><p>        dbg("".._Quest.Identifier.." "..self.Name..": invalid quest name!");</p><p>        return true;</p><p>    elseif self.WaitTime and (type(self.WaitTime) ~= "number" or self.WaitTime < 0) then</p><p>        dbg("".._Quest.Identifier.." "..self.Name..": waitTime must be a number!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>    self.WaitTimeTimer = nil;</p><p>    self.WaitTimeTimer = nil;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet den Quest, sobald ein anderer Quest erfolgreich abgeschlossen wurde.</p><p>-- @param _QuestName Name des Quest</p><p>-- @param _Time      Wartezeit</p><p>-- return Table mit Behavior</p><p>-- @within Trigger</p><p>    return b_Trigger_OnQuestSuccess:new(...);</p><p>Trigger_OnQuestSuccess</p><p>    Name = "Trigger_OnQuestSuccess",</p><p>    Description = {</p><p>        en = "Trigger: if a given quest has been finished successfully. Waiting time optional",</p><p>        de = "Auslöser: wenn eine angegebene Quest erfolgreich abgeschlossen wurde. Wartezeit optional",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.QuestName,     en = "Quest name", de = "Questname" },</p><p>        { ParameterType.Number,     en = "Waiting time", de = "Wartezeit"},</p><p>    },</p><p>    return { Triggers.Custom2,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.QuestName = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.WaitTime = (_Parameter ~= nil and tonumber(_Parameter)) or 0</p><p>    end</p><p>    if (GetQuestID(self.QuestName) ~= nil) then</p><p>        local QuestID = GetQuestID(self.QuestName)</p><p>        if (Quests[QuestID].Result == QuestResult.Success) then</p><p>            if self.WaitTime and self.WaitTime > 0 then</p><p>                self.WaitTimeTimer = self.WaitTimeTimer or Logic.GetTime();</p><p>                if Logic.GetTime() >= self.WaitTimeTimer + self.WaitTime then</p><p>                    return true;</p><p>                end</p><p>            else</p><p>                return true;</p><p>            end</p><p>        end</p><p>    end</p><p>    return false;</p><p>    if type(self.QuestName) ~= "string" then</p><p>        dbg("".._Quest.Identifier.." "..self.Name..": invalid quest name!");</p><p>        return true;</p><p>    elseif self.WaitTime and (type(self.WaitTime) ~= "number" or self.WaitTime < 0) then</p><p>        dbg("".._Quest.Identifier.." "..self.Name..": waittime must be a number!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>    self.WaitTimeTimer = nil;</p><p>    self.WaitTimeTimer = nil;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet den Quest, wenn eine benutzerdefinierte Variable einen bestimmten</p><p>-- Wert angenommen hat.</p><p>-- Benutzerdefinierte Variablen müssen Zahlen sein.</p><p>-- @param _Name     Name der Variable</p><p>-- @param _Relation Vergleichsoperator</p><p>-- @param _Value    Wert oder Custom Variable</p><p>-- @within Trigger</p><p>    return b_Trigger_CustomVariables:new(...);</p><p>Trigger_CustomVariables</p><p>    Name = "Trigger_CustomVariables",</p><p>    Description = {</p><p>        en = "Trigger: if the variable has a certain value.",</p><p>        de = "Auslöser: wenn die Variable einen bestimmen Wert eingenommen hat.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Default, en = "Name of Variable", de = "Variablennamen" },</p><p>        { ParameterType.Custom,  en = "Relation", de = "Relation" },</p><p>        { ParameterType.Default, en = "Value", de = "Wert" }</p><p>    }</p><p>    return { Triggers.Custom2, {self, self.CustomFunction} };</p><p>    if _Index == 0 then</p><p>        self.VariableName = _Parameter</p><p>    elseif _Index == 1 then</p><p>        self.Relation = _Parameter</p><p>    elseif _Index == 2 then</p><p>        local value = tonumber(_Parameter);</p><p>        value = (value ~= nil and value) or _Parameter;</p><p>        self.Value = value</p><p>    end</p><p>    if _G["QSB_CustomVariables_"..self.VariableName] ~= nil then</p><p>        if self.Relation == "==" then</p><p>            return _G["QSB_CustomVariables_"..self.VariableName] == ((type(self.Value) ~= "string" and self.Value) or _G["QSB_CustomVariables_"..self.Value]);</p><p>        elseif self.Relation ~= "~=" then</p><p>            return _G["QSB_CustomVariables_"..self.VariableName] ~= ((type(self.Value) ~= "string" and self.Value) or _G["QSB_CustomVariables_"..self.Value]);</p><p>        elseif self.Relation == ">" then</p><p>            return _G["QSB_CustomVariables_"..self.VariableName] > ((type(self.Value) ~= "string" and self.Value) or _G["QSB_CustomVariables_"..self.Value]);</p><p>        elseif self.Relation == ">=" then</p><p>            return _G["QSB_CustomVariables_"..self.VariableName] >= ((type(self.Value) ~= "string" and self.Value) or _G["QSB_CustomVariables_"..self.Value]);</p><p>        elseif self.Relation == "<=" then</p><p>            return _G["QSB_CustomVariables_"..self.VariableName] <= ((type(self.Value) ~= "string" and self.Value) or _G["QSB_CustomVariables_"..self.Value]);</p><p>        else</p><p>            return _G["QSB_CustomVariables_"..self.VariableName] < ((type(self.Value) ~= "string" and self.Value) or _G["QSB_CustomVariables_"..self.Value]);</p><p>        end</p><p>    end</p><p>    return false;</p><p>    if _Index == 1 then</p><p>        return {"==", "~=", "<=", "<", ">", ">="};</p><p>    end</p><p>    local relations = {"==", "~=", "<=", "<", ">", ">="}</p><p>    local results    = {true, false, nil}</p><p>    if not _G["QSB_CustomVariables_"..self.VariableName] then</p><p>        dbg(_Quest.Identifier.." "..self.Name..": variable '"..self.VariableName.."' do not exist!");</p><p>        return true;</p><p>    elseif not Inside(self.Relation,relations) then</p><p>        dbg(_Quest.Identifier.." "..self.Name..": '"..self.Relation.."' is an invalid relation!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet den Quest sofort.</p><p>-- @within Trigger</p><p>    return b_Trigger_AlwaysActive:new()</p><p>Trigger_AlwaysActive</p><p>    Name = "Trigger_AlwaysActive",</p><p>    Description = {</p><p>        en = "Trigger: the map has been started.",</p><p>        de = "Auslöser: Start der Karte.",</p><p>    },</p><p>    return {Triggers.Time, 0 }</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet den Quest im angegebenen Monat.</p><p>-- @param _Month Monat</p><p>-- @within Trigger</p><p>    return b_Trigger_OnMonth:new(...);</p><p>Trigger_OnMonth</p><p>    Name = "Trigger_OnMonth",</p><p>    Description = {</p><p>        en = "Trigger: a specified month",</p><p>        de = "Auslöser: ein bestimmter Monat",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Custom, en = "Month", de = "Monat" },</p><p>    },</p><p>    return { Triggers.Custom2,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.Month = _Parameter * 1</p><p>    end</p><p>    return self.Month == Logic.GetCurrentMonth()</p><p>    local Data = {}</p><p>    if _Index == 0 then</p><p>        for i = 1, 12 do</p><p>            table.insert( Data, i )</p><p>        end</p><p>    else</p><p>        assert( false )</p><p>    end</p><p>    return Data</p><p>    if self.Month < 1 or self.Month > 12 then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": Month has the wrong value")</p><p>        return true</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet den Quest sobald der Monsunregen einsetzt.</p><p>-- <b>Achtung:</b> Dieses Behavior ist nur für Reich des Ostens verfügbar.</p><p>-- @within Trigger</p><p>    return b_Trigger_OnMonsoon:new();</p><p>Trigger_OnMonsoon</p><p>    Name = "Trigger_OnMonsoon",</p><p>    Description = {</p><p>        en = "Trigger: on monsoon.",</p><p>        de = "Auslöser: wenn der Monsun beginnt.",</p><p>    },</p><p>    RequiresExtraNo = 1,</p><p>    return { Triggers.Custom2,{self, self.CustomFunction} }</p><p>    if Logic.GetWeatherDoesShallowWaterFlood(0) then</p><p>        return true</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet den Quest sobald der Timer abgelaufen ist.</p><p>-- Der Timer zählt immer vom Start der Map an.</p><p>-- @param _Time Zeit bis zum Start</p><p>-- @within Trigger</p><p>    return b_Trigger_Time:new(...);</p><p>Trigger_Time</p><p>    Name = "Trigger_Time",</p><p>    Description = {</p><p>        en = "Trigger: a given amount of time since map start",</p><p>        de = "Auslöser: eine gewisse Anzahl Sekunden nach Spielbeginn",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Number, en = "Time (sec.)", de = "Zeit (Sek.)" },</p><p>    },</p><p>    return {Triggers.Time, self.Time }</p><p>    if (_Index == 0) then</p><p>        self.Time = _Parameter * 1</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet den Quest sobald das Wasser gefriert.</p><p>-- @within Trigger</p><p>    return b_Trigger_OnWaterFreezes:new();</p><p>Trigger_OnWaterFreezes</p><p>    Name = "Trigger_OnWaterFreezes",</p><p>    Description = {</p><p>        en = "Trigger: if the water starts freezing",</p><p>        de = "Auslöser: wenn die Gewässer gefrieren",</p><p>    },</p><p>    return { Triggers.Custom2,{self, self.CustomFunction} }</p><p>    if Logic.GetWeatherDoesWaterFreeze(0) then</p><p>        return true</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet den Quest niemals.</p><p>-- Quests, für die dieser Trigger gesetzt ist, müssen durch einen anderen</p><p>-- Quest über Reward_QuestActive oder Reprisal_QuestActive gestartet werden.</p><p>-- @within Trigger</p><p>    return b_Trigger_NeverTriggered:new();</p><p>Trigger_NeverTriggered</p><p>    Name = "Trigger_NeverTriggered",</p><p>    Description = {</p><p>        en = "Never triggers a Quest. The quest may be set active by Reward_QuestActivate or Reward_QuestRestartForceActive",</p><p>        de = "Löst nie eine Quest aus. Die Quest kann von Reward_QuestActivate oder Reward_QuestRestartForceActive aktiviert werden.",</p><p>    },</p><p>    return {Triggers.Custom2, {self, function() end} }</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet den Quest, sobald wenigstens einer von zwei Quests fehlschlägt.</p><p>-- @param _QuestName1 Name des ersten Quest</p><p>-- @param _QuestName2 Name des zweiten Quest</p><p>-- @within Trigger</p><p>    return b_Trigger_OnAtLeastOneQuestFailure:new(...);</p><p>Trigger_OnAtLeastOneQuestFailure</p><p>    Name = "Trigger_OnAtLeastOneQuestFailure",</p><p>    Description = {</p><p>        en = "Trigger: if one or both of the given quests have failed.",</p><p>        de = "Auslöser: wenn einer oder beide der angegebenen Aufträge fehlgeschlagen sind.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.QuestName, en = "Quest Name 1", de = "Questname 1" },</p><p>        { ParameterType.QuestName, en = "Quest Name 2", de = "Questname 2" },</p><p>    },</p><p>    return {Triggers.Custom2, {self, self.CustomFunction}};</p><p>    self.QuestTable = {};</p><p>    if (_Index == 0) then</p><p>        self.Quest1 = _Parameter;</p><p>    elseif (_Index == 1) then</p><p>        self.Quest2 = _Parameter;</p><p>    end</p><p>    local Quest1 = Quests[GetQuestID(self.Quest1)];</p><p>    local Quest2 = Quests[GetQuestID(self.Quest2)];</p><p>    if (Quest1.State == QuestState.Over and Quest1.Result == QuestResult.Failure)</p><p>    or (Quest2.State == QuestState.Over and Quest2.Result == QuestResult.Failure) then</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>    if self.Quest1 == self.Quest2 then</p><p>        dbg(_Quest.Identifier..": "..self.Name..": Both quests are identical!");</p><p>        return true;</p><p>    elseif not IsValidQuest(self.Quest1) then</p><p>        dbg(_Quest.Identifier..": "..self.Name..": Quest '"..self.Quest1.."' does not exist!");</p><p>        return true;</p><p>    elseif not IsValidQuest(self.Quest2) then</p><p>        dbg(_Quest.Identifier..": "..self.Name..": Quest '"..self.Quest2.."' does not exist!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet den Quest, sobald wenigstens einer von zwei Quests erfolgreich ist.</p><p>-- @param _QuestName1 Name des ersten Quest</p><p>-- @param _QuestName2 Name des zweiten Quest</p><p>-- @within Trigger</p><p>    return b_Trigger_OnAtLeastOneQuestSuccess:new(...);</p><p>Trigger_OnAtLeastOneQuestSuccess</p><p>    Name = "Trigger_OnAtLeastOneQuestSuccess",</p><p>    Description = {</p><p>        en = "Trigger: if one or both of the given quests are won.",</p><p>        de = "Auslöser: wenn einer oder beide der angegebenen Aufträge gewonnen wurden.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.QuestName, en = "Quest Name 1", de = "Questname 1" },</p><p>        { ParameterType.QuestName, en = "Quest Name 2", de = "Questname 2" },</p><p>    },</p><p>    return {Triggers.Custom2, {self, self.CustomFunction}};</p><p>    self.QuestTable = {};</p><p>    if (_Index == 0) then</p><p>        self.Quest1 = _Parameter;</p><p>    elseif (_Index == 1) then</p><p>        self.Quest2 = _Parameter;</p><p>    end</p><p>    local Quest1 = Quests[GetQuestID(self.Quest1)];</p><p>    local Quest2 = Quests[GetQuestID(self.Quest2)];</p><p>    if (Quest1.State == QuestState.Over and Quest1.Result == QuestResult.Success)</p><p>    or (Quest2.State == QuestState.Over and Quest2.Result == QuestResult.Success) then</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>    if self.Quest1 == self.Quest2 then</p><p>        dbg(_Quest.Identifier..": "..self.Name..": Both quests are identical!");</p><p>        return true;</p><p>    elseif not IsValidQuest(self.Quest1) then</p><p>        dbg(_Quest.Identifier..": "..self.Name..": Quest '"..self.Quest1.."' does not exist!");</p><p>        return true;</p><p>    elseif not IsValidQuest(self.Quest2) then</p><p>        dbg(_Quest.Identifier..": "..self.Name..": Quest '"..self.Quest2.."' does not exist!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet den Quest, sobald mindestens X von Y Quests erfolgreich sind.</p><p>-- @param _MinAmount   Mindestens zu erfüllen (max. 5)</p><p>-- @param _QuestAmount Anzahl geprüfter Quests (max. 5 und >= _MinAmount)</p><p>-- @param _Quest1      Name des 1. Quest</p><p>-- @param _Quest2      Name des 2. Quest</p><p>-- @param _Quest3      Name des 3. Quest</p><p>-- @param _Quest4      Name des 4. Quest</p><p>-- @param _Quest5      Name des 5. Quest</p><p>-- @within Trigger</p><p>    return b_Trigger_OnAtLeastXOfYQuestsSuccess:new(...);</p><p>Trigger_OnAtLeastXOfYQuestsSuccess</p><p>    Name = "Trigger_OnAtLeastXOfYQuestsSuccess",</p><p>    Description = {</p><p>        en = "Trigger: if at least X of Y given quests has been finished successfully.",</p><p>        de = "Auslöser: wenn X von Y angegebener Quests erfolgreich abgeschlossen wurden.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Custom, en = "Least Amount", de = "Mindest Anzahl" },</p><p>        { ParameterType.Custom, en = "Quest Amount", de = "Quest Anzahl" },</p><p>        { ParameterType.QuestName, en = "Quest name 1", de = "Questname 1" },</p><p>        { ParameterType.QuestName, en = "Quest name 2", de = "Questname 2" },</p><p>        { ParameterType.QuestName, en = "Quest name 3", de = "Questname 3" },</p><p>        { ParameterType.QuestName, en = "Quest name 4", de = "Questname 4" },</p><p>        { ParameterType.QuestName, en = "Quest name 5", de = "Questname 5" },</p><p>    },</p><p>    return { Triggers.Custom2,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.LeastAmount = tonumber(_Parameter)</p><p>    elseif (_Index == 1) then</p><p>        self.QuestAmount = tonumber(_Parameter)</p><p>    elseif (_Index == 2) then</p><p>        self.QuestName1 = _Parameter</p><p>    elseif (_Index == 3) then</p><p>        self.QuestName2 = _Parameter</p><p>    elseif (_Index == 4) then</p><p>        self.QuestName3 = _Parameter</p><p>    elseif (_Index == 5) then</p><p>        self.QuestName4 = _Parameter</p><p>    elseif (_Index == 6) then</p><p>        self.QuestName5 = _Parameter</p><p>    end</p><p>    local least = 0</p><p>    for i = 1, self.QuestAmount do</p><p>        local QuestID = GetQuestID(self["QuestName"..i]);</p><p>        if IsValidQuest(QuestID) then</p><p>    end</p><p>    return false</p><p>    local leastAmount = self.LeastAmount</p><p>    local questAmount = self.QuestAmount</p><p>    if leastAmount <= 0 or leastAmount >5 then</p><p>        dbg(_Quest.Identifier .. ": Error in " .. self.Name .. ": LeastAmount is wrong")</p><p>        return true</p><p>    elseif questAmount <= 0 or questAmount > 5 then</p><p>        dbg(_Quest.Identifier .. ": Error in " .. self.Name .. ": QuestAmount is wrong")</p><p>        return true</p><p>    elseif leastAmount > questAmount then</p><p>        dbg(_Quest.Identifier .. ": Error in " .. self.Name .. ": LeastAmount is greater than QuestAmount")</p><p>        return true</p><p>    end</p><p>    for i = 1, questAmount do</p><p>        if not IsValidQuest(self["QuestName"..i]) then</p><p>            dbg(_Quest.Identifier .. ": Error in " .. self.Name .. ": Quest ".. self["QuestName"..i] .. " not found")</p><p>            return true</p><p>        end</p><p>    end</p><p>    return false</p><p>    if (_Index == 0) or (_Index == 1) then</p><p>        return {"1", "2", "3", "4", "5"}</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Führt eine Funktion im Skript als Trigger aus.</p><p>-- Die Funktion muss entweder true or false zurückgeben.</p><p>-- @param _FunctionName Name der Funktion</p><p>-- @within Trigger</p><p>    return b_Trigger_MapScriptFunction:new(...);</p><p>Trigger_MapScriptFunction</p><p>    Name = "Trigger_MapScriptFunction",</p><p>    Description = {</p><p>        en = "Calls a function within the global map script. If the function returns true the quest will be started",</p><p>        de = "Ruft eine Funktion im globalen Skript auf. Wenn sie true sendet, wird die Quest gestartet.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Default, en = "Function name", de = "Funktionsname" },</p><p>    },</p><p>    return {Triggers.Custom2, {self, self.CustomFunction}};</p><p>    if (__index_ == 0) then</p><p>        self.FuncName = __parameter_</p><p>    end</p><p>    return _G[self.FuncName](self, __quest_);</p><p>    if not self.FuncName or not _G[self.FuncName] then</p><p>        local text = string.format("s Trigger_MapScriptFunction: function 's' does not exist!", __quest_.Identifier, tostring(self.FuncName));</p><p>        dbg(text);</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Veränderte Behavior (Build 1410)                                           --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der Spieler muss im Chatdialog eine Eingabe tätigen.</p><p>-- Die Eingabe wird im Quest gespeichert und kann zur späteren Verarbeitung</p><p>-- angefragt werden.</p><p>-- Das Behaviour kann auch eingesetzt werden, um ein Passwort zu prüfen.</p><p>-- In diesem Fall wird die Eingabe mit dem Passwort verglichen. Die Anzal der</p><p>-- Versuche bestimmt, wie oft falsch eingegeben werden darf.</p><p>-- Wenn die Anzahl der Versuche begrenzt ist, wird eine Srandardnachricht mit</p><p>-- den übrigen Versuchen angezeigt. Optional kann eine Nachricht angegeben</p><p>-- werden, die stattdessen nach <u>jeder</u> Falscheingabe, <u>außer</u> der</p><p>-- letzten, angezeigt wird.</p><p>-- @param _Passwords Liste der Passwörter</p><p>-- @param _Trials    Anzahl versuche (0 für unendlich)</p><p>-- @param _Message   Alternative Fehlernachricht</p><p>-- @within Goal</p><p>    return b_Goal_InputDialog:new(...);</p><p>Goal_InputDialog </p><p>    Name = "Goal_InputDialog",</p><p>    Description = {</p><p>        en = "Goal: Player must type in something. The passwords have to be seperated by ; and whitespaces will be ignored.",</p><p>        de = "Ziel: Oeffnet einen Dialog, der Spieler muss Lösungswörter eingeben. Diese sind durch ; abzutrennen. Leerzeichen werden ignoriert.",</p><p>    },</p><p>    DefaultMessage = {</p><p>        de = "Versuche bis zum Fehlschlag: ",</p><p>        en = "Trials remaining until failure: "</p><p>    },</p><p>    Parameter = {</p><p>        {ParameterType.Default, en = "Password to enter", de = "Einzugebendes Passwort" },</p><p>        {ParameterType.Number, en = "Trials till failure (0 endless)", de = "Versuche bis Fehlschlag (0 endlos)" },</p><p>        {ParameterType.Default, en = "Wrong password message", de = "Text bei Falscheingabe" },</p><p>    }</p><p>    return { Objective.Custom2, {self, self.CustomFunction}}</p><p>    if (_Index == 0) then</p><p>        self.Password = self:LowerCase(_Parameter or "");</p><p>    elseif (_Index == 1) then</p><p>        self.Trials = (_Parameter or 0) * 1;</p><p>    elseif (_Index == 2) then</p><p>        self.Message = _Parameter;</p><p>        local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>        if type(self.Message) == "table" then</p><p>            self.Message = self.Message[lang];</p><p>        end</p><p>    end</p><p>    local Box = function(_QuestName)</p><p>        if not self.Shown then</p><p>            self:InitReturnVariable(_QuestName);</p><p>            self:ShowBox();</p><p>            self.Shown = true;</p><p>        end</p><p>    end</p><p>    if not IsBriefingActive or (IsBriefingActive and IsBriefingActive() == false) then</p><p>        if (not self.Trials) or (self.Trials) == 0 then</p><p>            Box(_Quest.Identifier);</p><p>        elseif not self.Shown then</p><p>            self.TrialCounter = self.TrialCounter or self.Trials;</p><p>            Box(_Quest.Identifier);</p><p>            self.TrialCounter = self.TrialCounter - 1;</p><p>        end</p><p>        if _Quest.InputDialogResult then</p><p>            Logic.ExecuteInLuaLocalState([[</p><p>                GUI_Chat.Confirm = GUI_Chat.Confirm_Orig_Goal_InputDialog</p><p>                GUI_Chat.Confirm_Orig_Goal_InputDialog = nil</p><p>                GUI_Chat.Abort = GUI_Chat.Abort_Orig_Goal_InputDialog</p><p>                GUI_Chat.Abort_Orig_Goal_InputDialog = nil</p><p>            ]]);</p><p>            if self.Password ~= nil and self.Password ~= "" then</p><p>                self.Shown = nil;</p><p>                if self:LowerCase(_Quest.InputDialogResult) == self.Password then</p><p>                    return true;</p><p>                elseif (self.Trials == 0) or (self.Trials > 0 and self.TrialCounter > 0) then</p><p>                    self:OnWrongInput(_Quest);</p><p>                    return;</p><p>                else</p><p>                    return false;</p><p>                end</p><p>            end</p><p>            return true;</p><p>        end</p><p>    end</p><p>    if self.Trials > 0 and not self.Message then</p><p>        local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>        Logic.DEBUG_AddNote(self.DefaultMessage .. self.TrialCounter);</p><p>        return;</p><p>    end</p><p>    if self.Message then</p><p>        Logic.DEBUG_AddNote(self.Message);</p><p>    end</p><p>    _Quest.InputDialogResult = nil;</p><p>    _Text = _Text:lower(_Text);</p><p>    -- Umlaute manuell austauschen</p><p>    -- FIXME: Ausländische Umlaute auch anpassen.</p><p>    _Text = _Text:gsub("Ä", "ä");</p><p>    _Text = _Text:gsub("Ö", "ö");</p><p>    _Text = _Text:gsub("Ü", "ü");</p><p>    return _Text;</p><p>    Logic.ExecuteInLuaLocalState([[</p><p>        Input.ChatMode()</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/ChatInput",1)</p><p>        XGUIEng.SetText("/InGame/Root/Normal/ChatInput/ChatInput", "")</p><p>        XGUIEng.SetFocus("/InGame/Root/Normal/ChatInput/ChatInput")</p><p>    ]])</p><p>    Logic.ExecuteInLuaLocalState([[</p><p>        GUI_Chat.Abort_Orig_Goal_InputDialog = GUI_Chat.Abort</p><p>        GUI_Chat.Confirm_Orig_Goal_InputDialog = GUI_Chat.Confirm</p><p>        GUI_Chat.Confirm = function()</p><p>            Input.GameMode()</p><p>            XGUIEng.ShowWidget("/InGame/Root/Normal/ChatInput",0)</p><p>            local ChatMessage = XGUIEng.GetText("/InGame/Root/Normal/ChatInput/ChatInput")</p><p>            g_Chat.JustClosed = 1</p><p>            GUI.SendScriptCommand("Quests[GetQuestID(']].. _QuestName ..[[')].InputDialogResult = '"..ChatMessage.."'")</p><p>        end</p><p>        GUI_Chat.Abort = function()</p><p>        end</p><p>    ]])</p><p>    return false;</p><p>    return {12,2};</p><p>    _Quest.InputDialogResult = nil;</p><p>    self.TrialCounter = nil;</p><p>    self.Shown = nil;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Behavior Nachimplementiert(Build 1420)                                     --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet den Quest, sobald ein Effekt zerstört wird oder verschwindet.</p><p>-- @param _EffectName Name des Effekt</p><p>-- @within Trigger</p><p>    return b_Trigger_OnEffectDestroyed:new(...);</p><p>Trigger_OnEffectDestroyed</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Setzt das Upgrade Level des angegebenen Gebäudes.</p><p>-- @param _ScriptName Skriptname des Gebäudes</p><p>-- @param _Level Upgrade Level</p><p>-- @within Reward</p><p>    return b_Reward_SetBuildingUpgradeLevel:new(...);</p><p>Reward_SetBuildingUpgradeLevel</p><p> </p><p> </p><p> </p><p>    if _Index == 1 then</p><p>        return { "0", "1", "2", "3" };</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {},</p><p>    Local = {}</p><p>-- Global Script ---------------------------------------------------------------</p><p>-- Initialisiert das Bundle im globalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>-- Gibt das im Quest gespeicherte Resultat von Goal_InputDialog zurück.</p><p>-- <b>Hinweis</b>: Es wird nur die letzte Eingabe zurückgegeben.</p><p>-- @param _QuestName [string] Name des Quest</p><p>-- @return [string] Eingabe des Spielers</p><p>-- @within Internal</p><p>-- @local</p><p>    local Quest = Quests[GetQuestID(_QuestName)];</p><p>    if not Quest then</p><p>        return;</p><p>    end</p><p>    return Quest.InputDialogResult;</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundleconstructioncontrol.lua.html">
            <div class='doclink'>
                <div>BundleConstructionControl</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia BundleConstructionControl                                    # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Mit diesem Bundle kann der Bau von Gebäudetypen oder Gebäudekategorien</p><p>-- unterbunden werden. Verbote können für bestimmte Bereiche (kreisförmige</p><p>-- Gebiete um ein Zentrum) oder ganze Territorien vereinbart werden.</p><p>-- Das wichtigste Auf einen Blick:</p><p>-- <ul></p><p>-- <li></p><p>-- Den Bau von Gebäuden an bestimmten Orten steuern.<br></p><p>-- <a href="#API.BanCategoryInArea">Bau verbieten</a>,</p><p>-- <a href="#API.UnbanCategoryInArea">Bau erlauben</a></p><p>-- </li></p><p>-- </ul></p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Untersagt den Bau des Typs im Territorium.</p><p>-- @param _type      [number] Entitytyp</p><p>-- @param _territory [number] Territorium</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.BanTypeAtTerritory(Entities.B_Bakery, 1);</p><p>function API.BanTypeAtTerritory(_type, _territory)</p><p>    if GUI then</p><p>        local Territory = (type(_center) == "string" and "'" .._territory.. "'") or _territory;</p><p>        GUI.SendScriptCommand("API.BanTypeAtTerritory(" .._type.. ", " ..Territory.. ")");</p><p>        return;</p><p>    end</p><p>    if type(_territory) == "string" then</p><p>        _territory = GetTerritoryIDByName(_territory);</p><p>    end</p><p>    BundleConstructionControl.Global.Data.TerritoryBlockEntities[_type] = BundleConstructionControl.Global.Data.TerritoryBlockEntities[_type] or {};</p><p>    if not Inside(_territory, BundleConstructionControl.Global.Data.TerritoryBlockEntities[_type]) then</p><p>        table.insert(BundleConstructionControl.Global.Data.TerritoryBlockEntities[_type], _territory);</p><p>    end</p><p>-- Untersagt den Bau der Kategorie im Territorium.</p><p>-- @param _eCat      [number] Entitykategorie</p><p>-- @param _territory [number] Territorium</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.BanCategoryAtTerritory(EntityCategories.AttackableBuilding, 2);</p><p>function API.BanCategoryAtTerritory(_eCat, _territory)</p><p>    if GUI then</p><p>        local Territory = (type(_center) == "string" and "'" .._territory.. "'") or _territory;</p><p>        GUI.SendScriptCommand("API.BanTypeAtTerritory(" .._eCat.. ", " ..Territory.. ")");</p><p>        return;</p><p>    end</p><p>    if type(_territory) == "string" then</p><p>        _territory = GetTerritoryIDByName(_territory);</p><p>    end</p><p>    BundleConstructionControl.Global.Data.TerritoryBlockCategories[_eCat] = BundleConstructionControl.Global.Data.TerritoryBlockCategories[_eCat] or {};</p><p>    if not Inside(_territory, BundleConstructionControl.Global.Data.TerritoryBlockCategories[_eCat]) then</p><p>        table.insert(BundleConstructionControl.Global.Data.TerritoryBlockCategories[_eCat], _territory);</p><p>    end</p><p>-- Untersagt den Bau des Typs im Gebiet.</p><p>-- @param _type   [number] Entitytyp</p><p>-- @param _center [string] Gebietszentrum</p><p>-- @param _area   [number] Gebietsgröße</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.BanTypeInArea(Entities.B_Bakery, "groundZero", 4000);</p><p>function API.BanTypeInArea(_type, _center, _area)</p><p>    if GUI then</p><p>        local Center = (type(_center) == "string" and "'" .._center.. "'") or _center;</p><p>        GUI.SendScriptCommand("API.BanTypeInArea(" .._type.. ", " ..Center.. ", " .._area.. ")");</p><p>        return;</p><p>    end</p><p>    BundleConstructionControl.Global.Data.AreaBlockEntities[_center] = BundleConstructionControl.Global.Data.AreaBlockEntities[_center] or {};</p><p>    if not Inside(_type, BundleConstructionControl.Global.Data.AreaBlockEntities[_center], true) then</p><p>        table.insert(BundleConstructionControl.Global.Data.AreaBlockEntities[_center], {_type, _area});</p><p>    end</p><p>-- Untersagt den Bau der Kategorie im Gebiet.</p><p>-- @param _eCat   [number] Entitytyp</p><p>-- @param _center [string] Gebietszentrum</p><p>-- @param _area   [number] Gebietsgröße</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.BanTypeInArea(EntityCategories.CityBuilding, "groundZero", 4000);</p><p>function API.BanCategoryInArea(_eCat, _center, _area)</p><p>    if GUI then</p><p>        local Center = (type(_center) == "string" and "'" .._center.. "'") or _center;</p><p>        GUI.SendScriptCommand("API.BanCategoryInArea(" .._eCat.. ", " ..Center.. ", " .._area.. ")");</p><p>        return;</p><p>    end</p><p>    BundleConstructionControl.Global.Data.AreaBlockCategories[_center] = BundleConstructionControl.Global.Data.AreaBlockCategories[_center] or {};</p><p>    if not Inside(_eCat, BundleConstructionControl.Global.Data.AreaBlockCategories[_center], true) then</p><p>        table.insert(BundleConstructionControl.Global.Data.AreaBlockCategories[_center], {_eCat, _area});</p><p>    end</p><p>-- Gibt einen Typ zum Bau im Territorium wieder frei.</p><p>-- @param _type      [number] Entitytyp</p><p>-- @param _territory [number] Territorium</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.UnbanTypeAtTerritory(Entities.B_Bakery, 1);</p><p>function API.UnbanTypeAtTerritory(_type, _territory)</p><p>    if GUI then</p><p>        local Territory = (type(_center) == "string" and "'" .._territory.. "'") or _territory;</p><p>        GUI.SendScriptCommand("API.UnbanTypeAtTerritory(" .._type.. ", " ..Territory.. ")");</p><p>        return;</p><p>    end</p><p>    if type(_territory) == "string" then</p><p>        _territory = GetTerritoryIDByName(_territory);</p><p>    end</p><p>    if not BundleConstructionControl.Global.Data.TerritoryBlockEntities[_type] then</p><p>        return;</p><p>    end</p><p>    for i= #BundleConstructionControl.Global.Data.TerritoryBlockEntities[_type], 1, -1 do</p><p>        if BundleConstructionControl.Global.Data.TerritoryBlockEntities[_type][i] == _territory then</p><p>            table.remove(BundleConstructionControl.Global.Data.TerritoryBlockEntities[_type], i);</p><p>            break;</p><p>        end</p><p>    end</p><p>-- Gibt eine Kategorie zum Bau im Territorium wieder frei.</p><p>-- @param _eCat      [number] Entitykategorie</p><p>-- @param _territory [number] Territorium</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.UnbanCategoryAtTerritory(EntityCategories.AttackableBuilding, 1);</p><p>function API.UnbanCategoryAtTerritory(_eCat, _territory)</p><p>    if GUI then</p><p>        local Territory = (type(_center) == "string" and "'" .._territory.. "'") or _territory;</p><p>        GUI.SendScriptCommand("API.UnbanTypeAtTerritory(" .._eCat.. ", " ..Territory.. ")");</p><p>        return;</p><p>    end</p><p>    if type(_territory) == "string" then</p><p>        _territory = GetTerritoryIDByName(_territory);</p><p>    end</p><p>    if not BundleConstructionControl.Global.Data.TerritoryBlockCategories[_eCat] then</p><p>        return;</p><p>    end</p><p>    for i= #BundleConstructionControl.Global.Data.TerritoryBlockCategories[_eCat], 1, -1 do</p><p>        if BundleConstructionControl.Global.Data.TerritoryBlockCategories[_eCat][i] == _territory then</p><p>            table.remove(BundleConstructionControl.Global.Data.TerritoryBlockCategories[_eCat], i);</p><p>            break;</p><p>        end</p><p>    end</p><p>-- Gibt einen Typ zum Bau im Gebiet wieder frei.</p><p>-- @param _type   [number] Entitytyp</p><p>-- @param _center [string] Gebiet</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.UnbanTypeInArea(Entities.B_Bakery, "groundZero");</p><p>function API.UnbanTypeInArea(_type, _center)</p><p>    if GUI then</p><p>        local Center = (type(_center) == "string" and "'" .._center.. "'") or _center;</p><p>        GUI.SendScriptCommand("API.UnbanTypeInArea(" .._eCat.. ", " ..Center.. ")");</p><p>        return;</p><p>    end</p><p>    if not BundleConstructionControl.Global.Data.AreaBlockEntities[_center] then</p><p>        return;</p><p>    end</p><p>    for i= #BundleConstructionControl.Global.Data.AreaBlockEntities[_center], 1, -1 do</p><p>        if BundleConstructionControl.Global.Data.AreaBlockEntities[_center][i][1] == _type then</p><p>            table.remove(BundleConstructionControl.Global.Data.AreaBlockEntities[_center], i);</p><p>            break;</p><p>        end</p><p>    end</p><p>-- Gibt eine Kategorie zum Bau im Gebiet wieder frei.</p><p>-- @param _eCat   [number] Entitykategorie</p><p>-- @param _center [string] Gebiet</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.UnbanCategoryInArea(EntityCategories.CityBuilding, "groundZero");</p><p>function API.UnbanCategoryInArea(_eCat, _center)</p><p>    if GUI then</p><p>        local Center = (type(_center) == "string" and "'" .._center.. "'") or _center;</p><p>        GUI.SendScriptCommand("API.UnbanCategoryInArea(" .._type.. ", " ..Center.. ")");</p><p>        return;</p><p>    end</p><p>    if not BundleConstructionControl.Global.Data.AreaBlockCategories[_center] then</p><p>        return;</p><p>    end</p><p>    for i= #BundleConstructionControl.Global.Data.AreaBlockCategories[_center], 1, -1 do</p><p>        if BundleConstructionControl.Global.Data.AreaBlockCategories[_center][i][1] == _eCat then</p><p>            table.remove(BundleConstructionControl.Global.Data.AreaBlockCategories[_center], i);</p><p>            break;</p><p>        end</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {</p><p>        Data = {</p><p>            TerritoryBlockCategories = {},</p><p>            TerritoryBlockEntities = {},</p><p>            AreaBlockCategories = {},</p><p>            AreaBlockEntities = {},</p><p>        }</p><p>    },</p><p>-- Global Script ---------------------------------------------------------------</p><p>-- Initalisiert das Bundle im globalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    Core:AppendFunction(</p><p>        "GameCallback_CanPlayerPlaceBuilding",</p><p>        BundleConstructionControl.Global.CanPlayerPlaceBuilding</p><p>    );</p><p>-- Verhindert den Bau von Entities in Gebieten und Territorien.</p><p>-- @param _PlayerID Spieler</p><p>-- @param _Type     Gebäudetyp</p><p>-- @param _x        X-Position</p><p>-- @param _y        Y-Position</p><p>-- @within Internal</p><p>-- @local</p><p>    -- Auf Territorium ---------------------------------------------</p><p>    -- Prüfe Kategorien</p><p>    for k,v in pairs(BundleConstructionControl.Global.Data.TerritoryBlockCategories) do</p><p>        if v then</p><p>            for key, val in pairs(v) do</p><p>                if val and Logic.GetTerritoryAtPosition(_x, _y) == val then</p><p>                    if Logic.IsEntityTypeInCategory(_Type, k) == 1 then</p><p>                        return false;</p><p>                    end</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>    -- Prüfe Typen</p><p>    for k,v in pairs(BundleConstructionControl.Global.Data.TerritoryBlockEntities) do</p><p>        if v then</p><p>            for key,val in pairs(v) do</p><p>                if val and Logic.GetTerritoryAtPosition(_x, _y) == val then</p><p>                    if _Type == k then</p><p>                        return false;</p><p>                    end</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>    -- In einem Gebiet ---------------------------------------------</p><p>    -- Prüfe Kategorien</p><p>    for k, v in pairs(BundleConstructionControl.Global.Data.AreaBlockCategories) do</p><p>        if v then</p><p>            for key, val in pairs(v) do</p><p>                if Logic.IsEntityTypeInCategory(_Type, val[1]) == 1 then</p><p>                    if GetDistance(k, {X= _x, Y= _y}) < val[2] then</p><p>                        return false;</p><p>                    end</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>    -- Prüfe Typen</p><p>    for k, v in pairs(BundleConstructionControl.Global.Data.AreaBlockEntities) do</p><p>        if v then</p><p>            for key, val in pairs(v) do</p><p>                if _Type == val[1] then</p><p>                    if GetDistance(k, {X= _x, Y= _y}) < val[2] then</p><p>                        return false;</p><p>                    end</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>    return true;</p><p>-- -------------------------------------------------------------------------- --</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundledestructioncontrol.lua.html">
            <div class='doclink'>
                <div>BundleDestructionControl</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia BundleDestructionControl                                     # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ermöglicht es einzelne Gebäude, Typen oder Kategorien von Gebäuden vor</p><p>-- dem Abriss zu schützen. Ebenso kann jeglicher Abriss von Gebäuden auf</p><p>-- einem Territrium komplett unterbunden werden.</p><p>-- Das wichtigste Auf einen Blick:</p><p>-- <ul></p><p>-- <li></p><p>-- Den Abriss für bestimmte Entities steuern.<br></p><p>-- <a href="#API.ProtectCategory">Entities beschützen</a>,</p><p>-- <a href="#API.UnprotectCategory">Schutz aufheben</a></p><p>-- </li></p><p>-- </ul></p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Fügt ein Entity hinzu, dass nicht abgerissen werden darf.</p><p>-- @param _entry [string] Nicht abreißbares Entity</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.ProtectEntity("bakery");</p><p>function API.ProtectEntity(_entry)</p><p>    if not GUI then</p><p>        API.Bridge([[</p><p>            API.ProtectEntity("]].._entry..[[")</p><p>        ]]);</p><p>    else</p><p>        if not Inside(_enitry, BundleDestructionControl.Local.Data.Entities) then</p><p>            table.insert(BundleDestructionControl.Local.Data.Entities, _entry);</p><p>        end</p><p>    end</p><p>-- Fügt einen Entitytyp hinzu, der nicht abgerissen werden darf.</p><p>-- @param _entry [number] Nicht abreißbarer Typ</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.ProtectEntityType(Entities.B_Bakery);</p><p>function API.ProtectEntityType(_entry)</p><p>    if not GUI then</p><p>        API.Bridge([[</p><p>            API.ProtectEntityType(]].._entry..[[)</p><p>        ]]);</p><p>    else</p><p>        if not Inside(_enitry, BundleDestructionControl.Local.Data.EntityTypes) then</p><p>            table.insert(BundleDestructionControl.Local.Data.EntityTypes, _entry);</p><p>        end</p><p>    end</p><p>-- Fügt eine Kategorie hinzu, die nicht abgerissen werden darf.</p><p>-- @param _entry [number] Nicht abreißbare Kategorie</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.ProtectCategory(EntityCategories.CityBuilding);</p><p>function API.ProtectCategory(_entry)</p><p>    if not GUI then</p><p>        API.Bridge([[</p><p>            API.ProtectCategory(]].._entry..[[)</p><p>        ]]);</p><p>    else</p><p>        if not Inside(_enitry, BundleDestructionControl.Local.Data.EntityCategories) then</p><p>            table.insert(BundleDestructionControl.Local.Data.EntityCategories, _entry);</p><p>        end</p><p>    end</p><p>-- Fügt ein Territory hinzu, auf dem nichts abgerissen werden kann.</p><p>-- @param _entry [number] Geschütztes Territorium</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.ProtectTerritory(1);</p><p>function API.ProtectTerritory(_entry)</p><p>    if not GUI then</p><p>        API.Bridge([[</p><p>            API.ProtectTerritory(]].._entry..[[)</p><p>        ]]);</p><p>    else</p><p>        if not Inside(_entry, BundleDestructionControl.Local.Data.OnTerritory) then</p><p>            table.insert(BundleDestructionControl.Local.Data.OnTerritory, _entry);</p><p>        end</p><p>    end</p><p>-- Entfernt ein Entity, dass nicht abgerissen werden darf.</p><p>-- @param _entry [string] Nicht abreißbares Entity</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.UnprotectEntity("bakery");</p><p>function API.UnprotectEntity(_entry)</p><p>    if not GUI then</p><p>        API.Bridge([[</p><p>            API.UnprotectEntity("]].._entry..[[")</p><p>        ]]);</p><p>    else</p><p>        for i=1,#BundleDestructionControl.Local.Data.Entities do</p><p>            if BundleDestructionControl.Local.Data.Entities[i] == _entry then</p><p>                table.remove(BundleDestructionControl.Local.Data.Entities, i);</p><p>                return;</p><p>            end</p><p>        end</p><p>    end</p><p>-- Entfernt einen Entitytyp, der nicht abgerissen werden darf.</p><p>-- @param _entry [number] Nicht abreißbarer Typ</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.UnprotectEntityType(Entities.B_Bakery);</p><p>function API.UnprotectEntityType(_entry)</p><p>    if not GUI then</p><p>        API.Bridge([[</p><p>            API.UnprotectEntityType(]].._entry..[[)</p><p>        ]]);</p><p>    else</p><p>        for i=1,#BundleDestructionControl.Local.Data.EntityTypes do</p><p>            if BundleDestructionControl.Local.Data.EntityTypes[i] == _entry then</p><p>                table.remove(BundleDestructionControl.Local.Data.EntityTypes, i);</p><p>                return;</p><p>            end</p><p>        end</p><p>    end</p><p>-- Entfernt eine Kategorie, die nicht abgerissen werden darf.</p><p>-- @param _entry [number] Nicht abreißbare Kategorie</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.UnprotectCategory(EntityCategories.CityBuilding);</p><p>function API.UnprotectCategory(_entry)</p><p>    if not GUI then</p><p>        API.Bridge([[</p><p>            API.UnprotectCategory(]].._entry..[[)</p><p>        ]]);</p><p>    else</p><p>        for i=1,#BundleDestructionControl.Local.Data.EntityCategories do</p><p>            if BundleDestructionControl.Local.Data.EntityCategories[i] == _entry then</p><p>                table.remove(BundleDestructionControl.Local.Data.EntityCategories, i);</p><p>                return;</p><p>            end</p><p>        end</p><p>    end</p><p>-- Entfernt ein Territory, auf dem nichts abgerissen werden kann.</p><p>-- @param _entry [number] Geschütztes Territorium</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.UnprotectTerritory(1);</p><p>function API.UnprotectTerritory(_entry)</p><p>    if not GUI then</p><p>        API.Bridge([[</p><p>            API.UnprotectTerritory(]].._entry..[[)</p><p>        ]]);</p><p>    else</p><p>        for i=1,#BundleDestructionControl.Local.Data.OnTerritory do</p><p>            if BundleDestructionControl.Local.Data.OnTerritory[i] == _entry then</p><p>                table.remove(BundleDestructionControl.Local.Data.OnTerritory, i);</p><p>                return;</p><p>            end</p><p>        end</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Local = {</p><p>        Data = {</p><p>            Entities = {},</p><p>            EntityTypes = {},</p><p>            EntityCategories = {},</p><p>            OnTerritory = {},</p><p>        }</p><p>    },</p><p>-- Local Script ----------------------------------------------------------------</p><p>-- Initalisiert das Bundle im lokalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    Core:AppendFunction(</p><p>        "GameCallback_GUI_DeleteEntityStateBuilding",</p><p>        BundleDestructionControl.Local.DeleteEntityStateBuilding</p><p>    );</p><p>-- Verhindert den Abriss von Entities.</p><p>-- @param _BuildingID EntityID des Gebäudes</p><p>-- @within Internal</p><p>-- @local</p><p>    local eType = Logic.GetEntityType(_BuildingID);</p><p>    local eName = Logic.GetEntityName(_BuildingID);</p><p>    local tID   = GetTerritoryUnderEntity(_BuildingID);</p><p>    if Logic.IsConstructionComplete(_BuildingID) == 1 then</p><p>        -- Prüfe auf Namen</p><p>        if Inside(eName, BundleDestructionControl.Local.Data.Entities) then</p><p>            GUI.CancelBuildingKnockDown(_BuildingID);</p><p>            return;</p><p>        end</p><p>        -- Prüfe auf Typen</p><p>        if Inside(eType, BundleDestructionControl.Local.Data.EntityTypes) then</p><p>            GUI.CancelBuildingKnockDown(_BuildingID);</p><p>            return;</p><p>        end</p><p>        -- Prüfe auf Territorien</p><p>        if Inside(tID, BundleDestructionControl.Local.Data.OnTerritory) then</p><p>            GUI.CancelBuildingKnockDown(_BuildingID);</p><p>            return;</p><p>        end</p><p>        -- Prüfe auf Category</p><p>        for k,v in pairs(BundleDestructionControl.Local.Data.EntityCategories) do</p><p>            if Logic.IsEntityInCategory(_BuildingID, v) == 1 then</p><p>                GUI.CancelBuildingKnockDown(_BuildingID);</p><p>                return;</p><p>            end</p><p>        end</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundledialogwindows.lua.html">
            <div class='doclink'>
                <div>BundleDialogWindows</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia BundleDialogWindows                                          # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Mit diesem Bundle können Dialogfenster ernstellt werden. Über Dialogfenster</p><p>-- kann der Spieler informiert werden. Er kann aber auch aufgefordert werden</p><p>-- eine Antwort auf eine Frage zu geben.</p><p>-- Zudem bietet das Bundle ein Textfenster an, welches eine nicht limitierte</p><p>-- Menge an Text anzeigen kann. Erreicht der Text eine entsprechende Menge,</p><p>-- wird automatisch eine Scrollbar eingeblendet.</p><p>-- Das wichtigste Auf einen Blick:</p><p>-- <ul></p><p>-- <li></p><p>-- <a href="#API.DialogInfoBox">Dialoge anzeigen</a></p><p>-- </li></p><p>-- <li></p><p>-- <a href="#API.SimpleTextWindow">Textfenster anzeigen</a></p><p>-- </li></p><p>-- </ul></p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Öffnet einen Info-Dialog. Sollte bereits ein Dialog zu sehen sein, wird</p><p>-- der Dialog der Dialogwarteschlange hinzugefügt.</p><p>-- <b>Alias</b>: UserOpenDialog</p><p>-- @param _Title  [string] Titel des Dialog</p><p>-- @param _Text   [string] Text des Dialog</p><p>-- @param _Action [function] Callback-Funktion</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.DialogInfoBox("Wichtige Information", "Diese Information ist Spielentscheidend!");</p><p>function API.DialogInfoBox(_Title, _Text, _Action)</p><p>    if not GUI then</p><p>        API.Fatal("API.DialogInfoBox: Can only be used in the local script!");</p><p>        return;</p><p>    end</p><p>    local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>    if type(_Title) == "table" then</p><p>       _Title = _Title[lang];</p><p>    end</p><p>    if type(_Text) == "table" then</p><p>       _Text = _Text[lang];</p><p>    end</p><p>    return BundleDialogWindows.Local:OpenDialog(_Title, _Text, _Action);</p><p>-- Öffnet einen Ja-Nein-Dialog. Sollte bereits ein Dialog zu sehen sein, wird</p><p>-- der Dialog der Dialogwarteschlange hinzugefügt.</p><p>-- Um die Entscheigung des Spielers abzufragen, wird ein Callback benötigt.</p><p>-- Das Callback bekommt eine Boolean übergeben, sobald der Spieler die</p><p>-- Entscheidung getroffen hat.</p><p>-- <b>Alias</b>: UserOpenRequesterDialog</p><p>-- @param _Title    [string] Titel des Dialog</p><p>-- @param _Text     [string] Text des Dialog</p><p>-- @param _Action   [function] Callback-Funktion</p><p>-- @param _OkCancel [boolean] Okay/Abbrechen statt Ja/Nein</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- function YesNoAction(_yes)</p><p>--     if _yes then GUI.AddNote("Ja wurde gedrückt"); end</p><p>-- end</p><p>-- API.DialogRequestBox("Frage", "Möchtest du das wirklich tun?", YesNoAction, false);</p><p>function API.DialogRequestBox(_Title, _Text, _Action, _OkCancel)</p><p>    if not GUI then</p><p>        API.Fatal("API.DialogRequestBox: Can only be used in the local script!");</p><p>        return;</p><p>    end</p><p>    local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>    if type(_Title) == "table" then</p><p>       _Title = _Title[lang];</p><p>    end</p><p>    if type(_Text) == "table" then</p><p>       _Text = _Text[lang];</p><p>    end</p><p>    return BundleDialogWindows.Local:OpenRequesterDialog(_Title, _Text, _Action, _OkCancel);</p><p>-- Öffnet einen Auswahldialog. Sollte bereits ein Dialog zu sehen sein, wird</p><p>-- der Dialog der Dialogwarteschlange hinzugefügt.</p><p>-- In diesem Dialog wählt der Spieler eine Option aus einer Liste von Optionen</p><p>-- aus. Anschließend erhält das Callback den Index der selektierten Option.</p><p>-- <b>Alias</b>: UserOpenSelectionDialog</p><p>-- @param _Title  [string] Titel des Dialog</p><p>-- @param _Text   [string] Text des Dialog</p><p>-- @param _Action [function] Callback-Funktion</p><p>-- @param _List   [table] Liste der Optionen</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- function OptionsAction(_idx)</p><p>--     GUI.AddNote(_idx.. " wurde ausgewählt!");</p><p>-- end</p><p>-- local List = {"Option A", "Option B", "Option C"};</p><p>-- API.DialogSelectBox("Auswahl", "Wähle etwas aus!", OptionsAction, List);</p><p>function API.DialogSelectBox(_Title, _Text, _Action, _List)</p><p>    if not GUI then</p><p>        API.Fatal("API.DialogSelectBox: Can only be used in the local script!");</p><p>        return;</p><p>    end</p><p>    local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>    if type(_Title) == "table" then</p><p>       _Title = _Title[lang];</p><p>    end</p><p>    if type(_Text) == "table" then</p><p>       _Text = _Text[lang];</p><p>    end</p><p>    _Text = _Text .. "{cr}";</p><p>    return BundleDialogWindows.Local:OpenSelectionDialog(_Title, _Text, _Action, _List);</p><p>-- Öffnet ein einfaches Textfenster mit dem angegebenen Text.</p><p>-- Die Länge des Textes ist nicht beschränkt. Überschreitet der Text die</p><p>-- Größe des Fensters, wird automatisch eine Bildlaufleiste eingeblendet.</p><p>-- @param _Caption [string] Titel des Fensters</p><p>-- @param _Content [string] Inhalt des Fensters</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- local Text = "Lorem ipsum dolor sit amet, consetetur sadipscing elitr, "..</p><p>--              "sed diam nonumy eirmod tempor invidunt ut labore et dolore"..</p><p>--              "magna aliquyam erat, sed diam voluptua. At vero eos et"..</p><p>--              " accusam et justo duo dolores et ea rebum. Stet clita kasd"..</p><p>--              " gubergren, no sea takimata sanctus est Lorem ipsum dolor"..</p><p>--              " sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing"..</p><p>--              " elitr, sed diam nonumy eirmod tempor invidunt ut labore et"..</p><p>--              " dolore magna aliquyam erat, sed diam voluptua. At vero eos"..</p><p>--              " et accusam et justo duo dolores et ea rebum. Stet clita"..</p><p>--              " kasd gubergren, no sea takimata sanctus est Lorem ipsum"..</p><p>--              " dolor sit amet.";</p><p>-- API.SimpleTextWindow("Überschrift", Text);</p><p>function API.SimpleTextWindow(_Caption, _Content)</p><p>    local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>    if type(_Caption) == "table" then</p><p>       _Caption = _Caption[lang];</p><p>    end</p><p>    if type(_Content) == "table" then</p><p>       _Content = _Content[lang];</p><p>    end</p><p>    if not GUI then</p><p>        API.Bridge("API.SimpleTextWindow('" .._Caption.. "', '" .._Content.. "')");</p><p>        return;</p><p>    end</p><p>    BundleDialogWindows.Local.TextWindow:New(_Caption, _Content):Show();</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {</p><p>        Data = {}</p><p>    },</p><p>    Local = {</p><p>        Data = {</p><p>            Requester = {</p><p>                ActionFunction = nil,</p><p>                ActionRequester = nil,</p><p>                Next = nil,</p><p>                Queue = {},</p><p>            },</p><p>        },</p><p>        TextWindow = {</p><p>            Data = {</p><p>                Shown       = false,</p><p>                Caption     = "",</p><p>                Text        = "",</p><p>                ButtonText  = "",</p><p>                Picture     = nil,</p><p>                Action      = nil,</p><p>                Callback    = function() end,</p><p>            },</p><p>        },</p><p>    },</p><p>-- Global Script ---------------------------------------------------------------</p><p>-- Initalisiert das Bundle im globalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>-- Local Script ----------------------------------------------------------------</p><p>-- Initalisiert das Bundle im lokalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    self:DialogOverwriteOriginal();</p><p>    TextWindow = self.TextWindow;</p><p>-- Führt das Callback eines Info-Fensters oder eines Selektionsfensters aus.</p><p>-- @within Internal</p><p>-- @local</p><p>    if self.Data.Requester.ActionFunction then</p><p>        self.Data.Requester.ActionFunction(CustomGame.Knight + 1);</p><p>    end</p><p>    self:OnDialogClosed();</p><p>-- Führt das Callback eines Ja-Nein-Dialogs aus.</p><p>-- @param _yes [boolean] Gegebene Antwort</p><p>-- @within Internal</p><p>-- @local</p><p>    if self.Data.Requester.ActionRequester then</p><p>        self.Data.Requester.ActionRequester(_yes);</p><p>    end</p><p>    self:OnDialogClosed();</p><p>-- Läd den nächsten Dialog aus der Warteschlange und stellt die Speicher-Hotkeys</p><p>-- wieder her.</p><p>-- @within Internal</p><p>-- @local</p><p>    self:DialogQueueStartNext();</p><p>    self:RestoreSaveGame();</p><p>-- Startet den nächsten Dialog in der Warteschlange, sofern möglich.</p><p>-- @within Internal</p><p>-- @local</p><p>    self.Data.Requester.Next = table.remove(self.Data.Requester.Queue, 1);</p><p>    DialogQueueStartNext_HiResControl = function()</p><p>        local Entry = BundleDialogWindows.Local.Data.Requester.Next;</p><p>        if Entry and Entry[1] and Entry[2] then</p><p>            local Methode = Entry[1];</p><p>            BundleDialogWindows.Local[Methode]( BundleDialogWindows.Local, unpack(Entry[2]) );</p><p>            BundleDialogWindows.Local.Data.Requester.Next = nil;</p><p>        end</p><p>        return true;</p><p>    end</p><p>    StartSimpleHiResJob("DialogQueueStartNext_HiResControl");</p><p>-- Fügt der Dialogwarteschlange einen neuen Dialog hinten an.</p><p>-- @param _Methode [string] Dialogfunktion als String</p><p>-- @param _Args    [table] Argumente als Table</p><p>-- @within Internal</p><p>-- @local</p><p>    local Entry = {_Methode, _Args};</p><p>    table.insert(self.Data.Requester.Queue, Entry);</p><p>-- Öffnet einen Info-Dialog. Sollte bereits ein Dialog zu sehen sein, wird</p><p>-- der Dialog der Dialogwarteschlange hinzugefügt.</p><p>-- @param _Title  [string] Titel des Dialog</p><p>-- @param _Text   [string] Text des Dialog</p><p>-- @param _Action [function] Callback-Funktion</p><p>-- @within Internal</p><p>-- @local</p><p>    if XGUIEng.IsWidgetShown(RequesterDialog) == 0 then</p><p>        assert(type(_Title) == "string");</p><p>        assert(type(_Text) == "string");</p><p>        _Title = "{center}" .. _Title;</p><p>        if string.len(_Text) < 35 then</p><p>            _Text = _Text .. "{cr}";</p><p>        end</p><p>        g_MapAndHeroPreview.SelectKnight = function()</p><p>        end</p><p>        XGUIEng.ShowAllSubWidgets("/InGame/Dialog/BG",1);</p><p>        XGUIEng.ShowWidget("/InGame/Dialog/Backdrop",0);</p><p>        XGUIEng.ShowWidget(RequesterDialog,1);</p><p>        XGUIEng.ShowWidget(RequesterDialog_Yes,0);</p><p>        XGUIEng.ShowWidget(RequesterDialog_No,0);</p><p>        XGUIEng.ShowWidget(RequesterDialog_Ok,1);</p><p>        if type(_Action) == "function" then</p><p>            self.Data.Requester.ActionFunction = _Action;</p><p>            local Action = "XGUIEng.ShowWidget(RequesterDialog, 0)";</p><p>            Action = Action .. "; XGUIEng.PopPage()";</p><p>            Action = Action .. "; BundleDialogWindows.Local.Callback(BundleDialogWindows.Local)";</p><p>            XGUIEng.SetActionFunction(RequesterDialog_Ok, Action);</p><p>        else</p><p>            self.Data.Requester.ActionFunction = nil;</p><p>            local Action = "XGUIEng.ShowWidget(RequesterDialog, 0)";</p><p>            Action = Action .. "; XGUIEng.PopPage()";</p><p>            Action = Action .. "; BundleDialogWindows.Local.Callback(BundleDialogWindows.Local)";</p><p>            XGUIEng.SetActionFunction(RequesterDialog_Ok, Action);</p><p>        end</p><p>        XGUIEng.SetText(RequesterDialog_Message, "{center}" .. _Text);</p><p>        XGUIEng.SetText(RequesterDialog_Title, _Title);</p><p>        XGUIEng.SetText(RequesterDialog_Title.."White", _Title);</p><p>        XGUIEng.PushPage(RequesterDialog,false);</p><p>        XGUIEng.ShowWidget("/InGame/InGame/MainMenu/Container/QuickSave", 0);</p><p>        XGUIEng.ShowWidget("/InGame/InGame/MainMenu/Container/SaveGame", 0);</p><p>        if not KeyBindings_SaveGame_Orig_QSB_Windows then</p><p>            KeyBindings_SaveGame_Orig_QSB_Windows = KeyBindings_SaveGame;</p><p>            KeyBindings_SaveGame = function() end;</p><p>        end</p><p>    else</p><p>        self:DialogQueuePush("OpenDialog", {_Title, _Text, _Action});</p><p>    end</p><p>-- Öffnet einen Ja-Nein-Dialog. Sollte bereits ein Dialog zu sehen sein, wird</p><p>-- der Dialog der Dialogwarteschlange hinzugefügt.</p><p>-- @param _Title    [string] Titel des Dialog</p><p>-- @param _Text     [string] Text des Dialog</p><p>-- @param _Action   [function] Callback-Funktion</p><p>-- @param _OkCancel [boolean] Okay/Abbrechen statt Ja/Nein</p><p>-- @within Internal</p><p>-- @local</p><p>    if XGUIEng.IsWidgetShown(RequesterDialog) == 0 then</p><p>        assert(type(_Title) == "string");</p><p>        assert(type(_Text) == "string");</p><p>        _Title = "{center}" .. _Title;</p><p>        self:OpenDialog(_Title, _Text, _Action);</p><p>        XGUIEng.ShowWidget(RequesterDialog_Yes,1);</p><p>        XGUIEng.ShowWidget(RequesterDialog_No,1);</p><p>        XGUIEng.ShowWidget(RequesterDialog_Ok,0);</p><p>        if _OkCancel ~= nil then</p><p>            XGUIEng.SetText(RequesterDialog_Yes, XGUIEng.GetStringTableText("UI_Texts/Ok_center"));</p><p>            XGUIEng.SetText(RequesterDialog_No, XGUIEng.GetStringTableText("UI_Texts/Cancel_center"));</p><p>        else</p><p>            XGUIEng.SetText(RequesterDialog_Yes, XGUIEng.GetStringTableText("UI_Texts/Yes_center"));</p><p>            XGUIEng.SetText(RequesterDialog_No, XGUIEng.GetStringTableText("UI_Texts/No_center"));</p><p>        end</p><p>        self.Data.Requester.ActionRequester = nil;</p><p>        if _Action then</p><p>            assert(type(_Action) == "function");</p><p>            self.Data.Requester.ActionRequester = _Action;</p><p>        end</p><p>        local Action = "XGUIEng.ShowWidget(RequesterDialog, 0)";</p><p>        Action = Action .. "; XGUIEng.PopPage()";</p><p>        Action = Action .. "; BundleDialogWindows.Local.CallbackRequester(BundleDialogWindows.Local, true)";</p><p>        XGUIEng.SetActionFunction(RequesterDialog_Yes, Action);</p><p>        local Action = "XGUIEng.ShowWidget(RequesterDialog, 0)";</p><p>        Action = Action .. "; XGUIEng.PopPage()";</p><p>        Action = Action .. "; BundleDialogWindows.Local.CallbackRequester(BundleDialogWindows.Local, false)"</p><p>        XGUIEng.SetActionFunction(RequesterDialog_No, Action);</p><p>    else</p><p>        self:DialogQueuePush("OpenRequesterDialog", {_Title, _Text, _Action, _OkCancel});</p><p>    end</p><p>-- Öffnet einen Auswahldialog. Sollte bereits ein Dialog zu sehen sein, wird</p><p>-- der Dialog der Dialogwarteschlange hinzugefügt.</p><p>-- @param _Title  [string] Titel des Dialog</p><p>-- @param _Text   [string] Text des Dialog</p><p>-- @param _Action [function] Callback-Funktion</p><p>-- @param _List   [table] Liste der Optionen</p><p>-- @within Internal</p><p>-- @local</p><p>    if XGUIEng.IsWidgetShown(RequesterDialog) == 0 then</p><p>        self:OpenDialog(_Title, _Text, _Action);</p><p>        local HeroComboBoxID = XGUIEng.GetWidgetID(CustomGame.Widget.KnightsList);</p><p>        XGUIEng.ListBoxPopAll(HeroComboBoxID);</p><p>        for i=1,#_List do</p><p>            XGUIEng.ListBoxPushItem(HeroComboBoxID, _List[i] );</p><p>        end</p><p>        XGUIEng.ListBoxSetSelectedIndex(HeroComboBoxID, 0);</p><p>        CustomGame.Knight = 0;</p><p>        local Action = "XGUIEng.ShowWidget(RequesterDialog, 0)";</p><p>        Action = Action .. "; XGUIEng.PopPage()";</p><p>        Action = Action .. "; XGUIEng.PopPage()";</p><p>        Action = Action .. "; XGUIEng.PopPage()";</p><p>        Action = Action .. "; BundleDialogWindows.Local.Callback(BundleDialogWindows.Local)";</p><p>        XGUIEng.SetActionFunction(RequesterDialog_Ok, Action);</p><p>        local Container = "/InGame/Singleplayer/CustomGame/ContainerSelection/";</p><p>        XGUIEng.SetText(Container .. "HeroComboBoxMain/HeroComboBox", "");</p><p>        if _List[1] then</p><p>            XGUIEng.SetText(Container .. "HeroComboBoxMain/HeroComboBox", _List[1]);</p><p>        end</p><p>        XGUIEng.PushPage(Container .. "HeroComboBoxContainer", false);</p><p>        XGUIEng.PushPage(Container .. "HeroComboBoxMain",false);</p><p>        XGUIEng.ShowWidget(Container .. "HeroComboBoxContainer", 0);</p><p>        local screen = {GUI.GetScreenSize()};</p><p>        local x1, y1 = XGUIEng.GetWidgetScreenPosition(RequesterDialog_Ok);</p><p>        XGUIEng.SetWidgetScreenPosition(Container .. "HeroComboBoxMain", x1-25, y1-90);</p><p>        XGUIEng.SetWidgetScreenPosition(Container .. "HeroComboBoxContainer", x1-25, y1-20);</p><p>    else</p><p>        self:DialogQueuePush("OpenSelectionDialog", {_Title, _Text, _Action, _List});</p><p>    end</p><p>-- Stellt die Hotkeys zum Speichern des Spiels wieder her.</p><p>-- @within Internal</p><p>-- @local</p><p>    if BundleGameHelperFunctions and not BundleGameHelperFunctions.Local.Data.ForbidSave then</p><p>        XGUIEng.ShowWidget("/InGame/InGame/MainMenu/Container/QuickSave", 1);</p><p>        XGUIEng.ShowWidget("/InGame/InGame/MainMenu/Container/SaveGame", 1);</p><p>    end</p><p>    if KeyBindings_SaveGame_Orig_QSB_Windows then</p><p>        KeyBindings_SaveGame = KeyBindings_SaveGame_Orig_QSB_Windows;</p><p>        KeyBindings_SaveGame_Orig_QSB_Windows = nil;</p><p>    end</p><p>-- Überschreibt die originalen Dialogfunktionen, um Fehler in den vorhandenen</p><p>-- Funktionen zu vermeiden.</p><p>-- @within Internal</p><p>-- @local</p><p>    OpenDialog_Orig_Windows = OpenDialog;</p><p>    OpenDialog = function(_Message, _Title, _IsMPError)</p><p>        if XGUIEng.IsWidgetShown(RequesterDialog) == 0 then</p><p>            local Action = "XGUIEng.ShowWidget(RequesterDialog, 0)";</p><p>            Action = Action .. "; XGUIEng.PopPage()";</p><p>            XGUIEng.SetActionFunction(RequesterDialog_Ok, Action);</p><p>            OpenDialog_Orig_Windows(_Title, _Message);</p><p>        end</p><p>    end</p><p>    OpenRequesterDialog_Orig_Windows = OpenRequesterDialog;</p><p>    OpenRequesterDialog = function(_Message, _Title, action, _OkCancel, no_action)</p><p>        if XGUIEng.IsWidgetShown(RequesterDialog) == 0 then</p><p>            local Action = "XGUIEng.ShowWidget(RequesterDialog, 0)";</p><p>            Action = Action .. "; XGUIEng.PopPage()";</p><p>            XGUIEng.SetActionFunction(RequesterDialog_Yes, Action);</p><p>            local Action = "XGUIEng.ShowWidget(RequesterDialog, 0)";</p><p>            Action = Action .. "; XGUIEng.PopPage()";</p><p>            XGUIEng.SetActionFunction(RequesterDialog_No, Action);</p><p>            OpenRequesterDialog_Orig_Windows(_Message, _Title, action, _OkCancel, no_action);</p><p>        end</p><p>    end</p><p>-- Erzeugt ein Textfenster, dass einen beliebig großen Text anzeigen kann.</p><p>-- Optional kann ein Button genutzt werden, der eine Aktion ausführt, wenn</p><p>-- er gedrückt wird.</p><p>-- <p><b>Alias</b>: TextWindow:New</p></p><p>-- Parameterliste:</p><p>-- <table></p><p>-- <tr></p><p>-- <th>Index</th></p><p>-- <th>Beschreibung</th></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>1</td></p><p>-- <td>Titel des Fensters</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>2</td></p><p>-- <td>Text des Fensters</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>3</td></p><p>-- <td>Aktion nach dem Schließen</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>4</td></p><p>-- <td>Beschriftung des Buttons</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>5</td></p><p>-- <td>Callback des Buttons</td></p><p>-- </tr></p><p>-- </table></p><p>-- @param ... [mixed..] Parameterliste</p><p>-- @return [table] Instanz des konfigurierten Fensters</p><p>-- @within TextWindow</p><p>-- @local</p><p>-- @usage</p><p>-- local MyWindow = TextWindow:New("Fenster", "Das ist ein Text");</p><p>    assert(self == BundleDialogWindows.Local.TextWindow, "Can not be used from instance!")</p><p>    local window           = API.InstanceTable(self);</p><p>    window.Data.Caption    = arg[1] or window.Data.Caption;</p><p>    window.Data.Text       = arg[2] or window.Data.Text;</p><p>    window.Data.Action     = arg[3];</p><p>    window.Data.ButtonText = arg[4] or window.Data.ButtonText;</p><p>    window.Data.Callback   = arg[5] or window.Data.Callback;</p><p>    return window;</p><p>-- Fügt einen beliebigen Parameter hinzu. Parameter müssen immer als</p><p>-- Schlüssel-Wert-Paare angegeben werden und dürfen vorhandene Pare nicht</p><p>-- überschreiben.</p><p>-- <p><b>Alias</b>: TextWindow:AddParamater</p></p><p>-- @param _Key   [string] Schlüssel</p><p>-- @param _Value [mixed] Wert</p><p>-- @return self</p><p>-- @within TextWindow</p><p>-- @local</p><p>-- @usage</p><p>-- MyWindow:AddParameter("Name", "Horst");</p><p>    assert(self ~= BundleDialogWindows.Local.TextWindow, "Can not be used in static context!");</p><p>    assert(self.Data[_Key] ~= nil, "Key '" .._Key.. "' already exists!");</p><p>    self.Data[_Key] = _Value;</p><p>    return self;</p><p>-- Setzt die Überschrift des TextWindow.</p><p>-- <p><b>Alias</b>: TextWindow:SetCaption</p></p><p>-- @param _Text [string] Titel des Textfenster</p><p>-- @return self</p><p>-- @within TextWindow</p><p>-- @local</p><p>-- @usage</p><p>-- MyWindow:SetCaption("Das ist der Titel");</p><p>    assert(self ~= BundleDialogWindows.Local.TextWindow, "Can not be used in static context!");</p><p>    local Language = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>    if type(_Text) == "table" then</p><p>        _Text = _Text[Language];</p><p>    end</p><p>    assert(type(_Text) == "string");</p><p>    self.Data.Caption = _Text;</p><p>    return self;</p><p>-- Setzt den Inhalt des TextWindow.</p><p>-- <p><b>Alias</b>: TextWindow:SetContent</p></p><p>-- @param _Text [string] Inhalt des Textfenster</p><p>-- @return self</p><p>-- @within TextWindow</p><p>-- @local</p><p>-- @usage</p><p>-- MyWindow:SetCaption("Das ist der Text. Er ist sehr informativ!");</p><p>    assert(self ~= BundleDialogWindows.Local.TextWindow, "Can not be used in static context!");</p><p>    local Language = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>    if type(_Text) == "table" then</p><p>        _Text = _Text[Language];</p><p>    end</p><p>    assert(type(_Text) == "string");</p><p>    self.Data.Text = _Text;</p><p>    return self;</p><p>-- Setzt die Close Action des TextWindow. Die Funktion wird beim schließen</p><p>-- des Fensters ausgeführt.</p><p>-- <p><b>Alias</b>: TextWindow:SetAction</p></p><p>-- @param _Function [function] Close Callback</p><p>-- @return self</p><p>-- @within TextWindow</p><p>-- @local</p><p>-- @usage</p><p>-- local MyAction = function(_Window)</p><p>--     -- Something is done here!</p><p>-- end</p><p>-- MyWindow:SetAction(MyAction);</p><p>    assert(self ~= BundleDialogWindows.Local.TextWindow, "Can not be used in static context!");</p><p>    assert(nil or type(_Function) == "function");</p><p>    self.Data.Callback = _Function;</p><p>    return self;</p><p>-- Setzt einen Aktionsbutton im TextWindow.</p><p>-- Der Button muss mit einer Funktion versehen werden. Sobald der Button</p><p>-- betätigt wird, wird die Funktion ausgeführt.</p><p>-- <p><b>Alias</b>: TextWindow:SetButton</p></p><p>-- @param _Text     [string] Beschriftung des Buttons</p><p>-- @param _Callback [function] Aktion des Buttons</p><p>-- @return self</p><p>-- @within TextWindow</p><p>-- @local</p><p>-- @usage</p><p>-- local MyButtonAction = function(_Window)</p><p>--     -- Something is done here!</p><p>-- end</p><p>-- MyWindow:SetAction("Button Text", MyButtonAction);</p><p>    assert(self ~= BundleDialogWindows.Local.TextWindow, "Can not be used in static context!");</p><p>    if _Text then</p><p>        local Language = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>        if type(_Text) == "table" then</p><p>            _Text = _Text[Language];</p><p>        end</p><p>        assert(type(_Text) == "string");</p><p>        assert(type(_Callback) == "function");</p><p>    end</p><p>    self.Data.ButtonText = _Text;</p><p>    self.Data.Action     = _Callback;</p><p>    return self;</p><p>-- Zeigt ein erzeigtes Fenster an.</p><p>-- <p><b>Alias</b>: TextWindow:Show</p></p><p>-- @within TextWindow</p><p>-- @local</p><p>-- @usage</p><p>-- MyWindow:Show();</p><p>    assert(self ~= BundleDialogWindows.Local.TextWindow, "Can not be used in static context!");</p><p>    BundleDialogWindows.Local.TextWindow.Data.Shown = true;</p><p>    self.Data.Shown = true;</p><p>    self:Prepare();</p><p>    XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions",1);</p><p>    XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/ToggleWhisperTarget",1);</p><p>    if not self.Data.Action then</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/ToggleWhisperTarget",0);</p><p>    end</p><p>    XGUIEng.SetText("/InGame/Root/Normal/MessageLog/Name","{center}"..self.Data.Caption);</p><p>    XGUIEng.SetText("/InGame/Root/Normal/ChatOptions/ToggleWhisperTarget","{center}"..self.Data.ButtonText);</p><p>    GUI_Chat.ClearMessageLog();</p><p>    GUI_Chat.ChatlogAddMessage(self.Data.Text);</p><p>    local stringlen = string.len(self.Data.Text);</p><p>    local iterator  = 1;</p><p>    local carreturn = 0;</p><p>    while (true)</p><p>    do</p><p>        local s,e = string.find(self.Data.Text, "{cr}", iterator);</p><p>        if not e then</p><p>            break;</p><p>        end</p><p>        if e-iterator <= 58 then</p><p>            stringlen = stringlen + 58-(e-iterator);</p><p>        end</p><p>        iterator = e+1;</p><p>    end</p><p>    if (stringlen + (carreturn*55)) > 1000 then</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/ChatLogSlider",1);</p><p>    end</p><p>    Game.GameTimeSetFactor(GUI.GetPlayerID(), 0);</p><p>-- Initialisiert das TextWindow, bevor es angezeigt wird.</p><p>-- @within TextWindow</p><p>-- @local</p><p>    function GUI_Chat.CloseChatMenu()</p><p>        BundleDialogWindows.Local.TextWindow.Data.Shown = false;</p><p>        self.Data.Shown = false;</p><p>        if self.Data.Callback then</p><p>            self.Data.Callback(self);</p><p>        end</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions",0);</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog",0);</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog/BG",1);</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog/Close",1);</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog/Slider",1);</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog/Text",1);</p><p>        Game.GameTimeReset(GUI.GetPlayerID());</p><p>    end</p><p>    function GUI_Chat.ToggleWhisperTargetUpdate()</p><p>        Game.GameTimeSetFactor(GUI.GetPlayerID(), 0);</p><p>    end</p><p>    function GUI_Chat.CheckboxMessageTypeWhisperUpdate()</p><p>        XGUIEng.SetText("/InGame/Root/Normal/ChatOptions/TextCheckbox","{center}"..self.Data.Caption);</p><p>    end</p><p>    function GUI_Chat.ToggleWhisperTarget()</p><p>        if self.Data.Action then</p><p>            self.Data.Action(self);</p><p>        end</p><p>    end</p><p>    function GUI_Chat.ClearMessageLog()</p><p>        g_Chat.ChatHistory = {}</p><p>    end</p><p>    function GUI_Chat.ChatlogAddMessage(_Message)</p><p>        table.insert(g_Chat.ChatHistory, _Message)</p><p>        local ChatlogMessage = ""</p><p>        for i,v in ipairs(g_Chat.ChatHistory) do</p><p>            ChatlogMessage = ChatlogMessage .. v .. "{cr}"</p><p>        end</p><p>        XGUIEng.SetText("/InGame/Root/Normal/ChatOptions/ChatLog", ChatlogMessage)</p><p>    end</p><p>    local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>    if type(self.Data.Caption) == "table" then</p><p>        self.Data.Caption = self.Data.Caption[lang];</p><p>    end</p><p>    if type(self.Data.ButtonText) == "table" then</p><p>        self.Data.ButtonText = self.Data.ButtonText[lang];</p><p>    end</p><p>    if type(self.Data.Text) == "table" then</p><p>        self.Data.Text = self.Data.Text[lang];</p><p>    end</p><p>    XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/ChatModeAllPlayers",0);</p><p>    XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/ChatModeTeam",0);</p><p>    XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/ChatModeWhisper",0);</p><p>    XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/ChatChooseModeCaption",0);</p><p>    XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/Background/TitleBig",1);</p><p>    XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/Background/TitleBig/Info",0);</p><p>    XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/ChatLogCaption",0);</p><p>    XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/BGChoose",0);</p><p>    XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/BGChatLog",0);</p><p>    XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/ChatLogSlider",0);</p><p>    XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog",1);</p><p>    XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog/BG",0);</p><p>    XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog/Close",0);</p><p>    XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog/Slider",0);</p><p>    XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog/Text",0);</p><p>    XGUIEng.DisableButton("/InGame/Root/Normal/ChatOptions/ToggleWhisperTarget",0);</p><p>    XGUIEng.SetWidgetLocalPosition("/InGame/Root/Normal/MessageLog",0,95);</p><p>    XGUIEng.SetWidgetLocalPosition("/InGame/Root/Normal/MessageLog/Name",0,0);</p><p>    XGUIEng.SetTextColor("/InGame/Root/Normal/MessageLog/Name",51,51,121,255);</p><p>    XGUIEng.SetWidgetLocalPosition("/InGame/Root/Normal/ChatOptions/ChatLog",140,150);</p><p>    XGUIEng.SetWidgetSize("/InGame/Root/Normal/ChatOptions/Background/DialogBG/1 (2)/2",150,400);</p><p>    XGUIEng.SetWidgetPositionAndSize("/InGame/Root/Normal/ChatOptions/Background/DialogBG/1 (2)/3",400,500,350,400);</p><p>    XGUIEng.SetWidgetSize("/InGame/Root/Normal/ChatOptions/ChatLog",640,580);</p><p>    XGUIEng.SetWidgetSize("/InGame/Root/Normal/ChatOptions/ChatLogSlider",46,660);</p><p>    XGUIEng.SetWidgetLocalPosition("/InGame/Root/Normal/ChatOptions/ChatLogSlider",780,130);</p><p>    XGUIEng.SetWidgetLocalPosition("/InGame/Root/Normal/ChatOptions/ToggleWhisperTarget",110,760);</p><p>-- -------------------------------------------------------------------------- --</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundleentitycommandfunctions.lua.html">
            <div class='doclink'>
                <div>BundleEntityCommandFunctions</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia BundleEntityCommandFunctions                                 # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Stellt Hilfsfunktionen bereit um Entities Befehle zu erteilen oder sie</p><p>-- zu bewegen.</p><p>-- Das wichtigste Auf einen Blick:</p><p>-- <ul></p><p>-- <li></p><p>-- <a href="#API.CommandAttack">Befehle für Entities</a></p><p>-- </li></p><p>-- <li></p><p>-- <a href="#API.MoveAndLookAt">Entities bewegen</a></p><p>-- </li></p><p>-- <li></p><p>-- <a href="#API.PlaceAndLookAt">Entities platzieren</a></p><p>-- </li></p><p>-- </ul></p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Setzt ein Entity oder ein Battalion an eine neue Position.</p><p>-- <p><b>Alias:</b> SetPosition</p></p><p>-- @param _Entity   [string|number] Entity zum versetzen</p><p>-- @param _Position [string|number|table] Neue Position</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.SetPostion("hakim", "hakimPos1");</p><p>function API.SetPosition(_Entity, _Position)</p><p>    if GUI then</p><p>        local Subject = (type(_Entity) ~= "string" and _Entity) or "'" .._Entity.. "'";</p><p>        local Position = _Position;</p><p>        if type(Position) == "table" then</p><p>            Position = "{X= " ..tostring(Position.X).. ", Y= " ..tostring(Position.Y).. "}";</p><p>        end</p><p>        API.Bridge("API.SetPosition(" ..Subject.. ", " ..Position.. ")")</p><p>        return;</p><p>    end</p><p>    if not IsExisting(_Entity) then</p><p>        local Subject = (type(_Entity) ~= "string" and _Entity) or "'" .._Entity.. "'";</p><p>        API.Fatal("API.SetPosition: Entity " ..Subject.. " does not exist!");</p><p>        return;</p><p>    end</p><p>    local Position = API.LocateEntity(_Position)</p><p>    if not API.ValidatePosition(Position) then</p><p>        API.Fatal("API.SetPosition: Position is invalid!");</p><p>        return;</p><p>    end</p><p>    return BundleEntityCommandFunctions.Global:SetPosition(_Entity, Position);</p><p>-- Das Entity wird relativ zu einem Winkel zum Ziel bewegt.</p><p>-- <p><b>Alias:</b> MoveEntityToPositionToAnotherOne</p></p><p>-- @param _Entity       [string|number] Zu bewegendes Entity</p><p>-- @param _Position     [string|number] Ziel</p><p>-- @param _Distance     [number] Entfernung zum Ziel</p><p>-- @param _Angle        [number] Winkel</p><p>-- @param _moveAsEntity [boolean] Blocking ignorieren</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.MoveToPosition("hakim", "saraya", 300, 0);</p><p>function API.MoveToPosition(_Entity, _Position, _Distance, _Angle, _moveAsEntity)</p><p>    if GUI then</p><p>        API.Bridge("API.MoveToPosition(" ..GetID(_Entity).. ", " ..GetID(_Position).. ", " .._Distance.. ", " .._Angle.. ", " ..tostring(_moveAsEntity).. ")")</p><p>        return;</p><p>    end</p><p>    if not IsExisting(_Entity) then</p><p>        local Subject = (type(_Entity) ~= "string" and _Entity) or "'" .._Entity.. "'";</p><p>        API.Fatal("API.MoveToPosition: Entity " ..Subject.. " does not exist!");</p><p>        return;</p><p>    end</p><p>    if not IsExisting(_Position) then</p><p>        local Subject = (type(_Position) ~= "string" and _Position) or "'" .._Position.. "'";</p><p>        API.Fatal("API.MoveToPosition: Entity " ..Subject.. " does not exist!");</p><p>        return;</p><p>    end</p><p>    return BundleEntityCommandFunctions.Global:MoveToPosition(_Entity, _Position, _Distance, _Angle, _moveAsEntity)</p><p>-- Das Entity wird relativ zu einem Winkel zum Ziel bewegt und schaut es</p><p>-- anschließend an.</p><p>-- <p><b>Alias:</b> MoveEx</br></p></p><p>-- <p><b>Alias:</b> MoveEntityFaceToFaceToAnotherOne</p></p><p>-- @param _Entity       [string|number] Zu bewegendes Entity</p><p>-- @param _Position     [string|number] Ziel</p><p>-- @param _Distance     [number] Entfernung zum Ziel</p><p>-- @param _moveAsEntity [boolean] Blocking ignorieren</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.MoveAndLookAt("hakim", "saraya", 300);</p><p>function API.MoveAndLookAt(_Entity, _Position, _Distance, _moveAsEntity)</p><p>    if GUI then</p><p>        API.Bridge("API.MoveAndLookAt(" ..GetID(_Entity).. ", " ..GetID(_Position).. ", " .._Distance.. ", " ..tostring(_moveAsEntity).. ")")</p><p>        return;</p><p>    end</p><p>    if not IsExisting(_Entity) then</p><p>        local Subject = (type(_Entity) ~= "string" and _Entity) or "'" .._Entity.. "'";</p><p>        API.Fatal("API.MoveAndLookAt: Entity " ..Subject.. " does not exist!");</p><p>        return;</p><p>    end</p><p>    if not IsExisting(_Position) then</p><p>        local Subject = (type(_Position) ~= "string" and _Position) or "'" .._Position.. "'";</p><p>        API.Fatal("API.MoveAndLookAt: Entity " ..Subject.. " does not exist!");</p><p>        return;</p><p>    end</p><p>    return BundleEntityCommandFunctions.Global:MoveAndLookAt(_Entity, _Position, _Distance, _moveAsEntity)</p><p>-- Das Entity wird relativ zu einem Winkel zum Zielpunkt gesetzt.</p><p>-- <p><b>Alias:</b> PlaceEntityToPositionToAnotherOne</p></p><p>-- @param _Entity          [string|number|table] Entity das bewegt wird</p><p>-- @param _Position        [string|number|table] Position zu der bewegt wird</p><p>-- @param _Distance        [number] Entfernung</p><p>-- @param _Angle           [number] Winkel</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.PlaceToPosition("hakim", "saraya", 300, 45);</p><p>function API.PlaceToPosition(_Entity, _Position, _Distance, _Angle)</p><p>    if GUI then</p><p>        API.Bridge("API.PlaceToPosition(" ..GetID(_Entity).. ", " ..GetID(_Position).. ", " .._Distance.. ", " .._Angle.. ")")</p><p>        return;</p><p>    end</p><p>    if not IsExisting(_Entity) then</p><p>        local Subject = (type(_Entity) ~= "string" and _Entity) or "'" .._Entity.. "'";</p><p>        API.Fatal("API.PlaceToPosition: Entity " ..Subject.. " does not exist!");</p><p>        return;</p><p>    end</p><p>    if not IsExisting(_Position) then</p><p>        local Subject = (type(_Position) ~= "string" and _Position) or "'" .._Position.. "'";</p><p>        API.Fatal("API.PlaceToPosition: Entity " ..Subject.. " does not exist!");</p><p>        return;</p><p>    end</p><p>    local Position = BundleEntityCommandFunctions.Shared:GetRelativePosition(_Position, _Distance, _Angle, true);</p><p>    API.SetPosition(_Entity, Position);</p><p>-- Das Entity wird relativ zu einem Winkel zum Zielpunkt gesetzt und schaut</p><p>-- das Ziel an.</p><p>-- <p><b>Alias:</b> PlaceEntityFaceToFaceToAnotherOne</p></p><p>-- <p><b>Alias:</b> SetPositionEx<br></p></p><p>-- @param _Entity          [string|number|table] Entity das bewegt wird</p><p>-- @param _Position        [string|number|table] Position zu der bewegt wird</p><p>-- @param _Distance        [number] Entfernung</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.PlaceAndLookAt("hakim", "saraya", 300);</p><p>function API.PlaceAndLookAt(_Entity, _Position, _Distance)</p><p>    if GUI then</p><p>        API.Bridge("API.PlaceAndLookAt(" ..GetID(_Entity).. ", " ..GetID(_Position).. ", " .._Distance.. ")")</p><p>        return;</p><p>    end</p><p>    API.PlaceToPosition(_Entity, _Position, _Distance, 0);</p><p>    LookAt(_Entity, _Position);</p><p>-- Das Entity greift ein anderes Entity an, sofern möglich.</p><p>-- <p><b>Alias:</b> Attack</p></p><p>-- @param_Entity  [string|number] Angreifendes Entity</p><p>-- @param _Target [string|number] Angegriffenes Entity</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.CommandAttack("hakim", "marcus");</p><p>function API.CommandAttack(_Entity, _Target)</p><p>    if GUI then</p><p>        API.Bridge("API.CommandAttack(" ..GetID(_Entity).. ", " ..GetID(_Target).. ")")</p><p>        return;</p><p>    end</p><p>    if not IsExisting(_Entity) then</p><p>        local Subject = (type(_Entity) == "string" and "'" .._Entity.. "'") or _Entity;</p><p>        API.Fatal("API.CommandAttack: Entity " ..Subject.. " does not exist!");</p><p>        return;</p><p>    end</p><p>    if not IsExisting(_Target) then</p><p>        local Subject = (type(_Target) == "string" and "'" .._Target.. "'") or _Target;</p><p>        API.Fatal("API.CommandAttack: Target " ..Subject.. " does not exist!");</p><p>        return;</p><p>    end</p><p>    return BundleEntityCommandFunctions.Global:Attack(_Entity, _Target);</p><p>-- Ein Entity oder ein Battalion wird zu einer Position laufen und</p><p>-- alle gültigen Ziele auf dem Weg angreifen.</p><p>-- <p><b>Alias:</b> AttackMove</p></p><p>-- @param _Entity   [string|number] Angreifendes Entity</p><p>-- @param _Position [string] Skriptname, EntityID oder Positionstable</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.CommandAttackMove("hakim", "area");</p><p>function API.CommandAttackMove(_Entity, _Position)</p><p>    if GUI then</p><p>        API.Fatal("API.CommandAttackMove: Cannot be used from local script!");</p><p>        return;</p><p>    end</p><p>    if not IsExisting(_Entity) then</p><p>        local Subject = (type(_Entity) == "string" and "'" .._Entity.. "'") or _Entity;</p><p>        API.Fatal("API.CommandAttackMove: Entity " ..Subject.. " does not exist!");</p><p>        return;</p><p>    end</p><p>    local Position = API.LocateEntity(_Position)</p><p>    if not API.ValidatePosition(Position) then</p><p>        API.Fatal("API.CommandAttackMove: Position is invalid!");</p><p>        return;</p><p>    end</p><p>    return BundleEntityCommandFunctions.Global:AttackMove(_Entity, Position);</p><p>-- Bewegt das Entity zur Zielposition.</p><p>-- <p><b>Alias:</b> Move</p></p><p>-- @param _Entity   [string|number] Bewegendes Entity</p><p>-- @param _Position [table] Positionstable</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.CommandMove("hakim", "pos");</p><p>function API.CommandMove(_Entity, _Position)</p><p>    if GUI then</p><p>        API.Fatal("API.CommandMove: Cannot be used from local script!");</p><p>        return;</p><p>    end</p><p>    if not IsExisting(_Entity) then</p><p>        local Subject = (type(_Entity) == "string" and "'" .._Entity.. "'") or _Entity;</p><p>        API.Fatal("API.CommandMove: Entity " ..Subject.. " does not exist!");</p><p>        return;</p><p>    end</p><p>    local Position = API.LocateEntity(_Position)</p><p>    if not API.ValidatePosition(Position) then</p><p>        API.Fatal("API.CommandMove: Position is invalid!");</p><p>        return;</p><p>    end</p><p>    return BundleEntityCommandFunctions.Global:Move(_Entity, Position);</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {</p><p>        Data = {}</p><p>    },</p><p>    Shared = {</p><p>        Data = {}</p><p>    },</p><p>-- Global Script ---------------------------------------------------------------</p><p>-- Initalisiert das Bundle im globalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>-- Setzt ein Entity oder ein Battalion an eine neue Position.</p><p>-- @param _Entity   [string|number] Entity zum versetzen</p><p>-- @param _Position [string|number|table] Neue Position</p><p>-- @within Internal</p><p>-- @local</p><p>    if not IsExisting(_Entity)then</p><p>        return</p><p>    end</p><p>    local EntityID = GetEntityId(_Entity);</p><p>    Logic.DEBUG_SetSettlerPosition(EntityID, _Position.X, _Position.Y);</p><p>    if Logic.IsLeader(EntityID) == 1 then</p><p>        local soldiers = {Logic.GetSoldiersAttachedToLeader(EntityID)};</p><p>        if soldiers[1] > 0 then</p><p>            for i=1,#soldiers do</p><p>                Logic.DEBUG_SetSettlerPosition(soldiers[i], _Position.X, _Position.Y);</p><p>            end</p><p>        end</p><p>    end</p><p>-- Das Entity wird relativ zu einem Winkel zum Zielpunkt bewegt.</p><p>-- @param _Entity       [string|number] Zu bewegendes Entity</p><p>-- @param _Position     [string|number] Ziel</p><p>-- @param _Distance     [number] Entfernung zum Ziel</p><p>-- @param _Angle        [number] Winkel</p><p>-- @param _moveAsEntity [boolean] Blocking ignorieren</p><p>-- @within Internal</p><p>-- @local</p><p>    if not IsExisting(_Entity)then</p><p>        return</p><p>    end</p><p>    if not _Distance then</p><p>        _Distance = 0;</p><p>    end</p><p>    local eID = GetID(_Entity);</p><p>    local tID = GetID(_Position);</p><p>    local pos = BundleEntityCommandFunctions.Shared:GetRelativePos(_Position, _Distance);</p><p>    if type(_Angle) == "number" then</p><p>        pos = BundleEntityCommandFunctions.Shared:GetRelativePos(_Position, _Distance, _Angle);</p><p>    end</p><p>    if _moveAsEntity then</p><p>        Logic.MoveEntity(eID, pos.X, pos.Y);</p><p>    else</p><p>        Logic.MoveSettler(eID, pos.X, pos.Y);</p><p>    end</p><p>    StartSimpleJobEx( function(_EntityID, _TargetID)</p><p>        if not Logic.IsEntityMoving(_EntityID) then</p><p>            LookAt(_EntityID, _TargetID);</p><p>            return true;</p><p>        end</p><p>    end, eID, tID);</p><p>-- Das Entity wird relativ zu einem Winkel zum Zielpunkt bewegt und schaut</p><p>-- das Ziel anschließend an.</p><p>-- @param _Entity       [string|number] Zu bewegendes Entity</p><p>-- @param _Position     [string|number] Ziel</p><p>-- @param _Distance     [number] Entfernung zum Ziel</p><p>-- @param _moveAsEntity [boolean] Blocking ignorieren</p><p>-- @within Internal</p><p>-- @local</p><p>    if not IsExisting(_Entity)then</p><p>        return</p><p>    end</p><p>    if not _Distance then</p><p>        _Distance = 0;</p><p>    end</p><p>    self:MoveToPosition(_Entity, _Position, _Distance, 0, _moveAsEntity);</p><p>    StartSimpleJobEx( function(_EntityID, _TargetID)</p><p>        if not Logic.IsEntityMoving(_EntityID) then</p><p>            LookAt(_EntityID, _TargetID);</p><p>            return true;</p><p>        end</p><p>    end, GetID(_Entity), GetID(_Position));</p><p>-- Das Entity greift ein anderes Entity an, sofern möglich.</p><p>-- @param_Entity  [string|number] Angreifendes Entity</p><p>-- @param _Target [string|number] Angegriffenes Entity</p><p>-- @within Internal</p><p>-- @local</p><p>    local EntityID = GetID(_Entity);</p><p>    local TargetID = GetID(_Target);</p><p>    Logic.GroupAttack(EntityID, TargetID);</p><p>-- Ein Entity oder ein Battalion wird zu einer Position laufen und</p><p>-- alle gültigen Ziele auf dem Weg angreifen.</p><p>-- @param _Entity   [string|number] Angreifendes Entity</p><p>-- @param _Position [string] Skriptname, EntityID oder Positionstable</p><p>-- @within Internal</p><p>-- @local</p><p>    local EntityID = GetID(_Entity);</p><p>    Logic.GroupAttackMove(EntityID, _Position.X, _Position.Y);</p><p>-- Bewegt das Entity zur Zielposition.</p><p>-- @param _Entity   [string|number] Bewegendes Entity</p><p>-- @param _Position [table] Positionstable</p><p>-- @within Internal</p><p>-- @local</p><p>    local EntityID = GetID(_Entity);</p><p>    Logic.MoveSettler(EntityID, _Position.X, _Position.Y);</p><p>-- Shared ----------------------------------------------------------------------</p><p>-- Errechnet eine Position relativ im angegebenen Winkel und Position zur</p><p>-- Basisposition. Die Basis kann ein Entity oder eine Positionstabelle sein.</p><p>-- @param _target          [string|number|table] Basisposition</p><p>-- @param _distance        [number] Entfernung</p><p>-- @param _angle           [number] Winkel</p><p>-- @param _buildingRealPos [boolean] Gebäudemitte statt Gebäudeeingang</p><p>-- @return [table] Position</p><p>-- @within Internal</p><p>-- @local</p><p>    if not type(_target) == "table" and not IsExisting(_target)then</p><p>        return</p><p>    end</p><p>    if _angle == nil then</p><p>        _angle = 0;</p><p>    end</p><p>    local pos1;</p><p>    if type(_target) == "table" then</p><p>        local pos = _target;</p><p>        local ori = 0+_angle;</p><p>        pos1 = { X= pos.X+_distance * math.cos(math.rad(ori)),</p><p>                 Y= pos.Y+_distance * math.sin(math.rad(ori))};</p><p>    else</p><p>        local eID = GetID(_target);</p><p>        local pos = GetPosition(eID);</p><p>        local ori = Logic.GetEntityOrientation(eID)+_angle;</p><p>        if Logic.IsBuilding(eID) == 1 and not _buildingRealPos then</p><p>            x, y = Logic.GetBuildingApproachPosition(eID);</p><p>            pos = {X= x, Y= y};</p><p>            ori = ori -90;</p><p>        end</p><p>        pos1 = { X= pos.X+_distance * math.cos(math.rad(ori)),</p><p>                 Y= pos.Y+_distance * math.sin(math.rad(ori))};</p><p>    end</p><p>    return pos1;</p><p>-- -------------------------------------------------------------------------- --</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundleentityhealth.lua.html">
            <div class='doclink'>
                <div>BundleEntityHealth</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia BundleEntityHealth                                           # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Dieses Bundle stellt Funktionen bereit, mit denen die Gesundheit von</p><p>-- Entities überwacht oder geändert werden kann.</p><p>-- Das wichtigste Auf einen Blick:</p><p>-- <ul></p><p>-- <li></p><p>-- <a href="#API.GetEntityHealth">Gesundheit ermitteln</a></p><p>-- </li></p><p>-- <li></p><p>-- <a href="#API.SetEntityHealth">Gesundheit verändern</a></p><p>-- </li></p><p>-- <li></p><p>-- <a href="#API.SetOnFire">Gebäude in Brand stecken</a></p><p>-- </li></p><p>-- <li></p><p>-- <a href="#API.AddOnEntityCreatedAction">Trigger anlegen</a></p><p>-- </li></p><p>-- </ul></p><p>-- @within Modulbeschreibung</p><p>-- @set sort=false</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Gibt die Gesundheit des Entity in prozent zurück.</p><p>-- Achtung: Nur Siedler (inklusive Millitär und Helden), Belagerungswaffen,</p><p>-- Gebäude und Raubtiere haben Gesundheit.</p><p>-- <p><b>Alias</b>: GetHealth</p></p><p>-- @param _Entity [string|number] Angefragtes Entity</p><p>-- @return [number] Gesundheit in Prozent</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- local Health = GetHealth("hakim");</p><p>function API.GetEntityHealth(_Entity)</p><p>    return BundleEntityHealth.Shared:GetHealth(_Entity);</p><p>-- Ändert die Gesundheit des Entity zu dem angegeben Wert in Prozent.</p><p>-- Achtung: Nur Siedler (inklusive Millitär und Helden), Belagerungswaffen,</p><p>-- Gebäude und Raubtiere haben Gesundheit.</p><p>-- <p><b>Alias</b>: SetHealth</p></p><p>-- @param _Entity     [string|number] Entity dessen Gesundheit geändert wird</p><p>-- @param _Percentage [number] Gesundheit in Prozent</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- SetHealth("hakim", 50);</p><p>function API.ChangeEntityHealth(_Entity, _Percentage)</p><p>    if GUI then</p><p>        local Sublect = (type(_Entity) == "string" and "'" .._Entity.. "'") or _Entity;</p><p>        API.Bridge("API.ChangeEntityHealth(" ..Sublect.. ", " .._Percentage.. ")");</p><p>        return;</p><p>    end</p><p>    if not IsExisting(_Entity) then</p><p>        local Sublect = (type(_Entity) == "string" and "'" .._Entity.. "'") or _Entity;</p><p>        API.Fatal("API.ChangeEntityHealth: _Entity " ..Sublect.. " does not exist!");</p><p>        return;</p><p>    end</p><p>    if type(_Percentage) ~= "number" then</p><p>        API.Fatal("API.ChangeEntityHealth: _Percentage must be a number!");</p><p>        return;</p><p>    end</p><p>    _Percentage = (_Percentage < 0 and 0) or _Percentage;</p><p>    if _Percentage > 100 then</p><p>        API.Warn("API.ChangeEntityHealth: _Percentage is larger than 100. This could cause problems!");</p><p>    end</p><p>    BundleEntityHealth.Global:SetEntityHealth(_Entity, _Percentage);</p><p>-- Steckt ein Gebäude in Brand.</p><p>-- Achtung: Nur Gebäude können in Brand gesteckt werden.</p><p>-- <p><b>Alias</b>: SetOnFire</p></p><p>-- @param _Entity   [string|number] Skriptname oder EntityID</p><p>-- @param _Strength [number] Stärke des Brandes</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- SetOnFire("headquarters1", 100);</p><p>function API.SetBuildingOnFire(_Entity, _Strength)</p><p>    if GUI then</p><p>        local Sublect = (type(_Entity) == "string" and "'" .._Entity.. "'") or _Entity;</p><p>        API.Bridge("API.SetBuildingOnFire(" ..Sublect.. ", " .._Strength.. ")");</p><p>        return;</p><p>    end</p><p>    if not IsExisting(_Entity) then</p><p>        local Sublect = (type(_Entity) == "string" and "'" .._Entity.. "'") or _Entity;</p><p>        API.Fatal("API.SetBuildingOnFire: Entity " ..Sublect.. " does not exist!");</p><p>        return;</p><p>    end</p><p>    if Logic.IsBuilding(GetID(_Entity)) == 0 then</p><p>        API.Fatal("API.SetBuildingOnFire: Only buildings can be set on fire!");</p><p>        return;</p><p>    end</p><p>    if type(_Strength) ~= "number" then</p><p>        API.Fatal("API.SetBuildingOnFire: _Strength must be a number!");</p><p>        return;</p><p>    end</p><p>    _Strength = (_Strength < 0 and 0) or _Strength;</p><p>    Logic.DEBUG_SetBuildingOnFile(GetID(_Entity), _Strength);</p><p>-- Verwundet ein Entity oder ein Battalion um den angegebenen Wert. Wird ein</p><p>-- Battalion verwundet, werden der Reihe nach alle Soldaten verwundet, bis</p><p>-- der gesamte Schaden verrechnet wurde oder alle Sodaten tot sind.</p><p>-- <p><b>Alias</b>: HurtEntityEx</p></p><p>-- @param _Target         [string|number] Ziel des Schadens</p><p>-- @param _AmountOfDamage [number] Menge an Schaden</p><p>-- @param _Attacker       [string|number] (Optional) Angreifendes Entity</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- HurtEntityEx("battalion", 250, "hakim");</p><p>function API.HurtEntity(_Target, _AmountOfDamage, _Attacker)</p><p>    if GUI then</p><p>        local Target = (type(_Target) == "string" and "'" .._Target.. "'") or _Target;</p><p>        local Attacker = (type(_Attacker) == "string" and "'" .._Attacker.. "'") or _Attacker;</p><p>        API.Bridge("API.HurtEntity(" ..Target.. ", " .._AmountOfDamage.. ", " ..tostring(Attacker).. ")");</p><p>        return;</p><p>    end</p><p>    if not IsExisting(_Target) then</p><p>        local Sublect = (type(_Target) == "string" and "'" .._Target.. "'") or _Target;</p><p>        API.Warn("API.HurtEntity: Entity " .._Target.. " does not exist!");</p><p>        return;</p><p>    end</p><p>    if type(_AmountOfDamage) ~= "number" or _AmountOfDamage < 0 then</p><p>        API.Fatal("API.HurtEntity: _AmountOfDamage must be a number greater or equal 0!");</p><p>        return;</p><p>    end</p><p>    local EntityID = GetID(_Target);</p><p>    local AttackerID = GetID(_Attacker);</p><p>    return BundleEntityHealth.Global:HurtEntityEx(EntityID, _AmountOfDamage, AttackerID);</p><p>-- Erstellt einen neuen Auslöser für Kampfgeschehen.</p><p>-- Jede Funktion wird immer dann ausgeführt, wenn ein Entity durch ein anderes</p><p>-- verwundet wird.</p><p>-- <p><b>Alias</b>: AddHurtAction</p></p><p>-- @param _Function [function] Funktion, die ausgeführt wird.</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.AddOnEntityHurtAction(SomeFunctionReference);</p><p>function API.AddOnEntityHurtAction(_Function)</p><p>    if GUI then</p><p>        API.Fatal("API.AddOnEntityHurtAction: Can not be used in local script!");</p><p>        return;</p><p>    end</p><p>    if type(_Function) ~= "function" then</p><p>        API.Fatal("_Function must be a function!");</p><p>        return;</p><p>    end</p><p>    BundleEntityHealth.Global.AddOnEntityHurtAction(_Function);</p><p>-- Erstellt einen neuen Auslöser für zerstörte Entities.</p><p>-- Jede Funktion wird immer dann ausgeführt, wenn ein Entity durch ein anderes</p><p>-- Entity oder durch das Skript zerstört wird.</p><p>-- <p><b>Alias</b>: AddKilledAction</p></p><p>-- @param _Function [function] Funktion, die ausgeführt wird.</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.AddOnEntityCreatedAction(SomeFunctionReference);</p><p>function API.AddOnEntityDestroyedAction(_Function)</p><p>    if GUI then</p><p>        API.Fatal("API.AddOnEntityDestroyedAction: Can not be used in local script!");</p><p>        return;</p><p>    end</p><p>    if type(_Function) ~= "function" then</p><p>        API.Fatal("_Function must be a function!");</p><p>        return;</p><p>    end</p><p>    BundleEntityHealth.Global.AddOnEntityDestroyedAction(_Function);</p><p>-- Fügt eine Funktion hinzu, die ausgeführt wird, wenn ein Entity erzeugt wird.</p><p>-- <p><b>Alias</b>: AddSpawnedAction</p></p><p>-- @param _Function [function] Funktion, die ausgeführt wird.</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.AddOnEntityCreatedAction(SomeFunctionReference);</p><p>function API.AddOnEntityCreatedAction(_Function)</p><p>    if GUI then</p><p>        API.Fatal("API.AddOnEntityCreatedAction: Can not be used in local script!");</p><p>        return;</p><p>    end</p><p>    if type(_Function) ~= "function" then</p><p>        API.Fatal("_Function must be a function!");</p><p>        return;</p><p>    end</p><p>    BundleEntityHealth.Global.AddOnEntityCreatedAction(_Function);</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {</p><p>        Data = {</p><p>            OnEntityCreatedAction = {},</p><p>            OnEntityDestroyedAction = {},</p><p>            OnEntityHurtAction = {},</p><p>        },</p><p>    },</p><p>    Local = {</p><p>        Data = {}</p><p>    },</p><p>    Shared = {</p><p>        Data = {}</p><p>    },</p><p>-- Global Script ---------------------------------------------------------------</p><p>-- Initialisiert das Bundle im globalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    BundleEntityHealth_EntityHurtEntityController = self.EntityHurtEntityController;</p><p>    Trigger.RequestTrigger(Events.LOGIC_EVENT_ENTITY_HURT_ENTITY, "", "BundleEntityHealth_EntityHurtEntityController", 1);</p><p>    BundleEntityHealth_EntityDestroyedController = self.EntityDestroyedController;</p><p>    Trigger.RequestTrigger(Events.LOGIC_EVENT_ENTITY_DESTROYED, "", "BundleEntityHealth_EntityDestroyedController", 1);</p><p>    Core:AppendFunction("GameCallback_SettlerSpawned", self.EntityCreatedController);</p><p>-- Ändert die Gesundheit des Entity zu dem angegeben Wert in Prozent.</p><p>-- @param _Entity     [string|number] Entity to change</p><p>-- @param _Percentage [number] Health amount</p><p>-- @within Internal</p><p>-- @local</p><p>    if not IsExisting(_Entity) then</p><p>        return;</p><p>    end</p><p>    local EntityID  = GetID(_Entity);</p><p>    local MaxHealth = Logic.GetEntityMaxHealth(EntityID);</p><p>    local Health    = Logic.GetEntityHealth(EntityID);</p><p>    local SetHealth = math.floor((MaxHealth * (_Percentage / 100)) + 0.5);</p><p>    Logic.HealEntity(EntityID, MaxHealth - Health);</p><p>    Logic.HurtEntity(EntityID, MaxHealth - SetHealth);</p><p>-- Verwundet ein Entity um den angegebenen Wert. Wird die ID des</p><p>-- Angreifers übergeben, werden die entsprechenden Callbacks für</p><p>-- Kampfhandlungen ausgelöst.</p><p>-- @param _EntityID       [number] ID des Opfers</p><p>-- @param _AmountOfDamage [number] Menge an Schaden</p><p>-- @param _AttackerID     [number] (optional) ID des Angreifers</p><p>-- @within Internal</p><p>-- @local</p><p>    if IsExisting(_EntityID)then</p><p>        local leader = 0</p><p>        if Logic.IsEntityInCategory(_EntityID,EntityCategories.Soldier) == 1 then</p><p>            leader = Logic.SoldierGetLeaderEntityID(_EntityID)</p><p>        end</p><p>        if Logic.IsEntityInCategory(_EntityID, EntityCategories.Leader) == 1 then</p><p>            leader = _EntityID</p><p>        end</p><p>        if leader ~= nil and leader ~= 0 then</p><p>            local soldiers = {Logic.GetSoldiersAttachedToLeader(leader)}</p><p>            if soldiers[1] == nil then soldiers[1] = 0 end</p><p>            if soldiers[1] > 0 then</p><p>                local victim = 0</p><p>                local lowestHealth = 1000</p><p>                for i=1,#soldiers do</p><p>                    local currentHealth = Logic.GetEntityHealth(soldiers[i])</p><p>                    if currentHealth < lowestHealth and currentHealth > 0 then</p><p>                        lowestHealth = currentHealth</p><p>                        victim = soldiers[i]</p><p>                    end</p><p>                end</p><p>                local damageVictim = soldiers[#soldiers]</p><p>                if victim ~= nil and victim ~= 0 then</p><p>                    damageVictim = victim</p><p>                end</p><p>                local hpEntity = 0</p><p>                local overkill = _AmountOfDamage</p><p>                if IsExisting(damageVictim)then</p><p>                    hpEntity = Logic.GetEntityHealth(damageVictim)</p><p>                    overkill = _AmountOfDamage - hpEntity</p><p>                    if hpEntity <= _AmountOfDamage then</p><p>                        if _AttackerID and hpEntity > 0 then</p><p>                            GameCallback_EntityKilled(_EntityID,</p><p>                                                      Logic.EntityGetPlayer(_EntityID),</p><p>                                                      _AttackerID,</p><p>                                                      Logic.EntityGetPlayer(_AttackerID),</p><p>                                                      Logic.GetEntityType(_EntityID),</p><p>                                                      Logic.GetEntityType(_AttackerID));</p><p>                            local x,y,z = Logic.EntityGetPos(_EntityID)</p><p>                            Logic.ExecuteInLuaLocalState("GameCallback_Feedback_EntityKilled("..</p><p>                                                         "".._EntityID..","..</p><p>                                                         ""..Logic.EntityGetPlayer(_EntityID)..","..</p><p>                                                         "".._AttackerID..","..</p><p>                                                         ""..Logic.EntityGetPlayer(_AttackerID)..","..</p><p>                                                         ""..Logic.GetEntityType(_EntityID)..","..</p><p>                                                         ""..Logic.GetEntityType(_AttackerID)..","..</p><p>                                                         ""..x..","..y..")")</p><p>                        end</p><p>                        Logic.HurtEntity(damageVictim,hpEntity)</p><p>                    else</p><p>                        Logic.HurtEntity(damageVictim,_AmountOfDamage)</p><p>                    end</p><p>                end</p><p>                if overkill > 0 then</p><p>                    HurtEntityEx(leader,overkill,_AttackerID)</p><p>                end</p><p>            end</p><p>        else</p><p>            local hpEntity = Logic.GetEntityHealth(_EntityID)</p><p>            if hpEntity <= _AmountOfDamage then</p><p>                if _AttackerID and hpEntity > 0 then</p><p>                    GameCallback_EntityKilled(_EntityID,</p><p>                                              Logic.EntityGetPlayer(_EntityID),</p><p>                                              _AttackerID,</p><p>                                              Logic.EntityGetPlayer(_AttackerID),</p><p>                                              Logic.GetEntityType(_EntityID),</p><p>                                              Logic.GetEntityType(_AttackerID))</p><p>                    local x,y,z = Logic.EntityGetPos(_EntityID)</p><p>                    Logic.ExecuteInLuaLocalState("GameCallback_Feedback_EntityKilled("..</p><p>                                                 "".._EntityID..","..</p><p>                                                 ""..Logic.EntityGetPlayer(_EntityID)..","..</p><p>                                                 "".._AttackerID..","..</p><p>                                                 ""..Logic.EntityGetPlayer(_AttackerID)..","..</p><p>                                                 ""..Logic.GetEntityType(_EntityID)..","..</p><p>                                                 ""..Logic.GetEntityType(_AttackerID)..","..</p><p>                                                 ""..x..","..y..")")</p><p>                end</p><p>                Logic.HurtEntity(_EntityID,hpEntity)</p><p>            else</p><p>                Logic.HurtEntity(_EntityID,_AmountOfDamage)</p><p>            end</p><p>        end</p><p>    end</p><p>-- Fügt eine Funktion hinzu, die ausgeführt wird, wenn ein Entity ein anderes</p><p>-- verwundet. Dabei wird EntityID des Angreifers und des Verteidigers an die</p><p>-- Funktion übergeben.</p><p>-- @param _Function [function] Funktion, die ausgeführt wird</p><p>-- @within Internal</p><p>-- @local</p><p>    table.insert(BundleEntityHealth.Global.Data.OnEntityHurtAction, _Function);</p><p>-- Fügt eine Funktion hinzu, die ausgeführt wird, wenn ein Entity zerstört</p><p>-- wird. Die EntityID des zerstörten Entity wird übergeben.</p><p>-- @param _Function [function] Funktion, die ausgeführt wird</p><p>-- @within Internal</p><p>-- @local</p><p>    table.insert(BundleEntityHealth.Global.Data.OnEntityDestroyedAction, _Function);</p><p>-- Fügt eine Funktion hinzu, die ausgeführt wird, wenn ein Entity erzeugt</p><p>-- wird. Die EntityID des zerstörten Entity wird übergeben.</p><p>-- @param _Function [function] Funktion, die ausgeführt wird</p><p>-- @within Internal</p><p>-- @local</p><p>    table.insert(BundleEntityHealth.Global.Data.OnEntityCreatedAction, _Function);</p><p>-- Führt alle registrierten Events aus, wenn ein Entity ein anderes angreift.</p><p>-- @within Internal</p><p>-- @local</p><p>    local AttackerIDs = {Event.GetEntityID1()};</p><p>    local DefenderIDs = {Event.GetEntityID2()};</p><p>    for i=1, #AttackerIDs, 1 do</p><p>        for j=1, #DefenderIDs, 1 do</p><p>            local Attacker = AttackerIDs[i];</p><p>            local Defender = DefenderIDs[j];</p><p>            if IsExisting(Attacker) and IsExisting(Defender) then</p><p>                for k, v in pairs(BundleEntityHealth.Global.Data.OnEntityHurtAction) do</p><p>                    if v then</p><p>                        v(Attacker, Defender);</p><p>                    end</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>-- Führt alle registrierten Events aus, wenn ein Entity zerstört wird.</p><p>-- @within Internal</p><p>-- @local</p><p>    local EntityIDs = {Event.GetEntityID()};</p><p>    for i=1, #EntityIDs, 1 do</p><p>        local EntityID = EntityIDs[i];</p><p>        for k, v in pairs(BundleEntityHealth.Global.Data.OnEntityDestroyedAction) do</p><p>            if v then</p><p>                v(EntityID);</p><p>            end</p><p>        end</p><p>    end</p><p>-- Führt alle registrierten Events aus, wenn ein Entity erzeugt wird.</p><p>-- @param _EntityID [number] ID des Entity</p><p>-- @within Internal</p><p>-- @local</p><p>    for k, v in pairs(BundleEntityHealth.Global.Data.OnEntityDestroyedAction) do</p><p>        if v then</p><p>            v(_EntityID);</p><p>        end</p><p>    end</p><p>-- Local Script ----------------------------------------------------------------</p><p>-- Initialisiert das Bundle im lokalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>-- Shared Script ---------------------------------------------------------------</p><p>-- Gibt die Gesundheit des Entity in prozent zurück.</p><p>-- @param _Entity [string|number] Entity to change</p><p>-- @return [number] Health in percent</p><p>-- @within Internal</p><p>-- @local</p><p>    if not IsExisting(_Entity) then</p><p>        return 0;</p><p>    end</p><p>    local EntityID  = GetID(_Entity);</p><p>    local MaxHealth = Logic.GetEntityMaxHealth(EntityID);</p><p>    local Health    = Logic.GetEntityHealth(EntityID);</p><p>    return (Health / MaxHealth) * 100;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ändert die Gesundheit eines Entity.</p><p>-- @param _Entity     [string] Entity</p><p>-- @param _Percentage [number] Prozentwert</p><p>-- @within Reprisal</p><p>    return b_Reprisal_SetHealth:new(...);</p><p>Reprisal_SetHealth</p><p>    Name = "Reprisal_SetHealth",</p><p>    Description = {</p><p>        en = "Reprisal: Changes the health of an entity.",</p><p>        de = "Vergeltung: Setzt die Gesundheit eines Entity.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Entity",     de = "Entity", },</p><p>        { ParameterType.Number,     en = "Percentage", de = "Prozentsatz", },</p><p>    },</p><p>    return { Reprisal.Custom, { self, self.CustomFunction } }</p><p>    if (_Index == 0) then</p><p>        self.Entity = _Parameter;</p><p>    elseif (_Index == 1) then</p><p>        self.Percentage = _Parameter;</p><p>    end</p><p>    SetHealth(self.Entity, self.Percentage);</p><p>    if not IsExisting(self.Entity) then</p><p>        dbg(_Quest.Identifier.. " " ..self.Name.. ": Entity is dead! :(");</p><p>        -- return true;</p><p>    end</p><p>    if self.Percentage < 0 or self.Percentage > 100 then</p><p>        dbg(_Quest.Identifier.. " " ..self.Name.. ": Percentage must be between 0 and 100!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ändert die Gesundheit eines Entity.</p><p>-- @param _Entity     [string] Entity</p><p>-- @param _Percentage [number] Prozentwert</p><p>-- @within Reward</p><p>    return b_Reward_SetHealth:new(...);</p><p>Reward_SetHealth = API.InstanceTable(b_Reprisal_SetHeal</p><p>Reward_SetHealth.Name = "Reward_SetHeal</p><p>Reward_SetHealth.Description.en = "Reward: Changes the health of an entit</p><p>Reward_SetHealth.Description.de = "Lohn: Setzt die Gesundheit eines Entit</p><p>Reward_SetHealth.GetReprisalTable = </p><p>Reward_SetHealth.GetRewardTable = function(self, _Qu</p><p>    return { Reward.Custom, { self, self.CustomFunction } }</p><p>    if not IsExisting(self.Entity) then</p><p>        dbg(_Quest.Identifier.. " " ..self.Name.. ": Entity is dead! :(");</p><p>        return true;</p><p>    end</p><p>    if self.Percentage < 0 or self.Percentage > 100 then</p><p>        dbg(_Quest.Identifier.. " " ..self.Name.. ": Percentage must be between 0 and 100!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Die Gesundheit eines Entities muss einen bestimmten Wert erreichen.</p><p>-- @param _Entity [string9 Entity, das überwacht wird</p><p>-- @param _Amount [number] Menge in Prozent</p><p>-- @within Trigger</p><p>    return b_Trigger_EntityHealth:new(...);</p><p>Trigger_EntityHealth</p><p>    Name = "Trigger_EntityHealth",</p><p>    Description = {</p><p>        en = "Trigger: The health of a unit must reach a certain point.",</p><p>        de = "Auslöser: Die Gesundheit eines Entity muss einen bestimmten Wert erreichen.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Script name", de = "Skriptname" },</p><p>        { ParameterType.Custom,     en = "Relation",    de = "Relation" },</p><p>        { ParameterType.Number,     en = "Percentage",  de = "Prozentwert" },</p><p>    },</p><p>    return {Triggers.Custom2, {self, self.CustomFunction}};</p><p>    if (_Index == 0) then</p><p>        self.ScriptName = _Parameter;</p><p>    elseif (_Index == 1) then</p><p>        self.BeSmalerThan = _Parameter == "<";</p><p>    elseif (_Index == 2) then</p><p>        self.Percentage = _Parameter;</p><p>    end</p><p>    if _Index == 1 then</p><p>        return { "<", ">=" };</p><p>    end</p><p>    if self.BeSmalerThan then</p><p>        return GetHealth(self.ScriptName) < self.Percentage;</p><p>    else</p><p>        return GetHealth(self.ScriptName) >= self.Percentage;</p><p>    end</p><p>    if not IsExisting(self.ScriptName) then</p><p>        dbg(_Quest.Identifier.. " " ..self.Name.. ": Entity is dead! :(");</p><p>        return true;</p><p>    end</p><p>    if self.Percentage < 0 or self.Percentage > 100 then</p><p>        dbg(_Quest.Identifier.. " " ..self.Name.. ": Percentage must be between 0 and 100!");</p><p>        return true;</p><p>    end</p><p>    return false;</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundleentityhelperfunctions.lua.html">
            <div class='doclink'>
                <div>BundleEntityHelperFunctions</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia BundleEntityHelperFunctions                                  # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Stellt Hilfsfunktionen bereit um die Eigenschaften von Entities zu</p><p>-- ermitteln oder zu verändern.</p><p>-- Das wichtigste Auf einen Blick:</p><p>-- <ul></p><p>-- <li></p><p>-- <a href="#API.EntityGetName">Eigenschaften von Entities</a></p><p>-- </li></p><p>-- <li></p><p>-- <a href="#API.GetEntitiesByPrefix">Entities ermitteln</a></p><p>-- </li></p><p>-- </ul></p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Sucht auf den angegebenen Territorium nach Entities mit bestimmten</p><p>-- Kategorien. Dabei kann für eine Partei oder für mehrere parteien gesucht</p><p>-- werden.</p><p>-- <p><b>Alias:</b> GetEntitiesOfCategoriesInTerritories<br></p></p><p>-- <p><b>Alias:</b> EntitiesInCategories</p></p><p>-- @param _player       [number|table] PlayerID [0-8] oder Table mit PlayerIDs</p><p>-- @param _category     [number|table] Kategorien oder Table mit Kategorien</p><p>-- @param _territory    [number|table] Zielterritorium oder Table mit Territorien</p><p>-- @return [table] Liste mit Resultaten</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- local Result = API.GetEntitiesOfCategoriesInTerritories({1, 2, 3}, EntityCategories.Hero, {5, 12, 23, 24});</p><p>function API.GetEntitiesOfCategoriesInTerritories(_player, _category, _territory)</p><p>    return BundleEntityHelperFunctions.Shared:GetEntitiesOfCategoriesInTerritories(_player, _category, _territory);</p><p>-- Gibt alle Entities zurück, deren Name mit dem Prefix beginnt.</p><p>-- <p><b>Alias:</b> GetEntitiesNamedWith</p></p><p>-- @param _Prefix [string] Präfix des Skriptnamen</p><p>-- @return [table] Liste mit Entities</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- -- Alle Entities mit "entranceCave" -> entranceCave1, entranceCave2, ...</p><p>-- local Result = API.GetEntitiesByPrefix("entranceCave");</p><p>function API.GetEntitiesByPrefix(_Prefix)</p><p>    return BundleEntityHelperFunctions.Shared:GetEntitiesByPrefix(_Prefix);</p><p>-- Setzt die Menge an Rohstoffen und die durchschnittliche Auffüllmenge</p><p>-- in einer Mine.</p><p>-- <p><b>Alias:</b> SetResourceAmount</p></p><p>-- @param _Entity       [string|number] Skriptname, EntityID der Mine</p><p>-- @param _StartAmount  [number] Menge an Rohstoffen</p><p>-- @param _RefillAmount [number] Minimale Nachfüllmenge (> 0)</p><p>-- @within User Spase</p><p>-- @usage</p><p>-- API.SetResourceAmount("mine1", 250, 150);</p><p>function API.SetResourceAmount(_Entity, _StartAmount, _RefillAmount)</p><p>    if GUI then</p><p>        local Subject = (type(_Entity) ~= "string" and _Entity) or "'" .._Entity.. "'";</p><p>        API.Bridge("API.SetResourceAmount(" ..Subject..", " .._StartAmount.. ", " .._RefillAmount.. ")")</p><p>        return;</p><p>    end</p><p>    if not IsExisting(_Entity) then</p><p>        local Subject = (type(_Entity) ~= "string" and _Entity) or "'" .._Entity.. "'";</p><p>        API.Fatal("API.SetResourceAmount: Entity " ..Subject.. " does not exist!");</p><p>        return;</p><p>    end</p><p>    return BundleEntityHelperFunctions.Global:SetResourceAmount(_Entity, _StartAmount, _RefillAmount);</p><p>-- Errechnet eine Position relativ im angegebenen Winkel und Position zur</p><p>-- Basisposition. Die Basis kann ein Entity oder eine Positionstabelle sein.</p><p>-- <p><b>Alias:</b> GetRelativePos</p></p><p>-- @param _target          [string|number|table] Basisposition</p><p>-- @param _distance        [number] Entfernung</p><p>-- @param _angle           [number] Winkel</p><p>-- @param _buildingRealPos [boolean] Gebäudemitte statt Gebäudeeingang</p><p>-- @return [table] Position</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- local RelativePostion = API.GetRelativePosition("pos1", 1000, 32);</p><p>function API.GetRelativePosition(_target, _distance, _angle, _buildingRealPos)</p><p>    if not API.ValidatePosition(_target) then</p><p>        if not IsExisting(_target) then</p><p>            API.Fatal("API.GetRelativePosition: Target is invalid!");</p><p>            return;</p><p>        end</p><p>    end</p><p>    return BundleEntityHelperFunctions.Shared:GetRelativePos(_target, _distance, _angle, _buildingRealPos);</p><p>-- Gibt den Skriptnamen des Entity zurück.</p><p>-- <p><b>Alias:</b> GetEntityName</p></p><p>-- @param _entity [number] Gesuchtes Entity</p><p>-- @return [string] Skriptname</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- local Name = API.EntityGetName(SomeEntityID);</p><p>function API.EntityGetName(_entity)</p><p>    if not IsExisting(_entity) then</p><p>        local Subject = (type(_entity) ~= "string" and _entity) or "'" .._entity.. "'";</p><p>        API.Warn("API.EntityGetName: Entity " ..Subject.. " does not exist!");</p><p>        return nil;</p><p>    end</p><p>    return Logic.GetEntityName(GetID(_entity));</p><p>-- Setzt den Skriptnamen des Entity.</p><p>-- <p><b>Alias:</b> SetEntityName</p></p><p>-- @param _entity [number] Entity</p><p>-- @param _name   [string] Skriptname</p><p>-- @return [string] Skriptname</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.EntitySetName(SomeEntityID, "myEntity");</p><p>function API.EntitySetName(_entity, _name)</p><p>    if GUI then</p><p>        API.Bridge("API.EntitySetName(" ..GetID(_EntityID).. ", '" .._name.. "')")</p><p>        return;</p><p>    end</p><p>    if IsExisting(_name) then</p><p>        API.Fatal("API.EntitySetName: Entity '" .._name.. "' already exists!");</p><p>        return;</p><p>    end</p><p>    return Logic.SetEntityName(GetID(_entity), _name);</p><p>-- Setzt die Orientierung des Entity.</p><p>-- <p><b>Alias:</b> SetOrientation</p></p><p>-- @param _entity [string|number] Gesuchtes Entity</p><p>-- @param _ori    [number] Ausrichtung in Grad</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.EntitySetOrientation("marcus", 52);</p><p>function API.EntitySetOrientation(_entity, _ori)</p><p>    if GUI then</p><p>        API.Bridge("API.EntitySetOrientation(" ..GetID(_entity).. ", " .._ori.. ")")</p><p>        return;</p><p>    end</p><p>    if not IsExisting(_entity) then</p><p>        local Subject = (type(_entity) ~= "string" and _entity) or "'" .._entity.. "'";</p><p>        API.Fatal("API.EntitySetOrientation: Entity " ..Subject.. " does not exist!");</p><p>        return;</p><p>    end</p><p>    return Logic.SetOrientation(GetID(_entity), _ori);</p><p>-- Gibt die Orientierung des Entity zurück.</p><p>-- <p><b>Alias:</b> GetOrientation</p></p><p>-- @param _entity [string|number] Gesuchtes Entity</p><p>-- @return [number] Orientierung in Grad</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- local Orientation = API.EntityGetOrientation("marcus");</p><p>function API.EntityGetOrientation(_entity)</p><p>    if not IsExisting(_entity) then</p><p>        local Subject = (type(_entity) ~= "string" and _entity) or "'" .._entity.. "'";</p><p>        API.Warn("API.EntityGetOrientation: Entity " ..Subject.. " does not exist!");</p><p>        return 0;</p><p>    end</p><p>    return Logic.GetEntityOrientation(GetID(_entity));</p><p>-- Ermittelt den Helden eines Spielers, ders dem Basis-Entity am nächsten ist.</p><p>-- <p><b>Alias:</b> GetClosestKnight</p></p><p>-- @param _eID      [number] Basis-Entity</p><p>-- @param _playerID [number] Besitzer der Helden</p><p>-- @return [number] Nächstes Entity</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- local Knight = API.GetKnightsNearby(GetID("IO1"), 1);</p><p>function API.GetKnightsNearby(_eID, _playerID)</p><p>    local Knights = {};</p><p>    Logic.GetKnights(_playerID, Knights);</p><p>    return API.GetEntitiesNearby(_eID, Knights);</p><p>-- Ermittelt aus einer liste von Entity-IDs das Entity, dass dem Basis-Entity</p><p>-- am nächsten ist.</p><p>-- <p><b>Alias:</b> GetClosestEntity</p></p><p>-- @param _eID      [number] Basis-Entity</p><p>-- @param _entities [table] Liste von Entities</p><p>-- @return [number] Nächstes Entity</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- local EntityList = API.GetEntitiesOfCategoriesInTerritories({1, 2, 3}, EntityCategories.Hero, {5, 12, 23, 24});</p><p>-- local Knight = API.GetEntitiesNearby(GetID("IO1"), EntityList);</p><p>function API.GetEntitiesNearby(_eID, _entities)</p><p>    if not IsExisting(_eID) then</p><p>        return;</p><p>    end</p><p>    if #_entities == 0 then</p><p>        API.Fatal("API.GetEntitiesNearby: The target list is empty!");</p><p>        return;</p><p>    end</p><p>    for i= 1, #_entities, 1 do</p><p>        if not IsExisting(_entities[i]) then</p><p>            API.Fatal("API.GetEntitiesNearby: At least one target entity is dead!");</p><p>            return;</p><p>        end</p><p>    end</p><p>    return BundleEntityHelperFunctions.Shared:GetNearestEntity(_eID,_entities);</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {</p><p>        Data = {</p><p>            RefillAmounts = {},</p><p>        }</p><p>    },</p><p>    Shared = {</p><p>        Data = {}</p><p>    },</p><p>-- Global Script ---------------------------------------------------------------</p><p>-- Initalisiert das Bundle im globalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    BundleEntityHelperFunctions.Global:OverwriteGeologistRefill();</p><p>-- Überschreibt das Auffüll-Callback, wenn es vorhanden ist, um Auffüllmengen</p><p>-- auch während des Spiels setzen zu können.</p><p>-- @within Internal</p><p>-- @local</p><p>    if Framework.GetGameExtraNo() >= 1 then</p><p>        GameCallback_OnGeologistRefill_Orig_QSBPlusComforts1 = GameCallback_OnGeologistRefill</p><p>        GameCallback_OnGeologistRefill = function( _PlayerID, _TargetID, _GeologistID )</p><p>            GameCallback_OnGeologistRefill_Orig_QSBPlusComforts1( _PlayerID, _TargetID, _GeologistID )</p><p>            if BundleEntityHelperFunctions.Global.Data.RefillAmounts[_TargetID] then</p><p>                local RefillAmount = BundleEntityHelperFunctions.Global.Data.RefillAmounts[_TargetID];</p><p>                local RefillRandom = RefillAmount + math.random(1, math.floor((RefillAmount * 0.2) + 0.5));</p><p>                Logic.SetResourceDoodadGoodAmount(_TargetID, RefillRandom);</p><p>            end</p><p>        end</p><p>    end</p><p>-- Setzt die Menge an Rohstoffen und die durchschnittliche Auffüllmenge</p><p>-- in einer Mine.</p><p>-- @param _Entity       [string|number] Skriptname, EntityID der Mine</p><p>-- @param _StartAmount  [number] Menge an Rohstoffen</p><p>-- @param _RefillAmount [number] Minimale Nachfüllmenge (> 0)</p><p>-- @return [boolean] Operation erfolgreich</p><p>-- @within Internal</p><p>-- @local</p><p>    assert(type(_StartAmount) == "number");</p><p>    assert(type(_RefillAmount) == "number");</p><p>    local EntityID = GetID(_Entity);</p><p>    if not IsExisting(EntityID) or Logic.GetResourceDoodadGoodType(EntityID) == 0 then</p><p>        API.Fatal("SetResourceAmount: Resource entity is invalid!");</p><p>        return false;</p><p>    end</p><p>    if Logic.GetResourceDoodadGoodAmount(EntityID) == 0 then</p><p>        EntityID = ReplaceEntity(EntityID, Logic.GetEntityType(EntityID));</p><p>    end</p><p>    Logic.SetResourceDoodadGoodAmount(EntityID, _StartAmount);</p><p>    if _RefillAmount then</p><p>        self.Data.RefillAmounts[EntityID] = _RefillAmount;</p><p>    end</p><p>    return true;</p><p>-- Shared ----------------------------------------------------------------------</p><p>-- Ermittelt alle Entities in den Kategorien auf den Territorien für die</p><p>-- Liste von Parteien und gibt sie als Liste zurück.</p><p>-- @param _player       [number|table] PlayerID [0-8] oder Table mit PlayerIDs</p><p>-- @param _category     [number|table] Kategorien oder Table mit Kategorien</p><p>-- @param _territory    [number|table] Zielterritorium oder Table mit Territorien</p><p>-- @return [table] Liste mit Resultaten</p><p>-- @within Internal</p><p>-- @local</p><p>    -- Tables erzwingen</p><p>    local p = (type(_player) == "table" and _player) or {_player};</p><p>    local c = (type(_category) == "table" and _category) or {_category};</p><p>    local t = (type(_territory) == "table" and _territory) or {_territory};</p><p>    local PlayerEntities = {};</p><p>    for i=1, #p, 1 do</p><p>        for j=1, #c, 1 do</p><p>            for k=1, #t, 1 do</p><p>                local Units = API.GetEntitiesOfCategoryInTerritory(p[i], c[j], t[k]);</p><p>                PlayerEntities = Array_Append(PlayerEntities, Units);</p><p>            end</p><p>        end</p><p>    end</p><p>    return PlayerEntities;</p><p>-- Gibt alle Entities zurück, deren Name mit dem Prefix beginnt.</p><p>-- @param _Prefix [string] Präfix des Skriptnamen</p><p>-- @return [table] Liste mit Entities</p><p>-- @within Internal</p><p>-- @local</p><p>    local list = {};</p><p>    local i = 1;</p><p>    local bFound = true;</p><p>    while bFound do</p><p>        local entity = GetID(_Prefix ..i);</p><p>        if entity ~= 0 then</p><p>            table.insert(list, entity);</p><p>        else</p><p>            bFound = false;</p><p>        end</p><p>        i = i + 1;</p><p>    end</p><p>    return list;</p><p>-- Errechnet eine Position relativ im angegebenen Winkel und Position zur</p><p>-- Basisposition. Die Basis kann ein Entity oder eine Positionstabelle sein.</p><p>-- @param _target          [string|number|table] Basisposition</p><p>-- @param _distance        [number] Entfernung</p><p>-- @param _angle           [number] Winkel</p><p>-- @param _buildingRealPos [boolean] Gebäudemitte statt Gebäudeeingang</p><p>-- @return [table] Position</p><p>-- @within Internal</p><p>-- @local</p><p>    if not type(_target) == "table" and not IsExisting(_target)then</p><p>        return</p><p>    end</p><p>    if _angle == nil then</p><p>        _angle = 0;</p><p>    end</p><p>    local pos1;</p><p>    if type(_target) == "table" then</p><p>        local pos = _target;</p><p>        local ori = 0+_angle;</p><p>        pos1 = { X= pos.X+_distance * math.cos(math.rad(ori)),</p><p>                 Y= pos.Y+_distance * math.sin(math.rad(ori))};</p><p>    else</p><p>        local eID = GetID(_target);</p><p>        local pos = GetPosition(eID);</p><p>        local ori = Logic.GetEntityOrientation(eID)+_angle;</p><p>        if Logic.IsBuilding(eID) == 1 and not _buildingRealPos then</p><p>            x, y = Logic.GetBuildingApproachPosition(eID);</p><p>            pos = {X= x, Y= y};</p><p>            ori = ori -90;</p><p>        end</p><p>        pos1 = { X= pos.X+_distance * math.cos(math.rad(ori)),</p><p>                 Y= pos.Y+_distance * math.sin(math.rad(ori))};</p><p>    end</p><p>    return pos1;</p><p>-- Ermittelt aus einer liste von Entity-IDs das Entity, dass dem Basis-Entity</p><p>-- am nächsten ist.</p><p>-- @param _eID      [number] Basis-Entity</p><p>-- @param _entities [table] Liste von Entities</p><p>-- @return [number] Nächstes Entity</p><p>-- @within Internal</p><p>-- @local</p><p>    local bestDistance = Logic.WorldGetSize();</p><p>    local best = nil;</p><p>    for i=1,#_entities do</p><p>        local distanceBetween = Logic.GetDistanceBetweenEntities(_entities[i], _eID);</p><p>        if distanceBetween < bestDistance and _entities[i] ~= _eID then</p><p>            bestDistance = distanceBetween;</p><p>            best = _entities[i];</p><p>        end</p><p>    end</p><p>    return best;</p><p>-- -------------------------------------------------------------------------- --</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundleentityscriptingvalues.lua.html">
            <div class='doclink'>
                <div>BundleEntityScriptingValues</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia BundleEntityScriptingValues                                  # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- <p>Mit diesem Bundle können Eigenschaften von Entities abgefragt oder</p><p>-- verändert werden, die sonst unzugänglich wären. Dazu zählen beispielsweise</p><p>-- die Größe des Entity und das Bewegungsziel.</p></p><p>-- <p><a href="#API.GetEntityPlayer">Scripting Values</a></p></p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Gibt den Größenfaktor des Entity zurück.</p><p>-- <p>Der Faktor gibt die relative Größe des Entity zu seiner normalen Größe an.</p><p>-- </p></p><p>-- <p><b>Alias</b>: GetScale</p></p><p>-- @param _Entity [string|number] Entity</p><p>-- @return [number] Größenfaktor</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- local Scale = API.GetEntityScale("alandra")</p><p>function API.GetEntityScale(_Entity)</p><p>    if not IsExisting(_Entity) then</p><p>        local Subject = (type(_Entity) == "string" and "'" .._Entity.. "'") or _Entity;</p><p>        API.Fatal("API.GetEntityScale: Target " ..Subject.. " is invalid!");</p><p>        return -1;</p><p>    end</p><p>    return BundleEntityScriptingValues.Shared:GetEntitySize(_Entity);</p><p>-- Gibt den Besitzer des Entity zurück.</p><p>-- <p><b>Alias</b>: GetPlayer</p></p><p>-- @param _Entity [string|number] Entity</p><p>-- @return [number] Besitzer</p><p>-- @within Anwenderfunktionen</p><p>function API.GetEntityPlayer(_Entity)</p><p>    if not IsExisting(_Entity) then</p><p>        local Subject = (type(_Entity) == "string" and "'" .._Entity.. "'") or _Entity;</p><p>        API.Fatal("API.GetEntityPlayer: Target " ..Subject.. " is invalid!");</p><p>        return -1;</p><p>    end</p><p>    return BundleEntityScriptingValues.Shared:GetPlayerID(_entity);</p><p>-- Gibt die Position zurück, zu der sich das Entity bewegt.</p><p>-- Über diese Koordinaten könnte man prüfen, ob ein Entity sich in einen</p><p>-- Bereich bewegt, in dem es nichts zu suchen hat.</p><p>-- <p><b>Alias</b>: GetMovingTarget</p></p><p>-- @param _Entity [string|number] Entity</p><p>-- @return [table] Positionstabelle</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- -- Hakim bleibt stehen, wenn er in ein Sperrgebiet bewegt wird.</p><p>-- local Destination = API.GetMovementTarget("hakim");</p><p>-- if GetDistance(Destination, "LockedArea") < 2000 then</p><p>--     local x,y,z = Logic.EntityGetPos(GetID("hakim"));</p><p>--     Logic.DEBUG_SetSettlerPosition(GetID("hakim"), x, y):</p><p>-- end</p><p>function API.GetMovementTarget(_Entity)</p><p>    if not IsExisting(_Entity) then</p><p>        local Subject = (type(_Entity) == "string" and "'" .._Entity.. "'") or _Entity;</p><p>        API.Fatal("API.GetMovementTarget: Target " ..Subject.. " is invalid!");</p><p>        return nil;</p><p>    end</p><p>    return BundleEntityScriptingValues.Shared:GetMovingTargetPosition(_Entity);</p><p>-- Gibt zurück, ob das NPC-Flag bei dem Siedler gesetzt ist.</p><p>-- Auf diese Weise kann geprüft werden, ob ein NPC auf dem Entity aktiv ist.</p><p>-- <p><b>Alias</b>: IsNpc</p></p><p>-- @param _Entity [string|number] Entity</p><p>-- @return [boolean] Ist NPC</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- local Active = API.IsActiveNpc("alandra");</p><p>-- if Active then</p><p>--     API.Note("NPC is active");</p><p>-- end</p><p>function API.IsActiveNpc(_Entity)</p><p>    if not IsExisting(_Entity) then</p><p>        local Subject = (type(_Entity) == "string" and "'" .._Entity.. "'") or _Entity;</p><p>        API.Fatal("API.IsActiveNpc: Target " ..Subject.. " is invalid!");</p><p>        return false;</p><p>    end</p><p>    return BundleEntityScriptingValues.Shared:IsOnScreenInformationActive(_Entity);</p><p>-- Gibt zurück, ob das Entity sichtbar ist.</p><p>-- <p><b>Alias</b>: IsVisible</p></p><p>-- @param _Entity [string|number] Entity</p><p>-- @return [boolean] Ist sichtbar</p><p>-- @within Anwenderfunktionen</p><p>function API.IsEntityVisible(_Entity)</p><p>    if not IsExisting(_Entity) then</p><p>        local Subject = (type(_Entity) == "string" and "'" .._Entity.. "'") or _Entity;</p><p>        API.Fatal("API.IsEntityVisible: Target " ..Subject.. " is invalid!");</p><p>        return false;</p><p>    end</p><p>    return BundleEntityScriptingValues.Shared:IsEntityVisible(_Entity);</p><p>-- Setzt den Größenfaktor des Entity.</p><p>-- Bei einem Siedler wird ebenfalls versucht die Bewegungsgeschwindigkeit an</p><p>-- die Größe anzupassen, was aber nicht bei allen Siedlern möglich ist.</p><p>-- <p><b>Alias</b>: SetScale</p></p><p>-- @param _Entity [string|number] Entity</p><p>-- @param _Scale  [number] Größenfaktor</p><p>-- @within Anwenderfunktionen</p><p>function API.SetEntityScale(_Entity, _Scale)</p><p>    if GUI or not IsExisting(_Entity) then</p><p>        local Subject = (type(_Entity) == "string" and "'" .._Entity.. "'") or _Entity;</p><p>        API.Fatal("API.SetEntityScale: Target " ..Subject.. " is invalid!");</p><p>        return;</p><p>    end</p><p>    if type(_Scale) ~= "number" then</p><p>        API.Fatal("API.SetEntityScale: Scale must be a number!");</p><p>        return;</p><p>    end</p><p>    return BundleEntityScriptingValues.Global:SetEntitySize(_Entity, _Scale);</p><p>-- Erzwingt einen neuen Besitzer für das Entity.</p><p>-- Mit dieser Funktion werden die Sicherungen des Spiels umgangen! Es ist</p><p>-- möglich ein Raubtier einem richtigen Spieler zuzuweisen.</p><p>-- <p><b>Alias</b>: ChangePlayer</p></p><p>-- @param _Entity   [string|number] Entity</p><p>-- @param _PlayerID [number] Besitzer</p><p>-- @within Anwenderfunktionen</p><p>function API.SetEntityPlayer(_Entity, _PlayerID)</p><p>    if GUI or not IsExisting(_Entity) then</p><p>        local Subject = (type(_Entity) == "string" and "'" .._Entity.. "'") or _Entity;</p><p>        API.Fatal("API.SetEntityPlayer: Target " ..Subject.. " is invalid!");</p><p>        return;</p><p>    end</p><p>    if type(_PlayerID) ~= "number" or _PlayerID <= 0 or _PlayerID > 8 then</p><p>        API.Fatal("API.SetEntityPlayer: Player-ID must between 0 and 8!");</p><p>        return;</p><p>    end</p><p>    return BundleEntityScriptingValues.Global:SetPlayerID(_Entity, math.floor(_PlayerID));</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {</p><p>        Data = {}</p><p>    },</p><p>    Local = {</p><p>        Data = {}</p><p>    },</p><p>    Shared = {</p><p>        Data = {}</p><p>    },</p><p>-- Global Script ---------------------------------------------------------------</p><p>-- Initalisiert das Bundle im globalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>-- Ändert die Größe des Entity.</p><p>-- @param _Entity [string|number] Entity</p><p>-- @param _Scale  [number] Größenfaktor</p><p>-- @within Internal</p><p>-- @local</p><p>    local EntityID = GetID(_Entity);</p><p>    Logic.SetEntityScriptingValue(EntityID, -45, BundleEntityScriptingValues.Shared:Float2Int(_size));</p><p>    if Logic.IsSettler(EntityID) == 1 then</p><p>        Logic.SetSpeedFactor(EntityID, _Scale);</p><p>    end</p><p>-- Ändert den Besitzer des Entity.</p><p>-- @param _Entity   [string|number] Entity</p><p>-- @param _PlayerID [number] Besitzer</p><p>-- @within Internal</p><p>-- @local</p><p>    local EntityID = GetID(_Entity);</p><p>    Logic.SetEntityScriptingValue(EntityID, -71, _PlayerID);</p><p>-- Local Script ----------------------------------------------------------------</p><p>-- Initalisiert das Bundle im lokalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>-- Shared ----------------------------------------------------------------------</p><p>-- Gibt die relative Größe des Entity zurück.</p><p>-- @param _Entity [string|number] Entity</p><p>-- @return [number] Größenfaktor</p><p>-- @within BundleEntityScriptingValues</p><p>-- @local</p><p>    local EntityID = GetID(_Entity);</p><p>    local size = Logic.GetEntityScriptingValue(EntityID, -45);</p><p>    return self:Int2Float(size);</p><p>-- Gibt den Besitzer des Entity zurück.</p><p>-- @param _Entity [string|number] Entity</p><p>-- @return [number] Besitzer</p><p>-- @within BundleEntityScriptingValues</p><p>-- @local</p><p>    local EntityID = GetID(_Entity);</p><p>    return Logic.GetEntityScriptingValue(EntityID, -71);</p><p>-- Gibt zurück, ob das Entity sichtbar ist.</p><p>-- @param _Entity [string|number] Entity</p><p>-- @return [boolean] Ist sichtbar</p><p>-- @within BundleEntityScriptingValues</p><p>-- @local</p><p>    local EntityID = GetID(_Entity);</p><p>    return Logic.GetEntityScriptingValue(EntityID, -50) == 801280;</p><p>-- Gibt zurück, ob eine NPC-Interaktion mit dem Siedler möglich ist.</p><p>-- @param _Entity [string|number] Entity</p><p>-- @return [boolean] Ist NPC</p><p>-- @within BundleEntityScriptingValues</p><p>-- @local</p><p>    local EntityID = GetID(_Entity);</p><p>    if Logic.IsSettler(EntityID) == 0 then</p><p>        return false;</p><p>    end</p><p>    return Logic.GetEntityScriptingValue(EntityID, 6) == 1;</p><p>-- Gibt das Bewegungsziel des Entity zurück.</p><p>-- @param _Entity [string|number] Entity</p><p>-- @return [table] Positionstabelle</p><p>-- @within BundleEntityScriptingValues</p><p>-- @local</p><p>    local pos = {};</p><p>    pos.X = self:GetValueAsFloat(_Entity, 19) or 0;</p><p>    pos.Y = self:GetValueAsFloat(_Entity, 20) or 0;</p><p>    return pos;</p><p>-- Gibt die Scripting Value des Entity als Ganzzahl zurück.</p><p>-- @param _Entity [string|number] Zu untersuchendes Entity</p><p>-- @param _index  [number] Index im RAM</p><p>-- @return [number] Ganzzahl</p><p>-- @within BundleEntityScriptingValues</p><p>-- @local</p><p>    local value = Logic.GetEntityScriptingValue(GetID(_Entity),_index);</p><p>    return value;</p><p>-- Gibt die Scripting Value des Entity als Dezimalzahl zurück.</p><p>-- @param _Entity [string|number] Zu untersuchendes Entity</p><p>-- @param _index  [number] Index im RAM</p><p>-- @return [number] Dezimalzahl</p><p>-- @within BundleEntityScriptingValues</p><p>-- @local</p><p>    local value = Logic.GetEntityScriptingValue(GetID(_Entity),_index);</p><p>    return self:Int2Float(value);</p><p>-- Bestimmt das Modul b der Zahl a.</p><p>-- @param a	[number] Zahl</p><p>-- @param b	[number] Modul</p><p>-- @return [number] qmod der Zahl</p><p>-- @within BundleEntityScriptingValues</p><p>-- @local</p><p>    return a - math.floor(a/b)*b</p><p>-- Konvertiert eine Ganzzahl in eine Dezimalzahl.</p><p>-- @param num [number] Integer</p><p>-- @return [number] Integer als Float</p><p>-- @within BundleEntityScriptingValues</p><p>-- @local</p><p>    if(num == 0) then return 0 end</p><p>    local sign = 1</p><p>    if(num < 0) then num = 2147483648 + num; sign = -1 end</p><p>    local frac = self:qmod(num, 8388608)</p><p>    local headPart = (num-frac)/8388608</p><p>    local expNoSign = self:qmod(headPart, 256)</p><p>    local exp = expNoSign-127</p><p>    local fraction = 1</p><p>    local fp = 0.5</p><p>    local check = 4194304</p><p>    for i = 23, 0, -1 do</p><p>        if(frac - check) > 0 then fraction = fraction + fp; frac = frac - check end</p><p>        check = check / 2; fp = fp / 2</p><p>    end</p><p>    return fraction * math.pow(2, exp) * sign</p><p>-- Gibt den Integer als Bits zurück.</p><p>-- @param num [number] Bits</p><p>-- @return [table] Table mit Bits</p><p>-- @within BundleEntityScriptingValues</p><p>-- @local</p><p>    local t={}</p><p>    while num>0 do</p><p>        rest=self:qmod(num, 2) table.insert(t,1,rest) num=(num-rest)/2</p><p>    end</p><p>    table.remove(t, 1)</p><p>    return t</p><p>-- Stellt eine Zahl als eine Folge von Bits in einer Table dar.</p><p>-- @param num [integer] Integer</p><p>-- @param t	  [table] Table</p><p>-- @return [table] Table mit Bits</p><p>-- @within BundleEntityScriptingValues</p><p>-- @local</p><p>    for i = 1, 48 do</p><p>        num = num * 2</p><p>        if(num >= 1) then table.insert(t, 1); num = num - 1 else table.insert(t, 0) end</p><p>        if(num == 0) then return t end</p><p>    end</p><p>    return t</p><p>-- Konvertiert eine Dezimalzahl in eine Ganzzahl.</p><p>-- @param fval [number] Float</p><p>-- @return [number] Float als Integer</p><p>-- @within BundleEntityScriptingValues</p><p>-- @local</p><p>    if(fval == 0) then return 0 end</p><p>    local signed = false</p><p>    if(fval < 0) then signed = true; fval = fval * -1 end</p><p>    local outval = 0;</p><p>    local bits</p><p>    local exp = 0</p><p>    if fval >= 1 then</p><p>        local intPart = math.floor(fval); local fracPart = fval - intPart;</p><p>        bits = self:bitsInt(intPart); exp = table.getn(bits); self:bitsFrac(fracPart, bits)</p><p>    else</p><p>        bits = {}; self:bitsFrac(fval, bits)</p><p>        while(bits[1] == 0) do exp = exp - 1; table.remove(bits, 1) end</p><p>        exp = exp - 1</p><p>        table.remove(bits, 1)</p><p>    end</p><p>    local bitVal = 4194304; local start = 1</p><p>    for bpos = start, 23 do</p><p>        local bit = bits[bpos]</p><p>        if(not bit) then break; end</p><p>        if(bit == 1) then outval = outval + bitVal end</p><p>        bitVal = bitVal / 2</p><p>    end</p><p>    outval = outval + (exp+127)*8388608</p><p>    if(signed) then outval = outval - 2147483648 end</p><p>    return outval;</p><p>-- -------------------------------------------------------------------------- --</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundleentityselection.lua.html">
            <div class='doclink'>
                <div>BundleEntitySelection</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia BundleEntitySelection                                        # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Mit diesem Bundle kann die Selektion von Entities gesteuert werden.</p><p>-- <p>Das wichtigste auf einen Blick:</p></p><p>-- <ul></p><p>-- <li><a href="#API.DisableReleaseSoldiers">Einheiten entlassen</a></li></p><p>-- <li><a href="#API.GetSelectedEntities">Selektierte Entities ermitteln</a></li></p><p>-- </ul></p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Deaktiviert oder aktiviert das Nachfüllen von Trebuchets.</p><p>-- @param _Flag [boolean] Deaktiviert (false) / Aktiviert (true)</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.DisableRefillTrebuchet(true);</p><p>function API.DisableRefillTrebuchet(_Flag)</p><p>    if not GUI then</p><p>        API.Bridge("API.DisableRefillTrebuchet(" ..tostring(_Flag).. ")");</p><p>        return;</p><p>    end</p><p>    API.Bridge("BundleEntitySelection.Local.Data.RefillTrebuchet = " ..tostring(not _Flag));</p><p>    BundleEntitySelection.Local.Data.RefillTrebuchet = not _Flag;</p><p>-- Deaktiviert oder aktiviert das Entlassen von Dieben.</p><p>-- @param _Flag [boolean] Deaktiviert (false) / Aktiviert (true)</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.DisableReleaseThieves(false);</p><p>function API.DisableReleaseThieves(_Flag)</p><p>    if not GUI then</p><p>        API.Bridge("API.DisableReleaseThieves(" ..tostring(_Flag).. ")");</p><p>        return;</p><p>    end</p><p>    BundleEntitySelection.Local.Data.ThiefRelease = not _Flag;</p><p>-- Deaktiviert oder aktiviert das Entlassen von Kriegsmaschinen.</p><p>-- @param _Flag [boolean] Deaktiviert (false) / Aktiviert (true)</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.DisableReleaseSiegeEngines(true);</p><p>function API.DisableReleaseSiegeEngines(_Flag)</p><p>    if not GUI then</p><p>        API.Bridge("API.DisableReleaseSiegeEngines(" ..tostring(_Flag).. ")");</p><p>        return;</p><p>    end</p><p>    BundleEntitySelection.Local.Data.SiegeEngineRelease = not _Flag;</p><p>-- Deaktiviert oder aktiviert das Entlassen von Soldaten.</p><p>-- @param _Flag [boolean] Deaktiviert (false) / Aktiviert (true)</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.DisableReleaseSoldiers(false);</p><p>function API.DisableReleaseSoldiers(_Flag)</p><p>    if not GUI then</p><p>        API.Bridge("API.DisableReleaseSoldiers(" ..tostring(_Flag).. ")");</p><p>        return;</p><p>    end</p><p>    BundleEntitySelection.Local.Data.MilitaryRelease = not _Flag;</p><p>-- Prüpft ob das Entity selektiert ist.</p><p>-- @param _Entity [string|number] Entity das selektiert sein soll</p><p>-- @return [boolean] Entity ist selektiert</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- if API.IsEntityInSelection("hakim") then</p><p>--     -- Do something</p><p>-- end</p><p>function API.IsEntityInSelection(_Entity)</p><p>    if IsExisting(_Entity) then</p><p>        local EntityID = GetID(_Entity);</p><p>        local SelectedEntities = BundleEntitySelection.Global.Data.SelectedEntities;</p><p>        if GUI then</p><p>            SelectedEntities = {GUI.GetSelectedEntities()};</p><p>        end</p><p>        for i= 1, #SelectedEntities, 1 do</p><p>            if SelectedEntities[i] == EntityID then</p><p>                return true;</p><p>            end</p><p>        end</p><p>    end</p><p>    return false;</p><p>-- Gibt die ID des selektierten Entity zurück.</p><p>-- Wenn mehr als ein Entity selektiert sind, wird das erste Entity</p><p>-- zurückgegeben. Sind keine Entities selektiert, wird 0 zurückgegeben.</p><p>-- @return [number] ID des selektierten Entities</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- local SelectedEntity = API.GetSelectedEntity();</p><p>function API.GetSelectedEntity()</p><p>    local SelectedEntity = BundleEntitySelection.Global.Data.SelectedEntities[1];</p><p>    if GUI then</p><p>        SelectedEntity = GUI.GetSelectedEntity();</p><p>    end</p><p>    return SelectedEntity or 0;</p><p>-- Gibt alle selektierten Entities zurück.</p><p>-- @return [table] ID des selektierten Entities</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- local Selection = API.GetSelectedEntities();</p><p>function API.GetSelectedEntities()</p><p>    local SelectedEntities = BundleEntitySelection.Global.Data.SelectedEntities;</p><p>    if GUI then</p><p>        SelectedEntities = {GUI.GetSelectedEntities()};</p><p>    end</p><p>    return SelectedEntities;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {</p><p>        Data = {</p><p>            RefillTrebuchet = true,</p><p>            AmmunitionUnderway = {},</p><p>            TrebuchetIDToCart = {},</p><p>            SelectedEntities = {};</p><p>        },</p><p>    },</p><p>    Local = {</p><p>        Data = {</p><p>            RefillTrebuchet = true,</p><p>            ThiefRelease = false,</p><p>            SiegeEngineRelease = true,</p><p>            MilitaryRelease = true,</p><p>            Tooltips = {</p><p>                KnightButton = {</p><p>                    Title = {</p><p>                        de = "Ritter selektieren",</p><p>                        en = "Select Knight",</p><p>                    },</p><p>                    Text = {</p><p>                        de = "- Klick selektiert den Ritter {cr}- Doppelklick springt zum Ritter{cr}- STRG halten selektiert alle Ritter",</p><p>                        en = "- Click selects the knight {cr}- Double click jumps to knight{cr}- Press CTRL to select all knights",</p><p>                    },</p><p>                },</p><p>                BattalionButton = {</p><p>                    Title = {</p><p>                        de = "Militär selektieren",</p><p>                        en = "Select Units",</p><p>                    },</p><p>                    Text = {</p><p>                        de = "- Selektiert alle Militäreinheiten {cr}- SHIFT halten um auch Munitionswagen und Trebuchets auszuwählen",</p><p>                        en = "- Selects all military units {cr}- Press SHIFT to additionally select ammunition carts and trebuchets",</p><p>                    },</p><p>                },</p><p>                ReleaseSoldiers = {</p><p>                    Title = {</p><p>                        de = "Militär entlassen",</p><p>                        en = "Release military unit",</p><p>                    },</p><p>                    Text = {</p><p>                        de = "- Eine Militäreinheit entlassen {cr}- Soldaten werden nacheinander entlassen",</p><p>                        en = "- Dismiss a military unit {cr}- Soldiers will be dismissed each after another",</p><p>                    },</p><p>                    Disabled = {</p><p>                        de = "Kann nicht entlassen werden!",</p><p>                        en = "Releasing is impossible!",</p><p>                    },</p><p>                },</p><p>                TrebuchetCart = {</p><p>                    Title = {</p><p>                        de = "Trebuchetwagen",</p><p>                        en = "Trebuchet cart",</p><p>                    },</p><p>                    Text = {</p><p>                        de = "- Kann einmalig zum Trebuchet ausgebaut werden",</p><p>                        en = "- Can uniquely be transmuted into a trebuchet",</p><p>                    },</p><p>                },</p><p>                Trebuchet = {</p><p>                    Title = {</p><p>                        de = "Trebuchet",</p><p>                        en = "Trebuchet",</p><p>                    },</p><p>                    Text = {</p><p>                        de = "- Kann über weite Strecken Gebäude angreifen {cr}- Kann Gebäude in Brand stecken {cr}- Kann nur durch Munitionsanforderung befüllt werden {cr}- Trebuchet kann manuell zurückgeschickt werden",</p><p>                        en = "- Can perform long range attacks on buildings {cr}- Can set buildings on fire {cr}- Can only be filled by ammunition request {cr}- The trebuchet can be manually send back to the city",</p><p>                    },</p><p>                },</p><p>                TrebuchetRefiller = {</p><p>                    Title = {</p><p>                        de = "Aufladen",</p><p>                        en = "Refill",</p><p>                    },</p><p>                    Text = {</p><p>                        de = "- Läd das Trebuchet mit Karren aus dem Lagerhaus nach {cr}- Benötigt die Differenz an Steinen {cr}- Kann jeweils nur einen Wagen zu selben Zeit senden",</p><p>                        en = "- Refill the Trebuchet with a cart from the storehouse {cr}- Stones for missing ammunition required {cr}- Only one cart at the time allowed",</p><p>                    },</p><p>                },</p><p>            },</p><p>        },</p><p>    },</p><p>-- Global Script ---------------------------------------------------------------</p><p>-- Initialisiert das Bundle im globalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>-- Deaktiviert oder aktiviert das Nachfüllen von Trebuchets.</p><p>-- @param _Boolean Nachfüllen deaktiviert</p><p>-- @within Internal</p><p>-- @local</p><p>    self.Data.RefillTrebuchet = not _Boolean;</p><p>    Logic.ExecuteInLuaLocalState([[</p><p>        BundleEntitySelection.Local:DeactivateRefillTrebuchet(]]..tostring(_Boolean)..[[)</p><p>    ]]);</p><p>-- Baut ein Trebuchet zu einem Trebuchet-Wagen ab.</p><p>-- @param _EntityID EntityID of Trebuchet</p><p>-- @within Internal</p><p>-- @local</p><p>    local x,y,z = Logic.EntityGetPos(_EntityID);</p><p>    local PlayerID = Logic.EntityGetPlayer(_EntityID);</p><p>    -- Externes Callback für das Kartenskript</p><p>    -- Bricht die Ausführung dieser Funktion ab!</p><p>    if GameCallback_QSB_OnDisambleTrebuchet then</p><p>        GameCallback_QSB_OnDisambleTrebuchet(_EntityID, PlayerID, x, y, z);</p><p>        return;</p><p>    end</p><p>    if self.Data.AmmunitionUnderway[_EntityID] then</p><p>        API.Message {</p><p>            de = "Eine Munitionslieferung ist auf dem Weg!",</p><p>            en = "A ammunition card is on the way!",</p><p>        };</p><p>        return;</p><p>    end</p><p>    Logic.CreateEffect(EGL_Effects.E_Shockwave01, x, y, 0);</p><p>    Logic.SetEntityInvulnerabilityFlag(_EntityID, 1);</p><p>    Logic.SetEntitySelectableFlag(_EntityID, 0);</p><p>    Logic.SetVisible(_EntityID, false);</p><p>    local TrebuchetCart = self.Data.TrebuchetIDToCart[_EntityID];</p><p>    if TrebuchetCart ~= nil then</p><p>        Logic.SetEntityInvulnerabilityFlag(TrebuchetCart, 0);</p><p>        Logic.SetEntitySelectableFlag(TrebuchetCart, 1);</p><p>        Logic.SetVisible(TrebuchetCart, true);</p><p>    else</p><p>        TrebuchetCart = Logic.CreateEntity(Entities.U_SiegeEngineCart, x, y, 0, PlayerID);</p><p>        self.Data.TrebuchetIDToCart[_EntityID] = TrebuchetCart;</p><p>    end</p><p>    Logic.DEBUG_SetSettlerPosition(TrebuchetCart, x, y);</p><p>    Logic.SetTaskList(TrebuchetCart, TaskLists.TL_NPC_IDLE);</p><p>    Logic.ExecuteInLuaLocalState([[</p><p>        GUI.SelectEntity(]]..TrebuchetCart..[[)</p><p>    ]]);</p><p>-- Baut einen Trebuchet-Wagen zu einem Trebuchet aus.</p><p>-- @param _EntityID EntityID of Trebuchet</p><p>-- @within Internal</p><p>-- @local</p><p>    local x,y,z = Logic.EntityGetPos(_EntityID);</p><p>    local PlayerID = Logic.EntityGetPlayer(_EntityID);</p><p>    -- Externes Callback für das Kartenskript</p><p>    -- Bricht die Ausführung dieser Funktion ab!</p><p>    if GameCallback_QSB_OnErectTrebuchet then</p><p>        GameCallback_QSB_OnErectTrebuchet(_EntityID, PlayerID, x, y, z);</p><p>        return;</p><p>    end</p><p>    Logic.CreateEffect(EGL_Effects.E_Shockwave01, x, y, 0);</p><p>    Logic.SetEntityInvulnerabilityFlag(_EntityID, 1);</p><p>    Logic.SetEntitySelectableFlag(_EntityID, 0);</p><p>    Logic.SetVisible(_EntityID, false);</p><p>    local Trebuchet;</p><p>    for k, v in pairs(self.Data.TrebuchetIDToCart) do</p><p>        if v == _EntityID then</p><p>            Trebuchet = tonumber(k);</p><p>        end</p><p>    end</p><p>    if Trebuchet == nil then</p><p>        Trebuchet = Logic.CreateEntity(Entities.U_Trebuchet, x, y, 0, PlayerID);</p><p>        self.Data.TrebuchetIDToCart[Trebuchet] = _EntityID;</p><p>    end</p><p>    Logic.SetEntityInvulnerabilityFlag(Trebuchet, 0);</p><p>    Logic.SetEntitySelectableFlag(Trebuchet, 1);</p><p>    Logic.SetVisible(Trebuchet, true);</p><p>    Logic.DEBUG_SetSettlerPosition(Trebuchet, x, y);</p><p>    Logic.ExecuteInLuaLocalState([[</p><p>        GUI.SelectEntity(]]..Trebuchet..[[)</p><p>    ]]);</p><p>-- Erzeugt einen Wagen, der zu dem Trebuchet fährt und es auffüll.</p><p>-- @param _EntityID EntityID of Trebuchet</p><p>-- @within Internal</p><p>-- @local</p><p>    local PlayerID = Logic.EntityGetPlayer(_EntityID);</p><p>    local StoreID = Logic.GetStoreHouse(PlayerID);</p><p>    local HaveAmount = Logic.GetAmmunitionAmount(_EntityID);</p><p>    local Stones = GetPlayerResources(Goods.G_Stone, PlayerID)</p><p>    -- Externes Callback für das Kartenskript</p><p>    -- Bricht die Ausführung dieser Funktion ab!</p><p>    if GameCallback_tHEA_OnRefillerCartCalled then</p><p>        GameCallback_tHEA_OnRefillerCartCalled(_EntityID, PlayerID, StoreID, HaveAmount, Stones);</p><p>        return;</p><p>    end</p><p>    if self.Data.AmmunitionUnderway[_EntityID] or StoreID == 0 then</p><p>        API.Message {</p><p>            de = "Eine Munitionslieferung ist auf dem Weg!",</p><p>            en = "A ammunition card is on the way!",</p><p>        };</p><p>        return;</p><p>    end</p><p>    if HaveAmount == 10 or Stones < 10-HaveAmount then</p><p>        API.Message {</p><p>            de = "Nicht genug Steine oder das Trebuchet ist voll!",</p><p>            en = "Not enough stones or the trebuchet is full!",</p><p>        };</p><p>        return;</p><p>    end</p><p>    local x,y = Logic.GetBuildingApproachPosition(StoreID);</p><p>    local CartID = Logic.CreateEntity(Entities.U_AmmunitionCart, x, y, 0, PlayerID);</p><p>    self.Data.AmmunitionUnderway[_EntityID] = {CartID, 10-HaveAmount};</p><p>    Logic.SetEntityInvulnerabilityFlag(CartID, 1);</p><p>    Logic.SetEntitySelectableFlag(CartID, 0);</p><p>    AddGood(Goods.G_Stone, (10-HaveAmount)*(-1), PlayerID);</p><p>    StartSimpleJobEx( function(_Trebuchet)</p><p>        local CartID = self.Data.AmmunitionUnderway[_EntityID][1];</p><p>        local Amount = self.Data.AmmunitionUnderway[_EntityID][2];</p><p>        if not IsExisting(CartID) or not IsExisting(_Trebuchet) then</p><p>            self.Data.AmmunitionUnderway[_EntityID] = nil;</p><p>            return true;</p><p>        end</p><p>        if not Logic.IsEntityMoving(CartID) then</p><p>            local x,y,z = Logic.EntityGetPos(_Trebuchet);</p><p>            Logic.MoveSettler(CartID, x, y);</p><p>        end</p><p>        if IsNear(CartID, _Trebuchet, 500) then</p><p>            for i=1, Amount, 1 do</p><p>                Logic.RefillAmmunitions(_Trebuchet);</p><p>            end</p><p>            DestroyEntity(CartID);</p><p>        end</p><p>    end, _EntityID);</p><p>-- Local Script ----------------------------------------------------------------</p><p>-- Initialisiert das Bundle im lokalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    self:OverwriteSelectAllUnits();</p><p>    self:OverwriteSelectKnight();</p><p>    self:OverwriteNamesAndDescription();</p><p>    self:OverwriteThiefDeliver();</p><p>    self:OverwriteMilitaryDismount();</p><p>    self:OverwriteMultiselectIcon();</p><p>    self:OverwriteMilitaryDisamble();</p><p>    self:OverwriteMilitaryErect();</p><p>    self:OverwriteMilitaryCommands();</p><p>    self:OverwriteGetStringTableText();</p><p>    Core:AppendFunction(</p><p>        "GameCallback_GUI_SelectionChanged",</p><p>        self.OnSelectionCanged</p><p>    );</p><p>-- Deaktiviert oder aktiviert das Nachfüllen von Trebuchets.</p><p>-- @param _Boolean Nachfüllen deaktiviert</p><p>-- @within Internal</p><p>-- @local</p><p>    self.Data.RefillTrebuchet = not _Boolean;</p><p>-- Callback-Funktion, die aufgerufen wird, wenn sich die Selektion ändert.</p><p>-- @param _Source Selection Source</p><p>-- @within Internal</p><p>-- @local</p><p>    local SelectedEntities = {GUI.GetSelectedEntities()}</p><p>    local PlayerID = GUI.GetPlayerID();</p><p>    local EntityID = GUI.GetSelectedEntity();</p><p>    local EntityType = Logic.GetEntityType(EntityID);</p><p>    -- Schreibe die selektierten Entities ins globale Skript</p><p>    local SelectedEntitiesString = API.ConvertTableToString(SelectedEntities);</p><p>    API.Bridge("BundleEntitySelection.Global.Data.SelectedEntities = " ..SelectedEntitiesString);</p><p>    if EntityID ~= nil then</p><p>        if EntityType == Entities.U_SiegeEngineCart then</p><p>            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection", 1);</p><p>            XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomRight/Selection", 0);</p><p>            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/BGMilitary", 1);</p><p>            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/DialogButtons", 1);</p><p>            XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomRight/DialogButtons", 0);</p><p>            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/DialogButtons/SiegeEngineCart", 1);</p><p>        elseif EntityType == Entities.U_Trebuchet then</p><p>            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection", 1);</p><p>            XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomRight/Selection", 0);</p><p>            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/BGMilitary", 1);</p><p>            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/DialogButtons", 1);</p><p>            XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomRight/DialogButtons", 0);</p><p>            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/DialogButtons/Military", 1);</p><p>            XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomRight/DialogButtons/Military", 1);</p><p>            if BundleEntitySelection.Local.Data.RefillTrebuchet then</p><p>                XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/DialogButtons/Military/Attack", 1);</p><p>            else</p><p>                XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/DialogButtons/Military/Attack", 0);</p><p>            end</p><p>            GUI_Military.StrengthUpdate();</p><p>            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/DialogButtons/SiegeEngine", 1);</p><p>        end</p><p>    end</p><p>-- Überscheibt die Funktion, die die Ingame-Texte aus den Quellen ausließt,</p><p>-- sodass eigene Texte für Keys angezeigt werden.</p><p>-- @within Internal</p><p>-- @local</p><p>    GetStringTableText_Orig_BundleEntitySelection = XGUIEng.GetStringTableText;</p><p>    XGUIEng.GetStringTableText = function(_key)</p><p>        local Language = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>        if _key == "UI_ObjectDescription/Attack" then</p><p>            local EntityID = GUI.GetSelectedEntity();</p><p>            if Logic.GetEntityType(EntityID) == Entities.U_Trebuchet then</p><p>                return BundleEntitySelection.Local.Data.Tooltips.TrebuchetRefiller.Text[Language];</p><p>            end</p><p>        end</p><p>        if _key == "UI_ObjectNames/Attack" then</p><p>            local EntityID = GUI.GetSelectedEntity();</p><p>            if Logic.GetEntityType(EntityID) == Entities.U_Trebuchet then</p><p>                return BundleEntitySelection.Local.Data.Tooltips.TrebuchetRefiller.Title[Language];</p><p>            end</p><p>        end</p><p>        return GetStringTableText_Orig_BundleEntitySelection(_key);</p><p>    end</p><p>-- Überschreibt die Millitärkommandos "Stop" und "Angreifen".</p><p>-- @within Internal</p><p>-- @local</p><p>    GUI_Military.AttackClicked = function()</p><p>        Sound.FXPlay2DSound( "ui\\menu_click");</p><p>        local SelectedEntities = {GUI.GetSelectedEntities()};</p><p>        local EntityType = Logic.GetEntityType(SelectedEntities[1]);</p><p>        if EntityType == Entities.U_Trebuchet then</p><p>            for i=1, #SelectedEntities, 1 do</p><p>                EntityType = Logic.GetEntityType(SelectedEntities[i]);</p><p>                if EntityType == Entities.U_Trebuchet then</p><p>                    GUI.SendScriptCommand([[</p><p>                        BundleEntitySelection.Global:MilitaryCallForRefiller(]]..SelectedEntities[i]..[[)</p><p>                    ]]);</p><p>                end</p><p>            end</p><p>        else</p><p>            GUI.ActivateExplicitAttackCommandState();</p><p>        end</p><p>    end</p><p>    GUI_Military.StandGroundClicked = function()</p><p>        Sound.FXPlay2DSound( "ui\\menu_click");</p><p>        local SelectedEntities = {GUI.GetSelectedEntities()};</p><p>        for i=1,#SelectedEntities do</p><p>            local LeaderID = SelectedEntities[i];</p><p>            local eType = Logic.GetEntityType(LeaderID);</p><p>            GUI.SendCommandStationaryDefend(LeaderID);</p><p>            if eType == Entities.U_Trebuchet then</p><p>                GUI.SendScriptCommand([[</p><p>                    Logic.SetTaskList(]]..LeaderID..[[, TaskLists.TL_NPC_IDLE)</p><p>                ]]);</p><p>            end</p><p>        end</p><p>    end</p><p>    GUI_Military.StandGroundUpdate = function()</p><p>        local WidgetAttack = "/InGame/Root/Normal/AlignBottomRight/DialogButtons/Military/Attack";</p><p>        local SelectedEntities = {GUI.GetSelectedEntities()};</p><p>        SetIcon(WidgetAttack, {12, 4});</p><p>        if #SelectedEntities == 1 then</p><p>            local eID = SelectedEntities[1];</p><p>            local eType = Logic.GetEntityType(eID);</p><p>            if eType == Entities.U_Trebuchet then</p><p>                if Logic.GetAmmunitionAmount(eID) > 0 then</p><p>                    XGUIEng.ShowWidget(WidgetAttack, 0);</p><p>                else</p><p>                    XGUIEng.ShowWidget(WidgetAttack, 1);</p><p>                end</p><p>                SetIcon(WidgetAttack, {1, 10});</p><p>            else</p><p>                XGUIEng.ShowWidget(WidgetAttack, 1);</p><p>            end</p><p>        end</p><p>    end</p><p>-- Überschreibt das Aufbauen von Kriegsmaschinen, sodass auch Trebuchets</p><p>-- auf- und abgebaut werden können.</p><p>-- @within Internal</p><p>-- @local</p><p>    GUI_Military.ErectClicked_Orig_BundleEntitySelection = GUI_Military.ErectClicked;</p><p>    GUI_Military.ErectClicked = function()</p><p>        GUI_Military.ErectClicked_Orig_BundleEntitySelection();</p><p>        local PlayerID = GUI.GetPlayerID();</p><p>        local SelectedEntities = {GUI.GetSelectedEntities()};</p><p>        for i=1, #SelectedEntities, 1 do</p><p>            local EntityType = Logic.GetEntityType(SelectedEntities[i]);</p><p>            if EntityType == Entities.U_SiegeEngineCart then</p><p>                GUI.SendScriptCommand([[</p><p>                    BundleEntitySelection.Global:MilitaryErectTrebuchet(]]..SelectedEntities[i]..[[)</p><p>                ]]);</p><p>            end</p><p>        end</p><p>    end</p><p>    GUI_Military.ErectUpdate_Orig_BundleEntitySelection = GUI_Military.ErectUpdate;</p><p>    GUI_Military.ErectUpdate = function()</p><p>        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();</p><p>        local SiegeCartID = GUI.GetSelectedEntity();</p><p>        local PlayerID = GUI.GetPlayerID();</p><p>        local EntityType = Logic.GetEntityType(SiegeCartID);</p><p>        if EntityType == Entities.U_SiegeEngineCart then</p><p>            XGUIEng.DisableButton(CurrentWidgetID, 0);</p><p>            SetIcon(CurrentWidgetID, {12, 6});</p><p>        else</p><p>            GUI_Military.ErectUpdate_Orig_BundleEntitySelection();</p><p>        end</p><p>    end</p><p>    GUI_Military.ErectMouseOver_Orig_BundleEntitySelection = GUI_Military.ErectMouseOver;</p><p>    GUI_Military.ErectMouseOver = function()</p><p>        local SiegeCartID = GUI.GetSelectedEntity();</p><p>        local TooltipTextKey;</p><p>        if Logic.GetEntityType(SiegeCartID) == Entities.U_SiegeEngineCart then</p><p>            TooltipTextKey = "ErectCatapult";</p><p>        else</p><p>            GUI_Military.ErectMouseOver_Orig_BundleEntitySelection();</p><p>            return;</p><p>        end</p><p>        GUI_Tooltip.TooltipNormal(TooltipTextKey, "Erect");</p><p>    end</p><p>-- Überschreibt das Abbauen von Kriegsmaschinen, sodass auch Trebuchets</p><p>-- abgebaut werden können.</p><p>-- @within Internal</p><p>-- @local</p><p>    GUI_Military.DisassembleClicked_Orig_BundleEntitySelection = GUI_Military.DisassembleClicked;</p><p>    GUI_Military.DisassembleClicked = function()</p><p>        GUI_Military.DisassembleClicked_Orig_BundleEntitySelection();</p><p>        local PlayerID = GUI.GetPlayerID();</p><p>        local SelectedEntities = {GUI.GetSelectedEntities()};</p><p>        for i=1, #SelectedEntities, 1 do</p><p>            local EntityType = Logic.GetEntityType(SelectedEntities[i]);</p><p>            if EntityType == Entities.U_Trebuchet then</p><p>                GUI.SendScriptCommand([[</p><p>                    BundleEntitySelection.Global:MilitaryDisambleTrebuchet(]]..SelectedEntities[i]..[[)</p><p>                ]]);</p><p>            end</p><p>        end</p><p>    end</p><p>    GUI_Military.DisassembleUpdate_Orig_BundleEntitySelection = GUI_Military.DisassembleUpdate;</p><p>    GUI_Military.DisassembleUpdate = function()</p><p>        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();</p><p>        local PlayerID = GUI.GetPlayerID();</p><p>        local SiegeEngineID = GUI.GetSelectedEntity();</p><p>        local EntityType = Logic.GetEntityType(SiegeEngineID);</p><p>        if EntityType == Entities.U_Trebuchet then</p><p>            XGUIEng.DisableButton(CurrentWidgetID, 0);</p><p>            SetIcon(CurrentWidgetID, {12, 9});</p><p>        else</p><p>            GUI_Military.DisassembleUpdate_Orig_BundleEntitySelection();</p><p>        end</p><p>    end</p><p>-- Überschreibt die Multiselektion, damit Trebuchets ein Icon bekommen.</p><p>-- @within Internal</p><p>-- @local</p><p>    GUI_MultiSelection.IconUpdate_Orig_BundleEntitySelection = GUI_MultiSelection.IconUpdate;</p><p>    GUI_MultiSelection.IconUpdate = function()</p><p>        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();</p><p>        local CurrentMotherID = XGUIEng.GetWidgetsMotherID(CurrentWidgetID);</p><p>        local CurrentMotherName = XGUIEng.GetWidgetNameByID(CurrentMotherID);</p><p>        local Index = CurrentMotherName + 0;</p><p>        local CurrentMotherPath = XGUIEng.GetWidgetPathByID(CurrentMotherID);</p><p>        local HealthWidgetPath = CurrentMotherPath .. "/Health";</p><p>        local EntityID = g_MultiSelection.EntityList[Index];</p><p>        local EntityType = Logic.GetEntityType(EntityID);</p><p>        local HealthState = Logic.GetEntityHealth(EntityID);</p><p>        local EntityMaxHealth = Logic.GetEntityMaxHealth(EntityID);</p><p>        if EntityType ~= Entities.U_SiegeEngineCart and EntityType ~= Entities.U_Trebuchet then</p><p>            GUI_MultiSelection.IconUpdate_Orig_BundleEntitySelection();</p><p>            return;</p><p>        end</p><p>        if Logic.IsEntityAlive(EntityID) == false then</p><p>            XGUIEng.ShowWidget(CurrentMotherID, 0);</p><p>            GUI_MultiSelection.CreateEX();</p><p>            return;</p><p>        end</p><p>        SetIcon(CurrentWidgetID, g_TexturePositions.Entities[EntityType]);</p><p>        HealthState = math.floor(HealthState / EntityMaxHealth * 100);</p><p>        if HealthState < 50 then</p><p>            local green = math.floor(2*255* (HealthState/100));</p><p>            XGUIEng.SetMaterialColor(HealthWidgetPath,0,255,green, 20,255);</p><p>        else</p><p>            local red = 2*255 - math.floor(2*255* (HealthState/100));</p><p>            XGUIEng.SetMaterialColor(HealthWidgetPath,0,red, 255, 20,255);</p><p>        end</p><p>        XGUIEng.SetProgressBarValues(HealthWidgetPath,HealthState, 100);</p><p>    end</p><p>    GUI_MultiSelection.IconMouseOver_Orig_BundleEntitySelection = GUI_MultiSelection.IconMouseOver;</p><p>    GUI_MultiSelection.IconMouseOver = function()</p><p>        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();</p><p>        local CurrentMotherID = XGUIEng.GetWidgetsMotherID(CurrentWidgetID);</p><p>        local CurrentMotherName = XGUIEng.GetWidgetNameByID(CurrentMotherID);</p><p>        local Index = tonumber(CurrentMotherName);</p><p>        local EntityID = g_MultiSelection.EntityList[Index];</p><p>        local EntityType = Logic.GetEntityType(EntityID);</p><p>        if EntityType ~= Entities.U_SiegeEngineCart and EntityType ~= Entities.U_Trebuchet then</p><p>            GUI_MultiSelection.IconMouseOver_Orig_BundleEntitySelection();</p><p>            return;</p><p>        end</p><p>        local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>        if EntityType == Entities.U_SiegeEngineCart then</p><p>            local TooltipData = BundleEntitySelection.Local.Data.Tooltips.TrebuchetCart;</p><p>            BundleEntitySelection.Local:SetTooltip(TooltipData.Title[lang], TooltipData.Text[lang]);</p><p>        elseif EntityType == Entities.U_Trebuchet then</p><p>            local TooltipData = BundleEntitySelection.Local.Data.Tooltips.Trebuchet;</p><p>            BundleEntitySelection.Local:SetTooltip(TooltipData.Title[lang], TooltipData.Text[lang]);</p><p>        end</p><p>    end</p><p>-- Überschreibt die Funktion zur Beendigung der Eskorte, damit Einheiten auch</p><p>-- entlassen werden können.</p><p>-- @within Internal</p><p>-- @local</p><p>    GUI_Military.DismountClicked_Orig_BundleEntitySelection = GUI_Military.DismountClicked;</p><p>    GUI_Military.DismountClicked = function()</p><p>        local Selected = GUI.GetSelectedEntity(Selected);</p><p>        local Type = Logic.GetEntityType(Selected);</p><p>        local PlayerID = GUI.GetPlayerID();</p><p>        if Logic.GetGuardianEntityID(Selected) == 0 and Logic.IsKnight(Selected) == false then</p><p>            if (Type == Entities.U_SiegeEngineCart or Type == Entities.U_MilitarySiegeTower or</p><p>                Type == Entities.U_MilitaryCatapult or Type == Entities.U_MilitaryBatteringRam or</p><p>                Type == Entities.U_SiegeTowerCart or Type == Entities.U_CatapultCart or</p><p>                Type == Entities.U_BatteringRamCart or Type == Entities.U_AmmunitionCart)</p><p>            and BundleEntitySelection.Local.Data.SiegeEngineRelease then</p><p>                Sound.FXPlay2DSound( "ui\\menu_click");</p><p>                GUI.SendScriptCommand([[DestroyEntity(]]..Selected..[[)]]);</p><p>                return;</p><p>            end</p><p>            if (Logic.IsLeader(Selected) == 1 and BundleEntitySelection.Local.Data.MilitaryRelease) then</p><p>                Sound.FXPlay2DSound( "ui\\menu_click");</p><p>                local Soldiers = {Logic.GetSoldiersAttachedToLeader(Selected)};</p><p>                GUI.SendScriptCommand([[DestroyEntity(]]..Soldiers[#Soldiers]..[[)]]);</p><p>                return;</p><p>            end</p><p>        else</p><p>            GUI_Military.DismountClicked_Orig_BundleEntitySelection();</p><p>        end</p><p>    end</p><p>    GUI_Military.DismountUpdate_Orig_BundleEntitySelection = GUI_Military.DismountUpdate;</p><p>    GUI_Military.DismountUpdate = function()</p><p>        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();</p><p>        local Selected = GUI.GetSelectedEntity();</p><p>        local Type = Logic.GetEntityType(Selected);</p><p>        if (Logic.GetGuardianEntityID(Selected) == 0 and Logic.IsKnight(Selected) == false and Logic.IsEntityInCategory(Selected, EntityCategories.AttackableMerchant) == 0) then</p><p>            if Logic.IsLeader(Selected) == 1 and not BundleEntitySelection.Local.Data.MilitaryRelease then</p><p>                XGUIEng.DisableButton(CurrentWidgetID, 1);</p><p>            elseif  Logic.IsLeader(Selected) == 0 then</p><p>                if not BundleEntitySelection.Local.Data.SiegeEngineRelease then</p><p>                    XGUIEng.DisableButton(CurrentWidgetID, 1);</p><p>                end</p><p>                if Type == Entities.U_Trebuchet then</p><p>                    XGUIEng.DisableButton(CurrentWidgetID, 1);</p><p>                end</p><p>            else</p><p>                SetIcon(CurrentWidgetID, {12, 1});</p><p>                XGUIEng.DisableButton(CurrentWidgetID, 0);</p><p>            end</p><p>            SetIcon(CurrentWidgetID, {14, 12});</p><p>        else</p><p>            SetIcon(CurrentWidgetID, {12, 1});</p><p>            GUI_Military.DismountUpdate_Orig_BundleEntitySelection();</p><p>        end</p><p>    end</p><p>-- Überschreibt "Beute abließern", sodass Diebe entlassen werden können.</p><p>-- @within Internal</p><p>-- @local</p><p>    GUI_Thief.ThiefDeliverClicked_Orig_BundleEntitySelection = GUI_Thief.ThiefDeliverClicked;</p><p>    GUI_Thief.ThiefDeliverClicked = function()</p><p>        if not BundleEntitySelection.Local.Data.ThiefRelease then</p><p>            GUI_Thief.ThiefDeliverClicked_Orig_BundleEntitySelection();</p><p>            return;</p><p>        end</p><p>        Sound.FXPlay2DSound( "ui\\menu_click");</p><p>        local PlayerID = GUI.GetPlayerID();</p><p>        local ThiefID = GUI.GetSelectedEntity()</p><p>        if ThiefID == nil or Logic.GetEntityType(ThiefID) ~= Entities.U_Thief then</p><p>            return;</p><p>        end</p><p>        GUI.SendScriptCommand([[DestroyEntity(]]..ThiefID..[[)]]);</p><p>    end</p><p>    GUI_Thief.ThiefDeliverMouseOver_Orig_BundleEntitySelection = GUI_Thief.ThiefDeliverMouseOver;</p><p>    GUI_Thief.ThiefDeliverMouseOver = function()</p><p>        if not BundleEntitySelection.Local.Data.ThiefRelease then</p><p>            GUI_Thief.ThiefDeliverMouseOver_Orig_BundleEntitySelection();</p><p>            return;</p><p>        end</p><p>        local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>        BundleEntitySelection.Local:SetTooltip(</p><p>            BundleEntitySelection.Local.Data.Tooltips.ReleaseSoldiers.Title[lang],</p><p>            BundleEntitySelection.Local.Data.Tooltips.ReleaseSoldiers.Text[lang]</p><p>        );</p><p>    end</p><p>    GUI_Thief.ThiefDeliverUpdate_Orig_BundleEntitySelection = GUI_Thief.ThiefDeliverUpdate;</p><p>    GUI_Thief.ThiefDeliverUpdate = function()</p><p>        if not BundleEntitySelection.Local.Data.ThiefRelease then</p><p>            GUI_Thief.ThiefDeliverUpdate_Orig_BundleEntitySelection();</p><p>            return;</p><p>        end</p><p>        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();</p><p>        local ThiefID = GUI.GetSelectedEntity();</p><p>        if ThiefID == nil or Logic.GetEntityType(ThiefID) ~= Entities.U_Thief then</p><p>            XGUIEng.DisableButton(CurrentWidgetID, 1);</p><p>        else</p><p>            XGUIEng.DisableButton(CurrentWidgetID, 0);</p><p>        end</p><p>        SetIcon(CurrentWidgetID, {14, 12});</p><p>    end</p><p>-- Hängt eine Funktion an die GUI_Tooltip.SetNameAndDescription an, sodass</p><p>-- Tooltips überschrieben werden können.</p><p>-- @within Internal</p><p>-- @local</p><p>    GUI_Tooltip.SetNameAndDescription_Orig_QSB_EntitySelection = GUI_Tooltip.SetNameAndDescription;</p><p>    GUI_Tooltip.SetNameAndDescription = function(_TooltipNameWidget, _TooltipDescriptionWidget, _OptionalTextKeyName, _OptionalDisabledTextKeyName, _OptionalMissionTextFileBoolean)</p><p>        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();</p><p>        local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>        if XGUIEng.GetWidgetID("/InGame/Root/Normal/AlignBottomRight/MapFrame/KnightButton") == CurrentWidgetID then</p><p>            BundleEntitySelection.Local:SetTooltip(</p><p>                BundleEntitySelection.Local.Data.Tooltips.KnightButton.Title[lang],</p><p>                BundleEntitySelection.Local.Data.Tooltips.KnightButton.Text[lang]</p><p>            );</p><p>            return;</p><p>        end</p><p>        if XGUIEng.GetWidgetID("/InGame/Root/Normal/AlignBottomRight/MapFrame/BattalionButton") == CurrentWidgetID then</p><p>            BundleEntitySelection.Local:SetTooltip(</p><p>                BundleEntitySelection.Local.Data.Tooltips.BattalionButton.Title[lang],</p><p>                BundleEntitySelection.Local.Data.Tooltips.BattalionButton.Text[lang]</p><p>            );</p><p>            return;</p><p>        end</p><p>        if XGUIEng.GetWidgetID("/InGame/Root/Normal/AlignBottomRight/DialogButtons/SiegeEngineCart/Dismount") == CurrentWidgetID </p><p>        or XGUIEng.GetWidgetID("/InGame/Root/Normal/AlignBottomRight/DialogButtons/AmmunitionCart/Dismount") == CurrentWidgetID </p><p>        or XGUIEng.GetWidgetID("/InGame/Root/Normal/AlignBottomRight/DialogButtons/Military/Dismount") == CurrentWidgetID </p><p>        then</p><p>            local SelectedEntity = GUI.GetSelectedEntity();</p><p>            if SelectedEntity ~= 0 then</p><p>                if Logic.IsEntityInCategory(SelectedEntity, EntityCategories.Military) == 1</p><p>                and Logic.IsEntityInCategory(SelectedEntity, EntityCategories.Hero) == 0</p><p>                then</p><p>                    local GuardianEntity = Logic.GetGuardianEntityID(SelectedEntity)</p><p>                    if GuardianEntity == nil or GuardianEntity == 0 then</p><p>                        BundleEntitySelection.Local:SetTooltip(</p><p>                            BundleEntitySelection.Local.Data.Tooltips.ReleaseSoldiers.Title[lang],</p><p>                            BundleEntitySelection.Local.Data.Tooltips.ReleaseSoldiers.Text[lang],</p><p>                            BundleEntitySelection.Local.Data.Tooltips.ReleaseSoldiers.Disabled[lang]</p><p>                        );</p><p>                        return;</p><p>                    end</p><p>                end</p><p>            end</p><p>        end</p><p>        GUI_Tooltip.SetNameAndDescription_Orig_QSB_EntitySelection(_TooltipNameWidget, _TooltipDescriptionWidget, _OptionalTextKeyName, _OptionalDisabledTextKeyName, _OptionalMissionTextFileBoolean);</p><p>    end</p><p>-- Schreibt einen anderen Text in einen normalen Tooltip.</p><p>-- @param _TitleText [string] Titel des Tooltip</p><p>-- @param _DescText [string] Text des Tooltip</p><p>-- @param _DisabledText [string] Disabled Text des Tooltip</p><p>-- @within Internal</p><p>-- @local</p><p>    local TooltipContainerPath = "/InGame/Root/Normal/TooltipNormal";</p><p>    local TooltipContainer = XGUIEng.GetWidgetID(TooltipContainerPath);</p><p>    local TooltipNameWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Name");</p><p>    local TooltipDescriptionWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Text");</p><p>    local PositionWidget = XGUIEng.GetCurrentWidgetID();</p><p>    _DisabledText = _DisabledText or "";</p><p>    local DisabledText = "";</p><p>    if XGUIEng.IsButtonDisabled(PositionWidget) == 1 and _disabledText ~= "" and _text ~= "" then</p><p>        DisabledText = DisabledText .. "{cr}{@color:255,32,32,255}" .. _DisabledText;</p><p>    end</p><p>    XGUIEng.SetText(TooltipNameWidget, "{center}" .. _TitleText);</p><p>    XGUIEng.SetText(TooltipDescriptionWidget, _DescText .. DisabledText);</p><p>    local Height = XGUIEng.GetTextHeight(TooltipDescriptionWidget, true);</p><p>    local W, H = XGUIEng.GetWidgetSize(TooltipDescriptionWidget);</p><p>    XGUIEng.SetWidgetSize(TooltipDescriptionWidget, W, Height);</p><p>-- Überschreibt den SelectKnight-Button. Durch drücken von CTLR können alle</p><p>-- Helden selektiert werden, die der Spieler kontrolliert.</p><p>-- @within Internal</p><p>-- @local</p><p>    GUI_Knight.JumpToButtonClicked = function()</p><p>        local PlayerID = GUI.GetPlayerID();</p><p>        local KnightID = Logic.GetKnightID(PlayerID);</p><p>        if KnightID > 0 then</p><p>            g_MultiSelection.EntityList = {};</p><p>            g_MultiSelection.Highlighted = {};</p><p>            GUI.ClearSelection();</p><p>            if XGUIEng.IsModifierPressed(Keys.ModifierControl) then</p><p>                local knights = {}</p><p>                Logic.GetKnights(PlayerID, knights);</p><p>                for i=1,#knights do</p><p>                    GUI.SelectEntity(knights[i]);</p><p>                end</p><p>            else</p><p>                GUI.SelectEntity(Logic.GetKnightID(PlayerID));</p><p>                if ((Framework.GetTimeMs() - g_Selection.LastClickTime ) < g_Selection.MaxDoubleClickTime) then</p><p>                    local pos = GetPosition(KnightID);</p><p>                    Camera.RTS_SetLookAtPosition(pos.X, pos.Y);</p><p>                else</p><p>                    Sound.FXPlay2DSound("ui\\mini_knight");</p><p>                end</p><p>                g_Selection.LastClickTime = Framework.GetTimeMs();</p><p>            end</p><p>            GUI_MultiSelection.CreateMultiSelection(g_SelectionChangedSource.User);</p><p>        else</p><p>            GUI.AddNote("Debug: You do not have a knight");</p><p>        end</p><p>    end</p><p>-- Überschreibt die Militärselektion, sodass der Spieler mit SHIFT zusätzlich</p><p>-- die Munitionswagen und Trebuchets selektieren kann.</p><p>-- @within Internal</p><p>-- @local</p><p>    GUI_MultiSelection.SelectAllPlayerUnitsClicked = function()</p><p>        if XGUIEng.IsModifierPressed(Keys.ModifierShift) then</p><p>            BundleEntitySelection.Local:ExtendedLeaderSortOrder();</p><p>        else</p><p>            BundleEntitySelection.Local:NormalLeaderSortOrder();</p><p>        end</p><p>        Sound.FXPlay2DSound("ui\\menu_click");</p><p>        GUI.ClearSelection();</p><p>        local PlayerID = GUI.GetPlayerID()</p><p>        for i = 1, #LeaderSortOrder do</p><p>            local EntitiesOfThisType = GetPlayerEntities(PlayerID, LeaderSortOrder[i])</p><p>            for j = 1, #EntitiesOfThisType do</p><p>                GUI.SelectEntity(EntitiesOfThisType[j])</p><p>            end</p><p>        end</p><p>        local Knights = {}</p><p>        Logic.GetKnights(PlayerID, Knights)</p><p>        for k = 1, #Knights do</p><p>            GUI.SelectEntity(Knights[k])</p><p>        end</p><p>        GUI_MultiSelection.CreateMultiSelection(g_SelectionChangedSource.User);</p><p>    end</p><p>-- Erzeugt die normale Sortierung ohne Munitionswagen und Trebuchets.</p><p>-- @within Internal</p><p>-- @local</p><p>    g_MultiSelection = {};</p><p>    g_MultiSelection.EntityList = {};</p><p>    g_MultiSelection.Highlighted = {};</p><p>    LeaderSortOrder     = {};</p><p>    LeaderSortOrder[1]  = Entities.U_MilitarySword;</p><p>    LeaderSortOrder[2]  = Entities.U_MilitaryBow;</p><p>    LeaderSortOrder[3]  = Entities.U_MilitarySword_RedPrince;</p><p>    LeaderSortOrder[4]  = Entities.U_MilitaryBow_RedPrince;</p><p>    LeaderSortOrder[5]  = Entities.U_MilitaryBandit_Melee_ME;</p><p>    LeaderSortOrder[6]  = Entities.U_MilitaryBandit_Melee_NA;</p><p>    LeaderSortOrder[7]  = Entities.U_MilitaryBandit_Melee_NE;</p><p>    LeaderSortOrder[8]  = Entities.U_MilitaryBandit_Melee_SE;</p><p>    LeaderSortOrder[9]  = Entities.U_MilitaryBandit_Ranged_ME;</p><p>    LeaderSortOrder[10] = Entities.U_MilitaryBandit_Ranged_NA;</p><p>    LeaderSortOrder[11] = Entities.U_MilitaryBandit_Ranged_NE;</p><p>    LeaderSortOrder[12] = Entities.U_MilitaryBandit_Ranged_SE;</p><p>    LeaderSortOrder[13] = Entities.U_MilitaryCatapult;</p><p>    LeaderSortOrder[14] = Entities.U_MilitarySiegeTower;</p><p>    LeaderSortOrder[15] = Entities.U_MilitaryBatteringRam;</p><p>    LeaderSortOrder[16] = Entities.U_CatapultCart;</p><p>    LeaderSortOrder[17] = Entities.U_SiegeTowerCart;</p><p>    LeaderSortOrder[18] = Entities.U_BatteringRamCart;</p><p>    LeaderSortOrder[19] = Entities.U_Thief;</p><p>    -- Asien wird nur in der Erweiterung gebraucht.</p><p>    if g_GameExtraNo >= 1 then</p><p>        table.insert(LeaderSortOrder,  4, Entities.U_MilitarySword_Khana);</p><p>        table.insert(LeaderSortOrder,  6, Entities.U_MilitaryBow_Khana);</p><p>        table.insert(LeaderSortOrder,  7, Entities.U_MilitaryBandit_Melee_AS);</p><p>        table.insert(LeaderSortOrder, 12, Entities.U_MilitaryBandit_Ranged_AS);</p><p>    end</p><p>-- Erzeugt die erweiterte Selektion mit Munitionswagen und Trebuchets.</p><p>-- @within Internal</p><p>-- @local</p><p>    g_MultiSelection = {};</p><p>    g_MultiSelection.EntityList = {};</p><p>    g_MultiSelection.Highlighted = {};</p><p>    LeaderSortOrder     = {};</p><p>    LeaderSortOrder[1]  = Entities.U_MilitarySword;</p><p>    LeaderSortOrder[2]  = Entities.U_MilitaryBow;</p><p>    LeaderSortOrder[3]  = Entities.U_MilitarySword_RedPrince;</p><p>    LeaderSortOrder[4]  = Entities.U_MilitaryBow_RedPrince;</p><p>    LeaderSortOrder[5]  = Entities.U_MilitaryBandit_Melee_ME;</p><p>    LeaderSortOrder[6]  = Entities.U_MilitaryBandit_Melee_NA;</p><p>    LeaderSortOrder[7]  = Entities.U_MilitaryBandit_Melee_NE;</p><p>    LeaderSortOrder[8]  = Entities.U_MilitaryBandit_Melee_SE;</p><p>    LeaderSortOrder[9]  = Entities.U_MilitaryBandit_Ranged_ME;</p><p>    LeaderSortOrder[10] = Entities.U_MilitaryBandit_Ranged_NA;</p><p>    LeaderSortOrder[11] = Entities.U_MilitaryBandit_Ranged_NE;</p><p>    LeaderSortOrder[12] = Entities.U_MilitaryBandit_Ranged_SE;</p><p>    LeaderSortOrder[13] = Entities.U_MilitaryCatapult;</p><p>    LeaderSortOrder[14] = Entities.U_Trebuchet;</p><p>    LeaderSortOrder[15] = Entities.U_MilitarySiegeTower;</p><p>    LeaderSortOrder[16] = Entities.U_MilitaryBatteringRam;</p><p>    LeaderSortOrder[17] = Entities.U_CatapultCart;</p><p>    LeaderSortOrder[18] = Entities.U_SiegeTowerCart;</p><p>    LeaderSortOrder[19] = Entities.U_BatteringRamCart;</p><p>    LeaderSortOrder[20] = Entities.U_AmmunitionCart;</p><p>    LeaderSortOrder[21] = Entities.U_Thief;</p><p>    -- Asien wird nur in der Erweiterung gebraucht.</p><p>    if g_GameExtraNo >= 1 then</p><p>        table.insert(LeaderSortOrder,  4, Entities.U_MilitarySword_Khana);</p><p>        table.insert(LeaderSortOrder,  6, Entities.U_MilitaryBow_Khana);</p><p>        table.insert(LeaderSortOrder,  7, Entities.U_MilitaryBandit_Melee_AS);</p><p>        table.insert(LeaderSortOrder, 12, Entities.U_MilitaryBandit_Ranged_AS);</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundlegamehelperfunctions.lua.html">
            <div class='doclink'>
                <div>BundleGameHelperFunctions</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia BundleGameHelperFunctions                                    # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Dieses Bundle gibt dem Mapper Werkzeuge in die Hand, um einige Features zu</p><p>-- gewähren oder zu entziehen.</p><p>-- Das wichtigste Auf einen Blick:</p><p>-- <ul></p><p>-- <li></p><p>-- <a href="#API.AllowCheats">Features aktivieren</a><br>Cheats, Erweiterter</p><p>-- Zoom, Feste feiern für KIs</p><p>-- </li></p><p>-- <li></p><p>-- <a href="#API.ForbidCheats">Features deaktivieren</a><br>Cheats, Erweiterter</p><p>-- Zoom, Feste feiern für KIs</p><p>-- </li></p><p>-- <li></p><p>-- <a href="#API.SpeedLimitActivate">Spielgeschwindigkeit steuern</a><br></p><p>-- Maximale Spielgeschwindigkeit festlegen</p><p>-- </li></p><p>-- <li></p><p>-- <a href="#API.ThridPersonActivate">Schulterblick aktivieren</a><br>Die</p><p>-- Kamera folgt einem Entity in der 3rd-Person-Ansicht.</p><p>-- </li></p><p>-- </ul></p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Fokusiert die Kamera auf dem Primärritter des Spielers.</p><p>-- <p><b>Alias:</b> SetCameraToPlayerKnight</p></p><p>-- @param _Player [number] Partei</p><p>-- @param _Rotation [number] Kamerawinkel</p><p>-- @param _ZoomFactor [number] Zoomfaktor</p><p>-- @within Anwenderfunktionen</p><p>function API.FocusCameraOnKnight(_Player, _Rotation, _ZoomFactor)</p><p>    API.FocusCameraOnEntity(Logic.GetKnightID(_Player), _Rotation, _ZoomFactor)</p><p>-- Fokusiert die Kamera auf dem Entity.</p><p>-- <p><b>Alias:</b> SetCameraToEntity</p></p><p>-- @param _Entity [string|number] Entity</p><p>-- @param _Rotation [number] Kamerawinkel</p><p>-- @param _ZoomFactor [number] Zoomfaktor</p><p>-- @within Anwenderfunktionen</p><p>function API.FocusCameraOnEntity(_Entity, _Rotation, _ZoomFactor)</p><p>    if not GUI then</p><p>        local Subject = (type(_Entity) ~= "string" and _Entity) or "'" .._Entity.. "'";</p><p>        API.Bridge("API.FocusCameraOnEntity(" ..Subject.. ", " .._Rotation.. ", " .._ZoomFactor.. ")")</p><p>        return;</p><p>    end</p><p>    if not IsExisting(_Entity) then</p><p>        local Subject = (type(_Entity) ~= "string" and _Entity) or "'" .._Entity.. "'";</p><p>        API.Warn("API.FocusCameraOnEntity: Entity " ..Subject.. " does not exist!");</p><p>        return;</p><p>    end</p><p>    return BundleGameHelperFunctions.Local:SetCameraToEntity(_Entity, _Rotation, _ZoomFactor);</p><p>-- Setzt die Obergrenze für die Spielgeschwindigkeit fest.</p><p>-- <p><b>Alias:</b> SetSpeedLimit</p></p><p>-- @param _Limit [number] Obergrenze</p><p>-- @within Anwenderfunktionen</p><p>function API.SpeedLimitSet(_Limit)</p><p>    if not GUI then</p><p>        API.Bridge("API.SpeedLimitSet(" .._Limit.. ")");</p><p>        return;</p><p>    end</p><p>    return BundleGameHelperFunctions.Local:SetSpeedLimit(_Limit);</p><p>-- Aktiviert die Speedbremse. Die vorher eingestellte Maximalgeschwindigkeit</p><p>-- kann nicht mehr überschritten werden.</p><p>-- <p><b>Alias:</b> ActivateSpeedLimit</p></p><p>-- @param _Flag [boolean] Speedbremse ist aktiv</p><p>-- @within Anwenderfunktionen</p><p>function API.SpeedLimitActivate(_Flag)</p><p>    if GUI then</p><p>        API.Bridge("API.SpeedLimitActivate(" ..tostring(_Flag).. ")");</p><p>        return;</p><p>    end</p><p>    return API.Bridge("BundleGameHelperFunctions.Local:ActivateSpeedLimit(" ..tostring(_Flag).. ")");</p><p>-- Deaktiviert die Tastenkombination zum Einschalten der Cheats.</p><p>-- <p><b>Alias:</b> KillCheats</p></p><p>-- @within Anwenderfunktionen</p><p>function API.ForbidCheats()</p><p>    if GUI then</p><p>        API.Bridge("API.ForbidCheats()");</p><p>        return;</p><p>    end</p><p>    return BundleGameHelperFunctions.Global:KillCheats();</p><p>-- Aktiviert die Tastenkombination zum Einschalten der Cheats.</p><p>-- <p><b>Alias:</b> RessurectCheats</p></p><p>-- @within Anwenderfunktionen</p><p>function API.AllowCheats()</p><p>    if GUI then</p><p>        API.Bridge("API.AllowCheats()");</p><p>        return;</p><p>    end</p><p>    return BundleGameHelperFunctions.Global:RessurectCheats();</p><p>-- Sperrt das Speichern von Spielständen oder gibt es wieder frei.</p><p>-- <p><b>Alias:</b> ForbidSaveGame</p></p><p>-- @param _Flag [boolean] Speichern gesperrt</p><p>-- @within Anwenderfunktionen</p><p>function API.ForbidSaveGame(_Flag)</p><p>    if GUI then</p><p>        API.Bridge("API.ForbidSaveGame(".. tostring(_Flag) ..")");</p><p>        return;</p><p>    end</p><p>    API.Bridge([[</p><p>        BundleGameHelperFunctions.Local.Data.ForbidSave = ]].. tostring(_Flag) ..[[ == true</p><p>        BundleGameHelperFunctions.Local:DisplaySaveButtons(]].. tostring(_Flag) ..[[)</p><p>    ]]);</p><p>-- Aktiviert den Hotkey zum Wechsel zwischen normalen und erweiterten Zoom.</p><p>-- <p><b>Alias:</b> AllowExtendedZoom</p></p><p>-- @param _Flag [boolean] Erweiterter Zoom gestattet</p><p>-- @within Anwenderfunktionen</p><p>function API.AllowExtendedZoom(_Flag)</p><p>    if GUI then</p><p>        API.Bridge("API.AllowExtendedZoom(".. tostring(_Flag) ..")");</p><p>        return;</p><p>    end</p><p>    BundleGameHelperFunctions.Global.Data.ExtendedZoomAllowed = _Flag == true;</p><p>    if _Flag == false then</p><p>        BundleGameHelperFunctions.Global:DeactivateExtendedZoom();</p><p>    end</p><p>-- Aktiviert die Heldenkamera und setzt den verfolgten Helden. Der</p><p>-- Held kann 0 sein, dann wird entweder der letzte Held verwendet</p><p>-- oder über den GUI-Spieler ermittelt.</p><p>-- <p><b>Alias:</b> HeroCameraActivate</p></p><p>-- @param _Hero [string|number] Skriptname/Entity-ID des Helden</p><p>-- @param _MaxZoom [number] Maximaler Zoomfaktor</p><p>-- @within Anwenderfunktionen</p><p>function API.ThridPersonActivate(_Hero, _MaxZoom)</p><p>    if GUI then</p><p>        local Target = (type(_Hero) == "string" and "'".._Hero.."'") or _Hero;</p><p>        API.Bridge("API.ThridPersonActivate(".. Target ..", ".. _MaxZoom ..")");</p><p>        return;</p><p>    end</p><p>    return BundleGameHelperFunctions.Global:ThridPersonActivate(_Hero, _MaxZoom);</p><p>-- Deaktiviert die Heldenkamera.</p><p>-- <p><b>Alias:</b> HeroCameraDeactivate</p></p><p>-- @within Anwenderfunktionen</p><p>function API.ThridPersonDeactivate()</p><p>    if GUI then</p><p>        API.Bridge("API.ThridPersonDeactivate()");</p><p>        return;</p><p>    end</p><p>    return BundleGameHelperFunctions.Global:ThridPersonDeactivate();</p><p>-- Prüft, ob die Heldenkamera aktiv ist.</p><p>-- <p><b>Alias:</b> HeroCameraIsRuning</p></p><p>-- @return [boolean] Kamera aktiv</p><p>-- @within Anwenderfunktionen</p><p>function API.ThridPersonIsRuning()</p><p>    if not GUI then</p><p>        return BundleGameHelperFunctions.Global:ThridPersonIsRuning();</p><p>    else</p><p>        return BundleGameHelperFunctions.Local:ThridPersonIsRuning();</p><p>    end</p><p>-- Lässt einen Siedler einem Helden folgen. Gibt die ID des Jobs</p><p>-- zurück, der die Verfolgung steuert.</p><p>-- <p><b>Hinweis:</b> Wenn eines der Entities zerstört wird, oder ins</p><p>-- Koma fällt, wird der Job beendet!</p></p><p>-- <p><b>Alias:</b> AddFollowKnightSave</p></p><p>-- @param _Entity [string|number] Entity das folgt</p><p>-- @param _Knight [string|number] Held</p><p>-- @param _Distance [number] Entfernung, die uberschritten sein muss</p><p>-- @param _Angle [number] Ausrichtung</p><p>-- @return [number] Job-ID</p><p>-- @within Anwenderfunktionen</p><p>function API.FollowKnightSaveStart(_Entity, _Knight, _Distance, _Angle)</p><p>    if GUI then</p><p>        local Target = (type(_Entity) == "string" and "'".._Entity.."'") or _Entity;</p><p>        local Knight = (type(_Knight) == "string" and "'".._Knight.."'") or _Knight;</p><p>        API.Bridge("API.FollowKnightSaveStart(" ..Target.. ", " ..Knight.. ", " .._Distance.. "," .._Angle.. ")");</p><p>        return;</p><p>    end</p><p>    return BundleGameHelperFunctions.Global:AddFollowKnightSave(_Entity, _Knight, _Distance, _Angle);</p><p>-- Beendet einen Verfolgungsjob.</p><p>-- <p><b>Alias:</b> StopFollowKnightSave</p></p><p>-- @param _JobID [number] Job-ID</p><p>-- @within Anwenderfunktionen</p><p>function API.FollowKnightSaveStop(_JobID)</p><p>    if GUI then</p><p>        API.Bridge("API.FollowKnightSaveStop(" .._JobID.. ")");</p><p>        return;</p><p>    end</p><p>    return BundleGameHelperFunctions.Global:StopFollowKnightSave(_JobID)</p><p>-- <p>Ändert die Bodentextur innerhalb des Quadrates. Offset bestimmt die</p><p>-- Abstände der Eckpunkte zum Zentralpunkt.</p></p><p>-- <p><b>Hinweis:</b> Für weitere Informationen zu Terraintexturen siehe</p><p>-- https://siedelwood-neu.de/23879-2/</p></p><p>-- <p><b>Alias:</b> TerrainType</p></p><p>-- @param _Center [string|number] Zentralpunkt</p><p>-- @param _Offset [number] Entfernung der Ecken zum Zentrum</p><p>-- @param _TerrainType [number] Textur ID</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.ChangeTerrainTypeInSquare("area", 500, 48)</p><p>function API.ChangeTerrainTypeInSquare(_Center, _Offset, _TerrainType)</p><p>    if GUI then</p><p>        local Target = (type(_Center) == "string" and "'".._Center.."'") or _Center;</p><p>        API.Bridge("API.ChangeTerrainTypeInSquare(" ..Target.. ", " .._Offset.. ", " .._TerrainType.. ")");</p><p>        return;</p><p>    end</p><p>    if not IsExisting(_Center) then</p><p>        API.Fatal("API.ChangeTerrainTypeInSquare: Central point does not exist!");</p><p>        return;</p><p>    end</p><p>    if _Offset < 100 then</p><p>        API.Warn("API.ChangeTerrainTypeInSquare: Check your offset! It seems to small!");</p><p>    end</p><p>    return BundleGameHelperFunctions.Global:ChangeTerrainTypeInSquare(_Center, _Offset, _TerrainType);</p><p>-- Ändert die Wasserhöhe in einem Quadrat. Offset bestimmt die Abstände</p><p>-- der Eckpunkte zum Zentrum.</p><p>-- Wird die relative Höhe verwendet, wird die Wasserhöhe nicht absolut</p><p>-- gesetzt sondern von der aktuellen Wasserhöhe ausgegangen.</p><p>-- <p><b>Alias:</b> WaterHeight</p></p><p>-- @param _Center [string|number] Zentralpunkt</p><p>-- @param _Offset [number] Entfernung der Ecken zum Zentrum</p><p>-- @param _Height [number] Neue Höhe</p><p>-- @param _Relative [boolean] Relative Höhe benutzen</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.ChangeWaterHeightInSquare("area", 500, 5555, true);</p><p>function API.ChangeWaterHeightInSquare(_Center, _Offset, _Height, _Relative)</p><p>    if GUI then</p><p>        local Target = (type(_Center) == "string" and "'".._Center.."'") or _Center;</p><p>        API.Bridge("API.ChangeWaterHeightInSquare(" ..Target.. ", " .._Offset.. ", " .._Height.. ", " ..tostring(_Relative).. ")");</p><p>        return;</p><p>    end</p><p>    if not IsExisting(_Center) then</p><p>        API.Fatal("API.ChangeWaterHeightInSquare: Central point does not exist!");</p><p>        return;</p><p>    end</p><p>    if _Offset < 100 then</p><p>        API.Warn("API.ChangeWaterHeightInSquare: Check your offset! It seems to small!");</p><p>    end</p><p>    return BundleGameHelperFunctions.Global:ChangeWaterHeightInSquare(_Center, _Offset, _Height, _Relative);</p><p>-- Ändert die Landhöhe in einem Quadrat. Offset bestimmt die Abstände</p><p>-- der Eckpunkte zum Zentralpunkt.</p><p>-- Wird die relative Höhe verwendet, wird die Landhöhe nicht absolut</p><p>-- gesetzt sondern von der aktuellen Landhöhe ausgegangen. Das Land muss nicht</p><p>-- eben sein. Auf diese Weise können Strukturen unverändert angehoben werden.</p><p>-- <p><b>Alias:</b> TerrainHeight</p></p><p>-- @param _Center [string|number] Zentralpunkt</p><p>-- @param _Offset [number] Entfernung der Ecken zum Zentrum</p><p>-- @param _Height [number] Neue Höhe</p><p>-- @param _Relative [boolean] Relative Höhe benutzen</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.ChangeTerrainHeightInSquare("area", 500, 5555, true);</p><p>function API.ChangeTerrainHeightInSquare(_Center, _Offset, _Height, _Relative)</p><p>    if GUI then</p><p>        local Target = (type(_Center) == "string" and "'".._Center.."'") or _Center;</p><p>        API.Bridge("API.ChangeTerrainHeightInSquare(" ..Target.. ", " .._Offset.. ", " .._Height.. ", " ..tostring(_Relative).. ")");</p><p>        return;</p><p>    end</p><p>    if not IsExisting(_Center) then</p><p>        API.Fatal("API.ChangeTerrainHeightInSquare: Central point does not exist!");</p><p>        return;</p><p>    end</p><p>    if _Offset < 100 then</p><p>        API.Warn("API.ChangeTerrainHeightInSquare: Check your offset! It seems to small!");</p><p>    end</p><p>    return BundleGameHelperFunctions.Global:ChangeTerrainHeightInSquare(_Center, _Offset, _Height, _Relative);</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {</p><p>        Data = {</p><p>            HumanPlayerChangedOnce = false,</p><p>            HumanKnightType = 0,</p><p>            HumanPlayerID = 1,</p><p>            ExtendedZoomAllowed = true,</p><p>            FollowKnightSave = {},</p><p>        }</p><p>    },</p><p>    Local = {</p><p>        Data = {</p><p>            SpeedLimit = 32,</p><p>            ThirdPersonIsActive = false,</p><p>            ThirdPersonLastHero = nil,</p><p>            ThirdPersonLastZoom = nil,</p><p>        }</p><p>    },</p><p>-- Global Script ---------------------------------------------------------------</p><p>-- Initalisiert das Bundle im globalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    self:InitExtendedZoomHotkeyFunction();</p><p>    self:InitExtendedZoomHotkeyDescription();</p><p>    API.AddSaveGameAction(BundleGameHelperFunctions.Global.OnSaveGameLoaded);</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Schaltet zwischen dem normalen und dem erweiterten Zoom um.</p><p>-- @within Internal</p><p>-- @local</p><p>    if self.Data.ExtendedZoomAllowed then</p><p>        if self.Data.ExtendedZoomActive then</p><p>            self:DeactivateExtendedZoom();</p><p>        else</p><p>            self:ActivateExtendedZoom();</p><p>        end</p><p>    end</p><p>-- Aktiviert den erweiterten Zoom.</p><p>-- @within Internal</p><p>-- @local</p><p>    self.Data.ExtendedZoomActive = true;</p><p>    API.Bridge("BundleGameHelperFunctions.Local:ActivateExtendedZoom()");</p><p>-- Deaktiviert den erweiterten Zoom.</p><p>-- @within Internal</p><p>-- @local</p><p>    self.Data.ExtendedZoomActive = false;</p><p>    API.Bridge("BundleGameHelperFunctions.Local:DeactivateExtendedZoom()");</p><p>-- Initialisiert den erweiterten Zoom.</p><p>-- @within Internal</p><p>-- @local</p><p>    API.Bridge([[</p><p>        BundleGameHelperFunctions.Local:ActivateExtendedZoomHotkey()</p><p>    ]]);</p><p>-- Initialisiert den erweiterten Zoom.</p><p>-- @within Internal</p><p>-- @local</p><p>    API.Bridge([[</p><p>        BundleGameHelperFunctions.Local:RegisterExtendedZoomHotkey()</p><p>    ]]);</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Deaktiviert die Tastenkombination zum Einschalten der Cheats.</p><p>-- @within Internal</p><p>-- @local</p><p>    self.Data.CheatsForbidden = true;</p><p>    API.Bridge("BundleGameHelperFunctions.Local:KillCheats()");</p><p>-- Aktiviert die Tastenkombination zum Einschalten der Cheats.</p><p>-- @within Internal</p><p>-- @local</p><p>    self.Data.CheatsForbidden = false;</p><p>    API.Bridge("BundleGameHelperFunctions.Local:RessurectCheats()");</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Aktiviert die Heldenkamera und setzt den verfolgten Helden. Der</p><p>-- Held kann 0 sein, dann wird entweder der letzte Held verwendet</p><p>-- oder über den GUI-Spieler ermittelt.</p><p>-- @param _Hero [string|number] Skriptname/Entity-ID des Helden</p><p>-- @param _MaxZoom [number] Maximaler Zoomfaktor</p><p>-- @within Internal</p><p>-- @local</p><p>    if BriefingSystem then</p><p>        BundleGameHelperFunctions.Global:ThridPersonOverwriteStartAndEndBriefing();</p><p>    end</p><p>    local Hero = GetID(_Hero);</p><p>    BundleGameHelperFunctions.Global.Data.ThridPersonIsActive = true;</p><p>    Logic.ExecuteInLuaLocalState([[</p><p>        BundleGameHelperFunctions.Local:ThridPersonActivate(]]..tostring(Hero)..[[, ]].. tostring(_MaxZoom) ..[[);</p><p>    ]]);</p><p>-- Deaktiviert die Heldenkamera.</p><p>-- @within Internal</p><p>-- @local</p><p>    BundleGameHelperFunctions.Global.Data.ThridPersonIsActive = false;</p><p>    Logic.ExecuteInLuaLocalState([[</p><p>        BundleGameHelperFunctions.Local:ThridPersonDeactivate();</p><p>    ]]);</p><p>-- Prüft, ob die Heldenkamera aktiv ist.</p><p>-- @return [boolean] Kamera aktiv</p><p>-- @within Internal</p><p>-- @local</p><p>    return self.Data.ThridPersonIsActive;</p><p>-- Überschreibt StartBriefing und EndBriefing des Briefing System,</p><p>-- wenn es vorhanden ist.</p><p>-- @within Internal</p><p>-- @local</p><p>    if BriefingSystem then</p><p>        if not BriefingSystem.StartBriefing_Orig_HeroCamera then</p><p>            BriefingSystem.StartBriefing_Orig_HeroCamera = BriefingSystem.StartBriefing;</p><p>            BriefingSystem.StartBriefing = function(_Briefing, _CutsceneMode)</p><p>                if BundleGameHelperFunctions.Global:ThridPersonIsRuning() then</p><p>                    BundleGameHelperFunctions.Global:ThridPersonDeactivate();</p><p>                    BundleGameHelperFunctions.Global.Data.ThirdPersonStoppedByCode = true;</p><p>                end</p><p>                BriefingSystem.StartBriefing_Orig_HeroCamera(_Briefing, _CutsceneMode);</p><p>            end</p><p>            StartBriefing = BriefingSystem.StartBriefing;</p><p>        end</p><p>        if not BriefingSystem.EndBriefing_Orig_HeroCamera then</p><p>            BriefingSystem.EndBriefing_Orig_HeroCamera = BriefingSystem.EndBriefing;</p><p>            BriefingSystem.EndBriefing = function(_Briefing, _CutsceneMode)</p><p>                BriefingSystem.EndBriefing_Orig_HeroCamera();</p><p>                if BundleGameHelperFunctions.Global.Data.ThridPersonStoppedByCode then</p><p>                    BundleGameHelperFunctions.Global:ThridPersonActivate(0);</p><p>                    BundleGameHelperFunctions.Global.Data.ThridPersonStoppedByCode = false;</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Lässt einen Siedler einem Helden folgen. Gibt die ID des Jobs</p><p>-- zurück, der die Verfolgung steuert.</p><p>-- @param _Entity [string|number] Entity das folgt</p><p>-- @param _Knight [string|number] Held</p><p>-- @param _Distance [number] Entfernung, die uberschritten sein muss</p><p>-- @param _Angle [number] Ausrichtung</p><p>-- @return [number] Job-ID</p><p>-- @within Internal</p><p>-- @local</p><p>    local EntityID = GetID(_Entity);</p><p>    local KnightID = GetID(_Knight);</p><p>    _Angle = _Angle or 0;</p><p>    local JobID = Trigger.RequestTrigger(Events.LOGIC_EVENT_EVERY_TURN,</p><p>                                         nil,</p><p>                                         "ControlFollowKnightSave",</p><p>                                         1,</p><p>                                         {},</p><p>                                         {EntityID, KnightID, _Distance, _Angle});</p><p>    table.insert(self.Data.FollowKnightSave, JobID);</p><p>    return JobID;</p><p>-- Beendet einen Verfolgungsjob.</p><p>-- @param _JobID [number] Job-ID</p><p>-- @within Internal</p><p>-- @local</p><p>    for k,v in pairs(self.Data.FollowKnightSave) do</p><p>        if _JobID == v then</p><p>            self.Data.FollowKnightSave[k] = nil;</p><p>            EndJob(_JobID);</p><p>        end</p><p>    end</p><p>-- Kontrolliert die Verfolgung eines Helden durch einen Siedler.</p><p>-- @param _EntityID [number]Entity das folgt</p><p>-- @param _KnightID [number]Held</p><p>-- @param _Distance [number] Entfernung, die uberschritten sein muss</p><p>-- @param _Angle [number] Ausrichtung</p><p>-- @within Internal</p><p>-- @local</p><p>    -- Entity oder Held sind hinüber bzw. haben ihre ID verändert</p><p>    if not IsExisting(_KnightID) or not IsExisting(_EntityID) then</p><p>        return true;</p><p>    end</p><p>    -- Wenn Entity ein Held ist, dann nur, wenn Entity nicht komatös ist</p><p>    if Logic.IsKnight(_EntityID) and Logic.KnightGetResurrectionProgress(_EntityID) ~= 1 then</p><p>        return false;</p><p>    end</p><p>    -- Wenn Knight ein Held ist, dann nur, wenn Knight nicht komatös ist</p><p>    if Logic.IsKnight(_KnightID) and Logic.KnightGetResurrectionProgress(_KnightID) ~= 1 then</p><p>        return false;</p><p>    end</p><p>    if  Logic.IsEntityMoving(_EntityID) == false and Logic.IsFighting(_EntityID) == false</p><p>    and IsNear(_EntityID, _KnightID, _Distance+300) == false then</p><p>        -- Relative Position hinter Held bestimmen</p><p>        local x, y, z = Logic.EntityGetPos(_KnightID);</p><p>        local orientation = Logic.GetEntityOrientation(_KnightID)-(180+_Angle);</p><p>        local xBehind = x + _Distance * math.cos(math.rad(orientation));</p><p>        local yBehind = y + _Distance * math.sin(math.rad(orientation));</p><p>        -- Relative Position blockingsicher machen</p><p>        local NoBlocking = Logic.CreateEntityOnUnblockedLand(Entities.XD_ScriptEntity, xBehind, yBehind, 0, 0);</p><p>        local x, y, z = Logic.EntityGetPos(NoBlocking);</p><p>        DestroyEntity(NoBlocking);</p><p>        -- Zur neuen unblockierten Position bewegen</p><p>        Logic.MoveSettler(_EntityID, x, y);</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ändert die Bodentextur innerhalb des Quadrates. Offset bestimmt die</p><p>-- Abstände der Eckpunkte zum Zentralpunkt.</p><p>-- @param _Center [string|number] Zentralpunkt</p><p>-- @param _Offset [number] Entfernung der Ecken zum Zentrum</p><p>-- @param _TerrainType [number] Textur ID</p><p>-- @within Internal</p><p>-- @local</p><p>    local Xmin, Ymin, Xmax, Ymax, z = self:GetSquareForWaterAndTerrain(_Center, _Offset);</p><p>    if Xmin == -1 or Xmin == -2 then</p><p>        return Xmin;</p><p>    end</p><p>    if type(_TerrainType) == "number" then</p><p>        for x10 = Xmin, Xmax do</p><p>            for y10 = Ymin, Ymax do</p><p>                Logic.SetTerrainNodeType( x10, y10, _TerrainType );</p><p>            end</p><p>        end</p><p>    end</p><p>    Logic.UpdateBlocking( Xmin, Ymin, Xmax, Ymax);</p><p>-- Ändert die Wasserhöhe in einem Quadrat. Offset bestimmt die Abstände</p><p>-- der Eckpunkte zum Zentralpunkt.</p><p>-- @param _Center [string|number] Zentralpunkt</p><p>-- @param _Offset [number] Entfernung der Ecken zum Zentrum</p><p>-- @param _Height [number] Neue Höhe</p><p>-- @param _Relative [boolean] Relative Höhe benutzen</p><p>-- @within Internal</p><p>-- @local</p><p>    local Xmin, Ymin, Xmax, Ymax, z = self:GetSquareForWaterAndTerrain(_Center, _Offset);</p><p>    if Xmin == -1 or Xmin == -2 then</p><p>        return Xmin;</p><p>    end</p><p>    if not _Relative then</p><p>        if _Height < 0 then</p><p>            return -3;</p><p>        end</p><p>        Logic.WaterSetAbsoluteHeight(Xmin, Ymin, Xmax, Ymax, _Height);</p><p>    else</p><p>        if z+_Height < 0 then</p><p>            return -3;</p><p>        end</p><p>        Logic.WaterSetAbsoluteHeight(Xmin, Ymin, Xmax, Ymax, z+_Height);</p><p>    end</p><p>    Logic.UpdateBlocking(Xmin, Ymin, Xmax, Ymax);</p><p>    return 0;</p><p>-- Ändert die Landhöhe in einem Quadrat. Offset bestimmt die Abstände</p><p>-- der Eckpunkte zum Zentralpunkt.</p><p>-- @param _Center [string|number] Zentralpunkt</p><p>-- @param _Offset [number] Entfernung der Ecken zum Zentrum</p><p>-- @param _Height [number] Neue Höhe</p><p>-- @param _Relative [boolean] Relative Höhe benutzen</p><p>-- @within Internal</p><p>-- @local</p><p>    local Xmin, Ymin, Xmax, Ymax, z = self:GetSquareForWaterAndTerrain(_Center, _Offset);</p><p>    if Xmin == -1 or Xmin == -2 then</p><p>        return Xmin;</p><p>    end</p><p>    local Height;</p><p>    if not _Relative then</p><p>        if _Height < 0 then</p><p>            return -3;</p><p>        end</p><p>        Height = _Height;</p><p>    else</p><p>        if z+_Height < 0 then</p><p>            return -3;</p><p>        end</p><p>        Height = z+_Height;</p><p>    end</p><p>    for x10 = Xmin, Xmax do</p><p>        for y10 = Ymin, Ymax do</p><p>            Logic.SetTerrainNodeHeight(x10, y10, Height);</p><p>        end</p><p>    end</p><p>    Logic.UpdateBlocking(Xmin, Ymin, Xmax, Ymax);</p><p>    return 0;</p><p>-- Gibt ein Quadrat für Land- und Wassermanipulation zurück.</p><p>-- Wird verwendet von: WaterHeight, TerrainHeight, TerrainType</p><p>-- @param _Center [string|number] Zentralpunkt des Quadrat</p><p>-- @param _Offset [number] Abstand der Ecken zum Zentrum</p><p>-- @return [number] X-Koordinate von Punkt 1</p><p>-- @return [number] Y-Koordinate von Punkt 1</p><p>-- @return [number] X-Koordinate von Punkt 2</p><p>-- @return [number] Y-Koordinate von Punkt 2</p><p>-- @return [number] Bodenhöhe</p><p>-- @within Internal</p><p>-- @local</p><p>    local Type = type(_Center);</p><p>    if (Type ~= "string" and Type ~= "number") or not IsExisting(_Center) then</p><p>        return -1;</p><p>    end</p><p>    local Xmin, Ymin, Xmax, Ymax;</p><p>    local eID = GetID(_Center);</p><p>    local x,y,z = Logic.EntityGetPos(eID);</p><p>    Xmin = math.floor((x - _Offset)/100);</p><p>    Ymin = math.floor((y - _Offset)/100);</p><p>    Xmax = math.floor((x + _Offset)/100);</p><p>    Ymax = math.floor((y + _Offset)/100);</p><p>    if IsValidPosition({X= Xmin, Y= Ymin}) == false or IsValidPosition({X= Xmax, Y= Ymax}) == false then</p><p>        return -2;</p><p>    end</p><p>    return Xmin, Ymin, Xmax, Ymax, z;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Stellt nicht-persistente Änderungen nach dem laden wieder her.</p><p>-- @within Internal</p><p>-- @local</p><p>    -- Geänderter Zoom --</p><p>    if BundleGameHelperFunctions.Global.Data.ExtendedZoomActive then</p><p>        BundleGameHelperFunctions.Global:ActivateExtendedZoom();</p><p>    end</p><p>    BundleGameHelperFunctions.Global:InitExtendedZoomHotkeyFunction();</p><p>    -- Cheats sperren --</p><p>    if BundleGameHelperFunctions.Global.Data.CheatsForbidden == true then</p><p>        BundleGameHelperFunctions.Global:KillCheats();</p><p>    end</p><p>-- Local Script ----------------------------------------------------------------</p><p>-- Initalisiert das Bundle im lokalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    self:InitForbidSpeedUp()</p><p>    self:InitForbidSaveGame();</p><p>-- Fokusiert die Kamera auf dem Entity.</p><p>-- @param _Entity [string|number] Entity</p><p>-- @param _Rotation [number] Kamerawinkel</p><p>-- @param _ZoomFactor [number] Zoomfaktor</p><p>-- @within Internal</p><p>-- @local</p><p>    local pos = GetPosition(_Entity);</p><p>    local rotation = (_Rotation or -45);</p><p>    local zoomFactor = (_ZoomFactor or 0.5);</p><p>    Camera.RTS_SetLookAtPosition(pos.X, pos.Y);</p><p>    Camera.RTS_SetRotationAngle(rotation);</p><p>    Camera.RTS_SetZoomFactor(zoomFactor);</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Setzt die Obergrenze für die Spielgeschwindigkeit fest.</p><p>-- @param _Limit [number] Obergrenze</p><p>-- @within Internal</p><p>-- @local</p><p>    _Limit = (_Limit < 1 and 1) or math.floor(_Limit);</p><p>    self.Data.SpeedLimit = _Limit;</p><p>-- Aktiviert die Speedbremse. Die vorher eingestellte Maximalgeschwindigkeit</p><p>-- kann nicht mehr überschritten werden.</p><p>-- @param _Flag [boolean] Speedbremse ist aktiv</p><p>-- @within Internal</p><p>-- @local</p><p>    self.Data.UseSpeedLimit = _Flag == true;</p><p>    if _Flag and Game.GameTimeGetFactor(GUI.GetPlayerID()) > self.Data.SpeedLimit then</p><p>        Game.GameTimeSetFactor(GUI.GetPlayerID(), self.Data.SpeedLimit);</p><p>    end</p><p>-- Überschreibt das Callback, das nach dem Ändern der Spielgeschwindigkeit</p><p>-- aufgerufen wird und installiert die Speedbremse.</p><p>-- @within Internal</p><p>-- @local</p><p>    GameCallback_GameSpeedChanged_Orig_Preferences_ForbidSpeedUp = GameCallback_GameSpeedChanged;</p><p>    GameCallback_GameSpeedChanged = function( _Speed )</p><p>        GameCallback_GameSpeedChanged_Orig_Preferences_ForbidSpeedUp( _Speed );</p><p>        if BundleGameHelperFunctions.Local.Data.UseSpeedLimit == true then</p><p>            if _Speed > BundleGameHelperFunctions.Local.Data.SpeedLimit then</p><p>                Game.GameTimeSetFactor(GUI.GetPlayerID(), BundleGameHelperFunctions.Local.Data.SpeedLimit);</p><p>            end</p><p>        end</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Deaktiviert die Tastenkombination zum Einschalten der Cheats.</p><p>-- @within Internal</p><p>-- @local</p><p>    Input.KeyBindDown(</p><p>        Keys.ModifierControl + Keys.ModifierShift + Keys.Divide,</p><p>        "KeyBindings_EnableDebugMode(0)",</p><p>        2,</p><p>        false</p><p>    );</p><p>-- Aktiviert die Tastenkombination zum Einschalten der Cheats.</p><p>-- @within Internal</p><p>-- @local</p><p>    Input.KeyBindDown(</p><p>        Keys.ModifierControl + Keys.ModifierShift + Keys.Divide,</p><p>        "KeyBindings_EnableDebugMode(2)",</p><p>        2,</p><p>        false</p><p>    );</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Schreibt den Hotkey für den erweiterten Zoom in das Hotkey-Register.</p><p>-- @within Internal</p><p>-- @local</p><p>    API.AddHotKey(</p><p>        {de = "Strg + Umschalt + K",       en = "Ctrl + Shift + K"},</p><p>        {de = "Alternativen Zoom ein/aus", en = "Alternative zoom on/off"}</p><p>    )</p><p>-- Aktiviert den Hotkey zum Wechsel zwischen normalen und erweiterten Zoom.</p><p>-- @within Internal</p><p>-- @local</p><p>    Input.KeyBindDown(</p><p>        Keys.ModifierControl + Keys.ModifierShift + Keys.K,</p><p>        "BundleGameHelperFunctions.Local:ToggleExtendedZoom()",</p><p>        2,</p><p>        false</p><p>    );</p><p>-- Wechselt zwischen erweitertem und normalen Zoom.</p><p>-- @within Internal</p><p>-- @local</p><p>    API.Bridge("BundleGameHelperFunctions.Global:ToggleExtendedZoom()");</p><p>-- Erweitert die Zoomrestriktion auf das Maximum.</p><p>-- @within Internal</p><p>-- @local</p><p>    Camera.RTS_SetZoomFactorMax(0.8701);</p><p>    Camera.RTS_SetZoomFactor(0.8700);</p><p>    Camera.RTS_SetZoomFactorMin(0.0999);</p><p>-- Stellt die normale Zoomrestriktion wieder her.</p><p>-- @within Internal</p><p>-- @local</p><p>    Camera.RTS_SetZoomFactor(0.5000);</p><p>    Camera.RTS_SetZoomFactorMax(0.5001);</p><p>    Camera.RTS_SetZoomFactorMin(0.0999);</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Überschreibt die Hotkey-Funktion, die das Spiel speichert.</p><p>-- @within Internal</p><p>-- @local</p><p>    KeyBindings_SaveGame_Orig_Preferences_SaveGame = KeyBindings_SaveGame;</p><p>    KeyBindings_SaveGame = function()</p><p>        if BundleGameHelperFunctions.Local.Data.ForbidSave then</p><p>            return;</p><p>        end</p><p>        KeyBindings_SaveGame_Orig_Preferences_SaveGame();</p><p>    end</p><p>-- Zeigt oder versteckt die Speicherbuttons im Spielmenü.</p><p>-- @param _Flag [boolean] Speicherbuttons sichtbar</p><p>-- @within Internal</p><p>-- @local</p><p>    XGUIEng.ShowWidget("/InGame/InGame/MainMenu/Container/SaveGame",  (_Flag and 0) or 1);</p><p>    XGUIEng.ShowWidget("/InGame/InGame/MainMenu/Container/QuickSave", (_Flag and 0) or 1);</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Aktiviert die Heldenkamera und setzt den verfolgten Helden. Der</p><p>-- Held kann 0 sein, dann wird entweder der letzte Held verwendet</p><p>-- oder über den GUI-Spieler ermittelt.</p><p>-- @param _Hero [string|number] Skriptname/Entity-ID des Helden</p><p>-- @param _MaxZoom [number] Maximaler Zoomfaktor</p><p>-- @within Internal</p><p>-- @local</p><p>    _Hero = (_Hero ~= 0 and _Hero) or self.Data.ThridPersonLastHero or Logic.GetKnightID(GUI.GetPlayerID());</p><p>    _MaxZoom = _MaxZoom or self.Data.ThridPersonLastZoom or 0.5;</p><p>    if not _Hero then</p><p>        return;</p><p>    end</p><p>    if not GameCallback_Camera_GetBorderscrollFactor_Orig_HeroCamera then</p><p>        self:ThridPersonOverwriteGetBorderScrollFactor();</p><p>    end</p><p>    self.Data.ThridPersonLastHero = _Hero;</p><p>    self.Data.ThridPersonLastZoom = _MaxZoom;</p><p>    self.Data.ThridPersonIsActive = true;</p><p>    local Orientation = Logic.GetEntityOrientation(_Hero);</p><p>    Camera.RTS_FollowEntity(_Hero);</p><p>    Camera.RTS_SetRotationAngle(Orientation-90);</p><p>    Camera.RTS_SetZoomFactor(_MaxZoom);</p><p>    Camera.RTS_SetZoomFactorMax(_MaxZoom + 0.0001);</p><p>-- Deaktiviert die Heldenkamera.</p><p>-- @within Internal</p><p>-- @local</p><p>    self.Data.ThridPersonIsActive = false;</p><p>    Camera.RTS_SetZoomFactorMax(0.5);</p><p>    Camera.RTS_SetZoomFactor(0.5);</p><p>    Camera.RTS_FollowEntity(0);</p><p>-- Prüft, ob die Heldenkamera aktiv ist.</p><p>-- @return [boolean] Kamera aktiv</p><p>-- @within Internal</p><p>-- @local</p><p>    return self.Data.ThridPersonIsActive;</p><p>-- Überschreibt GameCallback_GetBorderScrollFactor und wandelt den</p><p>-- Bildlauf am Bildschirmrand in Bildrotation um. Dabei wird die</p><p>-- Kamera um links oder rechts gedreht, abhänig von der Position</p><p>-- der Mouse.</p><p>-- @within Internal</p><p>-- @local</p><p>    GameCallback_Camera_GetBorderscrollFactor_Orig_HeroCamera = GameCallback_Camera_GetBorderscrollFactor</p><p>    GameCallback_Camera_GetBorderscrollFactor = function()</p><p>        if not BundleGameHelperFunctions.Local.Data.ThridPersonIsActive then</p><p>            return GameCallback_Camera_GetBorderscrollFactor_Orig_HeroCamera();</p><p>        end</p><p>        local CameraRotation = Camera.RTS_GetRotationAngle();</p><p>        local xS, yS = GUI.GetScreenSize();</p><p>        local xM, yM = GUI.GetMousePosition();</p><p>        local xR = xM / xS;</p><p>        if xR <= 0.02 then</p><p>            CameraRotation = CameraRotation + 0.3;</p><p>        elseif xR >= 0.98 then</p><p>            CameraRotation = CameraRotation - 0.3;</p><p>        else</p><p>            return 0;</p><p>        end</p><p>        if CameraRotation >= 360 then</p><p>            CameraRotation = 0;</p><p>        end</p><p>        Camera.RTS_SetRotationAngle(CameraRotation);</p><p>        return 0;</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundleinteractiveobjects.lua.html">
            <div class='doclink'>
                <div>BundleInteractiveObjects</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia BundleInteractiveObjects                                     # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Interaktive Objekte sind Gegenstände auf der Karte, mit denen interagiert</p><p>-- werden kann. Diese Interaktion geschieht über einen Button. Ziel dieses</p><p>-- Bundels ist es, die funktionalität von interaktiven Objekten zu erweitern.</p><p>-- Es ist möglich, beliebige Objekte zu interaktiven Objekten zu machen.</p><p>-- Die Einsatzmöglichkeiten sind vielfältig. Wenn ein Gegenstand oder ein</p><p>-- Objekt mit einer Funktion versehen ist, kann dies in verschiedenem Kontext</p><p>-- an die Geschichte angepasst werden: z.B. Helbel öffnen eine Geheimtür,</p><p>-- ein Gegenstand wird vom Helden aufgehoben, ein Marktstand, der etwas</p><p>-- verkauft, ....</p><p>-- Das wichtigste Auf einen Blick:</p><p>-- <ul></p><p>-- <li></p><p>-- <a href="#API.CreateObject">Objekt erzeugen</a></p><p>-- </li></p><p>-- <li></p><p>-- <a href="#API.InteractiveObjectActivate">Ein- und ausschalten von</p><p>-- interaktiven Objekten</a></p><p>-- </li></p><p>-- <li></p><p>-- <a href="#API.AddCustomIOName">Anzeigenamen im Questfenster definieren</a></p><p>-- </li></p><p>-- </ul></p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Erzeugt ein interaktives Objekt.</p><p>-- Die Parameter des interaktiven Objektes werden durch seine Beschreibung</p><p>-- festgelegt. Die Beschreibung ist eine Table, die bestimmte Werte für das</p><p>-- Objekt beinhaltet. Dabei müssen nicht immer alle Werte angegeben werden.</p><p>-- Mögliche Angaben:</p><p>-- <table border="1"></p><p>-- <tr></p><p>-- <td><b>Feldname</b></td></p><p>-- <td><b>Beschreibung</b></td></p><p>-- <td><b>Optional</b></td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>Name</td></p><p>-- <td>Der Skriptname des Entity, das zum interaktiven Objekt wird.</td></p><p>-- <td>nein</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>Title</td></p><p>-- <td>Der angezeigter Name im Beschreibungsfeld.</td></p><p>-- <td>ja</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>Text</td></p><p>-- <td>Der Beschreibungstext, der im Tooltip angezeigt wird.</td></p><p>-- <td>ja</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>Texture</td></p><p>-- <td>Bestimmt die Icongrafik, die angezeigt wird. Dabei kann es sich um</p><p>-- eine Ingame-Grafik oder eine eigene Grafik halten.</td></p><p>-- <td>ja</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>Distance</td></p><p>-- <td>Die minimale Entfernung zum Objekt, die ein Held benötigt um das</p><p>-- objekt zu aktivieren.</td></p><p>-- <td>ja</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>Waittime</td></p><p>-- <td>Die Zeit, die ein Held benötigt, um das Objekt zu aktivieren. Die</p><p>-- Wartezeit ist nur für I_X_ Entities verfügbar.</td></p><p>-- <td>ja</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>Costs</td></p><p>-- <td>Eine Table mit dem Typ und der Menge der Kosten.</td></p><p>-- <td>ja</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>Reward</td></p><p>-- <td>Der Warentyp und die Menge der gefundenen Waren im Objekt.</td></p><p>-- <td>ja</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>Callback</td></p><p>-- <td>Eine Funktion, die ausgeführt wird, sobald das Objekt aktiviert wird.</td></p><p>-- <td>ja</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>Condition</td></p><p>-- <td>Eine Funktion, die vor der Aktivierung eine Beringung prüft.</td></p><p>-- <td>ja</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>ConditionUnfulfilled</td></p><p>-- <td>Eine Nachricht, die angezeigt wird, falls die Bedingung nicht</p><p>-- erfüllt ist.</td></p><p>-- <td>ja</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>Opener</td></p><p>-- <td>Ein spezieller Held, der als einziger das Objekt aktivieren kann.</td></p><p>-- <td>ja</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>WrongKnight</td></p><p>-- <td>Nachricht, die angezeigt wird, wenn der falsche Held das Objekt</p><p>-- aktivieren will.</td></p><p>-- <td>ja</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>State</td></p><p>-- <td>Bestimmt, wie sich der Button des interaktiven Objektes verhält.</td></p><p>-- <td>ja</td></p><p>-- </tr></p><p>-- </table></p><p>-- Zusätzlich können beliebige weitere Felder an das Objekt angehangen</p><p>-- werden. Sie sind ausnahmslos im Callback und in der Condition des Objektes</p><p>-- abrufbar.</p><p>-- <p><b>Alias:</b> CreateObject</p></p><p>-- @param _Description [table] Beschreibung</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- -- Ein einfaches Objekt erstellen:</p><p>-- CreateObject {</p><p>--     Name     = "hut",</p><p>--     Distance = 1500,</p><p>--     Callback = function(_Data)</p><p>--         API.Note("Do something...");</p><p>--     end,</p><p>-- }</p><p>function API.CreateObject(_Description)</p><p>    if GUI then</p><p>        API.Fatal("API.CreateObject: Can not be used from local enviorment!");</p><p>        return;</p><p>    end</p><p>    return BundleInteractiveObjects.Global:CreateObject(_Description);</p><p>-- Löscht ein interaktives Objekt.</p><p>-- Das Entity wird dabei nicht gelöscht. Es wird ausschließlich die</p><p>-- Konfiguration des Objektes entfernt.</p><p>-- <p><b>Alias:</b> RemoveInteractiveObject</p></p><p>-- @param _EntityName [string] Skriptname des IO</p><p>-- @within Anwenderfunktionen</p><p>function API.RemoveInteractiveObject(_EntityName)</p><p>    if GUI then</p><p>        API.Bridge("API.RemoveInteractiveObject('" .._EntityName.. "')");</p><p>        return;</p><p>    end</p><p>    if not IsExisting(_EntityName) then</p><p>        API.Warn("API.RemoveInteractiveObject: Entity \"" .._EntityName.. "\" is invalid!");</p><p>        return;</p><p>    end</p><p>    return BundleInteractiveObjects.Global:RemoveInteractiveObject(_EntityName);</p><p>-- Aktiviert ein Interaktives Objekt, sodass es vom Spieler</p><p>-- aktiviert werden kann.</p><p>-- Der State bestimmt, ob es immer aktiviert werden kann, oder ob der Spieler</p><p>-- einen Helden benutzen muss. Wird der Parameter weggelassen, muss immer ein</p><p>-- Held das Objekt aktivieren.</p><p>-- <p><b>Alias</b>: InteractiveObjectActivate</p></p><p>-- @param _EntityName [string] Skriptname des Objektes</p><p>-- @param _State [number] State des Objektes</p><p>-- @within Anwenderfunktionen</p><p>function API.InteractiveObjectActivate(_EntityName, _State)</p><p>    if GUI then</p><p>        API.Bridge("API.InteractiveObjectActivate('" .._EntityName.. "', " ..tostring(_State).. ")");</p><p>        return;</p><p>    end</p><p>    if not IsExisting(_EntityName) then</p><p>        API.Warn("API.InteractiveObjectActivate: Entity \"" .._EntityName.. "\" is invalid!");</p><p>        return;</p><p>    end</p><p>    if not Logic.IsInteractiveObject(GetID(_EntityName)) then</p><p>        if IO[_EntityName] then</p><p>            IO[_EntityName].Inactive = false;</p><p>            IO[_EntityName].Used = false;</p><p>        end</p><p>    else</p><p>        API.ActivateIO(_EntityName, _State);</p><p>    end</p><p>-- Deaktiviert ein interaktives Objekt, sodass es nicht mehr vom Spieler</p><p>-- benutzt werden kann.</p><p>-- <p><b>Alias</b>: InteractiveObjectDeactivate</p></p><p>-- @param _EntityName [string] Scriptname des Objektes</p><p>-- @within Anwenderfunktionen</p><p>function API.InteractiveObjectDeactivate(_EntityName)</p><p>    if GUI then</p><p>        API.Bridge("API.InteractiveObjectDeactivate('" .._EntityName.. "')");</p><p>        return;</p><p>    end</p><p>    if not IsExisting(_EntityName) then</p><p>        API.Warn("API.InteractiveObjectDeactivate: Entity \"" .._EntityName.. "\" is invalid!");</p><p>        return;</p><p>    end</p><p>    if not Logic.IsInteractiveObject(GetID(_EntityName)) then</p><p>        if IO[_EntityName] then</p><p>            IO[_EntityName].Inactive = true;</p><p>        end</p><p>    else</p><p>        API.DeactivateIO(_EntityName);</p><p>    end</p><p>-- Erzeugt eine Beschriftung für Custom Objects.</p><p>-- Im Questfenster werden die Namen von Custom Objects als ungesetzt angezeigt.</p><p>-- Mit dieser Funktion kann ein Name angelegt werden.</p><p>-- <p><b>Alias:</b> AddCustomIOName</p></p><p>-- @param _Key [string] Typname des Entity</p><p>-- @param _Text [string|table] Text der Beschriftung</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.AddCustomIOName("D_X_ChestClosed", {de = "Schatztruhe", en = "Treasure");</p><p>-- API.AddCustomIOName("D_X_ChestOpenEmpty", "Leere Schatztruhe");</p><p>function API.AddCustomIOName(_Key, _Text)</p><p>    if type(_Text == "table") then</p><p>        local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>        _Text = _Text[lang];</p><p>    end</p><p>    if GUI then</p><p>        API.Bridge("API.AddCustomIOName('" .._Key.. "', '" .._Text.. "')");</p><p>        return;</p><p>    end</p><p>    return BundleInteractiveObjects.Global:AddCustomIOName(_Key, _Text);</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {</p><p>        Data = {}</p><p>    },</p><p>    Local = {</p><p>        Data = {</p><p>            IOCustomNames = {},</p><p>            IOCustomNamesByEntityName = {},</p><p>        },</p><p>    },</p><p>-- Global Script ---------------------------------------------------------------</p><p>-- Initalisiert das Bundle im globalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    IO = {};</p><p>-- Erzeugt ein interaktives Objekt. Dabei können sowohl interaktive</p><p>-- Objekte (alle mit I_X_), eine Auswahl von normalen Entities und</p><p>-- sogar (sichtbare) XD_ScriptEntities verwendet werden.</p><p>-- Name, Titel und Icon müssen immer angegeben werden. Die restlichen</p><p>-- Angaben hängen teilweise vom Typ der Entity, teilweise vom</p><p>-- Verwendungszweck ab.</p><p>-- @param _Description [table] Beschreibung</p><p>-- @within Internal</p><p>-- @local</p><p>    local lang = Network.GetDesiredLanguage();</p><p>    self:HackOnInteractionEvent();</p><p>    self:RemoveInteractiveObject(_Description.Name);</p><p>    if type(_Description.Title) == "table" then</p><p>        _Description.Title = _Description.Title[lang];</p><p>    end</p><p>    if not _Description.Title or _Description.Title == "" then</p><p>        _Description.Title = (lang == "de" and "Interaktion") or "Interaction";</p><p>    end</p><p>    if type(_Description.Text) == "table" then</p><p>        _Description.Text = _Description.Text[lang];</p><p>    end</p><p>    if not _Description.Text then</p><p>        _Description.Text = "";</p><p>    end</p><p>    if type(_Description.WrongKnight) == "table" then</p><p>        _Description.WrongKnight = _Description.WrongKnight[lang];</p><p>    end</p><p>    _Description.WrongKnight = _Description.WrongKnight or "";</p><p>    if type(_Description.ConditionUnfulfilled) == "table" then</p><p>        _Description.ConditionUnfulfilled = _Description.ConditionUnfulfilled[lang];</p><p>    end</p><p>    _Description.ConditionUnfulfilled = _Description.ConditionUnfulfilled or "";</p><p>    _Description.Condition = _Description.Condition or function() return true end</p><p>    _Description.Callback = _Description.Callback or function() end</p><p>    _Description.Distance = _Description.Distance or 1200;</p><p>    _Description.Waittime = _Description.Waittime or 15;</p><p>    _Description.Texture = _Description.Texture or {14,10};</p><p>    _Description.Reward = _Description.Reward or {};</p><p>    _Description.Costs = _Description.Costs or {};</p><p>    _Description.State = _Description.State or 0;</p><p>    Logic.ExecuteInLuaLocalState([[</p><p>        QSB.IOList[#QSB.IOList+1] = "]].._Description.Name..[["</p><p>        if not BundleInteractiveObjects.Local.Data.InteractionHackStarted then</p><p>            BundleInteractiveObjects.Local:ActivateInteractiveObjectControl()</p><p>            BundleInteractiveObjects.Local.Data.InteractionHackStarted = true;</p><p>        end</p><p>    ]]);</p><p>    IO[_Description.Name] = API.InstanceTable(_Description);</p><p>    local eID = GetID(_Description.Name);</p><p>    if Logic.IsInteractiveObject(eID) == true then</p><p>        Logic.InteractiveObjectClearCosts(eID);</p><p>        Logic.InteractiveObjectClearRewards(eID);</p><p>        Logic.InteractiveObjectSetInteractionDistance(eID,_Description.Distance);</p><p>        Logic.InteractiveObjectSetTimeToOpen(eID,_Description.Waittime);</p><p>        Logic.InteractiveObjectAddRewards(eID,_Description.Reward[1],_Description.Reward[2]);</p><p>        Logic.InteractiveObjectSetAvailability(eID, true);</p><p>        Logic.InteractiveObjectSetPlayerState(eID, _Description.PlayerID or 1, _Description.State);</p><p>        Logic.InteractiveObjectSetRewardResourceCartType(eID, Entities.U_ResourceMerchant);</p><p>        Logic.InteractiveObjectSetRewardGoldCartType(eID, Entities.U_GoldCart);</p><p>        table.insert(HiddenTreasures,eID);</p><p>    end</p><p>-- Löscht ein interaktives Objekt.</p><p>-- Das Entity wird dabei nicht gelöscht. Es wird ausschließlich die</p><p>-- Konfiguration des Objektes entfernt.</p><p>-- @param _EntityName [string] Skriptname des IO</p><p>-- @within Internal</p><p>-- @local</p><p>    for k,v in pairs(IO) do</p><p>        if k == _EntityName then</p><p>            Logic.ExecuteInLuaLocalState([[</p><p>                IO["]].._EntityName..[["] = nil;</p><p>            ]]);</p><p>            IO[_EntityName] = nil;</p><p>        end</p><p>    end</p><p>-- Erzeugt eine Beschriftung für Custom Objects.</p><p>-- Im Questfenster werden die Namen von Cusrom Objects als ungesetzt angezeigt.</p><p>-- Mit dieser Funktion kann ein Name angelegt werden.</p><p>-- @param _Key [string] Identifier der Beschriftung</p><p>-- @param _Text [string] Text der Beschriftung</p><p>-- @within Internal</p><p>-- @local</p><p>    if type(_Text) == "table" then</p><p>        local GermanText  = _Text.de;</p><p>        local EnglishText = _Text.en;</p><p>        Logic.ExecuteInLuaLocalState([[</p><p>            BundleInteractiveObjects.Local.Data.IOCustomNames["]].._Key..[["] = {</p><p>                de = "]]..GermanText..[[",</p><p>                en = "]]..EnglishText..[["</p><p>            }</p><p>        ]]);</p><p>    else</p><p>        Logic.ExecuteInLuaLocalState([[</p><p>            BundleInteractiveObjects.Local.Data.IOCustomNames["]].._Key..[["] = "]].._Text..[["</p><p>        ]]);</p><p>    end</p><p>-- Überschreibt die Events, die ausgelöst werden, wenn interaktive Objekte</p><p>-- benutzt werden.</p><p>-- @within Internal</p><p>-- @local</p><p>    if not BundleInteractiveObjects.Global.Data.InteractionEventHacked then</p><p>        StartSimpleJobEx(BundleInteractiveObjects.Global.ControlInteractiveObjects);</p><p>        BundleInteractiveObjects.Global.Data.InteractionEventHacked = true;</p><p>        OnTreasureFound = function(_TreasureID, _PlayerID)</p><p>            for i=1, #HiddenTreasures do</p><p>                local HiddenTreasureID = HiddenTreasures[i]</p><p>                if HiddenTreasureID == _TreasureID then</p><p>                    Logic.InteractiveObjectSetAvailability(_TreasureID,false)</p><p>                    for PlayerID = 1, 8 do</p><p>                        Logic.InteractiveObjectSetPlayerState(_TreasureID,PlayerID, 2)</p><p>                    end</p><p>                    table.remove(HiddenTreasures,i)</p><p>                    HiddenTreasures[0] = #HiddenTreasures</p><p>                    local ActivationSound = "menu_left_prestige";</p><p>                    local eName = Logic.GetEntityName(_TreasureID);</p><p>                    if IO[eName] and IO[eName].ActivationSound then</p><p>                        ActivationSound = IO[eName].ActivationSound;</p><p>                    end</p><p>                    Logic.ExecuteInLuaLocalState("Play2DSound(" .. _PlayerID ..",'" .. ActivationSound .. "')");</p><p>                end</p><p>            end</p><p>        end</p><p>        GameCallback_OnObjectInteraction = function(__entityID_, _PlayerID)</p><p>            OnInteractiveObjectOpened(__entityID_, _PlayerID);</p><p>            OnTreasureFound(__entityID_, _PlayerID);</p><p>            local eName = Logic.GetEntityName(__entityID_);</p><p>            for k,v in pairs(IO)do</p><p>                if k == eName then</p><p>                    if not v.Used then</p><p>                        IO[k].Used = true;</p><p>                        v.Callback(v, _PlayerID);</p><p>                    end</p><p>                end</p><p>            end</p><p>        end</p><p>        GameCallback_ExecuteCustomObjectReward = function(_PlayerID, _SpawnID, _Type, _Amount)</p><p>            local pos = GetPosition(_SpawnID);</p><p>            local resCat = Logic.GetGoodCategoryForGoodType(_Type);</p><p>            local ID;</p><p>            if resCat == GoodCategories.GC_Resource then</p><p>                ID = Logic.CreateEntityOnUnblockedLand(Entities.U_ResourceMerchant, pos.X, pos.Y,0,_PlayerID);</p><p>            elseif _Type == Goods.G_Medicine then</p><p>                ID = Logic.CreateEntityOnUnblockedLand(Entities.U_Medicus, pos.X, pos.Y,0,_PlayerID);</p><p>            elseif _Type == Goods.G_Gold then</p><p>                ID = Logic.CreateEntityOnUnblockedLand(Entities.U_GoldCart, pos.X, pos.Y,0,_PlayerID);</p><p>            else</p><p>                ID = Logic.CreateEntityOnUnblockedLand(Entities.U_Marketer, pos.X, pos.Y,0,_PlayerID);</p><p>            end</p><p>            Logic.HireMerchant(ID,_PlayerID,_Type,_Amount,_PlayerID);</p><p>        end</p><p>        function QuestTemplate:AreObjectsActivated(objectList)</p><p>            for i=1, objectList[0] do</p><p>                if not objectList[-i] then</p><p>                    objectList[-i] = GetEntityId(objectList[i]);</p><p>                end</p><p>                local EntityName = Logic.GetEntityName(objectList[-i]);</p><p>                if Logic.IsInteractiveObject(objectList[-i]) then</p><p>                    if not IsInteractiveObjectOpen(objectList[-i]) then</p><p>                        return false;</p><p>                    end</p><p>                else</p><p>                    if not IO[EntityName] then</p><p>                        return false;</p><p>                    end</p><p>                    if IO[EntityName].Used ~= true then</p><p>                        return false;</p><p>                    end</p><p>                end</p><p>            end</p><p>            return true;</p><p>        end</p><p>    end</p><p>-- Prüft für alle unbenutzten interaktiven Objekte, ob ihre Bedingung erfüllt</p><p>-- ist und erlaubt die Benutzung.</p><p>-- @within Internal</p><p>-- @local</p><p>    for k,v in pairs(IO) do</p><p>        if not v.Used == true then</p><p>            v.ConditionFullfilled = v.Condition(v);</p><p>        end</p><p>    end</p><p>-- Local Script ----------------------------------------------------------------</p><p>-- Initalisiert das Bundle im lokalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    IO = Logic.CreateReferenceToTableInGlobaLuaState("IO");</p><p>-- Prüft, ob die Kosten für ein interaktives Objekt beglichen werden können.</p><p>-- @param _PlayerID [number] Spieler, der zahlt</p><p>-- @param _Good [number] Typ der Ware</p><p>-- @param _Amount [number] Menge der Ware</p><p>-- @within Internal</p><p>-- @local</p><p>    local AmountOfGoods = GetPlayerGoodsInSettlement(_Good, _PlayerID, true);</p><p>    if AmountOfGoods < _Amount then</p><p>        return false;</p><p>    end</p><p>    return true;</p><p>-- Zieht die Kosten des Objektes aus dem Lagerhaus des Spielers ab.</p><p>-- @param _PlayerID [number] Spieler, der zahlt</p><p>-- @param _Good [number] Typ der Ware</p><p>-- @param _Amount [number] Menge der Ware</p><p>-- @within Internal</p><p>-- @local</p><p>    if Logic.GetGoodCategoryForGoodType(_Good) ~= GoodCategories.GC_Resource and _Good ~= Goods.G_Gold then</p><p>        local buildings = GetPlayerEntities(_PlayerID,0);</p><p>        local goodAmount = _Amount;</p><p>        for i=1,#buildings do</p><p>            if Logic.IsBuilding(buildings[i]) == 1 and goodAmount > 0 then</p><p>                if Logic.GetBuildingProduct(buildings[i]) == _Good then</p><p>                    local goodAmountInBuilding = Logic.GetAmountOnOutStockByIndex(buildings[i],0);</p><p>                    for j=1,goodAmountInBuilding do</p><p>                        API.Bridge("Logic.RemoveGoodFromStock("..buildings[i]..",".._Good..",1)");</p><p>                        goodAmount = goodAmount -1;</p><p>                    end</p><p>                end</p><p>            end</p><p>        end</p><p>    else</p><p>        API.Bridge("AddGood(".._Good..","..(_Amount*(-1))..",".._PlayerID..")");</p><p>    end</p><p>-- Überschreibt die Spielfunktione, die interaktive Objekte steuern.</p><p>-- @within Internal</p><p>-- @local</p><p>    g_Interaction.ActiveObjectsOnScreen = g_Interaction.ActiveObjectsOnScreen or {};</p><p>    g_Interaction.ActiveObjects = g_Interaction.ActiveObjects or {};</p><p>    GUI_Interaction.InteractiveObjectUpdate = function()</p><p>        local PlayerID = GUI.GetPlayerID();</p><p>        if g_Interaction.ActiveObjects == nil then</p><p>            return;</p><p>        end</p><p>        for i = 1, #g_Interaction.ActiveObjects do</p><p>            local ObjectID = g_Interaction.ActiveObjects[i];</p><p>            local X, Y = GUI.GetEntityInfoScreenPosition(ObjectID);</p><p>            local ScreenSizeX, ScreenSizeY = GUI.GetScreenSize();</p><p>            if X ~= 0 and Y ~= 0 and X > -50 and Y > -50 and X < (ScreenSizeX + 50) and Y < (ScreenSizeY + 50) then</p><p>                if Inside(ObjectID, g_Interaction.ActiveObjectsOnScreen) == false then</p><p>                    table.insert(g_Interaction.ActiveObjectsOnScreen, ObjectID);</p><p>                end</p><p>            else</p><p>                for i = 1, #g_Interaction.ActiveObjectsOnScreen do</p><p>                    if g_Interaction.ActiveObjectsOnScreen[i] == ObjectID then</p><p>                        table.remove(g_Interaction.ActiveObjectsOnScreen, i);</p><p>                    end</p><p>                end</p><p>            end</p><p>        end</p><p>        for i = 1, #g_Interaction.ActiveObjectsOnScreen do</p><p>            local Widget = "/InGame/Root/Normal/InteractiveObjects/" .. i;</p><p>            if XGUIEng.IsWidgetExisting(Widget) == 1 then</p><p>                local ObjectID = g_Interaction.ActiveObjectsOnScreen[i];</p><p>                local EntityType = Logic.GetEntityType(ObjectID);</p><p>                local X, Y = GUI.GetEntityInfoScreenPosition(ObjectID);</p><p>                local WidgetSize = {XGUIEng.GetWidgetScreenSize(Widget)};</p><p>                local BaseCosts = {Logic.InteractiveObjectGetCosts(ObjectID)};</p><p>                local EffectiveCosts = {Logic.InteractiveObjectGetEffectiveCosts(ObjectID, PlayerID)};</p><p>                local IsAvailable = Logic.InteractiveObjectGetAvailability(ObjectID);</p><p>                local eType = Logic.GetEntityType(ObjectID);</p><p>                local entityName = Logic.GetEntityName(ObjectID);</p><p>                local eTypeName = Logic.GetEntityTypeName(eType);</p><p>                local Disable = false;</p><p>                XGUIEng.SetWidgetScreenPosition(Widget, X - (WidgetSize[1]/2), Y - (WidgetSize[2]/2));</p><p>                if BaseCosts[1] ~= nil and EffectiveCosts[1] == nil and IsAvailable == true then</p><p>                    Disable = true;</p><p>                end</p><p>                local HasSpace = Logic.InteractiveObjectHasPlayerEnoughSpaceForRewards(ObjectID, PlayerID);</p><p>                if HasSpace == false then</p><p>                    Disable = true;</p><p>                end</p><p>                if Disable == true then</p><p>                    XGUIEng.DisableButton(Widget, 1);</p><p>                else</p><p>                    XGUIEng.DisableButton(Widget, 0);</p><p>                end</p><p>                if GUI_Interaction.InteractiveObjectUpdateEx1 ~= nil then</p><p>                    GUI_Interaction.InteractiveObjectUpdateEx1(Widget, EntityType);</p><p>                end</p><p>                if IO[entityName] then</p><p>                    BundleInteractiveObjects.Local:SetIcon(Widget, IO[entityName].Texture);</p><p>                end</p><p>                XGUIEng.ShowWidget(Widget, 1);</p><p>            end</p><p>        end</p><p>        for k,v in pairs(QSB.IOList) do</p><p>            local pID = GUI.GetPlayerID();</p><p>            local eType = Logic.GetEntityType(GetID(v));</p><p>            local eTypeName = Logic.GetEntityTypeName(eType);</p><p>            if eTypeName and v ~= "" then</p><p>                if  not(string.find(eTypeName,"I_X_")) and not(string.find(eTypeName,"Mine"))</p><p>                and not(string.find(eTypeName,"B_Wel")) and not(string.find(eTypeName,"B_Cis")) then</p><p>                    if IO[v].State == 0 and IO[v].Distance ~= nil and IO[v].Distance > 0 then</p><p>                        local knights = {};</p><p>                        Logic.GetKnights(pID,knights);</p><p>                        local found = false;</p><p>                        for i=1,#knights do</p><p>                            if IsNear(knights[i], v, IO[v].Distance) then</p><p>                                found = true;</p><p>                                break;</p><p>                            end</p><p>                        end</p><p>                        if not IO[v].Used and not IO[v].Inactive then</p><p>                            if found then</p><p>                                ScriptCallback_ObjectInteraction(pID,GetID(v));</p><p>                            else</p><p>                                ScriptCallback_CloseObjectInteraction(pID,GetID(v));</p><p>                            end</p><p>                        else</p><p>                            ScriptCallback_CloseObjectInteraction(pID,GetID(v));</p><p>                        end</p><p>                    else</p><p>                        if not IO[v].Used and not IO[v].Inactive then</p><p>                            ScriptCallback_ObjectInteraction(pID,GetID(v));</p><p>                        else</p><p>                            ScriptCallback_CloseObjectInteraction(pID,GetID(v));</p><p>                        end</p><p>                    end</p><p>                end</p><p>            end</p><p>        end</p><p>        for i = #g_Interaction.ActiveObjectsOnScreen + 1, 2 do</p><p>            local Widget = "/InGame/Root/Normal/InteractiveObjects/" .. i;</p><p>            XGUIEng.ShowWidget(Widget, 0);</p><p>        end</p><p>    end</p><p>    GUI_Interaction.InteractiveObjectMouseOver_Orig_BundleInteractiveObjects = GUI_Interaction.InteractiveObjectMouseOver;</p><p>    GUI_Interaction.InteractiveObjectMouseOver = function()</p><p>        local PlayerID = GUI.GetPlayerID();</p><p>        local ButtonNumber = tonumber(XGUIEng.GetWidgetNameByID(XGUIEng.GetCurrentWidgetID()));</p><p>        local ObjectID = g_Interaction.ActiveObjectsOnScreen[ButtonNumber];</p><p>        local EntityType = Logic.GetEntityType(ObjectID);</p><p>        -- Führe für Minen und Brunnen Originalfunction aus</p><p>        if g_GameExtraNo > 0 then</p><p>            if EntityType == Entities.R_StoneMine or EntityType == Entities.R_IronMine or EntityType == Entities.B_Cistern then</p><p>                GUI_Interaction.InteractiveObjectMouseOver_Orig_BundleInteractiveObjects();</p><p>                return;</p><p>            end</p><p>        end</p><p>        -- Führe für Ruinen Originalfunktion aus, wenn Skriptname Nummer ist</p><p>        local EntityTypeName = Logic.GetEntityTypeName(EntityType);</p><p>        if string.find(EntityTypeName, "^I_X_") and tonumber(Logic.GetEntityName(ObjectID)) ~= nil then</p><p>            GUI_Interaction.InteractiveObjectMouseOver_Orig_BundleInteractiveObjects();</p><p>            return;</p><p>        end</p><p>        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();</p><p>        local Costs = {Logic.InteractiveObjectGetEffectiveCosts(ObjectID, PlayerID)};</p><p>        local IsAvailable = Logic.InteractiveObjectGetAvailability(ObjectID);</p><p>        local TooltipTextKey;</p><p>        local TooltipDisabledTextKey;</p><p>        local eName = Logic.GetEntityName(ObjectID);</p><p>        if IsAvailable == true then</p><p>           TooltipTextKey = "InteractiveObjectAvailable";</p><p>        else</p><p>           TooltipTextKey = "InteractiveObjectNotAvailable";</p><p>        end</p><p>        if Logic.InteractiveObjectHasPlayerEnoughSpaceForRewards(ObjectID, PlayerID) == false then</p><p>           TooltipDisabledTextKey = "InteractiveObjectAvailableReward";</p><p>        end</p><p>        local CheckSettlement;</p><p>        if Costs and Costs[1] and Logic.GetGoodCategoryForGoodType(Costs[1]) ~= GoodCategories.GC_Resource then</p><p>           CheckSettlement = true;</p><p>        end</p><p>        if IO[eName] and IO[eName].Used ~= true then</p><p>            local title;</p><p>            local text;</p><p>            if IO[eName].Title or IO[eName].Text then</p><p>                title = IO[eName].Title or "";</p><p>                text  = IO[eName].Text or "";</p><p>            end</p><p>            Costs = IO[eName].Costs;</p><p>            if Costs and Costs[1] and Logic.GetGoodCategoryForGoodType(Costs[1]) ~= GoodCategories.GC_Resource then</p><p>                CheckSettlement = true;</p><p>            end</p><p>            BundleInteractiveObjects.Local:TextCosts(title, text, nil, {Costs[1], Costs[2], Costs[3], Costs[4]}, CheckSettlement);</p><p>            return;</p><p>        end</p><p>    end</p><p>    GUI_Interaction.InteractiveObjectClicked_Orig_BundleInteractiveObjects = GUI_Interaction.InteractiveObjectClicked</p><p>    GUI_Interaction.InteractiveObjectClicked = function()</p><p>        local i = tonumber(XGUIEng.GetWidgetNameByID(XGUIEng.GetCurrentWidgetID()));</p><p>        local lang = Network.GetDesiredLanguage();</p><p>        local eID = g_Interaction.ActiveObjectsOnScreen[i];</p><p>        local pID = GUI.GetPlayerID();</p><p>        local EntityType = Logic.GetEntityType(eID);</p><p>        -- Führe für Minen und Brunnen Originalfunction aus</p><p>        if g_GameExtraNo > 0 then</p><p>            if EntityType == Entities.R_StoneMine or EntityType == Entities.R_IronMine or EntityType == Entities.B_Cistern then</p><p>                GUI_Interaction.InteractiveObjectClicked_Orig_BundleInteractiveObjects();</p><p>                return;</p><p>            end</p><p>        end</p><p>        -- Führe für Ruinen Originalfunktion aus, wenn Skriptname Nummer ist</p><p>        local EntityTypeName = Logic.GetEntityTypeName(EntityType);</p><p>        if string.find(EntityTypeName, "^I_X_") and tonumber(Logic.GetEntityName(eID)) ~= nil then</p><p>            GUI_Interaction.InteractiveObjectClicked_Orig_BundleInteractiveObjects();</p><p>            return;</p><p>        end</p><p>        for k,v in pairs(IO)do</p><p>            if eID == GetID(k)then</p><p>                local ActivationSound = "menu_left_prestige";</p><p>                if v.ActivationSound then</p><p>                    ActivationSound = v.ActivationSound;</p><p>                end</p><p>                local Reward = {};</p><p>                if IO[k].Reward and IO[k].Reward[1] ~= nil then</p><p>                    table.insert(Reward,IO[k].Reward[1]);</p><p>                    table.insert(Reward,IO[k].Reward[2]);</p><p>                end</p><p>                local space = true;</p><p>                if  Reward[2] and type(Reward[2]) == "number" and Reward[1] ~= Goods.G_Gold</p><p>                and Logic.GetGoodCategoryForGoodType(Reward[1]) == GoodCategories.GC_Resource then</p><p>                    local freeSpace = Logic.GetPlayerUnreservedStorehouseSpace(pID);</p><p>                    if freeSpace < Reward[2] then</p><p>                        space = false;</p><p>                    end</p><p>                end</p><p>                local CheckSettlement;</p><p>                if IO[k].Costs and IO[k].Costs[1] then</p><p>                    if Logic.GetGoodCategoryForGoodType(IO[k].Costs[1]) ~= GoodCategories.GC_Resource then</p><p>                        CheckSettlement = true;</p><p>                    end</p><p>                    -- space</p><p>                    if space == false then</p><p>                        local MessageText = XGUIEng.GetStringTableText("Feedback_TextLines/TextLine_MerchantStorehouseSpace")</p><p>                        Message(MessageText);</p><p>                        return;</p><p>                    end</p><p>                    local Costs = IO[k].Costs;</p><p>                    local CanNotBuyString = XGUIEng.GetStringTableText("Feedback_TextLines/TextLine_NotEnough_Resources");</p><p>                    local CanBuyBoolean = true;</p><p>                    -- costs 1</p><p>                    if Costs[1] then</p><p>                        CanBuyBoolean = CanBuyBoolean and BundleInteractiveObjects.Local:CanBeBought(pID, Costs[1], Costs[2]);</p><p>                    end</p><p>                    -- costs 2</p><p>                    if Costs[3] then</p><p>                        CanBuyBoolean = CanBuyBoolean and BundleInteractiveObjects.Local:CanBeBought(pID, Costs[3], Costs[4]);</p><p>                    end</p><p>                    -- check condition</p><p>                    if not IO[k].ConditionFullfilled then</p><p>                        if IO[k].ConditionUnfulfilled and IO[k].ConditionUnfulfilled ~= "" then</p><p>                            Message(IO[k].ConditionUnfulfilled);</p><p>                        end</p><p>                        return;</p><p>                    end</p><p>                    -- check opener</p><p>                    if IO[k].Opener then</p><p>                        if Logic.GetDistanceBetweenEntities(GetID(IO[k].Opener),GetID(k)) > IO[k].Distance then</p><p>                            if IO[k].WrongKnight and IO[k].WrongKnight ~= "" then</p><p>                                Message(IO[k].WrongKnight);</p><p>                            end</p><p>                            return;</p><p>                        end</p><p>                    end</p><p>                    if CanBuyBoolean == true then</p><p>                        if Costs[1] ~= nil then</p><p>                            BundleInteractiveObjects.Local:BuyObject(pID, Costs[1], Costs[2]);</p><p>                        end</p><p>                        if Costs[3] ~= nil then</p><p>                            BundleInteractiveObjects.Local:BuyObject(pID, Costs[3], Costs[4]);</p><p>                        end</p><p>                        -- reward</p><p>                        if #Reward > 0 then</p><p>                            GUI.SendScriptCommand("GameCallback_ExecuteCustomObjectReward("..pID..",'"..k.."',"..Reward[1]..","..Reward[2]..")");</p><p>                        end</p><p>                        Play2DSound(pID, ActivationSound);</p><p>                        GUI.SendScriptCommand("GameCallback_OnObjectInteraction("..eID..","..pID..")");</p><p>                    else</p><p>                        Message(CanNotBuyString)</p><p>                    end</p><p>                else</p><p>                    -- space</p><p>                    if space == false then</p><p>                        local MessageText = XGUIEng.GetStringTableText("Feedback_TextLines/TextLine_MerchantStorehouseSpace")</p><p>                        Message(MessageText);</p><p>                        return;</p><p>                    end</p><p>                    -- check condition</p><p>                    if not IO[k].ConditionFullfilled then</p><p>                        if IO[k].ConditionUnfulfilled and IO[k].ConditionUnfulfilled ~= "" then</p><p>                            Message(IO[k].ConditionUnfulfilled);</p><p>                        end</p><p>                        return;</p><p>                    end</p><p>                    -- check opener</p><p>                    if IO[k].Opener then</p><p>                        if Logic.GetDistanceBetweenEntities(GetID(IO[k].Opener),GetID(k)) > IO[k].Distance then</p><p>                            if IO[k].WrongKnight and IO[k].WrongKnight ~= "" then</p><p>                                Message(IO[k].WrongKnight);</p><p>                            end</p><p>                            return;</p><p>                        end</p><p>                    end</p><p>                    -- reward</p><p>                    if #Reward > 0 then</p><p>                        GUI.SendScriptCommand("GameCallback_ExecuteCustomObjectReward("..pID..",'"..k.."',"..Reward[1]..","..Reward[2]..")");</p><p>                    end</p><p>                    Play2DSound(pID, ActivationSound);</p><p>                    GUI.SendScriptCommand("GameCallback_OnObjectInteraction("..eID..","..pID..")");</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>    GUI_Interaction.DisplayQuestObjective_Orig_BundleInteractiveObjects = GUI_Interaction.DisplayQuestObjective</p><p>    GUI_Interaction.DisplayQuestObjective = function(_QuestIndex, _MessageKey)</p><p>        local lang = Network.GetDesiredLanguage();</p><p>        if lang ~= "de" then lang = "en" end</p><p>        local QuestIndexTemp = tonumber(_QuestIndex);</p><p>        if QuestIndexTemp then</p><p>            _QuestIndex = QuestIndexTemp;</p><p>        end</p><p>        local Quest, QuestType = GUI_Interaction.GetPotentialSubQuestAndType(_QuestIndex);</p><p>        local QuestObjectivesPath = "/InGame/Root/Normal/AlignBottomLeft/Message/QuestObjectives";</p><p>        XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomLeft/Message/QuestObjectives", 0);</p><p>        local QuestObjectiveContainer;</p><p>        local QuestTypeCaption;</p><p>        local ParentQuest = Quests[_QuestIndex];</p><p>        local ParentQuestIdentifier;</p><p>        if ParentQuest ~= nil</p><p>        and type(ParentQuest) == "table" then</p><p>            ParentQuestIdentifier = ParentQuest.Identifier;</p><p>        end</p><p>        local HookTable = {};</p><p>        g_CurrentDisplayedQuestID = _QuestIndex;</p><p>        if QuestType == Objective.Object then</p><p>            QuestObjectiveContainer = QuestObjectivesPath .. "/List"</p><p>            QuestTypeCaption = Wrapped_GetStringTableText(_QuestIndex, "UI_Texts/QuestInteraction")</p><p>            local ObjectList = {}</p><p>            for i = 1, Quest.Objectives[1].Data[0] do</p><p>                local ObjectType</p><p>                if Logic.IsEntityDestroyed(Quest.Objectives[1].Data[i]) then</p><p>                    ObjectType = g_Interaction.SavedQuestEntityTypes[_QuestIndex][i]</p><p>                else</p><p>                    ObjectType = Logic.GetEntityType(GetEntityId(Quest.Objectives[1].Data[i]))</p><p>                end</p><p>                local ObjectEntityName = Logic.GetEntityName(Quest.Objectives[1].Data[i]);</p><p>                local ObjectName = ""</p><p>                if ObjectType ~= 0 then</p><p>                    local ObjectTypeName = Logic.GetEntityTypeName(ObjectType)</p><p>                    ObjectName = Wrapped_GetStringTableText(_QuestIndex, "Names/" .. ObjectTypeName)</p><p>                    if ObjectName == "" then</p><p>                        ObjectName = Wrapped_GetStringTableText(_QuestIndex, "UI_ObjectNames/" .. ObjectTypeName)</p><p>                    end</p><p>                    if ObjectName == "" then</p><p>                        ObjectName = BundleInteractiveObjects.Local.Data.IOCustomNames[ObjectTypeName];</p><p>                        if type(ObjectName) == "table" then</p><p>                            local lang = Network.GetDesiredLanguage();</p><p>                            lang = (lang == "de" and "de") or "en";</p><p>                            ObjectName = ObjectName[lang];</p><p>                        end</p><p>                    end</p><p>                    if ObjectName == "" then</p><p>                        ObjectName = BundleInteractiveObjects.Local.Data.IOCustomNames[ObjectEntityName];</p><p>                        if type(ObjectName) == "table" then</p><p>                            local lang = Network.GetDesiredLanguage();</p><p>                            lang = (lang == "de" and "de") or "en";</p><p>                            ObjectName = ObjectName[lang];</p><p>                        end</p><p>                    end</p><p>                    if ObjectName == "" then</p><p>                        ObjectName = "Debug: ObjectName missing for " .. ObjectTypeName</p><p>                    end</p><p>                end</p><p>                table.insert(ObjectList, ObjectName)</p><p>            end</p><p>            for i = 1, 4 do</p><p>                local String = ObjectList[i]</p><p>                if String == nil then</p><p>                    String = ""</p><p>                end</p><p>                XGUIEng.SetText(QuestObjectiveContainer .. "/Entry" .. i, "{center}" .. String)</p><p>            end</p><p>            SetIcon(QuestObjectiveContainer .. "/QuestTypeIcon",{14, 10});</p><p>            XGUIEng.SetText(QuestObjectiveContainer.."/Caption","{center}"..QuestTypeCaption);</p><p>            XGUIEng.ShowWidget(QuestObjectiveContainer, 1);</p><p>        else</p><p>            GUI_Interaction.DisplayQuestObjective_Orig_BundleInteractiveObjects(_QuestIndex, _MessageKey);</p><p>        end</p><p>    end</p><p>-- Setzt den Kostentooltip des aktuellen Widgets.</p><p>-- @param _Title [string] Titel des Tooltip</p><p>-- @param _Text [string] Text des Tooltip</p><p>-- @param _DisabledText [string] Textzusatz wenn inaktiv</p><p>-- @param _Costs [table] Kostentabelle</p><p>-- @param _InSettlement [boolean] Kosten in Siedlung suchen</p><p>-- @within Internal</p><p>-- @local</p><p>    local TooltipContainerPath = "/InGame/Root/Normal/TooltipBuy"</p><p>    local TooltipContainer = XGUIEng.GetWidgetID(TooltipContainerPath)</p><p>    local TooltipNameWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Name")</p><p>    local TooltipDescriptionWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Text")</p><p>    local TooltipBGWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/BG")</p><p>    local TooltipFadeInContainer = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn")</p><p>    local TooltipCostsContainer = XGUIEng.GetWidgetID(TooltipContainerPath .. "/Costs")</p><p>    local PositionWidget = XGUIEng.GetCurrentWidgetID()</p><p>    GUI_Tooltip.ResizeBG(TooltipBGWidget, TooltipDescriptionWidget)</p><p>    GUI_Tooltip.SetCosts(TooltipCostsContainer, _Costs, _InSettlement)</p><p>    local TooltipContainerSizeWidgets = {TooltipContainer, TooltipCostsContainer, TooltipBGWidget}</p><p>    GUI_Tooltip.SetPosition(TooltipContainer, TooltipContainerSizeWidgets, PositionWidget, nil, true)</p><p>    GUI_Tooltip.OrderTooltip(TooltipContainerSizeWidgets, TooltipFadeInContainer, TooltipCostsContainer, PositionWidget, TooltipBGWidget)</p><p>    GUI_Tooltip.FadeInTooltip(TooltipFadeInContainer)</p><p>    _DisabledText = _DisabledText or "";</p><p>    local disabled = ""</p><p>    if XGUIEng.IsButtonDisabled(PositionWidget) == 1 and _DisabledText ~= "" and _Text ~= "" then</p><p>        disabled = disabled .. "{cr}{@color:255,32,32,255}" .. _DisabledText</p><p>    end</p><p>    XGUIEng.SetText(TooltipNameWidget, "{center}" .. _Title)</p><p>    XGUIEng.SetText(TooltipDescriptionWidget, _Text .. disabled)</p><p>    local Height = XGUIEng.GetTextHeight(TooltipDescriptionWidget, true)</p><p>    local W, H = XGUIEng.GetWidgetSize(TooltipDescriptionWidget)</p><p>    XGUIEng.SetWidgetSize(TooltipDescriptionWidget, W, Height)</p><p>-- Ändert die Textur eines Icons des aktuellen Widget.</p><p>-- TODO: Eigene Matrizen funktionieren nicht - Grund unbekannt.</p><p>-- @param _Widget [string|number] Icon Widget</p><p>-- @param _Icon [string|table] Icon Textur</p><p>-- @within Internal</p><p>-- @local</p><p>    if type(_Icon) == "table" then</p><p>        if type(_Icon[3]) == "string" then</p><p>            local ButtonState = 1;</p><p>            if XGUIEng.IsButton(_Widget) == 1 then</p><p>                ButtonState = 7;</p><p>            end</p><p>            local u0, u1, v0, v1;</p><p>            u0 = (_Icon[1] - 1) * 64;</p><p>            v0 = (_Icon[2] - 1) * 64;</p><p>            u1 = (_Icon[1]) * 64;</p><p>            v1 = (_Icon[2]) * 64;</p><p>            XGUIEng.SetMaterialAlpha(_Widget, ButtonState, 255);</p><p>            XGUIEng.SetMaterialTexture(_Widget, ButtonState, _Icon[3].. "big.png");</p><p>            XGUIEng.SetMaterialUV(_Widget, ButtonState, u0, v0, u1, v1);</p><p>        else</p><p>            SetIcon(_Widget, _Icon);</p><p>        end</p><p>    else</p><p>        local screenSize = {GUI.GetScreenSize()};</p><p>        local Scale = 330;</p><p>        if screenSize[2] >= 800 then</p><p>            Scale = 260;</p><p>        end</p><p>        if screenSize[2] >= 1000 then</p><p>            Scale = 210;</p><p>        end</p><p>        XGUIEng.SetMaterialAlpha(_Widget, 1, 255);</p><p>        XGUIEng.SetMaterialTexture(_Widget, 1, _file);</p><p>        XGUIEng.SetMaterialUV(_Widget, 1, 0, 0, Scale, Scale);</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der Spieler muss bis zu 4 interaktive Objekte benutzen.</p><p>-- @param _ScriptName1 Erstes Objekt</p><p>-- @param _ScriptName2 (optional) Zweites Objekt</p><p>-- @param _ScriptName3 (optional) Drittes Objekt</p><p>-- @param _ScriptName4 (optional) Viertes Objekt</p><p>-- @within Goal</p><p>    return b_Goal_ActivateSeveralObjects:new(...);</p><p>Goal_ActivateSeveralObjects</p><p>    Name = "Goal_ActivateSeveralObjects",</p><p>    Description = {</p><p>        en = "Goal: Activate an interactive object",</p><p>        de = "Ziel: Aktiviere ein interaktives Objekt",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Object name 1", de = "Skriptname 1" },</p><p>        { ParameterType.ScriptName, en = "Object name 2", de = "Skriptname 2" },</p><p>        { ParameterType.ScriptName, en = "Object name 3", de = "Skriptname 3" },</p><p>        { ParameterType.ScriptName, en = "Object name 4", de = "Skriptname 4" },</p><p>    },</p><p>    ScriptNames = {};</p><p>    return {Objective.Object, { unpack(self.ScriptNames) } }</p><p>    if _Index == 0 then</p><p>        assert(_Parameter ~= nil and _Parameter ~= "", "Goal_ActivateSeveralObjects: At least one IO needed!");</p><p>    end</p><p>    if _Parameter ~= nil and _Parameter ~= "" then</p><p>        table.insert(self.ScriptNames, _Parameter);</p><p>    end</p><p>    return "Quest_Object_Activate"</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundleinterfaceapperance.lua.html">
            <div class='doclink'>
                <div>BundleInterfaceApperance</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia BundleInterfaceApperance                                     # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Dieses Bundle bietet dem Nutzer Funktionen zur Manipulation der Oberfläche</p><p>-- des Spiels. Es gibt Funktionen zum Ausblenden einiger Buttons und Menüs und</p><p>-- die Möglichkeit eigene Texte in Tooltips und eigene Grafiken für Widgets</p><p>-- zu setzen.</p><p>-- <p><a href="#API.InterfaceHideBuildMenu">Interface-Steuerung</a></p></p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Graut die Minimap aus oder macht sie wieder verwendbar.</p><p>-- <p><b>Hinweis:</b> Diese Änderung bleibt auch nach dem Laden eines Spielstandes</p><p>-- aktiv und muss explizit zurückgenommen werden!</p></p><p>-- @param _Flag [boolean] Widget versteckt</p><p>-- @within Anwenderfunktionen</p><p>function API.InterfaceHideMinimap(_Flag)</p><p>    if not GUI then</p><p>        Logic.ExecuteInLuaLocalState("API.InterfaceHideMinimap(" ..tostring(_Flag).. ")");</p><p>        return;</p><p>    end</p><p>    BundleInterfaceApperance.Local:HideInterfaceButton(</p><p>        "/InGame/Root/Normal/AlignBottomRight/MapFrame/Minimap/MinimapOverlay",</p><p>        _Flag</p><p>    );</p><p>    BundleInterfaceApperance.Local:HideInterfaceButton(</p><p>        "/InGame/Root/Normal/AlignBottomRight/MapFrame/Minimap/MinimapTerrain",</p><p>        _Flag</p><p>    );</p><p>-- Versteckt den Umschaltknopf der Minimap oder blendet ihn ein.</p><p>-- <p><b>Hinweis:</b> Diese Änderung bleibt auch nach dem Laden eines Spielstandes</p><p>-- aktiv und muss explizit zurückgenommen werden!</p></p><p>-- @param _Flag [boolean] Widget versteckt</p><p>-- @within Anwenderfunktionen</p><p>function API.InterfaceHideToggleMinimap(_Flag)</p><p>    if not GUI then</p><p>        Logic.ExecuteInLuaLocalState("API.InterfaceHideToggleMinimap(" ..tostring(_Flag).. ")");</p><p>        return;</p><p>    end</p><p>    BundleInterfaceApperance.Local:HideInterfaceButton(</p><p>        "/InGame/Root/Normal/AlignBottomRight/MapFrame/MinimapButton",</p><p>        _Flag</p><p>    );</p><p>-- Versteckt den Button des Diplomatiemenü oder blendet ihn ein.</p><p>-- <p><b>Hinweis:</b> Diese Änderung bleibt auch nach dem Laden eines Spielstandes</p><p>-- aktiv und muss explizit zurückgenommen werden!</p></p><p>-- @param _Flag [boolean] Widget versteckt</p><p>-- @within Anwenderfunktionen</p><p>function API.InterfaceHideDiplomacyMenu(_Flag)</p><p>    if not GUI then</p><p>        Logic.ExecuteInLuaLocalState("API.InterfaceHideDiplomacyMenu(" ..tostring(_Flag).. ")");</p><p>        return;</p><p>    end</p><p>    BundleInterfaceApperance.Local:HideInterfaceButton(</p><p>        "/InGame/Root/Normal/AlignBottomRight/MapFrame/DiplomacyMenuButton",</p><p>        _Flag</p><p>    );</p><p>-- Versteckt den Button des Produktionsmenü oder blendet ihn ein.</p><p>-- <p><b>Hinweis:</b> Diese Änderung bleibt auch nach dem Laden eines Spielstandes</p><p>-- aktiv und muss explizit zurückgenommen werden!</p></p><p>-- @param _Flag [boolean] Widget versteckt</p><p>-- @within Anwenderfunktionen</p><p>function API.InterfaceHideProductionMenu(_Flag)</p><p>    if not GUI then</p><p>        Logic.ExecuteInLuaLocalState("API.InterfaceHideProductionMenu(" ..tostring(_Flag).. ")");</p><p>        return;</p><p>    end</p><p>    BundleInterfaceApperance.Local:HideInterfaceButton(</p><p>        "/InGame/Root/Normal/AlignBottomRight/MapFrame/ProductionMenuButton",</p><p>        _Flag</p><p>    );</p><p>-- Versteckt den Button des Wettermenüs oder blendet ihn ein.</p><p>-- <p><b>Hinweis:</b> Diese Änderung bleibt auch nach dem Laden eines Spielstandes</p><p>-- aktiv und muss explizit zurückgenommen werden!</p></p><p>-- @param _Flag [boolean] Widget versteckt</p><p>-- @within Anwenderfunktionen</p><p>function API.InterfaceHideWeatherMenu(_Flag)</p><p>    if not GUI then</p><p>        Logic.ExecuteInLuaLocalState("API.InterfaceHideWeatherMenu(" ..tostring(_Flag).. ")");</p><p>        return;</p><p>    end</p><p>    BundleInterfaceApperance.Local:HideInterfaceButton(</p><p>        "/InGame/Root/Normal/AlignBottomRight/MapFrame/WeatherMenuButton",</p><p>        _Flag</p><p>    );</p><p>-- Versteckt den Button zum Territorienkauf oder blendet ihn ein.</p><p>-- <p><b>Hinweis:</b> Diese Änderung bleibt auch nach dem Laden eines Spielstandes</p><p>-- aktiv und muss explizit zurückgenommen werden!</p></p><p>-- @param _Flag [boolean] Widget versteckt</p><p>-- @within Anwenderfunktionen</p><p>function API.InterfaceHideBuyTerritory(_Flag)</p><p>    if not GUI then</p><p>        Logic.ExecuteInLuaLocalState("API.InterfaceHideBuyTerritory(" ..tostring(_Flag).. ")");</p><p>        return;</p><p>    end</p><p>    BundleInterfaceApperance.Local:HideInterfaceButton(</p><p>        "/InGame/Root/Normal/AlignBottomRight/DialogButtons/Knight/ClaimTerritory",</p><p>        _Flag</p><p>    );</p><p>-- Versteckt den Button der Heldenfähigkeit oder blendet ihn ein.</p><p>-- <p><b>Hinweis:</b> Diese Änderung bleibt auch nach dem Laden eines Spielstandes</p><p>-- aktiv und muss explizit zurückgenommen werden!</p></p><p>-- @param _Flag [boolean] Widget versteckt</p><p>-- @within Anwenderfunktionen</p><p>function API.InterfaceHideKnightAbility(_Flag)</p><p>    if not GUI then</p><p>        Logic.ExecuteInLuaLocalState("API.InterfaceHideKnightAbility(" ..tostring(_Flag).. ")");</p><p>        return;</p><p>    end</p><p>    BundleInterfaceApperance.Local:HideInterfaceButton(</p><p>        "/InGame/Root/Normal/AlignBottomRight/DialogButtons/Knight/StartAbilityProgress",</p><p>        _Flag</p><p>    );</p><p>    BundleInterfaceApperance.Local:HideInterfaceButton(</p><p>        "/InGame/Root/Normal/AlignBottomRight/DialogButtons/Knight/StartAbility",</p><p>        _Flag</p><p>    );</p><p>-- Versteckt den Button zur Heldenselektion oder blendet ihn ein.</p><p>-- <p><b>Hinweis:</b> Diese Änderung bleibt auch nach dem Laden eines Spielstandes</p><p>-- aktiv und muss explizit zurückgenommen werden!</p></p><p>-- @param _Flag [boolean] Widget versteckt</p><p>-- @within Anwenderfunktionen</p><p>function API.InterfaceHideKnightButton(_Flag)</p><p>    if not GUI then</p><p>        Logic.ExecuteInLuaLocalState("API.InterfaceHideKnightButton(" ..tostring(_Flag).. ")");</p><p>        return;</p><p>    end</p><p>    local KnightID = Logic.GetKnightID(GUI.GetPlayerID());</p><p>    if _Flag == true then</p><p>        GUI.SendScriptCommand("Logic.SetEntitySelectableFlag("..KnightID..", 0)");</p><p>        GUI.DeselectEntity(KnightID);</p><p>    else</p><p>        GUI.SendScriptCommand("Logic.SetEntitySelectableFlag("..KnightID..", 1)");</p><p>    end</p><p>    BundleInterfaceApperance.Local:HideInterfaceButton(</p><p>        "/InGame/Root/Normal/AlignBottomRight/MapFrame/KnightButtonProgress",</p><p>        _Flag</p><p>    );</p><p>    BundleInterfaceApperance.Local:HideInterfaceButton(</p><p>        "/InGame/Root/Normal/AlignBottomRight/MapFrame/KnightButton",</p><p>        _Flag</p><p>    );</p><p>-- Versteckt den Button zur Selektion des Militärs oder blendet ihn ein.</p><p>-- <p><b>Hinweis:</b> Diese Änderung bleibt auch nach dem Laden eines Spielstandes</p><p>-- aktiv und muss explizit zurückgenommen werden!</p></p><p>-- @param _Flag [boolean] Widget versteckt</p><p>-- @within Anwenderfunktionen</p><p>function API.InterfaceHideSelectionButton(_Flag)</p><p>    if not GUI then</p><p>        Logic.ExecuteInLuaLocalState("API.InterfaceHideSelectionButton(" ..tostring(_Flag).. ")");</p><p>        return;</p><p>    end</p><p>    API.InterfaceHideKnightButton(_Flag);</p><p>    GUI.ClearSelection();</p><p>    BundleInterfaceApperance.Local:HideInterfaceButton(</p><p>        "/InGame/Root/Normal/AlignBottomRight/MapFrame/BattalionButton",</p><p>        _Flag</p><p>    );</p><p>-- Versteckt das Baumenü oder blendet es ein.</p><p>-- <p><b>Hinweis:</b> Diese Änderung bleibt auch nach dem Laden eines Spielstandes</p><p>-- aktiv und muss explizit zurückgenommen werden!</p></p><p>-- @param _Flag [boolean] Widget versteckt</p><p>-- @within Anwenderfunktionen</p><p>function API.InterfaceHideBuildMenu(_Flag)</p><p>    if not GUI then</p><p>        Logic.ExecuteInLuaLocalState("API.InterfaceHideBuildMenu(" ..tostring(_Flag).. ")");</p><p>        return;</p><p>    end</p><p>    BundleInterfaceApperance.Local:HideInterfaceButton(</p><p>        "/InGame/Root/Normal/AlignBottomRight/BuildMenu",</p><p>        _Flag</p><p>    );</p><p>-- Setzt eine Grafik als Bild für einen Icon oder einen Button.</p><p>-- Die Größe des Bildes ist auf 200x200 Pixel festgelegt. Es kann an jedem</p><p>-- beliebigen Ort im interen Verzeichnis oder auf der Festplatte liegen. Es</p><p>-- muss jedoch immer der korrekte Pfad angegeben werden.</p><p>-- <p><b>Hinweis:</b> Es kann vorkommen, dass das Bild nicht genau da ist, wo es</p><p>-- sein soll, sondern seine Position, je nach Auflösung, um ein paar Pixel</p><p>-- unterschiedlich ist.</p></p><p>-- @param _widget [string|number] Widgetpfad oder ID</p><p>-- @param _file [string] Pfad zur Datei</p><p>-- @within Anwenderfunktionen</p><p>function API.InterfaceSetTexture(_widget, _file)</p><p>    if not GUI then</p><p>        return;</p><p>    end</p><p>    BundleInterfaceApperance.Local:SetTexture(_widget, _file)</p><p>-- Setzt einen Icon aus einer benutzerdefinierten Icon Matrix.</p><p>-- Dabei müssen die Quellen nach gui_768, gui_920 und gui_1080 in der</p><p>-- entsprechenden Größe gepackt werden. Die Ordner liegen in graphics/textures.</p><p>-- Jede Map muss einen eigenen eindeutigen Namen für jede Grafik verwenden.</p><p>-- <u>Größen:</u></p><p>-- Die Gesamtgröße ergibt sich aus der Anzahl der Buttons und der Pixelbreite</p><p>-- für die jeweilige Grö0e. z.B. 64 Buttons -> Größe * 8 x Größe * 8</p><p>-- <ul></p><p>-- <li>768: 41x41</li></p><p>-- <li>960: 52x52</li></p><p>-- <li>1200: 64x64</li></p><p>-- </ul></p><p>-- <u>Namenskonvention:</u></p><p>-- Die Namenskonvention wird durch das Spiel vorgegeben. Je nach Größe sind</p><p>-- die Namen der Matrizen erweitert mit .png, big.png und verybig.png. Du</p><p>-- gibst also niemals die Dateiendung mit an!</p><p>-- <ul></p><p>-- <li>Für normale Icons: _Name .. .png</li></p><p>-- <li>Für große Icons: _Name .. big.png</li></p><p>-- <li>Für riesige Icons: _Name .. verybig.png</li></p><p>-- </ul></p><p>-- @param _WidgetID [string|number] Widgetpfad oder ID</p><p>-- @param _Coordinates [table] Koordinaten</p><p>-- @param _Size [number] Größe des Icon</p><p>-- @param _Name [string] Name der Icon Matrix</p><p>-- @within Anwenderfunktionen</p><p>function API.InterfaceSetIcon(_WidgetID, _Coordinates, _Size, _Name)</p><p>    if not GUI then</p><p>        return;</p><p>    end</p><p>    BundleInterfaceApperance.Local:SetIcon(_WidgetID, _Coordinates, _Size, _Name)</p><p>-- Ändert den aktuellen Tooltip mit der Beschreibung.</p><p>-- <p><b>Alias:</b> UserSetTextNormal</p></p><p>-- Die Funtion ermittelt das aktuelle GUI Widget und ändert den Text des</p><p>-- Tooltip. Dazu muss die Funktion innerhalb der Mouseover-Funktion eines</p><p>-- Buttons oder Widgets mit Tooltip aufgerufen werden.</p><p>-- Die Funktion kann auch mit deutsch/english lokalisierten Tabellen als</p><p>-- Text gefüttert werden. In diesem Fall wird der deutsche Text genommen,</p><p>-- wenn es sich um eine deutsche Spielversion handelt. Andernfalls wird</p><p>-- immer der englische Text verwendet.</p><p>-- @param _title [string] Titel des Tooltip</p><p>-- @param _text [string] Text des Tooltip</p><p>-- @param _disabledText [string] Textzusatz wenn inaktiv</p><p>-- @within Anwenderfunktionen</p><p>function API.InterfaceSetTooltipNormal(_title, _text, _disabledText)</p><p>    if not GUI then</p><p>        return;</p><p>    end</p><p>    BundleInterfaceApperance.Local:TextNormal(_title, _text, _disabledText);</p><p>-- Ändert den aktuellen Tooltip mit der Beschreibung und den Kosten.</p><p>-- <p><b>Alias:</b> UserSetTextBuy</p></p><p>-- @see API.InterfaceSetTooltipNormal</p><p>-- @param _title [string] Titel des Tooltip</p><p>-- @param _text [string] Text des Tooltip</p><p>-- @param _disabledText [string] Textzusatz wenn inaktiv</p><p>-- @param _costs [table] Kostentabelle</p><p>-- @param _inSettlement [boolean] Kosten in Siedlung suchen</p><p>-- @within Anwenderfunktionen</p><p>function API.InterfaceSetTooltipCosts(_title,_text,_disabledText,_costs,_inSettlement)</p><p>    if not GUI then</p><p>        return;</p><p>    end</p><p>    BundleInterfaceApperance.Local:TextCosts(_title,_text,_disabledText,_costs,_inSettlement);</p><p>-- Gibt den Namen des Territoriums zurück.</p><p>-- <p><b>Alias:</b> GetTerritoryName</p></p><p>-- @param _TerritoryID [number] ID des Territoriums</p><p>-- @return [string]  Name des Territorium</p><p>-- @within Anwenderfunktionen</p><p>function API.InterfaceGetTerritoryName(_TerritoryID)</p><p>    local Name = Logic.GetTerritoryName(_TerritoryID);</p><p>    local MapType = Framework.GetCurrentMapTypeAndCampaignName();</p><p>    if MapType == 1 or MapType == 3 then</p><p>        return Name;</p><p>    end</p><p>    local MapName = Framework.GetCurrentMapName();</p><p>    local StringTable = "Map_" .. MapName;</p><p>    local TerritoryName = string.gsub(Name, " ","");</p><p>    TerritoryName = XGUIEng.GetStringTableText(StringTable .. "/Territory_" .. TerritoryName);</p><p>    if TerritoryName == "" then</p><p>        TerritoryName = Name .. "(key?)";</p><p>    end</p><p>    return TerritoryName;</p><p>-- Gibt den Namen des Spielers zurück.</p><p>-- <p><b>Alias:</b> GetPlayerName</p></p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @return [string]  Name des Territorium</p><p>-- @within Anwenderfunktionen</p><p>function API.InterfaceGetPlayerName(_PlayerID)</p><p>    local PlayerName = Logic.GetPlayerName(_PlayerID);</p><p>    local name = QSB.PlayerNames[_PlayerID];</p><p>    if name ~= nil and name ~= "" then</p><p>        PlayerName = name;</p><p>    end</p><p>    local MapType = Framework.GetCurrentMapTypeAndCampaignName();</p><p>    local MutliplayerMode = Framework.GetMultiplayerMapMode(Framework.GetCurrentMapName(), MapType);</p><p>    if MutliplayerMode > 0 then</p><p>        return PlayerName;</p><p>    end</p><p>    if MapType == 1 or MapType == 3 then</p><p>        local PlayerNameTmp, PlayerHeadTmp, PlayerAITmp = Framework.GetPlayerInfo(_PlayerID);</p><p>        if PlayerName ~= "" then</p><p>            return PlayerName;</p><p>        end</p><p>        return PlayerNameTmp;</p><p>    end</p><p>-- Gibt dem Spieler einen neuen Namen.</p><p>-- <p><b>Alias:</b> SetPlayerName</p></p><p>-- @param _playerID [number] ID des Spielers</p><p>-- @param _name [string] Name des Spielers</p><p>-- @return [string]  Name des Territorium</p><p>-- @within Anwenderfunktionen</p><p>function API.InterfaceSetPlayerName(_playerID,_name)</p><p>    assert(type(_playerID) == "number");</p><p>    assert(type(_name) == "string");</p><p>    if not GUI then</p><p>        Logic.ExecuteInLuaLocalState("SetPlayerName(".._playerID..",'".._name.."')");</p><p>    else</p><p>        GUI_MissionStatistic.PlayerNames[_playerID] = _name;</p><p>        GUI.SendScriptCommand("QSB.PlayerNames[".._playerID.."] = '".._name.."'");</p><p>    end</p><p>    QSB.PlayerNames[_playerID] = _name;</p><p>-- Setzt zu Spielbeginn eine andere Spielerfarbe.</p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @param _Color [number] Spielerfarbe</p><p>-- @param _Logo [number] Logo (optional)</p><p>-- @param _Pattern [number] Pattern (optional)</p><p>-- @return [string]  Name des Territorium</p><p>-- @within Anwenderfunktionen</p><p>function API.InterfaceSetPlayerColor(_PlayerID, _Color, _Logo, _Pattern)</p><p>    if GUI then</p><p>        return;</p><p>    end</p><p>    g_ColorIndex["ExtraColor1"] = 16;</p><p>    g_ColorIndex["ExtraColor2"] = 17;</p><p>    local Type    = type(_Color);</p><p>    local Col     = (type(_Color) == "string" and g_ColorIndex[_Color]) or _Color;</p><p>    local Logo    = _Logo or -1;</p><p>    local Pattern = _Pattern or -1;</p><p>    StartSimpleJobEx( function(Col, _PlayerID, _Logo, _Pattern)</p><p>        Logic.PlayerSetPlayerColor(_PlayerID, Col, _Logo, _Pattern);</p><p>        return true;</p><p>    end, Col, _PlayerID, Logo, Pattern);</p><p>-- Setzt das Portrait des Spielers.</p><p>-- Dabei gibt es 3 verschiedene Varianten:</p><p>-- <ul></p><p>-- <li>Wenn _Portrait nicht gesetzt wird, wird das Portrait des Primary</p><p>-- Knight genommen.</li></p><p>-- <li>Wenn _Portrait ein existierendes Entity ist, wird anhand des Typs</p><p>-- das Portrait bestimmt.</li></p><p>-- <li>Wenn _Portrait der Modellname eines Portrait ist, wird der Wert</p><p>-- als Portrait gesetzt.</li></p><p>-- </ul></p><p>-- Wenn kein Portrait bestimmt werden kann, wird H_NPC_Generic_Trader verwendet.</p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @param _Portrait [string] Name des Models</p><p>-- @within Anwenderfunktionen</p><p>-- @usage -- Primary Knight</p><p>-- API.InterfaceSetPlayerPortrait(2);</p><p>-- -- Durch Entity</p><p>-- API.InterfaceSetPlayerPortrait(2, "amma");</p><p>-- -- Durch Modelname</p><p>-- API.InterfaceSetPlayerPortrait(2, "H_NPC_Monk_AS");</p><p>function API.InterfaceSetPlayerPortrait(_PlayerID, _Portrait)</p><p>    if not _PlayerID or type(_PlayerID) ~= "number" or (_PlayerID < 1 or _PlayerID > 8) then</p><p>        API.Fatal("API.InterfaceSetPlayerPortrait: Invalid player ID!");</p><p>        return;</p><p>    end</p><p>    if not GUI then</p><p>        local Portrait = (_Portrait ~= nil and "'" .._Portrait.. "'") or "nil";</p><p>        API.Bridge("API.InterfaceSetPlayerPortrait(" .._PlayerID.. ", " ..Portrait.. ")")</p><p>        return;</p><p>    end</p><p>    </p><p>    if _Portrait == nil then</p><p>        BundleInterfaceApperance.Local:SetPlayerPortraitByPrimaryKnight(_PlayerID);</p><p>        return;</p><p>    end</p><p>    if _Portrait ~= nil and IsExisting(_Portrait) then</p><p>        BundleInterfaceApperance.Local:SetPlayerPortraitBySettler(_PlayerID, _Portrait);</p><p>        return;</p><p>    end</p><p>    BundleInterfaceApperance.Local:SetPlayerPortraitByModelName(_PlayerID, _Portrait);</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {},</p><p>    Local = {</p><p>        Data = {</p><p>            HiddenWidgets = {},</p><p>        },</p><p>    }</p><p>-- Global Script ---------------------------------------------------------------</p><p>-- Initialisiert das Bundle im globalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    API.AddSaveGameAction(BundleInterfaceApperance.Global.RestoreAfterLoad);</p><p>-- Stellt alle versteckten Buttons nach dem Laden eines Spielstandes wieder her.</p><p>-- @within Internal</p><p>-- @local</p><p>    Logic.ExecuteInLuaLocalState([[</p><p>        BundleInterfaceApperance.Local:RestoreAfterLoad();</p><p>    ]]);</p><p>-- Local Script ----------------------------------------------------------------</p><p>-- Initialisiert das Bundle im lokalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    StartMissionGoodOrEntityCounter = function(_Icon, _AmountToReach)</p><p>        if type(_Icon) == "string" then</p><p>            BundleInterfaceApperance.Local:SetTexture("/InGame/Root/Normal/MissionGoodOrEntityCounter/Icon", _Icon);</p><p>        else</p><p>            if type(_Icon[3]) == "string" then</p><p>                BundleInterfaceApperance.Local:SetIcon("/InGame/Root/Normal/MissionGoodOrEntityCounter/Icon", _Icon, 64, _Icon[3]);</p><p>            else</p><p>                SetIcon("/InGame/Root/Normal/MissionGoodOrEntityCounter/Icon", _Icon);</p><p>            end</p><p>        end</p><p>        g_MissionGoodOrEntityCounterAmountToReach = _AmountToReach;</p><p>        g_MissionGoodOrEntityCounterIcon = _Icon;</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/MissionGoodOrEntityCounter", 1);</p><p>    end</p><p>    GUI_Knight.ClaimTerritoryUpdate_Orig_QSB_InterfaceApperance = GUI_Knight.ClaimTerritoryUpdate;</p><p>    GUI_Knight.ClaimTerritoryUpdate = function()</p><p>        local Key = "/InGame/Root/Normal/AlignBottomRight/DialogButtons/Knight/ClaimTerritory";</p><p>        if BundleInterfaceApperance.Local.Data.HiddenWidgets[Key] == true</p><p>        then</p><p>            BundleInterfaceApperance.Local:HideInterfaceButton(Key, true);</p><p>        end</p><p>        GUI_Knight.ClaimTerritoryUpdate_Orig_QSB_InterfaceApperance();</p><p>    end</p><p>-- Setzt das Portrait des Spielers anhand des Primary Knight.</p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @within Internal</p><p>-- @local</p><p>    local KnightID = Logic.GetKnightID(_PlayerID);</p><p>    if KnightID == 0 then</p><p>        return;</p><p>    end</p><p>    local KnightType = Logic.GetEntityType(KnightID);</p><p>    local KnightTypeName = Logic.GetEntityTypeName(KnightType);</p><p>    local HeadModelName = "H" .. string.sub(KnightTypeName, 2, 8) .. "_" .. string.sub(KnightTypeName, 9);</p><p>    if not Models["Heads_" .. HeadModelName] then</p><p>        HeadModelName = "H_NPC_Generic_Trader";</p><p>    end</p><p>    g_PlayerPortrait[_PlayerID] = HeadModelName;</p><p>-- Setzt das Portrait des Spielers anhand der übergebenen Script Entity.</p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @param _Portrait [string] Skriptname des Entity</p><p>-- @within Internal</p><p>-- @local</p><p>    local PortraitMap = {</p><p>        ["U_KnightChivalry"]           = "H_Knight_Chivalry",</p><p>        ["U_KnightHealing"]            = "H_Knight_Healing",</p><p>        ["U_KnightPlunder"]            = "H_Knight_Plunder",</p><p>        ["U_KnightRedPrince"]          = "H_Knight_RedPrince",</p><p>        ["U_KnightSabatta"]            = "H_Knight_Sabatt",</p><p>        ["U_KnightSong"]               = "H_Knight_Song",</p><p>        ["U_KnightTrading"]            = "H_Knight_Trading",</p><p>        ["U_KnightWisdom"]             = "H_Knight_Wisdom",</p><p>        ["U_NPC_Amma_NE"]              = "H_NPC_Amma",</p><p>        ["U_NPC_Castellan_ME"]         = "H_NPC_Castellan_ME",</p><p>        ["U_NPC_Castellan_NA"]         = "H_NPC_Castellan_NA",</p><p>        ["U_NPC_Castellan_NE"]         = "H_NPC_Castellan_NE",</p><p>        ["U_NPC_Castellan_SE"]         = "H_NPC_Castellan_SE",</p><p>        ["U_MilitaryBandit_Ranged_ME"] = "H_NPC_Mercenary_ME",</p><p>        ["U_MilitaryBandit_Melee_NA"]  = "H_NPC_Mercenary_NA",</p><p>        ["U_MilitaryBandit_Melee_NE"]  = "H_NPC_Mercenary_NE",</p><p>        ["U_MilitaryBandit_Melee_SE"]  = "H_NPC_Mercenary_SE",</p><p>        ["U_NPC_Monk_ME"]              = "H_NPC_Monk_ME",</p><p>        ["U_NPC_Monk_NA"]              = "H_NPC_Monk_NA",</p><p>        ["U_NPC_Monk_NE"]              = "H_NPC_Monk_NE",</p><p>        ["U_NPC_Monk_SE"]              = "H_NPC_Monk_SE",</p><p>        ["U_NPC_Villager01_ME"]        = "H_NPC_Villager01_ME",</p><p>        ["U_NPC_Villager01_NA"]        = "H_NPC_Villager01_NA",</p><p>        ["U_NPC_Villager01_NE"]        = "H_NPC_Villager01_NE",</p><p>        ["U_NPC_Villager01_SE"]        = "H_NPC_Villager01_SE",</p><p>    }</p><p>    if g_GameExtraNo > 0 then</p><p>        PortraitMap["U_KnightPraphat"]           = "H_Knight_Praphat";</p><p>        PortraitMap["U_KnightSaraya"]            = "H_Knight_Saraya";</p><p>        PortraitMap["U_KnightKhana"]             = "H_Knight_Khana";</p><p>        PortraitMap["U_MilitaryBandit_Melee_AS"] = "H_NPC_Mercenary_AS";</p><p>        PortraitMap["U_NPC_Castellan_AS"]        = "H_NPC_Castellan_AS";</p><p>        PortraitMap["U_NPC_Villager_AS"]         = "H_NPC_Villager_AS";</p><p>        PortraitMap["U_NPC_Monk_AS"]             = "H_NPC_Monk_AS";</p><p>        PortraitMap["U_NPC_Monk_Khana"]          = "H_NPC_Monk_Khana";</p><p>    end</p><p>    local HeadModelName = "H_NPC_Generic_Trader";</p><p>    local EntityID = GetID(_Portrait);</p><p>    if EntityID ~= 0 then</p><p>        local EntityType = Logic.GetEntityType(EntityID);</p><p>        local EntityTypeName = Logic.GetEntityTypeName(EntityType);</p><p>        HeadModelName = PortraitMap[EntityTypeName] or "H_NPC_Generic_Trader";</p><p>        if not HeadModelName then</p><p>            HeadModelName = "H_NPC_Generic_Trader";</p><p>        end</p><p>    end</p><p>    g_PlayerPortrait[_PlayerID] = HeadModelName;</p><p>-- Setzt das Portrait des Spielers anhand des angegebenen Models.</p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @param _Portrait [string] Name des Models</p><p>-- @within Internal</p><p>-- @local</p><p>    if not Models["Heads_" .. tostring(_Portrait)] then</p><p>        _Portrait = "H_NPC_Generic_Trader";</p><p>    end</p><p>    g_PlayerPortrait[_PlayerID] = _Portrait;</p><p>-- Versteht ein Widget oder blendet es ein.</p><p>-- @param _Widget [string|number] Widgetpfad oder ID</p><p>-- @param _Hide [boolean] Hidden Flag</p><p>-- @within Internal</p><p>-- @local</p><p>    self.Data.HiddenWidgets[_Widget] = _Hide == true;</p><p>    XGUIEng.ShowWidget(_Widget, (_Hide == true and 0) or 1);</p><p>-- Stellt alle versteckten Buttons nach dem Laden eines Spielstandes wieder her.</p><p>-- @within Internal</p><p>-- @local</p><p>    for k, v in pairs(self.Data.HiddenWidgets) do</p><p>        if v then</p><p>            XGUIEng.ShowWidget(k, 0);</p><p>        end</p><p>    end</p><p>-- Setzt einen Icon aus einer benutzerdefinerten Datei.</p><p>-- @param _widget [string|number] Widgetpfad oder ID</p><p>-- @param _file [string] Pfad zur Datei</p><p>-- @within Internal</p><p>-- @local</p><p>    assert((type(_widget) == "string" or type(_widget) == "number"));</p><p>    local wID = (type(_widget) == "string" and XGUIEng.GetWidgetID(_widget)) or _widget;</p><p>    local screenSize = {GUI.GetScreenSize()};</p><p>    local state = 1;</p><p>    if XGUIEng.IsButton(wID) == 1 then</p><p>        state = 7;</p><p>    end</p><p>    local Scale = 330;</p><p>    if screenSize[2] >= 800 then</p><p>        Scale = 260;</p><p>    end</p><p>    if screenSize[2] >= 1000 then</p><p>        Scale = 210;</p><p>    end</p><p>    XGUIEng.SetMaterialAlpha(wID, state, 255);</p><p>    XGUIEng.SetMaterialTexture(wID, state, _file);</p><p>    XGUIEng.SetMaterialUV(wID, state, 0, 0, Scale, Scale);</p><p>-- Setzt einen Icon aus einer benutzerdefinierten Matrix.</p><p>-- @param _WidgetID [string|number] Widgetpfad oder ID</p><p>-- @param _Coordinates [table] Koordinaten</p><p>-- @param _Size [number] Größe des Icon</p><p>-- @param _Name [string] Name der Icon Matrix</p><p>-- @within Internal</p><p>-- @local</p><p>    if _Name == nil then</p><p>        _Name = "usericons";</p><p>    end</p><p>    if _Size == nil then</p><p>        _Size = 64;</p><p>    end</p><p>    if _Size == 44 then</p><p>        _Name = _Name .. ".png"</p><p>    end</p><p>    if _Size == 64 then</p><p>        _Name = _Name .. "big.png"</p><p>    end</p><p>    if _Size == 128 then</p><p>        _Name = _Name .. "verybig.png"</p><p>    end</p><p>    local u0, u1, v0, v1;</p><p>    u0 = (_Coordinates[1] - 1) * _Size;</p><p>    v0 = (_Coordinates[2] - 1) * _Size;</p><p>    u1 = (_Coordinates[1]) * _Size;</p><p>    v1 = (_Coordinates[2]) * _Size;</p><p>    State = 1;</p><p>    if XGUIEng.IsButton(_WidgetID) == 1 then</p><p>        State = 7;</p><p>    end</p><p>    XGUIEng.SetMaterialAlpha(_WidgetID, State, 255);</p><p>    XGUIEng.SetMaterialTexture(_WidgetID, State, _Name);</p><p>    XGUIEng.SetMaterialUV(_WidgetID, State, u0, v0, u1, v1);</p><p>-- Setzt einen Beschreibungstooltip.</p><p>-- @param _title [string] Titel des Tooltip</p><p>-- @param _text [string] Text des Tooltip</p><p>-- @param _disabledText [string] Textzusatz wenn inaktiv</p><p>-- @within Internal</p><p>-- @local</p><p>    local lang = Network.GetDesiredLanguage()</p><p>    if lang ~= "de" then lang = "en" end</p><p>    if type(_title) == "table" then</p><p>        _title = _title[lang];</p><p>    end</p><p>    if type(_text) == "table" then</p><p>        _text = _text[lang];</p><p>    end</p><p>    _text = _text or "";</p><p>    if type(_disabledText) == "table" then</p><p>        _disabledText = _disabledText[lang];</p><p>    end</p><p>    local TooltipContainerPath = "/InGame/Root/Normal/TooltipNormal"</p><p>    local TooltipContainer = XGUIEng.GetWidgetID(TooltipContainerPath)</p><p>    local TooltipNameWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Name")</p><p>    local TooltipDescriptionWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Text")</p><p>    local TooltipBGWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/BG")</p><p>    local TooltipFadeInContainer = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn")</p><p>    local PositionWidget = XGUIEng.GetCurrentWidgetID()</p><p>    GUI_Tooltip.ResizeBG(TooltipBGWidget, TooltipDescriptionWidget)</p><p>    local TooltipContainerSizeWidgets = {TooltipBGWidget}</p><p>    GUI_Tooltip.SetPosition(TooltipContainer, TooltipContainerSizeWidgets, PositionWidget)</p><p>    GUI_Tooltip.FadeInTooltip(TooltipFadeInContainer)</p><p>    _disabledText = _disabledText or "";</p><p>    local disabled = "";</p><p>    if XGUIEng.IsButtonDisabled(PositionWidget) == 1 and _disabledText ~= "" and _text ~= "" then</p><p>        disabled = disabled .. "{cr}{@color:255,32,32,255}" .. _disabledText</p><p>    end</p><p>    XGUIEng.SetText(TooltipNameWidget, "{center}" .. _title)</p><p>    XGUIEng.SetText(TooltipDescriptionWidget, _text .. disabled)</p><p>    local Height = XGUIEng.GetTextHeight(TooltipDescriptionWidget, true)</p><p>    local W, H = XGUIEng.GetWidgetSize(TooltipDescriptionWidget)</p><p>    XGUIEng.SetWidgetSize(TooltipDescriptionWidget, W, Height)</p><p>-- Setzt den Kostentooltip.</p><p>-- @param _title [string] Titel des Tooltip</p><p>-- @param _text [string] Text des Tooltip</p><p>-- @param _disabledText [string] Textzusatz wenn inaktiv</p><p>-- @param _costs [table] Kostentabelle</p><p>-- @param _inSettlement [boolean] Kosten in Siedlung suchen</p><p>-- @within Internal</p><p>-- @local</p><p>    local lang = Network.GetDesiredLanguage()</p><p>    if lang ~= "de" then lang = "en" end</p><p>    _costs = _costs or {};</p><p>    if type(_title) == "table" then</p><p>        _title = _title[lang];</p><p>    end</p><p>    if type(_text) == "table" then</p><p>        _text = _text[lang];</p><p>    end</p><p>    _text = _text or "";</p><p>    if type(_disabledText) == "table" then</p><p>        _disabledText = _disabledText[lang];</p><p>    end</p><p>    local TooltipContainerPath = "/InGame/Root/Normal/TooltipBuy"</p><p>    local TooltipContainer = XGUIEng.GetWidgetID(TooltipContainerPath)</p><p>    local TooltipNameWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Name")</p><p>    local TooltipDescriptionWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Text")</p><p>    local TooltipBGWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/BG")</p><p>    local TooltipFadeInContainer = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn")</p><p>    local TooltipCostsContainer = XGUIEng.GetWidgetID(TooltipContainerPath .. "/Costs")</p><p>    local PositionWidget = XGUIEng.GetCurrentWidgetID()</p><p>    GUI_Tooltip.ResizeBG(TooltipBGWidget, TooltipDescriptionWidget)</p><p>    GUI_Tooltip.SetCosts(TooltipCostsContainer, _costs, _inSettlement)</p><p>    local TooltipContainerSizeWidgets = {TooltipContainer, TooltipCostsContainer, TooltipBGWidget}</p><p>    GUI_Tooltip.SetPosition(TooltipContainer, TooltipContainerSizeWidgets, PositionWidget, nil, true)</p><p>    GUI_Tooltip.OrderTooltip(TooltipContainerSizeWidgets, TooltipFadeInContainer, TooltipCostsContainer, PositionWidget, TooltipBGWidget)</p><p>    GUI_Tooltip.FadeInTooltip(TooltipFadeInContainer)</p><p>    _disabledText = _disabledText or "";</p><p>    local disabled = ""</p><p>    if XGUIEng.IsButtonDisabled(PositionWidget) == 1 and _disabledText ~= "" and _text ~= "" then</p><p>        disabled = disabled .. "{cr}{@color:255,32,32,255}" .. _disabledText</p><p>    end</p><p>    XGUIEng.SetText(TooltipNameWidget, "{center}" .. _title)</p><p>    XGUIEng.SetText(TooltipDescriptionWidget, _text .. disabled)</p><p>    local Height = XGUIEng.GetTextHeight(TooltipDescriptionWidget, true)</p><p>    local W, H = XGUIEng.GetWidgetSize(TooltipDescriptionWidget)</p><p>    XGUIEng.SetWidgetSize(TooltipDescriptionWidget, W, Height)</p><p>-- -------------------------------------------------------------------------- --</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundleknighttitlerequirements.lua.html">
            <div class='doclink'>
                <div>BundleKnightTitleRequirements</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia BundleKnightTitleRequirements                                # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Erlaubt es dem Mapper die vorgegebenen Aufstiegsbedingungen idividuell</p><p>-- an die eigenen Vorstellungen anzupassen.</p><p>-- Die Aufstiegsbedingungen werden in der Funktion InitKnightTitleTables</p><p>-- angegeben und bearbeitet.</p><p>-- <p><a href="#InitKnightTitleTables">Aufstiegsbedingungen steuern</a></p></p><p>-- <p>Mögliche Aufstiegsbedingungen:</p><p>-- <ul></p><p>-- <li><b>Entitytyp besitzen</b><br/></p><p>-- Der Spieler muss eine bestimmte Anzahl von Entities eines Typs besitzen.</p><p>-- <pre><code></p><p>-- KnightTitleRequirements[KnightTitles.Mayor].Entities = {</p><p>--     {Entities.B_Bakery, 2},</p><p>--     ...</p><p>-- }</p><p>-- </code></pre></p><p>-- </li></p><p>-- <li><b>Entitykategorie besitzen</b><br/></p><p>-- Der Spieler muss eine bestimmte Anzahl von Entities einer Kategorie besitzen.</p><p>-- <pre><code></p><p>-- KnightTitleRequirements[KnightTitles.Mayor].Category = {</p><p>--     {EntitiyCategories.CattlePasture, 10},</p><p>--     ...</p><p>-- }</p><p>-- </code></pre></p><p>-- </li></p><p>-- <li><b>Gütertyp besitzen</b><br/></p><p>-- Der Spieler muss Rohstoffe oder Güter eines Typs besitzen.</p><p>-- <pre><code></p><p>-- KnightTitleRequirements[KnightTitles.Mayor].Goods = {</p><p>--     {Goods.G_RawFish, 35},</p><p>--     ...</p><p>-- }</p><p>-- </code></pre></p><p>-- </li></p><p>-- <li><b>Produkte erzeugen</b><br/></p><p>-- Der Spieler muss Gebrauchsgegenstände für ein Bedürfnis bereitstellen.</p><p>-- <pre><code></p><p>-- KnightTitleRequirements[KnightTitles.Mayor].Products = {</p><p>--     {GoodCategories.GC_Clothes, 6},</p><p>--     ...</p><p>-- }</p><p>-- </code></pre></p><p>-- </li></p><p>-- <li><b>Güter konsumieren</b><br/></p><p>-- Die Siedler müssen eine Menge einer bestimmten Waren konsumieren.</p><p>-- <pre><code></p><p>-- KnightTitleRequirements[KnightTitles.Mayor].Consume = {</p><p>--     {Goods.G_Bread, 30},</p><p>--     ...</p><p>-- }</p><p>-- </code></pre></p><p>-- </li></p><p>-- <li><b>Vielfältigkeit bereitstellen</b><br/></p><p>-- Der Spieler muss einen Vielfältigkeits-Buff aktivieren.</p><p>-- <pre><code></p><p>-- KnightTitleRequirements[KnightTitles.Mayor].Buff = {</p><p>--     Buffs.Buff_FoodDiversity,</p><p>--     ...</p><p>-- }</p><p>-- </code></pre></p><p>-- </li></p><p>-- <li><b>Stadtruf erreichen</b><br/></p><p>-- Der Ruf der Stadt muss einen bestimmten Wert erreichen oder überschreiten.</p><p>-- <pre><code></p><p>-- KnightTitleRequirements[KnightTitles.Mayor].Reputation = 20</p><p>-- </code></pre></p><p>-- <li><b>Anzahl an Dekorationen</b><br/></p><p>-- Der Spieler muss mindestens die Anzahl der angegebenen Dekoration besitzen.</p><p>-- <code><pre></p><p>-- KnightTitleRequirements[KnightTitles.Mayor].DecoratedBuildings = {</p><p>--     {Goods.G_Banner, 9 },</p><p>-- }</p><p>-- </code></pre></p><p>-- </li></p><p>-- <li><b>Anzahl voll dekorierter Gebäude</b><br/></p><p>-- Anzahl an Gebäuden, an die alle vier Dekorationen angebracht sein müssen.</p><p>-- <pre><code></p><p>-- KnightTitleRequirements[KnightTitles.Mayor].FullDecoratedBuildings = 12</p><p>-- </code></pre></p><p>-- </li></p><p>-- <li><b>Spezialgebäude ausbauen</b><br/></p><p>-- Ein Spezielgebäude muss ausgebaut werden.</p><p>-- <pre><code></p><p>-- KnightTitleRequirements[KnightTitles.Mayor].Headquarters = 1</p><p>-- KnightTitleRequirements[KnightTitles.Mayor].Storehouse = 1</p><p>-- KnightTitleRequirements[KnightTitles.Mayor].Cathedrals = 1</p><p>-- </code></pre></p><p>-- </li></p><p>-- <li><b>Anzahl Siedler</b><br/></p><p>-- Der Spieler benötigt eine Gesamtzahl an Siedlern.</p><p>-- <pre><code></p><p>-- KnightTitleRequirements[KnightTitles.Mayor].Settlers = 40</p><p>-- </code></pre></p><p>-- </li></p><p>-- <li><b>Anzahl reiche Stadtgebäude</b><br/></p><p>-- Eine Anzahl an Gebäuden muss durch Einnahmen Reichtum erlangen.</p><p>-- <pre><code></p><p>-- KnightTitleRequirements[KnightTitles.Mayor].RichBuildings = 30</p><p>-- </code></pre></p><p>-- </li></p><p>-- <li><b>Benutzerdefiniert</b><br/></p><p>-- Eine benutzerdefinierte Funktion, die entweder als Schalter oder als Zähler</p><p>-- fungieren kann und true oder false zurückgeben muss.</p><p>-- <pre><code></p><p>-- KnightTitleRequirements[KnightTitles.Mayor].Custom = {</p><p>--     {SomeFunction, {1, 1}, "Überschrift", "Beschreibung"}</p><p>-- }</p><p>-- </code></pre></p><p>-- </li></p><p>-- </ul></p></p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {},</p><p>    Local = {</p><p>        Data = {},</p><p>    }</p><p>-- Global Script ---------------------------------------------------------------</p><p>-- Installiert das Bundle im globalen Skript.</p><p>-- @within BundleKnightTitleRequirements</p><p>-- @local</p><p>    self:OverwriteConsumedGoods();</p><p>-- Zählt den Konsumzähler rauf, sobald eine Ware konsumiert wird.</p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @param _Good [number] Warentyp</p><p>-- @within BundleKnightTitleRequirements</p><p>-- @local</p><p>    QSB.ConsumedGoodsCounter[_PlayerID]        = QSB.ConsumedGoodsCounter[_PlayerID] or {};</p><p>    QSB.ConsumedGoodsCounter[_PlayerID][_Good] = QSB.ConsumedGoodsCounter[_PlayerID][_Good] or 0;</p><p>    QSB.ConsumedGoodsCounter[_PlayerID][_Good] = QSB.ConsumedGoodsCounter[_PlayerID][_Good] +1;</p><p>-- Überschreibt GameCallback_ConsumeGood, sodass konsumierte Waren gezählt</p><p>-- werden können.</p><p>-- @within BundleKnightTitleRequirements</p><p>-- @local</p><p>    GameCallback_ConsumeGood_Orig_QSB_Requirements = GameCallback_ConsumeGood</p><p>    GameCallback_ConsumeGood = function(_Consumer, _Good, _Building)</p><p>        GameCallback_ConsumeGood_Orig_QSB_Requirements(_Consumer, _Good, _Building)</p><p>        local PlayerID = Logic.EntityGetPlayer(_Consumer);</p><p>        BundleKnightTitleRequirements.Global:RegisterConsumedGoods(PlayerID, _Good);</p><p>        Logic.ExecuteInLuaLocalState([[</p><p>            BundleKnightTitleRequirements.Local:RegisterConsumedGoods(</p><p>                ]] ..PlayerID.. [[, ]] .._Good.. [[</p><p>            );</p><p>        ]]);</p><p>    end</p><p>-- Local Script ----------------------------------------------------------------</p><p>-- Installiert das Bundle im lokalen Skript.</p><p>-- @within BundleKnightTitleRequirements</p><p>-- @local</p><p>    self:OverwriteTooltips();</p><p>    self:InitTexturePositions();</p><p>    self:OverwriteUpdateRequirements();</p><p>    self:OverwritePromotionCelebration();</p><p>-- Zählt den Konsumzähler rauf, sobald eine Ware konsumiert wird.</p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @param _Good [number] Warentyp</p><p>-- @within BundleKnightTitleRequirements</p><p>-- @local</p><p>    QSB.ConsumedGoodsCounter[_PlayerID]        = QSB.ConsumedGoodsCounter[_PlayerID] or {};</p><p>    QSB.ConsumedGoodsCounter[_PlayerID][_Good] = QSB.ConsumedGoodsCounter[_PlayerID][_Good] or 0;</p><p>    QSB.ConsumedGoodsCounter[_PlayerID][_Good] = QSB.ConsumedGoodsCounter[_PlayerID][_Good] +1;</p><p>-- Fügt einige weitere Einträge zu den Texturpositionen hinzu.</p><p>-- @within BundleKnightTitleRequirements</p><p>-- @local</p><p>    g_TexturePositions.EntityCategories[EntityCategories.GC_Food_Supplier]          = { 1, 1};</p><p>    g_TexturePositions.EntityCategories[EntityCategories.GC_Clothes_Supplier]       = { 1, 2};</p><p>    g_TexturePositions.EntityCategories[EntityCategories.GC_Hygiene_Supplier]       = {16, 1};</p><p>    g_TexturePositions.EntityCategories[EntityCategories.GC_Entertainment_Supplier] = { 1, 4};</p><p>    g_TexturePositions.EntityCategories[EntityCategories.GC_Luxury_Supplier]        = {16, 3};</p><p>    g_TexturePositions.EntityCategories[EntityCategories.GC_Weapon_Supplier]        = { 1, 7};</p><p>    g_TexturePositions.EntityCategories[EntityCategories.GC_Medicine_Supplier]      = { 2,10};</p><p>    g_TexturePositions.EntityCategories[EntityCategories.Outpost]                   = {12, 3};</p><p>    g_TexturePositions.EntityCategories[EntityCategories.Spouse]                    = { 5,15};</p><p>    g_TexturePositions.EntityCategories[EntityCategories.CattlePasture]             = { 3,16};</p><p>    g_TexturePositions.EntityCategories[EntityCategories.SheepPasture]              = { 4, 1};</p><p>    g_TexturePositions.EntityCategories[EntityCategories.Soldier]                   = { 7,12};</p><p>    g_TexturePositions.EntityCategories[EntityCategories.GrainField]                = {14, 2};</p><p>    g_TexturePositions.EntityCategories[EntityCategories.OuterRimBuilding]          = { 3, 4};</p><p>    g_TexturePositions.EntityCategories[EntityCategories.CityBuilding]              = { 8, 1};</p><p>    g_TexturePositions.EntityCategories[EntityCategories.Leader]                    = { 7, 11};</p><p>    g_TexturePositions.EntityCategories[EntityCategories.Range]                     = { 9, 8};</p><p>    g_TexturePositions.EntityCategories[EntityCategories.Melee]                     = { 9, 7};</p><p>    g_TexturePositions.EntityCategories[EntityCategories.SiegeEngine]               = { 2,15};</p><p>    g_TexturePositions.Entities[Entities.B_Outpost]                                 = {12, 3};</p><p>    g_TexturePositions.Entities[Entities.B_Outpost_AS]                              = {12, 3};</p><p>    g_TexturePositions.Entities[Entities.B_Outpost_ME]                              = {12, 3};</p><p>    g_TexturePositions.Entities[Entities.B_Outpost_NA]                              = {12, 3};</p><p>    g_TexturePositions.Entities[Entities.B_Outpost_NE]                              = {12, 3};</p><p>    g_TexturePositions.Entities[Entities.B_Outpost_SE]                              = {12, 3};</p><p>    g_TexturePositions.Entities[Entities.B_Cathedral_Big]                           = { 3,12};</p><p>    g_TexturePositions.Entities[Entities.U_MilitaryBallista]                        = {10, 5};</p><p>    g_TexturePositions.Entities[Entities.U_Trebuchet]                               = { 9, 1};</p><p>    g_TexturePositions.Entities[Entities.U_SiegeEngineCart]                         = { 9, 4};</p><p>    g_TexturePositions.Needs[Needs.Medicine]                                        = { 2,10};</p><p>    g_TexturePositions.Technologies[Technologies.R_Castle_Upgrade_1]                = { 4, 7};</p><p>    g_TexturePositions.Technologies[Technologies.R_Castle_Upgrade_2]                = { 4, 7};</p><p>    g_TexturePositions.Technologies[Technologies.R_Castle_Upgrade_3]                = { 4, 7};</p><p>    g_TexturePositions.Technologies[Technologies.R_Cathedral_Upgrade_1]             = { 4, 5};</p><p>    g_TexturePositions.Technologies[Technologies.R_Cathedral_Upgrade_2]             = { 4, 5};</p><p>    g_TexturePositions.Technologies[Technologies.R_Cathedral_Upgrade_3]             = { 4, 5};</p><p>    g_TexturePositions.Technologies[Technologies.R_Storehouse_Upgrade_1]            = { 4, 6};</p><p>    g_TexturePositions.Technologies[Technologies.R_Storehouse_Upgrade_2]            = { 4, 6};</p><p>    g_TexturePositions.Technologies[Technologies.R_Storehouse_Upgrade_3]            = { 4, 6};</p><p>    g_TexturePositions.Buffs = g_TexturePositions.Buffs or {};</p><p>    g_TexturePositions.Buffs[Buffs.Buff_ClothesDiversity]                           = { 1, 2};</p><p>    g_TexturePositions.Buffs[Buffs.Buff_EntertainmentDiversity]                     = { 1, 4};</p><p>    g_TexturePositions.Buffs[Buffs.Buff_FoodDiversity]                              = { 1, 1};</p><p>    g_TexturePositions.Buffs[Buffs.Buff_HygieneDiversity]                           = { 1, 3};</p><p>    g_TexturePositions.Buffs[Buffs.Buff_Colour]                                     = { 5,11};</p><p>    g_TexturePositions.Buffs[Buffs.Buff_Entertainers]                               = { 5,12};</p><p>    g_TexturePositions.Buffs[Buffs.Buff_ExtraPayment]                               = { 1, 8};</p><p>    g_TexturePositions.Buffs[Buffs.Buff_Sermon]                                     = { 4,14};</p><p>    g_TexturePositions.Buffs[Buffs.Buff_Spice]                                      = { 5,10};</p><p>    g_TexturePositions.Buffs[Buffs.Buff_NoTaxes]                                    = { 1, 6};</p><p>    if Framework.GetGameExtraNo() ~= 0 then</p><p>        g_TexturePositions.Buffs[Buffs.Buff_Gems]                                   = { 1, 1, 1};</p><p>        g_TexturePositions.Buffs[Buffs.Buff_MusicalInstrument]                      = { 1, 3, 1};</p><p>        g_TexturePositions.Buffs[Buffs.Buff_Olibanum]                               = { 1, 2, 1};</p><p>    end</p><p>    g_TexturePositions.GoodCategories = g_TexturePositions.GoodCategories or {};</p><p>    g_TexturePositions.GoodCategories[GoodCategories.GC_Ammunition]                 = {10, 6};</p><p>    g_TexturePositions.GoodCategories[GoodCategories.GC_Animal]                     = { 4,16};</p><p>    g_TexturePositions.GoodCategories[GoodCategories.GC_Clothes]                    = { 1, 2};</p><p>    g_TexturePositions.GoodCategories[GoodCategories.GC_Document]                   = { 5, 6};</p><p>    g_TexturePositions.GoodCategories[GoodCategories.GC_Entertainment]              = { 1, 4};</p><p>    g_TexturePositions.GoodCategories[GoodCategories.GC_Food]                       = { 1, 1};</p><p>    g_TexturePositions.GoodCategories[GoodCategories.GC_Gold]                       = { 1, 8};</p><p>    g_TexturePositions.GoodCategories[GoodCategories.GC_Hygiene]                    = {16, 1};</p><p>    g_TexturePositions.GoodCategories[GoodCategories.GC_Luxury]                     = {16, 3};</p><p>    g_TexturePositions.GoodCategories[GoodCategories.GC_Medicine]                   = { 2,10};</p><p>    g_TexturePositions.GoodCategories[GoodCategories.GC_None]                       = {15,16};</p><p>    g_TexturePositions.GoodCategories[GoodCategories.GC_RawFood]                    = { 3, 4};</p><p>    g_TexturePositions.GoodCategories[GoodCategories.GC_RawMedicine]                = { 2, 2};</p><p>    g_TexturePositions.GoodCategories[GoodCategories.GC_Research]                   = { 5, 6};</p><p>    g_TexturePositions.GoodCategories[GoodCategories.GC_Resource]                   = { 3, 4};</p><p>    g_TexturePositions.GoodCategories[GoodCategories.GC_Tools]                      = { 4,12};</p><p>    g_TexturePositions.GoodCategories[GoodCategories.GC_Water]                      = { 1,16};</p><p>    g_TexturePositions.GoodCategories[GoodCategories.GC_Weapon]                     = { 8, 5};</p><p>-- Überschreibt die Aktualisierungsfunktion der Aufstiegsbedingungen.</p><p>-- @within BundleKnightTitleRequirements</p><p>-- @local</p><p>    GUI_Knight.UpdateRequirements = function()</p><p>        local WidgetPos = BundleKnightTitleRequirements.Local.Data.RequirementWidgets;</p><p>        local RequirementsIndex = 1;</p><p>        local PlayerID = GUI.GetPlayerID();</p><p>        local CurrentTitle = Logic.GetKnightTitle(PlayerID);</p><p>        local NextTitle = CurrentTitle + 1;</p><p>        --Headline</p><p>        local KnightID = Logic.GetKnightID(PlayerID);</p><p>        local KnightType = Logic.GetEntityType(KnightID);</p><p>        XGUIEng.SetText("/InGame/Root/Normal/AlignBottomRight/KnightTitleMenu/NextKnightTitle", "{center}" .. GUI_Knight.GetTitleNameByTitleID(KnightType, NextTitle));</p><p>        XGUIEng.SetText("/InGame/Root/Normal/AlignBottomRight/KnightTitleMenu/NextKnightTitleWhite", "{center}" .. GUI_Knight.GetTitleNameByTitleID(KnightType, NextTitle));</p><p>        -- show Settlers</p><p>        if KnightTitleRequirements[NextTitle].Settlers ~= nil then</p><p>            SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", {5,16})</p><p>            local IsFulfilled, CurrentAmount, NeededAmount = DoesNeededNumberOfSettlersForKnightTitleExist(PlayerID, NextTitle)</p><p>            XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount)</p><p>            if IsFulfilled then</p><p>                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1)</p><p>            else</p><p>                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0)</p><p>            end</p><p>            XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1)</p><p>            QSB.RequirementTooltipTypes[RequirementsIndex] = "Settlers";</p><p>            RequirementsIndex = RequirementsIndex +1;</p><p>        end</p><p>        -- show rich buildings</p><p>        if KnightTitleRequirements[NextTitle].RichBuildings ~= nil then</p><p>            SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", {8,4});</p><p>            local IsFulfilled, CurrentAmount, NeededAmount = DoNeededNumberOfRichBuildingsForKnightTitleExist(PlayerID, NextTitle);</p><p>            if NeededAmount == -1 then</p><p>                NeededAmount = Logic.GetNumberOfPlayerEntitiesInCategory(PlayerID, EntityCategories.CityBuilding);</p><p>            end</p><p>            XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);</p><p>            if IsFulfilled then</p><p>                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);</p><p>            else</p><p>                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);</p><p>            end</p><p>            XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);</p><p>            QSB.RequirementTooltipTypes[RequirementsIndex] = "RichBuildings";</p><p>            RequirementsIndex = RequirementsIndex +1;</p><p>        end</p><p>        -- Castle</p><p>        if KnightTitleRequirements[NextTitle].Headquarters ~= nil then</p><p>            SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", {4,7});</p><p>            local IsFulfilled, CurrentAmount, NeededAmount = DoNeededSpecialBuildingUpgradeForKnightTitleExist(PlayerID, NextTitle, EntityCategories.Headquarters);</p><p>            XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount + 1 .. "/" .. NeededAmount + 1);</p><p>            if IsFulfilled then</p><p>                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);</p><p>            else</p><p>                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);</p><p>            end</p><p>            XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);</p><p>            QSB.RequirementTooltipTypes[RequirementsIndex] = "Headquarters";</p><p>            RequirementsIndex = RequirementsIndex +1;</p><p>        end</p><p>        -- Storehouse</p><p>        if KnightTitleRequirements[NextTitle].Storehouse ~= nil then</p><p>            SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", {4,6});</p><p>            local IsFulfilled, CurrentAmount, NeededAmount = DoNeededSpecialBuildingUpgradeForKnightTitleExist(PlayerID, NextTitle, EntityCategories.Storehouse);</p><p>            XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount + 1 .. "/" .. NeededAmount + 1);</p><p>            if IsFulfilled then</p><p>                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);</p><p>            else</p><p>                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);</p><p>            end</p><p>            XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);</p><p>            QSB.RequirementTooltipTypes[RequirementsIndex] = "Storehouse";</p><p>            RequirementsIndex = RequirementsIndex +1;</p><p>        end</p><p>        -- Cathedral</p><p>        if KnightTitleRequirements[NextTitle].Cathedrals ~= nil then</p><p>            SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", {4,5});</p><p>            local IsFulfilled, CurrentAmount, NeededAmount = DoNeededSpecialBuildingUpgradeForKnightTitleExist(PlayerID, NextTitle, EntityCategories.Cathedrals);</p><p>            XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount + 1 .. "/" .. NeededAmount + 1);</p><p>            if IsFulfilled then</p><p>                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);</p><p>            else</p><p>                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);</p><p>            end</p><p>            XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);</p><p>            QSB.RequirementTooltipTypes[RequirementsIndex] = "Cathedrals";</p><p>            RequirementsIndex = RequirementsIndex +1;</p><p>        end</p><p>        -- Neue Bedingungen --------------------------------------------</p><p>        -- Volldekorierte Gebäude</p><p>        if KnightTitleRequirements[NextTitle].FullDecoratedBuildings ~= nil then</p><p>            local IsFulfilled, CurrentAmount, NeededAmount = DoNeededNumberOfFullDecoratedBuildingsForKnightTitleExist(PlayerID, NextTitle);</p><p>            local EntityCategory = KnightTitleRequirements[NextTitle].FullDecoratedBuildings;</p><p>            SetIcon(WidgetPos[RequirementsIndex].."/Icon"  , g_TexturePositions.Needs[Needs.Wealth]);</p><p>            XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);</p><p>            if IsFulfilled then</p><p>                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);</p><p>            else</p><p>                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);</p><p>            end</p><p>            XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] , 1);</p><p>            QSB.RequirementTooltipTypes[RequirementsIndex] = "FullDecoratedBuildings";</p><p>            RequirementsIndex = RequirementsIndex +1;</p><p>        end</p><p>        -- Stadtruf</p><p>        if KnightTitleRequirements[NextTitle].Reputation ~= nil then</p><p>            SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", {5,14});</p><p>            local IsFulfilled, CurrentAmount, NeededAmount = DoesNeededCityReputationForKnightTitleExist(PlayerID, NextTitle);</p><p>            XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);</p><p>            if IsFulfilled then</p><p>                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);</p><p>            else</p><p>                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);</p><p>            end</p><p>            XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);</p><p>            QSB.RequirementTooltipTypes[RequirementsIndex] = "Reputation";</p><p>            RequirementsIndex = RequirementsIndex +1;</p><p>        end</p><p>        -- Güter sammeln</p><p>        if KnightTitleRequirements[NextTitle].Goods ~= nil then</p><p>            for i=1, #KnightTitleRequirements[NextTitle].Goods do</p><p>                local GoodType = KnightTitleRequirements[NextTitle].Goods[i][1];</p><p>                SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", g_TexturePositions.Goods[GoodType]);</p><p>                local IsFulfilled, CurrentAmount, NeededAmount = DoesNeededNumberOfGoodTypesForKnightTitleExist(PlayerID, NextTitle, i);</p><p>                XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);</p><p>                if IsFulfilled then</p><p>                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);</p><p>                else</p><p>                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);</p><p>                end</p><p>                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);</p><p>                QSB.RequirementTooltipTypes[RequirementsIndex] = "Goods" .. i;</p><p>                RequirementsIndex = RequirementsIndex +1;</p><p>            end</p><p>        end</p><p>        -- Kategorien</p><p>        if KnightTitleRequirements[NextTitle].Category ~= nil then</p><p>            for i=1, #KnightTitleRequirements[NextTitle].Category do</p><p>                local Category = KnightTitleRequirements[NextTitle].Category[i][1];</p><p>                SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", g_TexturePositions.EntityCategories[Category]);</p><p>                local IsFulfilled, CurrentAmount, NeededAmount = DoesNeededNumberOfEntitiesInCategoryForKnightTitleExist(PlayerID, NextTitle, i);</p><p>                XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);</p><p>                if IsFulfilled then</p><p>                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);</p><p>                else</p><p>                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);</p><p>                end</p><p>                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);</p><p>                local EntitiesInCategory = {Logic.GetEntityTypesInCategory(Category)};</p><p>                if Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.GC_Weapon_Supplier) == 1 then</p><p>                    QSB.RequirementTooltipTypes[RequirementsIndex] = "Weapons" .. i;</p><p>                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.SiegeEngine) == 1 then</p><p>                    QSB.RequirementTooltipTypes[RequirementsIndex] = "HeavyWeapons" .. i;</p><p>                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.Spouse) == 1 then</p><p>                    QSB.RequirementTooltipTypes[RequirementsIndex] = "Spouse" .. i;</p><p>                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.Worker) == 1 then</p><p>                    QSB.RequirementTooltipTypes[RequirementsIndex] = "Worker" .. i;</p><p>                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.Soldier) == 1 then</p><p>                    QSB.RequirementTooltipTypes[RequirementsIndex] = "Soldiers" .. i;</p><p>                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.Leader) == 1 then</p><p>                    QSB.RequirementTooltipTypes[RequirementsIndex] = "Leader" .. i;</p><p>                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.Outpost) == 1 then</p><p>                    QSB.RequirementTooltipTypes[RequirementsIndex] = "Outposts" .. i;</p><p>                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.CattlePasture) == 1 then</p><p>                    QSB.RequirementTooltipTypes[RequirementsIndex] = "Cattle" .. i;</p><p>                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.SheepPasture) == 1 then</p><p>                    QSB.RequirementTooltipTypes[RequirementsIndex] = "Sheep" .. i;</p><p>                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.CityBuilding) == 1 then</p><p>                    QSB.RequirementTooltipTypes[RequirementsIndex] = "CityBuilding" .. i;</p><p>                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.OuterRimBuilding) == 1 then</p><p>                    QSB.RequirementTooltipTypes[RequirementsIndex] = "OuterRimBuilding" .. i;</p><p>                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.AttackableBuilding) == 1 then</p><p>                    QSB.RequirementTooltipTypes[RequirementsIndex] = "Buildings" .. i;</p><p>                else</p><p>                    QSB.RequirementTooltipTypes[RequirementsIndex] = "EntityCategoryDefault" .. i;</p><p>                end</p><p>                RequirementsIndex = RequirementsIndex +1;</p><p>            end</p><p>        end</p><p>        -- Entities</p><p>        if KnightTitleRequirements[NextTitle].Entities ~= nil then</p><p>            for i=1, #KnightTitleRequirements[NextTitle].Entities do</p><p>                local EntityType = KnightTitleRequirements[NextTitle].Entities[i][1];</p><p>                SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", g_TexturePositions.Entities[EntityType]);</p><p>                local IsFulfilled, CurrentAmount, NeededAmount = DoesNeededNumberOfEntitiesOfTypeForKnightTitleExist(PlayerID, NextTitle, i);</p><p>                XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);</p><p>                if IsFulfilled then</p><p>                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);</p><p>                else</p><p>                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);</p><p>                end</p><p>                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);</p><p>                QSB.RequirementTooltipTypes[RequirementsIndex] = "Entities" .. i;</p><p>                RequirementsIndex = RequirementsIndex +1;</p><p>            end</p><p>        end</p><p>        -- Güter konsumieren</p><p>        if KnightTitleRequirements[NextTitle].Consume ~= nil then</p><p>            for i=1, #KnightTitleRequirements[NextTitle].Consume do</p><p>                local GoodType = KnightTitleRequirements[NextTitle].Consume[i][1];</p><p>                SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", g_TexturePositions.Goods[GoodType]);</p><p>                local IsFulfilled, CurrentAmount, NeededAmount = DoNeededNumberOfConsumedGoodsForKnightTitleExist(PlayerID, NextTitle, i);</p><p>                XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);</p><p>                if IsFulfilled then</p><p>                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);</p><p>                else</p><p>                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);</p><p>                end</p><p>                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);</p><p>                QSB.RequirementTooltipTypes[RequirementsIndex] = "Consume" .. i;</p><p>                RequirementsIndex = RequirementsIndex +1;</p><p>            end</p><p>        end</p><p>        -- Güter aus Gruppe produzieren</p><p>        if KnightTitleRequirements[NextTitle].Products ~= nil then</p><p>            for i=1, #KnightTitleRequirements[NextTitle].Products do</p><p>                local Product = KnightTitleRequirements[NextTitle].Products[i][1];</p><p>                SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", g_TexturePositions.GoodCategories[Product]);</p><p>                local IsFulfilled, CurrentAmount, NeededAmount = DoNumberOfProductsInCategoryExist(PlayerID, NextTitle, i);</p><p>                XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);</p><p>                if IsFulfilled then</p><p>                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);</p><p>                else</p><p>                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);</p><p>                end</p><p>                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);</p><p>                QSB.RequirementTooltipTypes[RequirementsIndex] = "Products" .. i;</p><p>                RequirementsIndex = RequirementsIndex +1;</p><p>            end</p><p>        end</p><p>        -- Bonus aktivieren</p><p>        if KnightTitleRequirements[NextTitle].Buff ~= nil then</p><p>            for i=1, #KnightTitleRequirements[NextTitle].Buff do</p><p>                local Buff = KnightTitleRequirements[NextTitle].Buff[i];</p><p>                SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", g_TexturePositions.Buffs[Buff]);</p><p>                local IsFulfilled = DoNeededDiversityBuffForKnightTitleExist(PlayerID, NextTitle, i);</p><p>                XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "");</p><p>                if IsFulfilled then</p><p>                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);</p><p>                else</p><p>                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);</p><p>                end</p><p>                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);</p><p>                QSB.RequirementTooltipTypes[RequirementsIndex] = "Buff" .. i;</p><p>                RequirementsIndex = RequirementsIndex +1;</p><p>            end</p><p>        end</p><p>        -- Selbstdefinierte Bedingung</p><p>        if KnightTitleRequirements[NextTitle].Custom ~= nil then</p><p>            for i=1, #KnightTitleRequirements[NextTitle].Custom do</p><p>                local Icon = KnightTitleRequirements[NextTitle].Custom[i][2];</p><p>                BundleKnightTitleRequirements.Local:RequirementIcon(WidgetPos[RequirementsIndex] .. "/Icon", Icon);</p><p>                local IsFulfilled, CurrentAmount, NeededAmount = DoCustomFunctionForKnightTitleSucceed(PlayerID, NextTitle, i);</p><p>                if CurrentAmount and NeededAmount then</p><p>                    XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);</p><p>                else</p><p>                    XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "");</p><p>                end</p><p>                if IsFulfilled then</p><p>                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);</p><p>                else</p><p>                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);</p><p>                end</p><p>                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);</p><p>                QSB.RequirementTooltipTypes[RequirementsIndex] = "Custom" .. i;</p><p>                RequirementsIndex = RequirementsIndex +1;</p><p>            end</p><p>        end</p><p>        -- Dekorationselemente</p><p>        if KnightTitleRequirements[NextTitle].DecoratedBuildings ~= nil then</p><p>            for i=1, #KnightTitleRequirements[NextTitle].DecoratedBuildings do</p><p>                local GoodType = KnightTitleRequirements[NextTitle].DecoratedBuildings[i][1];</p><p>                SetIcon(WidgetPos[RequirementsIndex].."/Icon", g_TexturePositions.Goods[GoodType]);</p><p>                local IsFulfilled, CurrentAmount, NeededAmount = DoNeededNumberOfDecoratedBuildingsForKnightTitleExist(PlayerID, NextTitle, i);</p><p>                XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);</p><p>                if IsFulfilled then</p><p>                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);</p><p>                else</p><p>                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);</p><p>                end</p><p>                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);</p><p>                QSB.RequirementTooltipTypes[RequirementsIndex] = "DecoratedBuildings" ..i;</p><p>                RequirementsIndex = RequirementsIndex +1;</p><p>            end</p><p>        end</p><p>        -- Übrige ausblenden</p><p>        for i=RequirementsIndex, 6 do</p><p>            XGUIEng.ShowWidget(WidgetPos[i], 0);</p><p>        end</p><p>    end</p><p>-- Überschreibt die Beförderung des Primary Knight.</p><p>-- @within BundleKnightTitleRequirements</p><p>-- @local</p><p>    StartKnightsPromotionCelebration = function( _PlayerID , _OldTitle, _FirstTime)</p><p>        if _PlayerID ~= GUI.GetPlayerID() or Logic.GetTime() < 5 then</p><p>            return;</p><p>        end</p><p>        local MarketplaceID = Logic.GetMarketplace(_PlayerID);</p><p>        if _FirstTime == 1 then</p><p>            local KnightID = Logic.GetKnightID(_PlayerID);</p><p>            local Random</p><p>            repeat</p><p>                Random = 1 + XGUIEng.GetRandom(3)</p><p>            until Random ~= g_LastGotPromotionMessageRandom</p><p>            g_LastGotPromotionMessageRandom = Random;</p><p>            local TextKey = "Title_GotPromotion" .. Random;</p><p>            LocalScriptCallback_QueueVoiceMessage(_PlayerID, TextKey, false, _PlayerID);</p><p>            GUI.StartFestival(_PlayerID, 1);</p><p>        end</p><p>        -- reset local</p><p>        local Consume = QSB.ConsumedGoodsCounter[_PlayerID];</p><p>        QSB.ConsumedGoodsCounter[_PlayerID] = Consume or {};</p><p>        for k,v in pairs(QSB.ConsumedGoodsCounter[_PlayerID]) do</p><p>            QSB.ConsumedGoodsCounter[_PlayerID][k] = 0;</p><p>        end</p><p>        -- reset global</p><p>        GUI.SendScriptCommand([[</p><p>            local Consume = QSB.ConsumedGoodsCounter[]].._PlayerID..[[];</p><p>            QSB.ConsumedGoodsCounter[]].._PlayerID..[[] = Consume or {};</p><p>            for k,v in pairs(QSB.ConsumedGoodsCounter[]].._PlayerID..[[]) do</p><p>                QSB.ConsumedGoodsCounter[]].._PlayerID..[[][k] = 0;</p><p>            end</p><p>        ]]);</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/KnightTitleMenu", 0);</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopCenter/KnightTitleMenuBig", 0);</p><p>        g_WantsPromotionMessageInterval = 30;</p><p>        g_TimeOfPromotionPossible = nil;</p><p>    end</p><p>-- Überschreibt die Tooltips im Aufstiegsmenü.</p><p>-- @within BundleKnightTitleRequirements</p><p>-- @local</p><p>    GUI_Tooltip.SetNameAndDescription_Orig_QSB_Requirements = GUI_Tooltip.SetNameAndDescription;</p><p>    GUI_Tooltip.SetNameAndDescription = function(_TooltipNameWidget, _TooltipDescriptionWidget, _OptionalTextKeyName, _OptionalDisabledTextKeyName, _OptionalMissionTextFileBoolean)</p><p>        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();</p><p>        local Selected = GUI.GetSelectedEntity();</p><p>        local PlayerID = GUI.GetPlayerID();</p><p>        for k,v in pairs(BundleKnightTitleRequirements.Local.Data.RequirementWidgets) do</p><p>            if v .. "/Icon" == XGUIEng.GetWidgetPathByID(CurrentWidgetID) then</p><p>                local key = QSB.RequirementTooltipTypes[k];</p><p>                local num = tonumber(string.sub(key, string.len(key)));</p><p>                if num ~= nil then</p><p>                    key = string.sub(key, 1, string.len(key)-1);</p><p>                end</p><p>                BundleKnightTitleRequirements.Local:RequirementTooltipWrapped(key, num);</p><p>                return;</p><p>            end</p><p>        end</p><p>        GUI_Tooltip.SetNameAndDescription_Orig_QSB_Requirements(_TooltipNameWidget, _TooltipDescriptionWidget, _OptionalTextKeyName, _OptionalDisabledTextKeyName, _OptionalMissionTextFileBoolean);</p><p>    end</p><p>    GUI_Knight.RequiredGoodTooltip = function()</p><p>        local key = QSB.RequirementTooltipTypes[2];</p><p>        local num = tonumber(string.sub(key, string.len(key)));</p><p>        if num ~= nil then</p><p>            key = string.sub(key, 1, string.len(key)-1);</p><p>        end</p><p>        BundleKnightTitleRequirements.Local:RequirementTooltipWrapped(key, num);</p><p>    end</p><p>    if Framework.GetGameExtraNo() ~= 0 then</p><p>        BundleKnightTitleRequirements.Local.Data.BuffTypeNames[Buffs.Buff_Gems] = {</p><p>            de = "Edelsteine beschaffen", en = "Obtain gems"</p><p>        }</p><p>        BundleKnightTitleRequirements.Local.Data.BuffTypeNames[Buffs.Buff_Olibanum] = {</p><p>            de = "Weihrauch beschaffen", en = "Obtain olibanum"</p><p>        }</p><p>        BundleKnightTitleRequirements.Local.Data.BuffTypeNames[Buffs.Buff_MusicalInstrument] = {</p><p>            de = "Muskinstrumente beschaffen", en = "Obtain instruments"</p><p>        }</p><p>    end</p><p>-- Ändert die Textur eines Icons in den Aufstiegsbedingungen.</p><p>-- Icons für Aufstiegsbedingungen können sein:</p><p>-- <ul></p><p>-- <li>Koordinaten auf der Spielinternen Icon Matrix</li></p><p>-- <li>Koordinaten auf einer externen Icon Matrix (Name .. "big.png")</li></p><p>-- <li>Pfad zu einelnem Icon (200x200 Pixel)</li></p><p>-- </ul></p><p>-- @param _Widget [string] Icon Widget</p><p>-- @param _Icon [string|table] Icon Textur</p><p>-- @within BundleKnightTitleRequirements</p><p>-- @local</p><p>    if type(_Icon) == "table" then</p><p>        if type(_Icon[3]) == "string" then</p><p>            local ButtonState = 1;</p><p>            if XGUIEng.IsButton(_Widget) == 1 then</p><p>                ButtonState = 7;</p><p>            end</p><p>            local u0, u1, v0, v1;</p><p>            u0 = (_Icon[1] - 1) * 64;</p><p>            v0 = (_Icon[2] - 1) * 64;</p><p>            u1 = (_Icon[1]) * 64;</p><p>            v1 = (_Icon[2]) * 64;</p><p>            XGUIEng.SetMaterialAlpha(_Widget, ButtonState, 255);</p><p>            XGUIEng.SetMaterialTexture(_Widget, ButtonState, _Icon[3].. "big.png");</p><p>            XGUIEng.SetMaterialUV(_Widget, ButtonState, u0, v0, u1, v1);</p><p>        else</p><p>            SetIcon(_Widget, _Icon);</p><p>        end</p><p>    else</p><p>        local screenSize = {GUI.GetScreenSize()};</p><p>        local Scale = 330;</p><p>        if screenSize[2] >= 800 then</p><p>            Scale = 260;</p><p>        end</p><p>        if screenSize[2] >= 1000 then</p><p>            Scale = 210;</p><p>        end</p><p>        XGUIEng.SetMaterialAlpha(_Widget, 1, 255);</p><p>        XGUIEng.SetMaterialTexture(_Widget, 1, _file);</p><p>        XGUIEng.SetMaterialUV(_Widget, 1, 0, 0, Scale, Scale);</p><p>    end</p><p>-- Setzt einen für den Tooltip des aktuellen Widget einen neuen Text.</p><p>-- @param _Title [string] Titel des Tooltip</p><p>-- @param _Text [string] Text des Tooltip</p><p>-- @within BundleKnightTitleRequirements</p><p>-- @local</p><p>    local TooltipContainerPath = "/InGame/Root/Normal/TooltipNormal";</p><p>    local TooltipContainer = XGUIEng.GetWidgetID(TooltipContainerPath);</p><p>    local TooltipNameWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Name");</p><p>    local TooltipDescriptionWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Text");</p><p>    local TooltipBGWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/BG");</p><p>    local TooltipFadeInContainer = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn");</p><p>    local PositionWidget = XGUIEng.GetCurrentWidgetID();</p><p>    GUI_Tooltip.ResizeBG(TooltipBGWidget, TooltipDescriptionWidget);</p><p>    local TooltipContainerSizeWidgets = {TooltipBGWidget};</p><p>    GUI_Tooltip.SetPosition(TooltipContainer, TooltipContainerSizeWidgets, PositionWidget);</p><p>    GUI_Tooltip.FadeInTooltip(TooltipFadeInContainer);</p><p>    XGUIEng.SetText(TooltipNameWidget, "{center}" .. _Title);</p><p>    XGUIEng.SetText(TooltipDescriptionWidget, _Text);</p><p>    local Height = XGUIEng.GetTextHeight(TooltipDescriptionWidget, true);</p><p>    local W, H = XGUIEng.GetWidgetSize(TooltipDescriptionWidget);</p><p>    XGUIEng.SetWidgetSize(TooltipDescriptionWidget, W, Height);</p><p>-- Ermittelt die veränderten Texte für den Tooltip hinter dem angegebenen Key.</p><p>-- @param _key [string] Index in Description</p><p>-- @param _i   [number] Buttonindex</p><p>-- @within BundleKnightTitleRequirements</p><p>-- @local</p><p>    local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>    local PlayerID = GUI.GetPlayerID();</p><p>    local KnightTitle = Logic.GetKnightTitle(PlayerID);</p><p>    local Title = ""</p><p>    local Text = "";</p><p>    if _key == "Consume" or _key == "Goods" or _key == "DecoratedBuildings" then</p><p>        local GoodType     = KnightTitleRequirements[KnightTitle+1][_key][_i][1];</p><p>        local GoodTypeName = Logic.GetGoodTypeName(GoodType);</p><p>        local GoodName     = XGUIEng.GetStringTableText("UI_ObjectNames/" .. GoodTypeName);</p><p>        if GoodName == nil then</p><p>            GoodName = "Goods." .. GoodTypeName;</p><p>        end</p><p>        Title = GoodName;</p><p>        Text  = BundleKnightTitleRequirements.Local.Data.Description[_key].Text;</p><p>    elseif _key == "Products" then</p><p>        local GoodCategoryNames = BundleKnightTitleRequirements.Local.Data.GoodCategoryNames;</p><p>        local Category = KnightTitleRequirements[KnightTitle+1][_key][_i][1];</p><p>        local CategoryName = GoodCategoryNames[Category][lang];</p><p>        if CategoryName == nil then</p><p>            CategoryName = "ERROR: Name missng!";</p><p>        end</p><p>        Title = CategoryName;</p><p>        Text  = BundleKnightTitleRequirements.Local.Data.Description[_key].Text;</p><p>    elseif _key == "Entities" then</p><p>        local EntityType     = KnightTitleRequirements[KnightTitle+1][_key][_i][1];</p><p>        local EntityTypeName = Logic.GetEntityTypeName(EntityType);</p><p>        local EntityName = XGUIEng.GetStringTableText("Names/" .. EntityTypeName);</p><p>        if EntityName == nil then</p><p>            EntityName = "Entities." .. EntityTypeName;</p><p>        end</p><p>        Title = EntityName;</p><p>        Text  = BundleKnightTitleRequirements.Local.Data.Description[_key].Text;</p><p>    elseif _key == "Custom" then</p><p>        local Custom = KnightTitleRequirements[KnightTitle+1].Custom[_i];</p><p>        Title = Custom[3];</p><p>        Text  = Custom[4];</p><p>    elseif _key == "Buff" then</p><p>        local BuffTypeNames = BundleKnightTitleRequirements.Local.Data.BuffTypeNames;</p><p>        local BuffType = KnightTitleRequirements[KnightTitle+1][_key][_i];</p><p>        local BuffTitle = BuffTypeNames[BuffType][lang];</p><p>        if BuffTitle == nil then</p><p>            BuffTitle = "ERROR: Name missng!";</p><p>        end</p><p>        Title = BuffTitle;</p><p>        Text  = BundleKnightTitleRequirements.Local.Data.Description[_key].Text;</p><p>    else</p><p>        Title = BundleKnightTitleRequirements.Local.Data.Description[_key].Title;</p><p>        Text  = BundleKnightTitleRequirements.Local.Data.Description[_key].Text;</p><p>    end</p><p>    Title = (type(Title) == "table" and Title[lang]) or Title;</p><p>    Text  = (type(Text) == "table" and Text[lang]) or Text;</p><p>    self:RequirementTooltip(Title, Text);</p><p>    [1] = "/InGame/Root/Normal/AlignBottomRight/KnightTitleMenu/Requirements/Settlers",</p><p>    [2] = "/InGame/Root/Normal/AlignBottomRight/KnightTitleMenu/Requirements/Goods",</p><p>    [3] = "/InGame/Root/Normal/AlignBottomRight/KnightTitleMenu/Requirements/RichBuildings",</p><p>    [4] = "/InGame/Root/Normal/AlignBottomRight/KnightTitleMenu/Requirements/Castle",</p><p>    [5] = "/InGame/Root/Normal/AlignBottomRight/KnightTitleMenu/Requirements/Storehouse",</p><p>    [6] = "/InGame/Root/Normal/AlignBottomRight/KnightTitleMenu/Requirements/Cathedral",</p><p>    [GoodCategories.GC_Ammunition]      = {de = "Munition", en = "Ammunition"},</p><p>    [GoodCategories.GC_Animal]          = {de = "Nutztiere", en = "Livestock"},</p><p>    [GoodCategories.GC_Clothes]         = {de = "Kleidung", en = "Clothes"},</p><p>    [GoodCategories.GC_Document]        = {de = "Dokumente", en = "Documents"},</p><p>    [GoodCategories.GC_Entertainment]   = {de = "Unterhaltung", en = "Entertainment"},</p><p>    [GoodCategories.GC_Food]            = {de = "Nahrungsmittel", en = "Food"},</p><p>    [GoodCategories.GC_Gold]            = {de = "Gold", en = "Gold"},</p><p>    [GoodCategories.GC_Hygiene]         = {de = "Hygieneartikel", en = "Hygiene"},</p><p>    [GoodCategories.GC_Luxury]          = {de = "Dekoration", en = "Decoration"},</p><p>    [GoodCategories.GC_Medicine]        = {de = "Medizin", en = "Medicine"},</p><p>    [GoodCategories.GC_None]            = {de = "Nichts", en = "None"},</p><p>    [GoodCategories.GC_RawFood]         = {de = "Nahrungsmittel", en = "Food"},</p><p>    [GoodCategories.GC_RawMedicine]     = {de = "Medizin", en = "Medicine"},</p><p>    [GoodCategories.GC_Research]        = {de = "Forschung", en = "Research"},</p><p>    [GoodCategories.GC_Resource]        = {de = "Rohstoffe", en = "Resource"},</p><p>    [GoodCategories.GC_Tools]           = {de = "Werkzeug", en = "Tools"},</p><p>    [GoodCategories.GC_Water]           = {de = "Wasser", en = "Water"},</p><p>    [GoodCategories.GC_Weapon]          = {de = "Waffen", en = "Weapon"},</p><p>    [Buffs.Buff_ClothesDiversity]        = {de = "Abwechslungsreiche Kleidung", en = "Clothes diversity"},</p><p>    [Buffs.Buff_Colour]                  = {de = "Farben beschaffen", en = "Obtain color"},</p><p>    -- Funktioniert nicht, belegt MP</p><p>    [Buffs.Buff_Entertainers]            = {de = "Gaukler anheuern", en = "Hire entertainer"},</p><p>    [Buffs.Buff_EntertainmentDiversity]  = {de = "Abwechslungsreiche Unterhaltung", en = "Entertainment diversity"},</p><p>    [Buffs.Buff_ExtraPayment]            = {de = "Sonderzahlung", en = "Extra payment"},</p><p>    -- Funktioniert nicht, belegt MP</p><p>    [Buffs.Buff_Festival]                = {de = "Fest veranstalten", en = "Hold Festival"},</p><p>    [Buffs.Buff_FoodDiversity]           = {de = "Abwechslungsreiche Nahrung", en = "Food diversity"},</p><p>    [Buffs.Buff_HygieneDiversity]        = {de = "Abwechslungsreiche Hygiene", en = "Hygiene diversity"},</p><p>    [Buffs.Buff_NoTaxes]                 = {de = "Steuerbefreiung", en = "No taxes"},</p><p>    [Buffs.Buff_Sermon]                  = {de = "Pregigt abhalten", en = "Hold sermon"},</p><p>    [Buffs.Buff_Spice]                   = {de = "Salz beschaffen", en = "Obtain salt"},</p><p>    Settlers = {</p><p>        Title = {</p><p>            de = "Benötigte Siedler",</p><p>            en = "Needed settlers",</p><p>        },</p><p>        Text = {</p><p>            de = "- Benötigte Menge an Siedlern",</p><p>            en = "- Needed number of settlers",</p><p>        },</p><p>    },</p><p>    RichBuildings = {</p><p>        Title = {</p><p>            de = "Reiche Stadtgebäude",</p><p>            en = "Rich city buildings",</p><p>        },</p><p>        Text = {</p><p>            de = "- Menge an reichen Stadtgebäuden",</p><p>            en = "- Needed amount of rich city buildings",</p><p>        },</p><p>    },</p><p>    Goods = {</p><p>        Title = {</p><p>            de = "Waren lagern",</p><p>            en = "Store Goods",</p><p>        },</p><p>        Text = {</p><p>            de = "- Benötigte Menge",</p><p>            en = "- Needed amount",</p><p>        },</p><p>    },</p><p>    FullDecoratedBuildings = {</p><p>        Title = {</p><p>            de = "Dekorierte Stadtgebäude",</p><p>            en = "Decorated City buildings",</p><p>        },</p><p>        Text = {</p><p>            de = "- Menge an voll dekorierten Gebäuden",</p><p>            en = "- Amount of full decoraded city buildings",</p><p>        },</p><p>    },</p><p>    DecoratedBuildings = {</p><p>        Title = {</p><p>            de = "Dekoration",</p><p>            en = "Decoration",</p><p>        },</p><p>        Text = {</p><p>            de = "- Menge an Dekorationsgütern in der Siedlung",</p><p>            en = "- Amount of decoration goods in settlement",</p><p>        },</p><p>    },</p><p>    Headquarters = {</p><p>        Title = {</p><p>            de = "Burgstufe",</p><p>            en = "Castle level",</p><p>        },</p><p>        Text = {</p><p>            de = "- Benötigte Ausbauten der Burg",</p><p>            en = "- Needed castle upgrades",</p><p>        },</p><p>    },</p><p>    Storehouse = {</p><p>        Title = {</p><p>            de = "Lagerhausstufe",</p><p>            en = "Storehouse level",</p><p>        },</p><p>        Text = {</p><p>            de = "- Benötigte Ausbauten des Lagerhauses",</p><p>            en = "- Needed storehouse upgrades",</p><p>        },</p><p>    },</p><p>    Cathedrals = {</p><p>        Title = {</p><p>            de = "Kirchenstufe",</p><p>            en = "Cathedral level",</p><p>        },</p><p>        Text = {</p><p>            de = "- Benötigte Ausbauten der Kirche",</p><p>            en = "- Needed cathedral upgrades",</p><p>        },</p><p>    },</p><p>    Reputation = {</p><p>        Title = {</p><p>            de = "Ruf der Stadt",</p><p>            en = "City reputation",</p><p>        },</p><p>        Text = {</p><p>            de = "- Benötigter Ruf der Stadt",</p><p>            en = "- Needed city reputation",</p><p>        },</p><p>    },</p><p>    EntityCategoryDefault = {</p><p>        Title = {</p><p>            de = "",</p><p>            en = "",</p><p>        },</p><p>        Text = {</p><p>            de = "- Benötigte Anzahl",</p><p>            en = "- Needed amount",</p><p>        },</p><p>    },</p><p>    Cattle = {</p><p>        Title = {</p><p>            de = "Kühe",</p><p>            en = "Cattle",</p><p>        },</p><p>        Text = {</p><p>            de = "- Benötigte Menge an Kühen",</p><p>            en = "- Needed amount of cattle",</p><p>        },</p><p>    },</p><p>    Sheep = {</p><p>        Title = {</p><p>            de = "Schafe",</p><p>            en = "Sheeps",</p><p>        },</p><p>        Text = {</p><p>            de = "- Benötigte Menge an Schafen",</p><p>            en = "- Needed amount of sheeps",</p><p>        },</p><p>    },</p><p>    Outposts = {</p><p>        Title = {</p><p>            de = "Territorien",</p><p>            en = "Territories",</p><p>        },</p><p>        Text = {</p><p>            de = "- Zu erobernde Territorien",</p><p>            en = "- Territories to claim",</p><p>        },</p><p>    },</p><p>    CityBuilding = {</p><p>        Title = {</p><p>            de = "Stadtgebäude",</p><p>            en = "City buildings",</p><p>        },</p><p>        Text = {</p><p>            de = "- Menge benötigter Stadtgebäude",</p><p>            en = "- Needed amount of city buildings",</p><p>        },</p><p>    },</p><p>    OuterRimBuilding = {</p><p>        Title = {</p><p>            de = "Rohstoffgebäude",</p><p>            en = "Gatherer",</p><p>        },</p><p>        Text = {</p><p>            de = "- Menge benötigter Rohstoffgebäude",</p><p>            en = "- Needed amount of gatherer",</p><p>        },</p><p>    },</p><p>    Consume = {</p><p>        Title = {</p><p>            de = "",</p><p>            en = "",</p><p>        },</p><p>        Text = {</p><p>            de = "- Durch Siedler zu konsumierende Menge",</p><p>            en = "- Amount to be consumed by the settlers",</p><p>        },</p><p>    },</p><p>    Products = {</p><p>        Title = {</p><p>            de = "",</p><p>            en = "",</p><p>        },</p><p>        Text = {</p><p>            de = "- Benötigte Menge",</p><p>            en = "- Needed amount",</p><p>        },</p><p>    },</p><p>    Buff = {</p><p>        Title = {</p><p>            de = "Bonus aktivieren",</p><p>            en = "Activate Buff",</p><p>        },</p><p>        Text = {</p><p>            de = "- Aktiviere diesen Bonus auf den Ruf der Stadt",</p><p>            en = "- Raise the city reputatition with this buff",</p><p>        },</p><p>    },</p><p>    Leader = {</p><p>        Title = {</p><p>            de = "Batalione",</p><p>            en = "Battalions",</p><p>        },</p><p>        Text = {</p><p>            de = "- Menge an Batalionen unterhalten",</p><p>            en = "- Battalions you need under your command",</p><p>        },</p><p>    },</p><p>    Soldiers = {</p><p>        Title = {</p><p>            de = "Soldaten",</p><p>            en = "Soldiers",</p><p>        },</p><p>        Text = {</p><p>            de = "- Menge an Streitkräften unterhalten",</p><p>            en = "- Soldiers you need under your command",</p><p>        },</p><p>    },</p><p>    Worker = {</p><p>        Title = {</p><p>            de = "Arbeiter",</p><p>            en = "Workers",</p><p>        },</p><p>        Text = {</p><p>            de = "- Menge an arbeitender Bevölkerung",</p><p>            en = "- Workers you need under your reign",</p><p>        },</p><p>    },</p><p>    Entities = {</p><p>        Title = {</p><p>            de = "",</p><p>            en = "",</p><p>        },</p><p>        Text = {</p><p>            de = "- Benötigte Menge",</p><p>            en = "- Needed Amount",</p><p>        },</p><p>    },</p><p>    Buildings = {</p><p>        Title = {</p><p>            de = "Gebäude",</p><p>            en = "Buildings",</p><p>        },</p><p>        Text = {</p><p>            de = "- Gesamtmenge an Gebäuden",</p><p>            en = "- Amount of buildings",</p><p>        },</p><p>    },</p><p>    Weapons = {</p><p>        Title = {</p><p>            de = "Waffen",</p><p>            en = "Weapons",</p><p>        },</p><p>        Text = {</p><p>            de = "- Benötigte Menge an Waffen",</p><p>            en = "- Needed amount of weapons",</p><p>        },</p><p>    },</p><p>    HeavyWeapons = {</p><p>        Title = {</p><p>            de = "Belagerungsgeräte",</p><p>            en = "Siege Engines",</p><p>        },</p><p>        Text = {</p><p>            de = "- Benötigte Menge an Belagerungsgeräten",</p><p>            en = "- Needed amount of siege engine",</p><p>        },</p><p>    },</p><p>    Spouse = {</p><p>        Title = {</p><p>            de = "Ehefrauen",</p><p>            en = "Spouses",</p><p>        },</p><p>        Text = {</p><p>            de = "- Benötigte Anzahl Ehefrauen in der Stadt",</p><p>            en = "- Needed amount of spouses in your city",</p><p>        },</p><p>    },</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Spielfunktionen                                                            --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Prüft, ob genug Entities in einer bestimmten Kategorie existieren.</p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @param _KnightTitle [number] Nächster Titel</p><p>-- @param _i [number] Button Index</p><p>-- @within Originalfunktionen</p><p>-- @local</p><p>    if KnightTitleRequirements[_KnightTitle].Category == nil then</p><p>        return;</p><p>    end</p><p>    if _i then</p><p>        local EntityCategory = KnightTitleRequirements[_KnightTitle].Category[_i][1];</p><p>        local NeededAmount = KnightTitleRequirements[_KnightTitle].Category[_i][2];</p><p>        local ReachedAmount = 0;</p><p>        if EntityCategory == EntityCategories.Spouse then</p><p>            ReachedAmount = Logic.GetNumberOfSpouses(_PlayerID);</p><p>        else</p><p>            local Buildings = {Logic.GetPlayerEntitiesInCategory(_PlayerID, EntityCategory)};</p><p>            for i=1, #Buildings do</p><p>                if Logic.IsBuilding(Buildings[i]) == 1 then</p><p>                    if Logic.IsConstructionComplete(Buildings[i]) == 1 then</p><p>                        ReachedAmount = ReachedAmount +1;</p><p>                    end</p><p>                else</p><p>                    ReachedAmount = ReachedAmount +1;</p><p>                end</p><p>            end</p><p>        end</p><p>        if ReachedAmount >= NeededAmount then</p><p>            return true, ReachedAmount, NeededAmount;</p><p>        end</p><p>        return false, ReachedAmount, NeededAmount;</p><p>    else</p><p>        local bool, reach, need;</p><p>        for i=1,#KnightTitleRequirements[_KnightTitle].Category do</p><p>            bool, reach, need = DoesNeededNumberOfEntitiesInCategoryForKnightTitleExist(_PlayerID, _KnightTitle, i);</p><p>            if bool == false then</p><p>                return bool, reach, need</p><p>            end</p><p>        end</p><p>        return bool;</p><p>    end</p><p>-- Prüft, ob genug Entities eines bestimmten Typs existieren.</p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @param _KnightTitle [number] Nächster Titel</p><p>-- @param _i [number] Button Index</p><p>-- @within Originalfunktionen</p><p>-- @local</p><p>    if KnightTitleRequirements[_KnightTitle].Entities == nil then</p><p>        return;</p><p>    end</p><p>    if _i then</p><p>        local EntityType = KnightTitleRequirements[_KnightTitle].Entities[_i][1];</p><p>        local NeededAmount = KnightTitleRequirements[_KnightTitle].Entities[_i][2];</p><p>        local Buildings = GetPlayerEntities(_PlayerID, EntityType);</p><p>        local ReachedAmount = 0;</p><p>        for i=1, #Buildings do</p><p>            if Logic.IsBuilding(Buildings[i]) == 1 then</p><p>                if Logic.IsConstructionComplete(Buildings[i]) == 1 then</p><p>                    ReachedAmount = ReachedAmount +1;</p><p>                end</p><p>            else</p><p>                ReachedAmount = ReachedAmount +1;</p><p>            end</p><p>        end</p><p>        if ReachedAmount >= NeededAmount then</p><p>            return true, ReachedAmount, NeededAmount;</p><p>        end</p><p>        return false, ReachedAmount, NeededAmount;</p><p>    else</p><p>        local bool, reach, need;</p><p>        for i=1,#KnightTitleRequirements[_KnightTitle].Entities do</p><p>            bool, reach, need = DoesNeededNumberOfEntitiesOfTypeForKnightTitleExist(_PlayerID, _KnightTitle, i);</p><p>            if bool == false then</p><p>                return bool, reach, need</p><p>            end</p><p>        end</p><p>        return bool;</p><p>    end</p><p>-- Prüft, ob es genug Einheiten eines Warentyps gibt.</p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @param _KnightTitle [number] Nächster Titel</p><p>-- @param _i [number] Button Index</p><p>-- @within Originalfunktionen</p><p>-- @local</p><p>    if KnightTitleRequirements[_KnightTitle].Goods == nil then</p><p>        return;</p><p>    end</p><p>    if _i then</p><p>        local GoodType = KnightTitleRequirements[_KnightTitle].Goods[_i][1];</p><p>        local NeededAmount = KnightTitleRequirements[_KnightTitle].Goods[_i][2];</p><p>        local ReachedAmount = GetPlayerGoodsInSettlement(GoodType, _PlayerID, true);</p><p>        if ReachedAmount >= NeededAmount then</p><p>            return true, ReachedAmount, NeededAmount;</p><p>        end</p><p>        return false, ReachedAmount, NeededAmount;</p><p>    else</p><p>        local bool, reach, need;</p><p>        for i=1,#KnightTitleRequirements[_KnightTitle].Goods do</p><p>            bool, reach, need = DoesNeededNumberOfGoodTypesForKnightTitleExist(_PlayerID, _KnightTitle, i);</p><p>            if bool == false then</p><p>                return bool, reach, need</p><p>            end</p><p>        end</p><p>        return bool;</p><p>    end</p><p>-- Prüft, ob die Siedler genug Einheiten einer Ware konsumiert haben.</p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @param _KnightTitle [number] Nächster Titel</p><p>-- @param _i [number] Button Index</p><p>-- @within Originalfunktionen</p><p>-- @local</p><p>    if KnightTitleRequirements[_KnightTitle].Consume == nil then</p><p>        return;</p><p>    end</p><p>    if _i then</p><p>        QSB.ConsumedGoodsCounter[_PlayerID] = QSB.ConsumedGoodsCounter[_PlayerID] or {};</p><p>        local GoodType = KnightTitleRequirements[_KnightTitle].Consume[_i][1];</p><p>        local GoodAmount = QSB.ConsumedGoodsCounter[_PlayerID][GoodType] or 0;</p><p>        local NeededGoodAmount = KnightTitleRequirements[_KnightTitle].Consume[_i][2];</p><p>        if GoodAmount >= NeededGoodAmount then</p><p>            return true, GoodAmount, NeededGoodAmount;</p><p>        else</p><p>            return false, GoodAmount, NeededGoodAmount;</p><p>        end</p><p>    else</p><p>        local bool, reach, need;</p><p>        for i=1,#KnightTitleRequirements[_KnightTitle].Consume do</p><p>            bool, reach, need = DoNeededNumberOfConsumedGoodsForKnightTitleExist(_PlayerID, _KnightTitle, i);</p><p>            if bool == false then</p><p>                return false, reach, need</p><p>            end</p><p>        end</p><p>        return true, reach, need;</p><p>    end</p><p>-- Prüft, ob genug Waren der Kategorie hergestellt wurde.</p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @param _KnightTitle [number] Nächster Titel</p><p>-- @param _i [number] Button Index</p><p>-- @within Originalfunktionen</p><p>-- @local</p><p>    if KnightTitleRequirements[_KnightTitle].Products == nil then</p><p>        return;</p><p>    end</p><p>    if _i then</p><p>        local GoodAmount = 0;</p><p>        local NeedAmount = KnightTitleRequirements[_KnightTitle].Products[_i][2];</p><p>        local GoodCategory = KnightTitleRequirements[_KnightTitle].Products[_i][1];</p><p>        local GoodsInCategory = {Logic.GetGoodTypesInGoodCategory(GoodCategory)};</p><p>        for i=1, #GoodsInCategory do</p><p>            GoodAmount = GoodAmount + GetPlayerGoodsInSettlement(GoodsInCategory[i], _PlayerID, true);</p><p>        end</p><p>        return (GoodAmount >= NeedAmount), GoodAmount, NeedAmount;</p><p>    else</p><p>        local bool, reach, need;</p><p>        for i=1,#KnightTitleRequirements[_KnightTitle].Products do</p><p>            bool, reach, need = DoNumberOfProductsInCategoryExist(_PlayerID, _KnightTitle, i);</p><p>            if bool == false then</p><p>                return bool, reach, need</p><p>            end</p><p>        end</p><p>        return bool;</p><p>    end</p><p>-- Prüft, ob ein bestimmter Buff für den Spieler aktiv ist.</p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @param _KnightTitle [number] Nächster Titel</p><p>-- @param _i [number] Button Index</p><p>-- @within Originalfunktionen</p><p>-- @local</p><p>    if KnightTitleRequirements[_KnightTitle].Buff == nil then</p><p>        return;</p><p>    end</p><p>    if _i then</p><p>        local buff = KnightTitleRequirements[_KnightTitle].Buff[_i];</p><p>        if Logic.GetBuff(_PlayerID,buff) and Logic.GetBuff(_PlayerID,buff) ~= 0 then</p><p>            return true;</p><p>        end</p><p>        return false;</p><p>    else</p><p>        local bool, reach, need;</p><p>        for i=1,#KnightTitleRequirements[_KnightTitle].Buff do</p><p>            bool, reach, need = DoNeededDiversityBuffForKnightTitleExist(_PlayerID, _KnightTitle, i);</p><p>            if bool == false then</p><p>                return bool, reach, need</p><p>            end</p><p>        end</p><p>        return bool;</p><p>    end</p><p>-- Prüft, ob die Custom Function true vermeldet.</p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @param _KnightTitle [number] Nächster Titel</p><p>-- @param _i [number] Button Index</p><p>-- @within Originalfunktionen</p><p>-- @local</p><p>    if KnightTitleRequirements[_KnightTitle].Custom == nil then</p><p>        return;</p><p>    end</p><p>    if _i then</p><p>        return KnightTitleRequirements[_KnightTitle].Custom[_i][1]();</p><p>    else</p><p>        local bool, reach, need;</p><p>        for i=1,#KnightTitleRequirements[_KnightTitle].Custom do</p><p>            bool, reach, need = DoCustomFunctionForKnightTitleSucceed(_PlayerID, _KnightTitle, i);</p><p>            if bool == false then</p><p>                return bool, reach, need</p><p>            end</p><p>        end</p><p>        return bool;</p><p>    end</p><p>-- Prüft, ob genug Dekoration eines Typs angebracht wurde.</p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @param _KnightTitle [number] Nächster Titel</p><p>-- @param _i [number] Button Index</p><p>-- @within Originalfunktionen</p><p>-- @local</p><p>    if KnightTitleRequirements[_KnightTitle].DecoratedBuildings == nil then</p><p>        return</p><p>    end</p><p>    if _i then</p><p>        local CityBuildings = {Logic.GetPlayerEntitiesInCategory(_PlayerID, EntityCategories.CityBuilding)}</p><p>        local DecorationGoodType = KnightTitleRequirements[_KnightTitle].DecoratedBuildings[_i][1]</p><p>        local NeededBuildingsWithDecoration = KnightTitleRequirements[_KnightTitle].DecoratedBuildings[_i][2]</p><p>        local BuildingsWithDecoration = 0</p><p>        for i=1, #CityBuildings do</p><p>            local BuildingID = CityBuildings[i]</p><p>            local GoodState = Logic.GetBuildingWealthGoodState(BuildingID, DecorationGoodType)</p><p>            if GoodState > 0 then</p><p>                BuildingsWithDecoration = BuildingsWithDecoration + 1</p><p>            end</p><p>        end</p><p>        if BuildingsWithDecoration >= NeededBuildingsWithDecoration then</p><p>            return true, BuildingsWithDecoration, NeededBuildingsWithDecoration</p><p>        else</p><p>            return false, BuildingsWithDecoration, NeededBuildingsWithDecoration</p><p>        end</p><p>    else</p><p>        local bool, reach, need;</p><p>        for i=1,#KnightTitleRequirements[_KnightTitle].DecoratedBuildings do</p><p>            bool, reach, need = DoNeededNumberOfDecoratedBuildingsForKnightTitleExist(_PlayerID, _KnightTitle, i);</p><p>            if bool == false then</p><p>                return bool, reach, need</p><p>            end</p><p>        end</p><p>        return bool;</p><p>    end</p><p>-- Prüft, ob die Spezialgebäude weit genug ausgebaut sind.</p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @param _KnightTitle [number] Nächster Titel</p><p>-- @param _EntityCategory Entity Category</p><p>-- @within Originalfunktionen</p><p>-- @local</p><p>    local SpecialBuilding</p><p>    local SpecialBuildingName</p><p>    if _EntityCategory == EntityCategories.Headquarters then</p><p>        SpecialBuilding = Logic.GetHeadquarters(_PlayerID)</p><p>        SpecialBuildingName = "Headquarters"</p><p>    elseif _EntityCategory == EntityCategories.Storehouse then</p><p>        SpecialBuilding = Logic.GetStoreHouse(_PlayerID)</p><p>        SpecialBuildingName = "Storehouse"</p><p>    elseif _EntityCategory == EntityCategories.Cathedrals then</p><p>        SpecialBuilding = Logic.GetCathedral(_PlayerID)</p><p>        SpecialBuildingName = "Cathedrals"</p><p>    else</p><p>        return</p><p>    end</p><p>    if KnightTitleRequirements[_KnightTitle][SpecialBuildingName] == nil then</p><p>        return</p><p>    end</p><p>    local NeededUpgradeLevel = KnightTitleRequirements[_KnightTitle][SpecialBuildingName]</p><p>    if SpecialBuilding ~= nil then</p><p>        local SpecialBuildingUpgradeLevel = Logic.GetUpgradeLevel(SpecialBuilding)</p><p>        if SpecialBuildingUpgradeLevel >= NeededUpgradeLevel then</p><p>            return true, SpecialBuildingUpgradeLevel, NeededUpgradeLevel</p><p>        else</p><p>            return false, SpecialBuildingUpgradeLevel, NeededUpgradeLevel</p><p>        end</p><p>    else</p><p>        return false, 0, NeededUpgradeLevel</p><p>    end</p><p>-- Prüft, ob der Ruf der Stadt hoch genug ist.</p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @param _KnightTitle [number] Nächster Titel</p><p>-- @within Originalfunktionen</p><p>-- @local</p><p>    if KnightTitleRequirements[_KnightTitle].Reputation == nil then</p><p>        return;</p><p>    end</p><p>    local NeededAmount = KnightTitleRequirements[_KnightTitle].Reputation;</p><p>    if not NeededAmount then</p><p>        return;</p><p>    end</p><p>    local ReachedAmount = math.floor((Logic.GetCityReputation(_PlayerID) * 100) + 0.5);</p><p>    if ReachedAmount >= NeededAmount then</p><p>        return true, ReachedAmount, NeededAmount;</p><p>    end</p><p>    return false, ReachedAmount, NeededAmount;</p><p>-- Prüft, ob genug Gebäude vollständig dekoriert sind.</p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @param _KnightTitle [number] Nächster Titel</p><p>-- @within Originalfunktionen</p><p>-- @local</p><p>    if KnightTitleRequirements[_KnightTitle].FullDecoratedBuildings == nil then</p><p>        return</p><p>    end</p><p>    local CityBuildings = {Logic.GetPlayerEntitiesInCategory(_PlayerID, EntityCategories.CityBuilding)}</p><p>    local NeededBuildingsWithDecoration = KnightTitleRequirements[_KnightTitle].FullDecoratedBuildings</p><p>    local BuildingsWithDecoration = 0</p><p>    for i=1, #CityBuildings do</p><p>        local BuildingID = CityBuildings[i]</p><p>        local AmountOfWealthGoodsAtBuilding = 0</p><p>        if Logic.GetBuildingWealthGoodState(BuildingID, Goods.G_Banner ) > 0 then</p><p>            AmountOfWealthGoodsAtBuilding = AmountOfWealthGoodsAtBuilding  + 1</p><p>        end</p><p>        if Logic.GetBuildingWealthGoodState(BuildingID, Goods.G_Sign  ) > 0 then</p><p>            AmountOfWealthGoodsAtBuilding = AmountOfWealthGoodsAtBuilding  + 1</p><p>        end</p><p>        if Logic.GetBuildingWealthGoodState(BuildingID, Goods.G_Candle) > 0 then</p><p>            AmountOfWealthGoodsAtBuilding = AmountOfWealthGoodsAtBuilding  + 1</p><p>        end</p><p>        if Logic.GetBuildingWealthGoodState(BuildingID, Goods.G_Ornament  ) > 0 then</p><p>            AmountOfWealthGoodsAtBuilding = AmountOfWealthGoodsAtBuilding  + 1</p><p>        end</p><p>        if AmountOfWealthGoodsAtBuilding >= 4 then</p><p>            BuildingsWithDecoration = BuildingsWithDecoration + 1</p><p>        end</p><p>    end</p><p>    if BuildingsWithDecoration >= NeededBuildingsWithDecoration then</p><p>        return true, BuildingsWithDecoration, NeededBuildingsWithDecoration</p><p>    else</p><p>        return false, BuildingsWithDecoration, NeededBuildingsWithDecoration</p><p>    end</p><p>-- Prüft, ob der Spieler befördert werden kann.</p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @param _KnightTitle [number] Nächster Titel</p><p>-- @within Originalfunktionen</p><p>-- @local</p><p>    if _KnightTitle == nil then</p><p>        _KnightTitle = Logic.GetKnightTitle(_PlayerID) + 1;</p><p>    end</p><p>    if Logic.CanStartFestival(_PlayerID, 1) == true then</p><p>        if  KnightTitleRequirements[_KnightTitle] ~= nil</p><p>        and DoesNeededNumberOfSettlersForKnightTitleExist(_PlayerID, _KnightTitle) ~= false</p><p>        and DoNeededNumberOfGoodsForKnightTitleExist( _PlayerID, _KnightTitle)  ~= false</p><p>        and DoNeededSpecialBuildingUpgradeForKnightTitleExist( _PlayerID, _KnightTitle, EntityCategories.Headquarters) ~= false</p><p>        and DoNeededSpecialBuildingUpgradeForKnightTitleExist( _PlayerID, _KnightTitle, EntityCategories.Storehouse) ~= false</p><p>        and DoNeededSpecialBuildingUpgradeForKnightTitleExist( _PlayerID, _KnightTitle, EntityCategories.Cathedrals)  ~= false</p><p>        and DoNeededNumberOfRichBuildingsForKnightTitleExist( _PlayerID, _KnightTitle)  ~= false</p><p>        and DoNeededNumberOfFullDecoratedBuildingsForKnightTitleExist( _PlayerID, _KnightTitle) ~= false</p><p>        and DoNeededNumberOfDecoratedBuildingsForKnightTitleExist( _PlayerID, _KnightTitle) ~= false</p><p>        and DoesNeededCityReputationForKnightTitleExist( _PlayerID, _KnightTitle) ~= false</p><p>        and DoesNeededNumberOfEntitiesInCategoryForKnightTitleExist( _PlayerID, _KnightTitle) ~= false</p><p>        and DoesNeededNumberOfEntitiesOfTypeForKnightTitleExist( _PlayerID, _KnightTitle) ~= false</p><p>        and DoesNeededNumberOfGoodTypesForKnightTitleExist( _PlayerID, _KnightTitle) ~= false</p><p>        and DoNeededDiversityBuffForKnightTitleExist( _PlayerID, _KnightTitle) ~= false</p><p>        and DoCustomFunctionForKnightTitleSucceed( _PlayerID, _KnightTitle) ~= false</p><p>        and DoNeededNumberOfConsumedGoodsForKnightTitleExist( _PlayerID, _KnightTitle) ~= false</p><p>        and DoNumberOfProductsInCategoryExist( _PlayerID, _KnightTitle) ~= false then</p><p>            return true;</p><p>        end</p><p>    end</p><p>    return false;</p><p>-- Der Spieler gewinnt das Spiel</p><p>-- @within Originalfunktionen</p><p>-- @local</p><p>    QuestTemplate:TerminateEventsAndStuff();</p><p>    Victory(g_VictoryAndDefeatType.VictoryMissionComplete);</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Aufstiegsbedingungen                                                       --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Definiert andere Aufstiegsbedingungen für den Spieler. Muss stets nach dem</p><p>-- Laden der QSB im globalen und lokalen Skript aufgerufen werden!</p><p>-- Diese Funktion muss entweder in der QSB modifiziert oder sowohl im globalen</p><p>-- als auch im lokalen Skript überschrieben werden. Bei Modifikationen muss</p><p>-- das Schema für Aufstiegsbedingungen und Rechtevergabe immer beibehalten</p><p>-- werden.</p><p>-- @within Originalfunktionen</p><p>    KnightTitles = {}</p><p>    KnightTitles.Knight     = 0</p><p>    KnightTitles.Mayor      = 1</p><p>    KnightTitles.Baron      = 2</p><p>    KnightTitles.Earl       = 3</p><p>    KnightTitles.Marquees   = 4</p><p>    KnightTitles.Duke       = 5</p><p>    KnightTitles.Archduke   = 6</p><p>    -- ---------------------------------------------------------------------- --</p><p>    -- Rechte und Pflichten                                                   --</p><p>    -- ---------------------------------------------------------------------- --</p><p>    NeedsAndRightsByKnightTitle ={}</p><p>    -- Ritter ------------------------------------------------------------------</p><p>    NeedsAndRightsByKnightTitle[KnightTitles.Knight] = {</p><p>        ActivateNeedForPlayer,</p><p>        {</p><p>            Needs.Nutrition,                                    -- Bedürfnis: Nahrung</p><p>            Needs.Medicine,                                     -- Bedürfnis: Medizin</p><p>        },</p><p>        ActivateRightForPlayer,</p><p>        {</p><p>            Technologies.R_Gathering,                           -- Recht: Rohstoffsammler</p><p>            Technologies.R_Woodcutter,                          -- Recht: Holzfäller</p><p>            Technologies.R_StoneQuarry,                         -- Recht: Steinbruch</p><p>            Technologies.R_HuntersHut,                          -- Recht: Jägerhütte</p><p>            Technologies.R_FishingHut,                          -- Recht: Fischerhütte</p><p>            Technologies.R_CattleFarm,                          -- Recht: Kuhfarm</p><p>            Technologies.R_GrainFarm,                           -- Recht: Getreidefarm</p><p>            Technologies.R_SheepFarm,                           -- Recht: Schaffarm</p><p>            Technologies.R_IronMine,                            -- Recht: Eisenmine</p><p>            Technologies.R_Beekeeper,                           -- Recht: Imkerei</p><p>            Technologies.R_HerbGatherer,                        -- Recht: Kräutersammler</p><p>            Technologies.R_Nutrition,                           -- Recht: Nahrung</p><p>            Technologies.R_Bakery,                              -- Recht: Bäckerei</p><p>            Technologies.R_Dairy,                               -- Recht: Käserei</p><p>            Technologies.R_Butcher,                             -- Recht: Metzger</p><p>            Technologies.R_SmokeHouse,                          -- Recht: Räucherhaus</p><p>            Technologies.R_Clothes,                             -- Recht: Kleidung</p><p>            Technologies.R_Tanner,                              -- Recht: Ledergerber</p><p>            Technologies.R_Weaver,                              -- Recht: Weber</p><p>            Technologies.R_Construction,                        -- Recht: Konstruktion</p><p>            Technologies.R_Wall,                                -- Recht: Mauer</p><p>            Technologies.R_Pallisade,                           -- Recht: Palisade</p><p>            Technologies.R_Trail,                               -- Recht: Pfad</p><p>            Technologies.R_KnockDown,                           -- Recht: Abriss</p><p>            Technologies.R_Sermon,                              -- Recht: Predigt</p><p>            Technologies.R_SpecialEdition,                      -- Recht: Special Edition</p><p>            Technologies.R_SpecialEdition_Pavilion,             -- Recht: Pavilion AeK SE</p><p>        }</p><p>    }</p><p>    -- Landvogt ----------------------------------------------------------------</p><p>    NeedsAndRightsByKnightTitle[KnightTitles.Mayor] = {</p><p>        ActivateNeedForPlayer,</p><p>        {</p><p>            Needs.Clothes,                                      -- Bedürfnis: KLeidung</p><p>        },</p><p>        ActivateRightForPlayer, {</p><p>            Technologies.R_Hygiene,                             -- Recht: Hygiene</p><p>            Technologies.R_Soapmaker,                           -- Recht: Seifenmacher</p><p>            Technologies.R_BroomMaker,                          -- Recht: Besenmacher</p><p>            Technologies.R_Military,                            -- Recht: Militär</p><p>            Technologies.R_SwordSmith,                          -- Recht: Schwertschmied</p><p>            Technologies.R_Barracks,                            -- Recht: Schwertkämpferkaserne</p><p>            Technologies.R_Thieves,                             -- Recht: Diebe</p><p>            Technologies.R_SpecialEdition_StatueFamily,         -- Recht: Familienstatue Aek SE</p><p>        },</p><p>        StartKnightsPromotionCelebration                        -- Beförderungsfest aktivieren</p><p>    }</p><p>    -- Baron -------------------------------------------------------------------</p><p>    NeedsAndRightsByKnightTitle[KnightTitles.Baron] = {</p><p>        ActivateNeedForPlayer,</p><p>        {</p><p>            Needs.Hygiene,                                      -- Bedürfnis: Hygiene</p><p>        },</p><p>        ActivateRightForPlayer, {</p><p>            Technologies.R_Medicine,                            -- Recht: Medizin</p><p>            Technologies.R_BowMaker,                            -- Recht: Bogenmacher</p><p>            Technologies.R_BarracksArchers,                     -- Recht: Bogenschützenkaserne</p><p>            Technologies.R_Entertainment,                       -- Recht: Unterhaltung</p><p>            Technologies.R_Tavern,                              -- Recht: Taverne</p><p>            Technologies.R_Festival,                            -- Recht: Fest</p><p>            Technologies.R_Street,                              -- Recht: Straße</p><p>            Technologies.R_SpecialEdition_Column,               -- Recht: Säule AeK SE</p><p>        },</p><p>        StartKnightsPromotionCelebration                        -- Beförderungsfest aktivieren</p><p>    }</p><p>    -- Graf --------------------------------------------------------------------</p><p>    NeedsAndRightsByKnightTitle[KnightTitles.Earl] = {</p><p>        ActivateNeedForPlayer,</p><p>        {</p><p>            Needs.Entertainment,                                -- Bedürfnis: Unterhaltung</p><p>            Needs.Prosperity,                                   -- Bedürfnis: Reichtum</p><p>        },</p><p>        ActivateRightForPlayer, {</p><p>            Technologies.R_SiegeEngineWorkshop,                 -- Recht: Belagerungswaffenschmied</p><p>            Technologies.R_BatteringRam,                        -- Recht: Ramme</p><p>            Technologies.R_Baths,                               -- Recht: Badehaus</p><p>            Technologies.R_AmmunitionCart,                      -- Recht: Munitionswagen</p><p>            Technologies.R_Prosperity,                          -- Recht: Reichtum</p><p>            Technologies.R_Taxes,                               -- Recht: Steuern einstellen</p><p>            Technologies.R_Ballista,                            -- Recht: Mauerkatapult</p><p>            Technologies.R_SpecialEdition_StatueSettler,        -- Recht: Siedlerstatue AeK SE</p><p>        },</p><p>        StartKnightsPromotionCelebration                        -- Beförderungsfest aktivieren</p><p>    }</p><p>    -- Marquees ----------------------------------------------------------------</p><p>    NeedsAndRightsByKnightTitle[KnightTitles.Marquees] = {</p><p>        ActivateNeedForPlayer,</p><p>        {</p><p>            Needs.Wealth,                                       -- Bedürfnis: Verschönerung</p><p>        },</p><p>        ActivateRightForPlayer, {</p><p>            Technologies.R_Theater,                             -- Recht: Theater</p><p>            Technologies.R_Wealth,                              -- Recht: Schmuckgebäude</p><p>            Technologies.R_BannerMaker,                         -- Recht: Bannermacher</p><p>            Technologies.R_SiegeTower,                          -- Recht: Belagerungsturm</p><p>            Technologies.R_SpecialEdition_StatueProduction,     -- Recht: Produktionsstatue AeK SE</p><p>        },</p><p>        StartKnightsPromotionCelebration                        -- Beförderungsfest aktivieren</p><p>    }</p><p>    -- Herzog ------------------------------------------------------------------</p><p>    NeedsAndRightsByKnightTitle[KnightTitles.Duke] = {</p><p>        ActivateNeedForPlayer, nil,</p><p>        ActivateRightForPlayer, {</p><p>            Technologies.R_Catapult,                            -- Recht: Katapult</p><p>            Technologies.R_Carpenter,                           -- Recht: Tischler</p><p>            Technologies.R_CandleMaker,                         -- Recht: Kerzenmacher</p><p>            Technologies.R_Blacksmith,                          -- Recht: Schmied</p><p>            Technologies.R_SpecialEdition_StatueDario,          -- Recht: Dariostatue AeK SE</p><p>        },</p><p>        StartKnightsPromotionCelebration                        -- Beförderungsfest aktivieren</p><p>    }</p><p>    -- Erzherzog ---------------------------------------------------------------</p><p>    NeedsAndRightsByKnightTitle[KnightTitles.Archduke] = {</p><p>        ActivateNeedForPlayer,nil,</p><p>        ActivateRightForPlayer, {</p><p>            Technologies.R_Victory                              -- Sieg</p><p>        },</p><p>        -- VictroryBecauseOfTitle,                              -- Sieg wegen Titel</p><p>        StartKnightsPromotionCelebration                        -- Beförderungsfest aktivieren</p><p>    }</p><p>    -- Reich des Ostens --------------------------------------------------------</p><p>    if g_GameExtraNo >= 1 then</p><p>        local TechnologiesTableIndex = 4;</p><p>        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Mayor][TechnologiesTableIndex],Technologies.R_Cistern);</p><p>        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Mayor][TechnologiesTableIndex],Technologies.R_Beautification_Brazier);</p><p>        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Mayor][TechnologiesTableIndex],Technologies.R_Beautification_Shrine);</p><p>        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Baron][TechnologiesTableIndex],Technologies.R_Beautification_Pillar);</p><p>        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Earl][TechnologiesTableIndex],Technologies.R_Beautification_StoneBench);</p><p>        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Earl][TechnologiesTableIndex],Technologies.R_Beautification_Vase);</p><p>        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Marquees][TechnologiesTableIndex],Technologies.R_Beautification_Sundial);</p><p>        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Archduke][TechnologiesTableIndex],Technologies.R_Beautification_TriumphalArch);</p><p>        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Duke][TechnologiesTableIndex],Technologies.R_Beautification_VictoryColumn);</p><p>    end</p><p>    -- ---------------------------------------------------------------------- --</p><p>    -- Bedingungen                                                            --</p><p>    -- ---------------------------------------------------------------------- --</p><p>    KnightTitleRequirements = {}</p><p>    -- Ritter ------------------------------------------------------------------</p><p>    KnightTitleRequirements[KnightTitles.Mayor] = {}</p><p>    KnightTitleRequirements[KnightTitles.Mayor].Headquarters = 1</p><p>    KnightTitleRequirements[KnightTitles.Mayor].Settlers = 10</p><p>    KnightTitleRequirements[KnightTitles.Mayor].Products = {</p><p>        {GoodCategories.GC_Clothes, 6},</p><p>    }</p><p>    -- Baron -------------------------------------------------------------------</p><p>    KnightTitleRequirements[KnightTitles.Baron] = {}</p><p>    KnightTitleRequirements[KnightTitles.Baron].Settlers = 30</p><p>    KnightTitleRequirements[KnightTitles.Baron].Headquarters = 1</p><p>    KnightTitleRequirements[KnightTitles.Baron].Storehouse = 1</p><p>    KnightTitleRequirements[KnightTitles.Baron].Cathedrals = 1</p><p>    KnightTitleRequirements[KnightTitles.Baron].Products = {</p><p>        {GoodCategories.GC_Hygiene, 12},</p><p>    }</p><p>    -- Graf --------------------------------------------------------------------</p><p>    KnightTitleRequirements[KnightTitles.Earl] = {}</p><p>    KnightTitleRequirements[KnightTitles.Earl].Settlers = 50</p><p>    KnightTitleRequirements[KnightTitles.Earl].Headquarters = 2</p><p>    KnightTitleRequirements[KnightTitles.Earl].Products = {</p><p>        {GoodCategories.GC_Entertainment, 18},</p><p>    }</p><p>    -- Marquess ----------------------------------------------------------------</p><p>    KnightTitleRequirements[KnightTitles.Marquees] = {}</p><p>    KnightTitleRequirements[KnightTitles.Marquees].Settlers = 70</p><p>    KnightTitleRequirements[KnightTitles.Marquees].Headquarters = 2</p><p>    KnightTitleRequirements[KnightTitles.Marquees].Storehouse = 2</p><p>    KnightTitleRequirements[KnightTitles.Marquees].Cathedrals = 2</p><p>    KnightTitleRequirements[KnightTitles.Marquees].RichBuildings = 20</p><p>    -- Herzog ------------------------------------------------------------------</p><p>    KnightTitleRequirements[KnightTitles.Duke] = {}</p><p>    KnightTitleRequirements[KnightTitles.Duke].Settlers = 90</p><p>    KnightTitleRequirements[KnightTitles.Duke].Storehouse = 2</p><p>    KnightTitleRequirements[KnightTitles.Duke].Cathedrals = 2</p><p>    KnightTitleRequirements[KnightTitles.Duke].Headquarters = 3</p><p>    KnightTitleRequirements[KnightTitles.Duke].DecoratedBuildings = {</p><p>        {Goods.G_Banner, 9 },</p><p>    }</p><p>    -- Erzherzog ---------------------------------------------------------------</p><p>    KnightTitleRequirements[KnightTitles.Archduke] = {}</p><p>    KnightTitleRequirements[KnightTitles.Archduke].Settlers = 150</p><p>    KnightTitleRequirements[KnightTitles.Archduke].Storehouse = 3</p><p>    KnightTitleRequirements[KnightTitles.Archduke].Cathedrals = 3</p><p>    KnightTitleRequirements[KnightTitles.Archduke].Headquarters = 3</p><p>    KnightTitleRequirements[KnightTitles.Archduke].RichBuildings = 30</p><p>    KnightTitleRequirements[KnightTitles.Archduke].FullDecoratedBuildings = 30</p><p>    -- Einstellungen Aktivieren</p><p>    CreateTechnologyKnightTitleTable()</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundleminimapmarker.lua.html">
            <div class='doclink'>
                <div>BundleMinimapMarker</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia BundleMinimapMarker                                          # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ermöglocht das Anlegen von Markierungen auf der Minimap.</p><p>-- Mögliche Typen von Markierungen:</p><p>-- <ul></p><p>-- <li>Signal: Eine flüchtige Markierung, die nach wenigen Sekunden wieder</p><p>-- verschwindet.</li></p><p>-- <li>Marker: Eine statische Markierung, die dauerhaft verbleibt.</li></p><p>-- <li>Pulse: Eine pulsierende Markierung, die dauerhaft verbleibt.</li></p><p>-- </ul></p><p>-- Die Farbe eines Markers kann auf 2 verschiedene Weisen bestimmt werden.</p><p>-- <ol></p><p>-- <li>Durch die Spielerfarbe des "Besitzers" der Markierung.</p><p>-- <pre> API.CreateMinimapSignal(1, GetPosition("pos"));</pre></p><p>-- </li></p><p>-- <li>Durch Übergabe einer vordefinierten Farbe oder einer Farbtabelle</p><p>-- <pre></p><p>-- API.CreateMinimapSignal(MarkerColor.Red, GetPosition("pos"));</p><p>-- API.CreateMinimapSignal({180, 180, 180}, GetPosition("pos"));</pre></p><p>-- </li></p><p>-- </ol></p><p>-- Durchsichtige Marker sind nicht vorgesehen!</p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>-- Vordefinierte Farben für Minimap Marker.</p><p>-- @field Blue Königsblau</p><p>-- @field Red Blutrot</p><p>-- @field Yellow Sonnengelb</p><p>-- @field Green Blattgrün</p><p>-- @usage API.CreateMinimapSignal(MarkerColor.Red, GetPosition("pos"));</p><p>    Blue    = { 17,   7, 216},</p><p>    Red     = {216,   7,   7},</p><p>    Yellow  = { 25, 185,   8},</p><p>    Green   = { 16, 194, 220},</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Erstellt eine flüchtige Markierung auf der Minimap.</p><p>-- <b>Hinweis</b>: Die Farbe richtet sich nach der Spielerfarbe!</p><p>-- <b>Alias</b>: CreateMinimapSignal</p><p>-- @param _PlayerID [number|table] PlayerID oder Farbtabelle</p><p>-- @param _Position [string|number|table] Position des Markers</p><p>-- @return [number] ID des Markers</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.CreateMinimapSignal(1, GetPosition("pos"));</p><p>function API.CreateMinimapSignal(_PlayerID, _Position)</p><p>    if GUI then</p><p>        dbg("API.CreateMinimapSignal: Can not be used in local script!");</p><p>        return;</p><p>    end</p><p>    local Position = _Position;</p><p>    if type(_Position) ~= "table" then</p><p>        Position = GetPosition(_Position);</p><p>    end</p><p>    if type(Position) ~= "table" or (not Position.X or not Position.X) then</p><p>        dbg("API.CreateMinimapSignal: Position is invalid!");</p><p>        return;</p><p>    end</p><p>    return BundleMinimapMarker.Global:CreateMinimapMarker(_PlayerID, Position.X, Position.Y, 7);</p><p>-- Erstellt eine statische Markierung auf der Minimap.</p><p>-- <b>Hinweis</b>: Die Farbe richtet sich nach der Spielerfarbe!</p><p>-- <b>Alias</b>: CreateMinimapMarker</p><p>-- @param _PlayerID [number|table] PlayerID oder Farbtabelle</p><p>-- @param _Position [string|number|table] Position des Markers</p><p>-- @return [number] ID des Markers</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.CreateMinimapMarker(1, GetPosition("pos"));</p><p>function API.CreateMinimapMarker(_PlayerID, _Position)</p><p>    if GUI then</p><p>        dbg("API.CreateMinimapMarker: Can not be used in local script!");</p><p>        return;</p><p>    end</p><p>    local Position = _Position;</p><p>    if type(_Position) ~= "table" then</p><p>        Position = GetPosition(_Position);</p><p>    end</p><p>    if type(Position) ~= "table" or (not Position.X or not Position.X) then</p><p>        dbg("API.CreateMinimapMarker: Position is invalid!");</p><p>        return;</p><p>    end</p><p>    return BundleMinimapMarker.Global:CreateMinimapMarker(_PlayerID, Position.X, Position.Y, 6);</p><p>-- Erstellt eine pulsierende Markierung auf der Minimap.</p><p>-- <b>Hinweis</b>: Die Farbe richtet sich nach der Spielerfarbe!</p><p>-- <b>Alias</b>: CreateMinimapPulse</p><p>-- @param _PlayerID [number|table] PlayerID oder Farbtabelle</p><p>-- @param _Position [string|number|table] Position des Markers</p><p>-- @return [number] ID des Markers</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.CreateMinimapPulse(1, GetPosition("pos"));</p><p>function API.CreateMinimapPulse(_PlayerID, _Position)</p><p>    if GUI then</p><p>        dbg("API.CreateMinimapPulse: Can not be used in local script!");</p><p>        return;</p><p>    end</p><p>    local Position = _Position;</p><p>    if type(_Position) ~= "table" then</p><p>        Position = GetPosition(_Position);</p><p>    end</p><p>    </p><p>    if type(Position) ~= "table" or (not Position.X or not Position.X) then</p><p>        dbg("API.CreateMinimapPulse: Position is invalid!");</p><p>        return;</p><p>    end</p><p>    return BundleMinimapMarker.Global:CreateMinimapMarker(_PlayerID, Position.X, Position.Y, 1);</p><p>-- Zerstört eine Markierung auf der Minimap.</p><p>-- <b>Alias</b>: DestroyMinimapSignal</p><p>-- @param _ID [number] ID des Markers</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.DestroyMinimapSignal(SomeMarkerID);</p><p>function API.DestroyMinimapSignal(_ID)</p><p>    if GUI then</p><p>        dbg("API.DestroyMinimapSignal: Can not be used in local script!");</p><p>        return;</p><p>    end</p><p>    if type(_ID) ~= "number" then</p><p>        dbg("API.DestroyMinimapSignal: _ID must be a number!");</p><p>        return;</p><p>    end</p><p>    BundleMinimapMarker.Global:DestroyMinimapMarker(_ID);</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {</p><p>        Data = {</p><p>            MarkerCounter = 1000000,</p><p>            CreatedMinimapMarkers = {},</p><p>        },</p><p>    },</p><p>    Local = {</p><p>        Data = {},</p><p>    }</p><p>-- Global Script ---------------------------------------------------------------</p><p>-- Initialisiert das Bundle im globalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    API.AddSaveGameAction(self.OnSaveGameLoaded);</p><p>-- Erstellt eine neue Markierung auf der Minimap.</p><p>-- </p><p>-- @param _PlayerID [number] ID des Besitzers</p><p>-- @param _X [number] X-Koordinate des Markers</p><p>-- @param _Y [number] Y-Koordinate des Makers</p><p>-- @param _Type [number] Typ des Markers</p><p>-- @return [number] ID des Markers</p><p>-- @within Internal</p><p>-- @local</p><p>    self.Data.MarkerCounter = self.Data.MarkerCounter +1;</p><p>    -- Flüchtige Markierungen werden nicht gespeichert!</p><p>    self.Data.CreatedMinimapMarkers[self.Data.MarkerCounter] = {</p><p>        _PlayerID, _X, _Y, _Type</p><p>    };</p><p>    self:ShowMinimapMarker(self.Data.MarkerCounter);</p><p>    return self.Data.MarkerCounter;</p><p>-- Zerstort eine Markierung auf der Minimap.</p><p>-- </p><p>-- @param _ID [number] ID des Markers</p><p>-- @within Internal</p><p>-- @local</p><p>    self.Data.CreatedMinimapMarkers[_ID] = nil;</p><p>    API.Bridge([[GUI.DestroyMinimapSignal(]] .._ID.. [[)]]);</p><p>-- Zeigt eine erstellte Markierung auf der Minimap an.</p><p>-- </p><p>-- @param _ID [number] ID des Markers</p><p>-- @within Internal</p><p>-- @local</p><p>    if not self.Data.CreatedMinimapMarkers[_ID] then</p><p>        return;</p><p>    end</p><p>    local Marker = self.Data.CreatedMinimapMarkers[_ID];</p><p>    local ColorOrPlayerID = Marker[1];</p><p>    if type(ColorOrPlayerID) == "table" then</p><p>        ColorOrPlayerID = API.ConvertTableToString(ColorOrPlayerID);</p><p>    end</p><p>    API.Bridge([[</p><p>        BundleMinimapMarker.Local:ShowMinimapMarker(</p><p>            ]] .._ID.. [[,]] ..ColorOrPlayerID.. [[,]] ..Marker[2].. [[,]] ..Marker[3].. [[, ]] ..Marker[4].. [[</p><p>        )</p><p>    ]]);</p><p>-- Stellt Markierungen auf der Minimap wieder her, wenn ein Spielstand</p><p>-- geladen wird.</p><p>-- </p><p>-- @within Internal</p><p>-- @local</p><p>    for k, v in pairs(BundleMinimapMarker.Global.Data.CreatedMinimapMarkers) do</p><p>        if v and v[4] ~= 7 then</p><p>            BundleMinimapMarker.Global:ShowMinimapMarker(k);</p><p>        end</p><p>    end</p><p>-- Local Script ------------------------------------------------------------- --</p><p>-- Initialisiert das Bundle im globalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>-- Initialisiert das Bundle im globalen Skript.</p><p>-- @param _ID [number|table] Besitzer oder Farbtabelle</p><p>-- @param _PlayerID [number] ID des Besitzers</p><p>-- @param _X [number] X-Koordinate des Markers</p><p>-- @param _Y [number] Y-Koordinate des Makers</p><p>-- @param _Type [number] Typ des Markers</p><p>-- @within Internal</p><p>-- @local</p><p>    local R, G, B;</p><p>    if type(_PlayerID) == "number" then</p><p>        R, G, B = GUI.GetPlayerColor(_PlayerID);</p><p>    else</p><p>        R = _PlayerID[1];</p><p>        G = _PlayerID[2];</p><p>        B = _PlayerID[3];</p><p>    end</p><p>    GUI.CreateMinimapSignalRGBA(_ID, _X, _Y, R, G, B, 255, _Type);</p><p>-- -------------------------------------------------------------------------- --</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundlemusictools.lua.html">
            <div class='doclink'>
                <div>BundleMusicTools</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia BundleMusicTools                                             # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- <p>Dieses Bundle bietet die Möglichkeit Musikstücke abzuspielen. Die</p><p>-- Musik kann als einzelne Titel oder als Playlist wiedergegeben werden.</p></p><p>-- <p><a href="#API.StartMusic">Musik abspielen</a></p></p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet ein Musikstück als Stimme.</p><p>-- <p><b>Alias:</b> StartSong</p></p><p>-- Es wird nicht als Musik behandelt, sondern als Sprache! Die Lautstäkre</p><p>-- sämtlicher Sprache wird beeinflusst, weshalb immer nur 1 Song gleichzeitig</p><p>-- gespielt werden kann! Alle als Sprache abgespielten Sounds werden die</p><p>-- gleiche Lautstärke haben, wie die Musik.</p><p>-- _Description hat folgendes Format:</p><p>-- <ul></p><p>-- <li>File     - Path + Dateiname</li></p><p>-- <li>Volume   - Lautstärke</li></p><p>-- <li>length   - abgespielte Länge in Sekunden (nicht zwingend |Musikstück|)</li></p><p>-- <li>Fadeout  - Ausblendzeit in Zehntels. (>= 5 oder 0 für sofort)</li></p><p>-- <li>MuteAtmo - Hintergrundgeräusche aus</li></p><p>-- <li>MuteUI   - GUI-Sounds aus</li></p><p>-- </ul></p><p>-- @param _Description [table] Definition des Musikstück</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.StartMusic({</p><p>--     File     = "music/s6_10_antagonist.mp3",</p><p>--     Volume   = 70,</p><p>--     Length   = 49,</p><p>--     Fadeout  = 20,</p><p>--     MuteAtmo = true;</p><p>--     MuteUI   = true,</p><p>-- });</p><p>function API.StartMusic(_Description)</p><p>    if GUI then</p><p>        API.Log("Could not execute API.StartMusic in local script!");</p><p>        return;</p><p>    end</p><p>    BundleMusicTools.Global:StartSong(_Description);</p><p>-- Vereinfachter einzeiliger Aufruf für StartSong.</p><p>-- <p><b>Alias:</b> StartSongSimple</p></p><p>-- @param _File [string] Pfad zur Datei</p><p>-- @param _Volume [number] Lautstärke</p><p>-- @param _Length [number] Abspieldower (<= Dauer Musikstück)</p><p>-- @param _FadeOut [number] Ausblenden in Sekunden</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.StartMusicSimple("music/s6_10_antagonist.mp3", 70, 49, 1)</p><p>function API.StartMusicSimple(_File, _Volume, _Length, _FadeOut)</p><p>    if GUI then</p><p>        API.Bridge("API.StartMusicSimple('" .._File.. "', " .._Volume.. ", " .._Length.. ", " .._FadeOut.. ")");</p><p>        return;</p><p>    end</p><p>    local Data = {</p><p>        File     = _File,</p><p>        Volume   = _Volume,</p><p>        Length   = _Length,</p><p>        Fadeout  = _FadeOut * 10,</p><p>        MuteAtmo = true;</p><p>        MuteUI   = true,</p><p>    };</p><p>    BundleMusicTools.Global:StartSong(Data);</p><p>-- Spielt eine Playlist ab.</p><p>-- <p><b>Alias:</b> StartPlaylist</p></p><p>-- Eine im Skript definierte Playlist, nicht</p><p>-- eine XML! Die Playlist kann einmal abgearbeitet oder auf Wiederholung</p><p>-- gestellt werden. Alle Einträge haben das Format von StartSong!</p><p>-- Zusätzlich kann der Wahrheitswert Repeat gesetzt werden, damit</p><p>-- sich die Playlist endlos wiederholt.</p><p>-- @param _Playlist [table] Definition der Playlist</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- local Playlist = {</p><p>--     {</p><p>--         File     = "music/s6_10_antagonist.mp3",</p><p>--         Volume   = 70,</p><p>--         Length   = 49,</p><p>--         Fadeout  = 20,</p><p>--         MuteAtmo = true;</p><p>--         MuteUI   = true,</p><p>--     },</p><p>--     {</p><p>--         File     = "music/s6_04_blaze.mp3",</p><p>--         Volume   = 70,</p><p>--         Length   = 65,</p><p>--         Fadeout  = 20,</p><p>--         MuteAtmo = false;</p><p>--         MuteUI   = true,</p><p>--     },</p><p>-- }</p><p>-- API.StartPlaylist(Playlist);</p><p>function API.StartPlaylist(_Playlist)</p><p>    if GUI then</p><p>        API.Log("Could not execute API.StartPlaylist in local script!");</p><p>        return;</p><p>    end</p><p>    BundleMusicTools.Global:StartPlaylist(_Playlist);</p><p>-- Stoppt gerade gespielte Musik und startet die Playlist mit dem</p><p>-- angegebenen Titel. Es muss eine Playlist existieren! Nachdem der</p><p>-- Titel abgespielt ist, wird die Playlist normal weiter gespielt.</p><p>-- <p><b>Alias:</b> StartPlaylistTitle</p></p><p>-- @param _Title [number] Index des Titels</p><p>-- @within Anwenderfunktionen</p><p>function API.StartPlaylistTitle(_Title)</p><p>    if GUI then</p><p>        API.Log("Could not execute API.StartPlaylistTitle in local script!");</p><p>        return;</p><p>    end</p><p>    BundleMusicTools.Global:StartPlaylistTitle(_Title);</p><p>-- Stopt Musik und stellt die alte Soundkonfiguration wieder her.</p><p>-- <p><b>Alias:</b> StopSong</p></p><p>-- @within Anwenderfunktionen</p><p>function API.StopSong()</p><p>    if GUI then</p><p>        API.Bridge("API.StopSong()");</p><p>        return;</p><p>    end</p><p>    BundleMusicTools.Global:StopSong();</p><p>-- Stopt den gerade laufenden Song und leert sowohl die Songdaten</p><p>-- als auch die Playlist.</p><p>-- <p><b>Alias:</b> AbortSongOrPlaylist</p></p><p>-- @within Anwenderfunktionen</p><p>function API.AbortMusic()</p><p>    if GUI then</p><p>        API.Bridge("API.AbortMusic()");</p><p>        return;</p><p>    end</p><p>    BundleMusicTools.Global:AbortMusic();</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {</p><p>        Data = {</p><p>            StartSongData = {},</p><p>            StartSongPlaylist = {},</p><p>            StartSongQueue = {},</p><p>        }</p><p>    },</p><p>    Local = {</p><p>        Data = {</p><p>            SoundBackup = {},</p><p>        }</p><p>    },</p><p>-- Global Script ---------------------------------------------------------------</p><p>-- Initalisiert das Bundle im globalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>-- Startet ein Musikstück als Stimme.</p><p>-- @param _Description [table] Beschreibung des Musikstücks</p><p>-- @within Internal</p><p>-- @local</p><p>    if self.Data.StartSongData.Running then</p><p>        table.insert(self.Data.StartSongQueue, _Description);</p><p>    else</p><p>        assert(type(_Description.File) == "string");</p><p>        assert(type(_Description.Volume) == "number");</p><p>        assert(type(_Description.Length) == "number");</p><p>        _Description.Length = _Description.Length * 10;</p><p>        assert(type(_Description.Fadeout) == "number");</p><p>        _Description.MuteAtmo = _Description.MuteAtmo == true;</p><p>        _Description.MuteUI = _Description.MuteUI == true;</p><p>        _Description.CurrentVolume = _Description.Volume;</p><p>        _Description.Time = 0;</p><p>        self.Data.StartSongData = _Description;</p><p>        self.Data.StartSongData.Running = true;</p><p>        Logic.ExecuteInLuaLocalState([[</p><p>            BundleMusicTools.Local:BackupSound(</p><p>                ]].. _Description.Volume ..[[,</p><p>                "]].. _Description.File ..[[",</p><p>                ]].. tostring(_Description.MuteAtmo) ..[[,</p><p>                ]].. tostring(_Description.MuteUI) ..[[</p><p>            )</p><p>        ]])</p><p>        if not self.Data.StartSongJob then</p><p>            self.Data.StartSongJob = StartSimpleHiResJob("StartSongControl");</p><p>        end</p><p>    end</p><p>-- Spielt eine Playlist ab.</p><p>-- @param _Playlist [table] Playlist</p><p>-- @within Internal</p><p>-- @local</p><p>    for i=1, #_Playlist, 1 do</p><p>        table.insert(self.Data.StartSongPlaylist, _Playlist[i]);</p><p>        self:StartSong(_Playlist[i]);</p><p>    end</p><p>    self.Data.StartSongPlaylist.Repeat = _Playlist.Repeat == true;</p><p>-- Stoppt gerade gespielte Musik und startet die Playlist mit dem</p><p>-- angegebenen Titel. Es muss eine Playlist existieren! Nachdem der</p><p>-- Titel abgespielt ist, wird die Playlist normal weiter gespielt.</p><p>-- @param _Title [number] Index des Titels</p><p>-- @within Internal</p><p>-- @local</p><p>    local playlist = self.Data.StartSongPlaylist;</p><p>    local length = #length;</p><p>    if (length >= _Title) then</p><p>        self.Data.StartSongData.Running = false;</p><p>        self.Data.StartSongQueue = {};</p><p>        self.Data.StartSongData = {};</p><p>        self:StopSong();</p><p>        EndJob(self.Data.StartSongJob);</p><p>        self.Data.StartSongJob = nil;</p><p>        for i=_Title, length, 1 do</p><p>            self:StartSong(playlist);</p><p>        end</p><p>    end</p><p>-- Stopt Musik und stellt die alte Soundkonfiguration wieder her.</p><p>-- @within Internal</p><p>-- @local</p><p>    local Queue = #self.Data.StartSongQueue;</p><p>    local Data = self.Data.StartSongData;</p><p>    Logic.ExecuteInLuaLocalState([[</p><p>        BundleMusicTools.Local:ResetSound(</p><p>            "]].. ((Data.File ~= nil and Data.File) or "") ..[[",</p><p>            ]].. Queue ..[[</p><p>        )</p><p>    ]]);</p><p>-- Stopt den gerade laufenden Song und leert sowohl die Songdaten</p><p>-- als auch die Playlist.</p><p>-- @within Internal</p><p>-- @local</p><p>    self.Data.StartSongPlaylist = {};</p><p>    self.Data.StartSongQueue = {};</p><p>    self:StopSong();</p><p>    self.Data.StartSongData = {};</p><p>    EndJob(self.Data.StartSongJob);</p><p>    self.Data.StartSongJob = nil;</p><p>-- Kontrolliert den Song / die Playlist. Wenn ein Song durch ist, wird</p><p>-- der nächste Song in der Warteschlange gestartet, sofern vorhanden.</p><p>-- Ist die Warteschlange leer, endet der Job. Existiert eine Playlist,</p><p>-- für die Repeat = true ist, dann wird die Playlist neu gestartet.</p><p>-- @within Internal</p><p>-- @local</p><p>    if not BundleMusicTools.Global.Data.StartSongData.Running then</p><p>        BundleMusicTools.Global.Data.StartSongData = {};</p><p>        BundleMusicTools.Global.Data.StartSongJob = nil;</p><p>        if #BundleMusicTools.Global.Data.StartSongQueue > 0 then</p><p>            local Description = table.remove(BundleMusicTools.Global.Data.StartSongQueue, 1);</p><p>            BundleMusicTools.Global:StartSong(Description);</p><p>        else</p><p>            if BundleMusicTools.Global.Data.StartSongPlaylist.Repeat then</p><p>                BundleMusicTools.Global:StartPlaylist(BundleMusicTools.Global.Data.StartSongPlaylist);</p><p>            end</p><p>        end</p><p>        return true;</p><p>    end</p><p>    local Data = BundleMusicTools.Global.Data.StartSongData;</p><p>    -- Zeit zählen</p><p>    BundleMusicTools.Global.Data.StartSongData.Time = Data.Time +1;</p><p>    if Data.Fadeout < 5 then</p><p>        if Data.Time >= Data.Length then</p><p>            BundleMusicTools.Global.Data.StartSongData.Running = false;</p><p>            BundleMusicTools.Global:StopSong();</p><p>        end</p><p>    else</p><p>        local FadeoutTime = Data.Length - Data.Fadeout+1;</p><p>        if Data.Time >= FadeoutTime then</p><p>            if Data.Time >= Data.Length then</p><p>                BundleMusicTools.Global.Data.StartSongData.Running = false;</p><p>                BundleMusicTools.Global:StopSong();</p><p>            else</p><p>                local VolumeStep = Data.Volume / Data.Fadeout;</p><p>                BundleMusicTools.Global.Data.StartSongData.CurrentVolume = Data.CurrentVolume - VolumeStep;</p><p>                Logic.ExecuteInLuaLocalState([[</p><p>                    Sound.SetSpeechVolume(]]..Data.CurrentVolume..[[)</p><p>                ]]);</p><p>            end</p><p>        end</p><p>    end</p><p>-- Local Script ----------------------------------------------------------------</p><p>-- Initalisiert das Bundle im lokalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>-- Speichert die Soundeinstellungen.</p><p>-- @param _Volume [number] Lautstärke</p><p>-- @param _Song [string] Pfad zum Titel</p><p>-- @param _MuteAtmo [boolean] Atmosphäre stumm schalten</p><p>-- @param _MuteUI [boolean] UI stumm schalten</p><p>-- @within Internal</p><p>-- @local</p><p>    if self.Data.SoundBackup.FXSP == nil then</p><p>        self.Data.SoundBackup.FXSP = Sound.GetFXSoundpointVolume();</p><p>        self.Data.SoundBackup.FXAtmo = Sound.GetFXAtmoVolume();</p><p>        self.Data.SoundBackup.FXVol = Sound.GetFXVolume();</p><p>        self.Data.SoundBackup.Sound = Sound.GetGlobalVolume();</p><p>        self.Data.SoundBackup.Music = Sound.GetMusicVolume();</p><p>        self.Data.SoundBackup.Voice = Sound.GetSpeechVolume();</p><p>        self.Data.SoundBackup.UI = Sound.Get2DFXVolume();</p><p>    end</p><p>    Sound.SetFXVolume(100);</p><p>    Sound.SetSpeechVolume(_Volume);</p><p>    if _MuteAtmo == true then</p><p>        Sound.SetFXSoundpointVolume(0);</p><p>        Sound.SetFXAtmoVolume(0);</p><p>    end</p><p>    if _MuteUI == true then</p><p>        Sound.Set2DFXVolume(0);</p><p>        Sound.SetFXVolume(0);</p><p>    end</p><p>    Sound.SetMusicVolume(0);</p><p>    Sound.PlayVoice("ImportantStuff", _Song);</p><p>-- Stellt die Soundeinstellungen wieder her.</p><p>-- @param _File [string] Pfad zur Datei</p><p>-- @param _QueueLength [number] Länge der Warteschlange</p><p>-- @within Internal</p><p>-- @local</p><p>    if _File ~= nil then</p><p>        Sound.StopVoice("ImportantStuff", _File)</p><p>    end</p><p>    if _QueueLength <= 0 then</p><p>        if self.Data.SoundBackup.FXSP ~= nil then</p><p>            Sound.SetFXSoundpointVolume(self.Data.SoundBackup.FXSP)</p><p>            Sound.SetFXAtmoVolume(self.Data.SoundBackup.FXAtmo)</p><p>            Sound.SetFXVolume(self.Data.SoundBackup.FXVol)</p><p>            Sound.SetGlobalVolume(self.Data.SoundBackup.Sound)</p><p>            Sound.SetMusicVolume(self.Data.SoundBackup.Music)</p><p>            Sound.SetSpeechVolume(self.Data.SoundBackup.Voice)</p><p>            Sound.Set2DFXVolume(self.Data.SoundBackup.UI)</p><p>            self.Data.SoundBackup = {}</p><p>        end</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundlenonplayercharacter.lua.html">
            <div class='doclink'>
                <div>BundleNonPlayerCharacter</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia BundleNonPlayerCharacter                                     # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- <p>Mit diesem Bundle wird ein spezieller Modus für Nichtspieler-Charaktere</p><p>-- bereitgestellt. Die Helden eines Spielers können mit diesen NPCs sprechen.</p><p>-- Dazu muss der Held selektiert sein. Dann kann der Spieler ihm mit einem</p><p>-- Rechtsklick befehlen, den NPC anzusprechen. Dabei wird der Mauszeiger zu</p><p>-- einer Hand.</p></p><p>-- <p>Ein NPC wird durch ein leichtes Glitzern auf der Spielwelt hervorgehoben.</p><p>-- </p></p><p>-- <p><a href="#API.NpcCompose">NPCs erzeugen und verwalten</a></p></p><p>-- @within Modulbeschreibung</p><p>-- @set sort=false</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Erstellt einen neuen NPC für den angegebenen Siedler.</p><p>-- Der NPC wird sofort aktiviert und kann angesprochen werden. Er wird durch</p><p>-- eine glitzernde Aura hervorgehoben.</p><p>-- Mögliche Einstellungen für den NPC:</p><p>-- <table border="1"></p><p>-- <tr></p><p>-- <th><b>Eigenschaft</b></th></p><p>-- <th><b>Beschreibung</b></th></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>Name</td></p><p>-- <td>Stringname des Siedlers, der zum NPC werden soll.</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>Hero</td></p><p>-- <td>Skriptname eines Helden, mit dem der NPC sprechen will.</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>WrongHeroMessage</td></p><p>-- <td>Eine optionale Nachricht, wenn der falsche Held angesprochen wird.</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>Callback</td></p><p>-- <td>Eine Funktion, die aufgerufen wird, wenn der NPC angesprochen wird.</td></p><p>-- </tr></p><p>-- </table></p><p>-- <p><b>Alias:</b> CreateNPC</p></p><p>-- @param _Data [table] Nichtspieler-Charakter</p><p>-- @return [table] NPC-Objekt</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.NpcCompose {</p><p>--     Name     = "horst",</p><p>--     Callback = function(_Npc, _Hero)</p><p>--        -- Hier kann was passieren</p><p>--     end,</p><p>-- }</p><p>function API.NpcCompose(_Data)</p><p>    local WronHeroCallback = function(_Npc)</p><p>        if _Npc.WrongHeroMessage then</p><p>            API.Note(_Npc.WrongHeroMessage);</p><p>        end</p><p>    end</p><p>    local NPC = NonPlayerCharacter:New(_Data.Name);</p><p>    NPC:SetDialogPartner(_Data.Hero);</p><p>    NPC:SetWrongPartnerCallback(WronHeroCallback);</p><p>    NPC:SetCallback(_Data.Callback);</p><p>    return NPC:Activate();</p><p>-- Entfernt den NPC komplett vom Entity. Das Entity bleibt dabei erhalten.</p><p>-- <p><b>Alias:</b> DestroyNPC</p></p><p>-- @param _Entity [string|number] Nichtspieler-Charakter</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.NpcDispose("horst")</p><p>function API.NpcDispose(_Entity)</p><p>    local ScriptName = Logic.GetEntityName(GetID(_Entity));</p><p>    local NPC = NonPlayerCharacter:GetInstance(ScriptName);</p><p>    if not NPC then</p><p>        return;</p><p>    end</p><p>    NPC:Dispose();</p><p>-- Aktiviert einen inaktiven NPC. Wenn ein NPC bereits gesprochen hat, muss</p><p>-- er zuvor zurückgesetzt werden.</p><p>-- <p><b>Alias:</b> EnableNPC</P></p><p>-- @param _Entity [string|number] Nichtspieler-Charakter</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.NpcActivate("horst")</p><p>function API.NpcActivate(_Entity)</p><p>    local ScriptName = Logic.GetEntityName(GetID(_Entity));</p><p>    local NPC = NonPlayerCharacter:GetInstance(ScriptName);</p><p>    if not NPC then</p><p>        return;</p><p>    end</p><p>    NPC:Activate();</p><p>-- Deaktiviert einen NPC, sodass dieser nicht angesprochen werden kann.</p><p>-- <p><b>Alias:</b> DisableNPC</P></p><p>-- @param _Entity [string|number] Nichtspieler-Charakter</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.NpcDeactivate("horst")</p><p>function API.NpcDeactivate(_Entity)</p><p>    local ScriptName = Logic.GetEntityName(GetID(_Entity));</p><p>    local NPC = NonPlayerCharacter:GetInstance(ScriptName);</p><p>    if not NPC then</p><p>        return;</p><p>    end</p><p>    NPC:Deactivate();</p><p>-- Setzt einen NPC zurück, sodass er nicht mehr als angesprochen gilt.</p><p>-- <p><b>Alias:</b> ResetNPC<p></p><p>-- @param _Entity [string|number] Nichtspieler-Charakter</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.NpcReset("horst")</p><p>function API.NpcReset(_Entity)</p><p>    local ScriptName = Logic.GetEntityName(GetID(_Entity));</p><p>    local NPC = NonPlayerCharacter:GetInstance(ScriptName);</p><p>    if not NPC then</p><p>        return;</p><p>    end</p><p>    NPC:Reset();</p><p>-- Prüft, ob der NPC bereits angesprochen wurde. Wenn ein Ansprechpartner</p><p>-- vorgegeben ist, muss dieser den NPC ansprechen.</p><p>-- <p><b>Alias:</b> TalkedToNPC</p></p><p>-- @param _Entity [string|number] Nichtspieler-Charakter</p><p>-- @return [boolean] NPC wurde angesprochen</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.NpcHasSpoken("horst")</p><p>function API.NpcHasSpoken(_Entity)</p><p>    local ScriptName = Logic.GetEntityName(GetID(_Entity));</p><p>    local NPC = NonPlayerCharacter:GetInstance(ScriptName);</p><p>    if not NPC then</p><p>        return;</p><p>    end</p><p>    return NPC:HasTalkedTo();</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {</p><p>        NonPlayerCharacter = {</p><p>            Data = {},</p><p>        },</p><p>        NonPlayerCharacterObjects = {},</p><p>        LastNpcEntityID = 0,</p><p>        LastHeroEntityID = 0,</p><p>    },</p><p>    Local = {}</p><p>-- Erzeugt ein neues Objekt von NonPlayerCharacter und bindet es an den</p><p>-- angegebenen Siedler. Dadurch wird der Siedler zu einem NPC, ist allerdings</p><p>-- noch nicht aktiv.</p><p>-- <p><b>Alias:</b> NonPlayerCharacter:New</p></p><p>-- @param _ScriptName [string] Skriptname des NPC</p><p>-- @return [table] Instanz von NonPlayerCharacter</p><p>-- @within NonPlayerCharacter</p><p>-- @local</p><p>-- @usage</p><p>-- Einen normalen NPC erzeugen:</p><p>-- local NPC = NonPlayerCharacter:New("npc")</p><p>--     :SetDialogPartner("hero")                -- Optional</p><p>--     :SetCallback(Briefing1)                  -- Optional</p><p>--     :Activate();</p><p>    assert( self == BundleNonPlayerCharacter.Global.NonPlayerCharacter, 'Can not be used from instance!');</p><p>    assert(IsExisting(_ScriptName), 'entity "' .._ScriptName.. '" does not exist!');</p><p>    local npc = CopyTableRecursive(self);</p><p>    npc.Data.NpcName = _ScriptName;</p><p>    BundleNonPlayerCharacter.Global.NonPlayerCharacterObjects[_ScriptName] = npc;</p><p>    npc:CreateMarker();</p><p>    npc:HideMarker();</p><p>    return npc;</p><p>-- Gibt das Objekt des NPC zurück, wenn denn eins für dieses Entity existiert.</p><p>-- Wurde noch kein NPC für diesen Skriptnamen erzeugt, wird nil zurückgegeben.</p><p>-- <p><b>Alias:</b> NonPlayerCharacter:GetInstance</p></p><p>-- @param _ScriptName [string] Skriptname des NPC</p><p>-- @return [table] Interaktives Objekt</p><p>-- @within NonPlayerCharacter</p><p>-- @local</p><p>-- @usage -- NPC ermitteln</p><p>-- local NPC = NonPlayerCharacter:GetInstance("horst");</p><p>-- -- Etwas mit dem NPC tun</p><p>-- NPC:SetDialogPartner("hilda");</p><p>    assert( self == BundleNonPlayerCharacter.Global.NonPlayerCharacter, 'Can not be used from instance!');</p><p>    local EntityID = GetID(_ScriptName)</p><p>    local ScriptName = Logic.GetEntityName(EntityID);</p><p>    if Logic.IsEntityInCategory(EntityID, EntityCategories.Soldier) == 1 then</p><p>        local LeaderID = Logic.SoldierGetLeaderEntityID(EntityID);</p><p>        if IsExisting(LeaderID) then</p><p>            ScriptName = Logic.GetEntityName(LeaderID);</p><p>        end</p><p>    end</p><p>    return BundleNonPlayerCharacter.Global.NonPlayerCharacterObjects[ScriptName];</p><p>-- Gibt die Entity ID des letzten angesprochenen NPC zurück.</p><p>-- <p><b>Alias:</b> NonPlayerCharacter:GetNpcId</p></p><p>-- @return [number] ID des letzten NPC</p><p>-- @within NonPlayerCharacter</p><p>-- @local</p><p>    assert( self == BundleNonPlayerCharacter.Global.NonPlayerCharacter, 'Can not be used from instance!');</p><p>    return BundleNonPlayerCharacter.Global.LastNpcEntityID;</p><p>-- Gibt die Entity ID des letzten Helden zurück, der einen NPC</p><p>-- angesprochen hat.</p><p>-- <p><b>Alias:</b> NonPlayerCharacter:GetHeroId</p></p><p>-- @return [number] ID des letzten Heden</p><p>-- @within NonPlayerCharacter</p><p>-- @local</p><p>    assert( self == BundleNonPlayerCharacter.Global.NonPlayerCharacter, 'Can not be used from instance!');</p><p>    return BundleNonPlayerCharacter.Global.LastHeroEntityID;</p><p>-- Gibt die Entity ID des NPC zurück. Ist der NPC ein Leader, wird</p><p>-- der erste Soldat zurückgegeben, wenn es einen gibt.</p><p>-- <p><b>Alias:</b> NonPlayerCharacter:GetID</p></p><p>-- @return [number] ID des NPC</p><p>-- @within NonPlayerCharacter</p><p>-- @local</p><p>    assert(self ~= BundleNonPlayerCharacter.Global.NonPlayerCharacter, 'Can not be used in static context!');</p><p>    local EntityID = GetID(self.Data.NpcName);</p><p>    if Logic.IsEntityInCategory(EntityID, EntityCategories.Leader) == 1 then</p><p>        local Soldiers = {Logic.GetSoldiersAttachedToLeader(EntityID)};</p><p>        if Soldiers[1] > 0 then</p><p>            return Soldiers[2];</p><p>        end</p><p>    end</p><p>    return EntityID</p><p>-- Löscht einen NPC.</p><p>-- <p><b>Alias:</b> NonPlayerCharacter:Dispose</p></p><p>-- @within NonPlayerCharacter</p><p>-- @local</p><p>-- @usage -- NPC löschen</p><p>-- NPC:Dispose();</p><p>    assert(self ~= BundleNonPlayerCharacter.Global.NonPlayerCharacter, 'Can not be used in static context!');</p><p>    self:Deactivate();</p><p>    self:DestroyMarker();</p><p>    BundleNonPlayerCharacter.Global.NonPlayerCharacterObjects[self.Data.NpcName] = nil;</p><p>-- Aktiviert einen inaktiven NPC, sodass er wieder angesprochen werden kann.</p><p>-- <p><b>Alias:</b> NonPlayerCharacter:Activate</p></p><p>-- @return [table] Instanz von NonPlayerCharacter</p><p>-- @within NonPlayerCharacter</p><p>-- @local</p><p>-- @usage -- NPC aktivieren:</p><p>-- NPC:Activate();</p><p>    assert(self ~= BundleNonPlayerCharacter.Global.NonPlayerCharacter, 'Can not be used in static context!');</p><p>    if IsExisting(self.Data.NpcName) then</p><p>        Logic.SetOnScreenInformation(self:GetID(), 1);</p><p>        self:ShowMarker();</p><p>    end</p><p>    return self;</p><p>-- Deaktiviert einen aktiven NPC, sodass er nicht angesprochen werden kann.</p><p>-- <p><b>Alias:</b> NonPlayerCharacter:Deactivate</p></p><p>-- @return [table] Instanz von NonPlayerCharacter</p><p>-- @within NonPlayerCharacter</p><p>-- @local</p><p>-- @usage -- NPC deaktivieren:</p><p>-- NPC:Deactivate();</p><p>    assert(self ~= BundleNonPlayerCharacter.Global.NonPlayerCharacter, 'Can not be used in static context!');</p><p>    if IsExisting(self.Data.NpcName) then</p><p>        Logic.SetOnScreenInformation(self:GetID(), 0);</p><p>        self:HideMarker();</p><p>    end</p><p>    return self;</p><p>-- <p>Gibt true zurück, wenn der NPC aktiv ist.</p></p><p>-- <p><b>Alias:</b> NonPlayerCharacter:IsActive</p></p><p>-- @return [boolean] NPC ist aktiv</p><p>-- @within NonPlayerCharacter</p><p>-- @local</p><p>    assert(self ~= BundleNonPlayerCharacter.Global.NonPlayerCharacter, 'Can not be used in static context!');</p><p>    return Logic.GetEntityScriptingValue(self:GetID(), 6) == 1;</p><p>-- Setzt den NPC zurück, sodass er erneut aktiviert werden kann.</p><p>-- <p><b>Alias:</b> NonPlayerCharacter:Reset</p></p><p>-- @return [table] Instanz von NonPlayerCharacter</p><p>-- @within NonPlayerCharacter</p><p>-- @local</p><p>    assert(self ~= BundleNonPlayerCharacter.Global.NonPlayerCharacter, 'Can not be used in static context!');</p><p>    if IsExisting(self.Data.NpcName) then</p><p>        Logic.SetOnScreenInformation(self:GetID(), 0);</p><p>        self.Data.TalkedTo = nil;</p><p>        self:HideMarker();</p><p>    end</p><p>    return self;</p><p>-- Gibt true zurück, wenn der NPC angesprochen wurde. Ist ein</p><p>-- spezieller Ansprechpartner definiert, wird nur dann true</p><p>-- zurückgegeben, wenn dieser Held mit dem NPC spricht.</p><p>-- <p><b>Alias:</b> NonPlayerCharacter:HasTalkedTo</p></p><p>-- @return [boolean] NPC wurde angesprochen</p><p>-- @within NonPlayerCharacter</p><p>-- @local</p><p>    assert(self ~= BundleNonPlayerCharacter.Global.NonPlayerCharacter, 'Can not be used in static context!');</p><p>    if self.Data.HeroName then</p><p>        return self.Data.TalkedTo == GetID(self.Data.HeroName);</p><p>    end</p><p>    return self.Data.TalkedTo ~= nil;</p><p>-- Setzt den Ansprechpartner für diesen NPC.</p><p>-- <p><b>Alias:</b> NonPlayerCharacter:SetDialogPartner</p></p><p>-- @param _HeroName [string] Skriptname des Helden</p><p>-- @return [table] Instanz von NonPlayerCharacter</p><p>-- @within NonPlayerCharacter</p><p>-- @local</p><p>    assert(self ~= BundleNonPlayerCharacter.Global.NonPlayerCharacter, 'Can not be used in static context!');</p><p>    self.Data.HeroName = _HeroName;</p><p>    return self;</p><p>-- Setzt das Callback für den Fall, dass ein falscher Held den</p><p>-- NPC anspricht.</p><p>-- <p><b>Alias:</b> NonPlayerCharacter:SetWrongPartnerCallback</p></p><p>-- @param _Callback [function] Callback</p><p>-- @return [table] Instanz von NonPlayerCharacter</p><p>-- @within NonPlayerCharacter</p><p>-- @local</p><p>    assert(self ~= BundleNonPlayerCharacter.Global.NonPlayerCharacter, 'Can not be used in static context!');</p><p>    self.Data.WrongHeroCallback = _Callback;</p><p>    return self;</p><p>-- Setzt das Callback des NPC, dass beim Ansprechen ausgeführt wird.</p><p>-- <p><b>Alias:</b> NonPlayerCharacter:SetCallback</p></p><p>-- @param _Callback [function] Callback</p><p>-- @return [table] Instanz von NonPlayerCharacter</p><p>-- @within NonPlayerCharacter</p><p>-- @local</p><p>    assert(self ~= BundleNonPlayerCharacter.Global.NonPlayerCharacter, 'Can not be used in static context!');</p><p>    assert(type(_Callback) == "function", 'callback must be a function!');</p><p>    self.Data.Callback = _Callback;</p><p>    return self;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Behavior                                                                   --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der Held muss einen Nichtspielercharakter ansprechen.</p><p>-- Es wird automatisch ein NPC erzeugt und überwacht, sobald der Quest</p><p>-- aktiviert wurde.</p><p>-- @param _NpcName  [string] Skriptname des NPC</p><p>-- @param _HeroName [string] Skriptname des Helden (optional)</p><p>-- @within Goal</p><p>    return b_Goal_NPC:new(...);</p><p>Goal_NPC</p><p>    Name             = "Goal_NPC",</p><p>    Description     = {</p><p>        en = "Goal: The hero has to talk to a non-player character.",</p><p>        de = "Ziel: Der Held muss einen Nichtspielercharakter ansprechen.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "NPC",  de = "NPC" },</p><p>        { ParameterType.ScriptName, en = "Hero", de = "Held" },</p><p>    },</p><p>    return {Objective.Distance, -65565, self.Hero, self.NPC, self }</p><p>    if (__index_ == 0) then</p><p>        self.NPC = __parameter_</p><p>    elseif (__index_ == 1) then</p><p>        self.Hero = __parameter_</p><p>        if self.Hero == "-" then</p><p>            self.Hero = nil</p><p>        end</p><p>   end</p><p>    return {14,10}</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet den Quest, sobald der NPC angesprochen wurde.</p><p>-- Es wird automatisch ein NPC erzeugt und überwacht, sobald der Quest</p><p>-- erzeugt wurde.</p><p>-- @param _NpcName  [string] Skriptname des NPC</p><p>-- @param _HeroName [string] Skriptname des Helden (optional)</p><p>-- @within Trigger</p><p>    return b_Trigger_NPC:new(...);</p><p>Trigger_NPC</p><p>    Name = "Trigger_NPC",</p><p>    Description = {</p><p>        en = "Trigger: Starts the quest after the npc was spoken to.",</p><p>        de = "Ausloeser: Startet den Quest, sobald der NPC angesprochen wurde.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "NPC",  de = "NPC" },</p><p>        { ParameterType.ScriptName, en = "Hero", de = "Held" },</p><p>    },</p><p>    return { Triggers.Custom2,{self, self.CustomFunction} }</p><p>    if (__index_ == 0) then</p><p>        self.NPC = __parameter_</p><p>    elseif (__index_ == 1) then</p><p>        self.Hero = __parameter_</p><p>        if self.Hero == "-" then</p><p>            self.Hero = nil</p><p>        end</p><p>    end</p><p>    if not IsExisting(self.NPC) then</p><p>        return;</p><p>    end</p><p>    if not self.NpcInstance then</p><p>        local NPC = NonPlayerCharacter:New(self.NPC);</p><p>        NPC:SetDialogPartner(self.Hero);</p><p>        self.NpcInstance = NPC;</p><p>    end</p><p>    local TalkedTo = self.NpcInstance:HasTalkedTo(self.Hero);</p><p>    if not TalkedTo then</p><p>        if not self.NpcInstance:IsActive() then</p><p>            self.NpcInstance:Activate();</p><p>        end</p><p>    end</p><p>    return TalkedTo;</p><p>    if self.NpcInstance then</p><p>        self.NpcInstance:Dispose();</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Global Script ---------------------------------------------------------------</p><p>-- Initialisiert das Bundle im globalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    NonPlayerCharacter = BundleNonPlayerCharacter.Global.NonPlayerCharacter;</p><p>    ---</p><p>    -- Führt die statische Steuerungsfunktion für alle NPC aus.</p><p>    --</p><p>    StartSimpleJobEx( function()</p><p>        for k, v in pairs(BundleNonPlayerCharacter.Global.NonPlayerCharacterObjects) do</p><p>            v:ControlMarker();</p><p>        end</p><p>    end);</p><p>    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</p><p>    GameCallback_OnNPCInteraction_Orig_QSB_NPC_Rewrite = GameCallback_OnNPCInteraction</p><p>    GameCallback_OnNPCInteraction = function(_EntityID, _PlayerID)</p><p>        GameCallback_OnNPCInteraction_Orig_QSB_NPC_Rewrite(_EntityID, _PlayerID)</p><p>        Quest_OnNPCInteraction(_EntityID, _PlayerID)</p><p>    end</p><p>    Quest_OnNPCInteraction = function(_EntityID, _PlayerID)</p><p>        local KnightIDs = {};</p><p>        Logic.GetKnights(_PlayerID, KnightIDs);</p><p>        -- Akteure ermitteln</p><p>        local ClosestKnightID = 0;</p><p>        local ClosestKnightDistance = Logic.WorldGetSize();</p><p>        for i= 1, #KnightIDs, 1 do</p><p>            local DistanceBetween = Logic.GetDistanceBetweenEntities(KnightIDs[i], _EntityID);</p><p>            if DistanceBetween < ClosestKnightDistance then</p><p>                ClosestKnightDistance = DistanceBetween;</p><p>                ClosestKnightID = KnightIDs[i];</p><p>            end</p><p>        end</p><p>        BundleNonPlayerCharacter.Global.LastHeroEntityID = ClosestKnightID;</p><p>        local NPC = NonPlayerCharacter:GetInstance(_EntityID);</p><p>        BundleNonPlayerCharacter.Global.LastNpcEntityID = NPC:GetID();</p><p>        if NPC then</p><p>            NPC:RotateActors();</p><p>            NPC.Data.TalkedTo = ClosestKnightID;</p><p>            if NPC:HasTalkedTo() then</p><p>                NPC:Deactivate();</p><p>                if NPC.Data.Callback then</p><p>                    NPC.Data.Callback(NPC, ClosestKnightID);</p><p>                end</p><p>            else</p><p>                if NPC.Data.WrongHeroCallback then</p><p>                    NPC.Data.WrongHeroCallback(NPC, ClosestKnightID);</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>    function QuestTemplate:RemoveQuestMarkers()</p><p>        for i=1, self.Objectives[0] do</p><p>            if self.Objectives[i].Type == Objective.Distance then</p><p>                if ((type(self.Objectives[i].Data[1]) == "number" and self.Objectives[i].Data[1] > 0)</p><p>                or (type(self.Objectives[i].Data[1]) ~= "number")) and self.Objectives[i].Data[4] then</p><p>                    DestroyQuestMarker(self.Objectives[i].Data[2]);</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>    function QuestTemplate:ShowQuestMarkers()</p><p>        for i=1, self.Objectives[0] do</p><p>            if self.Objectives[i].Type == Objective.Distance then</p><p>                if ((type(self.Objectives[i].Data[1]) == "number" and self.Objectives[i].Data[1] > 0)</p><p>                or (type(self.Objectives[i].Data[1]) ~= "number")) and self.Objectives[i].Data[4] then</p><p>                    ShowQuestMarker(self.Objectives[i].Data[2]);</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>    function QuestTemplate:RemoveNPCMarkers()</p><p>        for i=1, self.Objectives[0] do</p><p>            if type(self.Objectives[i].Data) == "table" then</p><p>                if self.Objectives[i].Data[1] == -65565 then</p><p>                    if type(self.Objectives[i].Data[4]) == "table" then</p><p>                        if self.Objectives[i].Data[4].NpcInstance then</p><p>                            self.Objectives[i].Data[4].NpcInstance:Dispose();</p><p>                            self.Objectives[i].Data[4].NpcInstance = nil;</p><p>                        end</p><p>                    end</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>    QuestTemplate.Interrupt_Orig_BundleNonPlayerCharacter = QuestTemplate.Interrupt;</p><p>    QuestTemplate.Interrupt = function(_quest, i)</p><p>        QuestTemplate.Interrupt_Orig_BundleNonPlayerCharacter(_quest, i);</p><p>        _quest:RemoveNPCMarkers();</p><p>    end</p><p>    QuestTemplate.IsObjectiveCompleted_Orig_BundleNonPlayerCharacter = QuestTemplate.IsObjectiveCompleted;</p><p>    QuestTemplate.IsObjectiveCompleted = function(self, objective)</p><p>        local objectiveType = objective.Type;</p><p>        local data = objective.Data;</p><p>        if objective.Completed ~= nil then</p><p>            return objective.Completed;</p><p>        end</p><p>        if objectiveType ~= Objective.Distance then</p><p>            return self:IsObjectiveCompleted_Orig_BundleNonPlayerCharacter(objective);</p><p>        else</p><p>            if data[1] == -65565 then</p><p>                if not IsExisting(data[3]) then</p><p>                    API.Fatal(data[3].. " is dead! :(");</p><p>                    objective.Completed = false;</p><p>                else</p><p>                    if not data[4].NpcInstance then</p><p>                        local NPC = NonPlayerCharacter:New(data[3]);</p><p>                        NPC:SetDialogPartner(data[2]);</p><p>                        data[4].NpcInstance = NPC;</p><p>                    end</p><p>                    if data[4].NpcInstance:HasTalkedTo(data[2]) then</p><p>                        objective.Completed = true;</p><p>                    end</p><p>                    if not objective.Completed then</p><p>                        if not data[4].NpcInstance:IsActive() then</p><p>                            data[4].NpcInstance:Activate();</p><p>                        end</p><p>                    end</p><p>                end</p><p>            else</p><p>                return self:IsObjectiveCompleted_Orig_BundleNonPlayerCharacter(objective);</p><p>            end</p><p>        end</p><p>    end</p><p>-- Rotiert alle nahen Helden zum NPC und den NPC zu dem Helden,</p><p>-- der ihn angesprochen hat.</p><p>-- @within NonPlayerCharacter</p><p>-- @local</p><p>    assert(self ~= BundleNonPlayerCharacter.Global.NonPlayerCharacter, 'Can not be used in static context!');</p><p>    local PlayerID = Logic.EntityGetPlayer(BundleNonPlayerCharacter.Global.LastHeroEntityID);</p><p>    local KnightIDs = {};</p><p>    Logic.GetKnights(PlayerID, KnightIDs);</p><p>    for i= 1, #KnightIDs, 1 do</p><p>        if Logic.GetDistanceBetweenEntities(KnightIDs[i], BundleNonPlayerCharacter.Global.LastNpcEntityID) < 3000 then</p><p>            local x,y,z = Logic.EntityGetPos(KnightIDs[i]);</p><p>            if Logic.IsEntityMoving(KnightIDs[i]) then</p><p>                Logic.MoveEntity(KnightIDs[i], x, y);</p><p>            end</p><p>            LookAt(KnightIDs[i], self.Data.NpcName);</p><p>        end</p><p>    end</p><p>    local NpcOffset = 0;</p><p>    if Logic.IsKnight(GetID(self.Data.NpcName)) then</p><p>        NpcOffset = 15;</p><p>    end</p><p>    LookAt(self.Data.NpcName, BundleNonPlayerCharacter.Global.LastHeroEntityID, NpcOffset);</p><p>    LookAt(BundleNonPlayerCharacter.Global.LastHeroEntityID, self.Data.NpcName, 15);</p><p>-- Erzeugt das Entity des NPC-Markers.</p><p>-- @within NonPlayerCharacter</p><p>-- @local</p><p>    assert(self ~= BundleNonPlayerCharacter.Global.NonPlayerCharacter, 'Can not be used in static context!');</p><p>    local x,y,z = Logic.EntityGetPos(self:GetID());</p><p>    local MarkerID = Logic.CreateEntity(Entities.XD_ScriptEntity, x, y, 0, 0);</p><p>    DestroyEntity(self.Data.MarkerID);</p><p>    self.Data.MarkerID = MarkerID;</p><p>    self:HideMarker();</p><p>    return self;</p><p>-- Entfernt das Entity des NPC-Markers.</p><p>-- @within NonPlayerCharacter</p><p>-- @local</p><p>    assert(self ~= BundleNonPlayerCharacter.Global.NonPlayerCharacter, 'Can not be used in static context!');</p><p>    if self.Data.MarkerID then</p><p>        DestroyEntity(self.Data.MarkerID);</p><p>        self.Data.MarkerID = nil;</p><p>    end</p><p>    return self;</p><p>-- Zeigt den NPC-Marker des NPC an.</p><p>-- @within NonPlayerCharacter</p><p>-- @local</p><p>    assert(self ~= BundleNonPlayerCharacter.Global.NonPlayerCharacter, 'Can not be used in static context!');</p><p>    if IsExisting(self.Data.MarkerID) then</p><p>        local EntityScale = Logic.GetEntityScriptingValue(self:GetID(), -45);</p><p>        Logic.SetEntityScriptingValue(self.Data.MarkerID, -45, EntityScale);</p><p>        Logic.SetModel(self.Data.MarkerID, Models.Effects_E_Wealth);</p><p>        Logic.SetVisible(self.Data.MarkerID, true);</p><p>    end</p><p>    self.Data.MarkerVisibility = true;</p><p>    return self;</p><p>-- Versteckt den NPC-Marker des NPC.</p><p>-- @within NonPlayerCharacter</p><p>-- @local</p><p>    assert(self ~= BundleNonPlayerCharacter.Global.NonPlayerCharacter, 'Can not be used in static context!');</p><p>    if IsExisting(self.Data.MarkerID) then</p><p>        Logic.SetModel(self.Data.MarkerID, Models.Effects_E_NullFX);</p><p>        Logic.SetVisible(self.Data.MarkerID, false);</p><p>    end</p><p>    self.Data.MarkerVisibility = false;</p><p>    return self;</p><p>-- Gibt true zurück, wenn der Marker des NPC sichtbar ist.</p><p>-- @return [boolen] Sichtbarkeit</p><p>-- @within NonPlayerCharacter</p><p>-- @local</p><p>    assert(self ~= BundleNonPlayerCharacter.Global.NonPlayerCharacter, 'Can not be used in static context!');</p><p>    return IsExisting(self.Data.MarkerID) and self.Data.MarkerVisibility == true;</p><p>-- Kontrolliert die Sichtbarkeit und die Position des NPC-Markers.</p><p>-- @within NonPlayerCharacter</p><p>-- @local</p><p>    if self:IsActive() and not self:HasTalkedTo() then</p><p>        -- Blinken</p><p>        if self:IsMarkerVisible() then</p><p>            self:HideMarker();</p><p>        else</p><p>            self:ShowMarker();</p><p>        end</p><p>        -- Repositionierung</p><p>        local x1,y1,z1 = Logic.EntityGetPos(self.Data.MarkerID);</p><p>        local x2,y2,z2 = Logic.EntityGetPos(self:GetID());</p><p>        if math.abs(x1-x2) > 20 or math.abs(y1-y2) > 20 then</p><p>            Logic.DEBUG_SetPosition(self.Data.MarkerID, x2, y2);</p><p>        end</p><p>    end</p><p>    -- Während Briefings immer verstecken</p><p>    if IsBriefingActive and IsBriefingActive() then</p><p>        self:HideMarker();</p><p>    end</p><p>-- Local Script ----------------------------------------------------------------</p><p>-- Initialisiert das Bundle im lokalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    g_CurrentDisplayedQuestID = 0;</p><p>    GUI_Interaction.DisplayQuestObjective_Orig_BundleNonPlayerCharacter = GUI_Interaction.DisplayQuestObjective</p><p>    GUI_Interaction.DisplayQuestObjective = function(_QuestIndex, _MessageKey)</p><p>        local lang = Network.GetDesiredLanguage();</p><p>        if lang ~= "de" then lang = "en" end</p><p>        local QuestIndexTemp = tonumber(_QuestIndex);</p><p>        if QuestIndexTemp then</p><p>            _QuestIndex = QuestIndexTemp;</p><p>        end</p><p>        local Quest, QuestType = GUI_Interaction.GetPotentialSubQuestAndType(_QuestIndex);</p><p>        local QuestObjectivesPath = "/InGame/Root/Normal/AlignBottomLeft/Message/QuestObjectives";</p><p>        XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomLeft/Message/QuestObjectives", 0);</p><p>        local QuestObjectiveContainer;</p><p>        local QuestTypeCaption;</p><p>        local ParentQuest = Quests[_QuestIndex];</p><p>        local ParentQuestIdentifier;</p><p>        if ParentQuest ~= nil</p><p>        and type(ParentQuest) == "table" then</p><p>            ParentQuestIdentifier = ParentQuest.Identifier;</p><p>        end</p><p>        local HookTable = {};</p><p>        g_CurrentDisplayedQuestID = _QuestIndex;</p><p>        if QuestType == Objective.Distance then</p><p>            QuestObjectiveContainer = QuestObjectivesPath .. "/List";</p><p>            QuestTypeCaption = Wrapped_GetStringTableText(_QuestIndex, "UI_Texts/QuestInteraction");</p><p>            local ObjectList = {};</p><p>            if Quest.Objectives[1].Data[1] == -65565 then</p><p>                QuestObjectiveContainer = QuestObjectivesPath .. "/Distance";</p><p>                QuestTypeCaption = Wrapped_GetStringTableText(_QuestIndex, "UI_Texts/QuestMoveHere");</p><p>                SetIcon(QuestObjectiveContainer .. "/QuestTypeIcon",{7,10});</p><p>                local MoverEntityID = GetEntityId(Quest.Objectives[1].Data[2]);</p><p>                local MoverEntityType = Logic.GetEntityType(MoverEntityID);</p><p>                local MoverIcon = g_TexturePositions.Entities[MoverEntityType];</p><p>                if Quest.Objectives[1].Data[1] == -65567 or not MoverIcon then</p><p>                    MoverIcon = {16,12};</p><p>                end</p><p>                SetIcon(QuestObjectiveContainer .. "/IconMover", MoverIcon);</p><p>                local TargetEntityID = GetEntityId(Quest.Objectives[1].Data[3]);</p><p>                local TargetEntityType = Logic.GetEntityType(TargetEntityID);</p><p>                local TargetIcon = g_TexturePositions.Entities[TargetEntityType];</p><p>                if not TargetIcon then</p><p>                    TargetIcon = {14,10};</p><p>                end</p><p>                local IconWidget = QuestObjectiveContainer .. "/IconTarget";</p><p>                local ColorWidget = QuestObjectiveContainer .. "/TargetPlayerColor";</p><p>                SetIcon(IconWidget, TargetIcon);</p><p>                XGUIEng.SetMaterialColor(ColorWidget, 0, 255, 255, 255, 0);</p><p>                SetIcon(QuestObjectiveContainer .. "/QuestTypeIcon",{16,12});</p><p>                local caption = {de = "Gespräch beginnen", en = "Start conversation"};</p><p>                QuestTypeCaption = caption[lang];</p><p>                XGUIEng.SetText(QuestObjectiveContainer.."/Caption","{center}"..QuestTypeCaption);</p><p>                XGUIEng.ShowWidget(QuestObjectiveContainer, 1);</p><p>            else</p><p>                GUI_Interaction.DisplayQuestObjective_Orig_BundleNonPlayerCharacter(_QuestIndex, _MessageKey);</p><p>            end</p><p>        else</p><p>            GUI_Interaction.DisplayQuestObjective_Orig_BundleNonPlayerCharacter(_QuestIndex, _MessageKey);</p><p>        end</p><p>    end</p><p>    GUI_Interaction.GetEntitiesOrTerritoryListForQuest_Orig_BundleNonPlayerCharacter = GUI_Interaction.GetEntitiesOrTerritoryListForQuest</p><p>    GUI_Interaction.GetEntitiesOrTerritoryListForQuest = function( _Quest, _QuestType )</p><p>        local EntityOrTerritoryList = {}</p><p>        local IsEntity = true</p><p>        if _QuestType == Objective.Distance then</p><p>            if _Quest.Objectives[1].Data[1] == -65565 then</p><p>                local Entity = GetEntityId(_Quest.Objectives[1].Data[3]);</p><p>                table.insert(EntityOrTerritoryList, Entity);</p><p>            else</p><p>                return GUI_Interaction.GetEntitiesOrTerritoryListForQuest_Orig_BundleNonPlayerCharacter( _Quest, _QuestType );</p><p>            end</p><p>        else</p><p>            return GUI_Interaction.GetEntitiesOrTerritoryListForQuest_Orig_BundleNonPlayerCharacter( _Quest, _QuestType );</p><p>        end</p><p>        return EntityOrTerritoryList, IsEntity</p><p>    end</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundleplayerhelperfunctions.lua.html">
            <div class='doclink'>
                <div>BundlePlayerHelperFunctions</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia BundlePlayerHelperFunctions                                   # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Mit diesem Bundle kommen einige Funktionalitäten zur Steuerung von</p><p>-- spielerbezogenen Features.</p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Entfernt ein Territorium für den angegebenen Spieler aus der Liste</p><p>-- der entdeckten Territorien.</p><p>-- <p><b>Alias:</b> UndiscoverTerritory</p></p><p>-- @param _PlayerID [number] Spieler-ID</p><p>-- @param _TerritoryID [number] Territorium-ID</p><p>-- @within Anwenderfunktionen</p><p>function API.UndiscoverTerritory(_PlayerID, _TerritoryID)</p><p>    if GUI then</p><p>        API.Bridge("API.UndiscoverTerritory(" .._PlayerID.. ", ".._TerritoryID.. ")")</p><p>        return;</p><p>    end</p><p>    return BundlePlayerHelperFunctions.Global:UndiscoverTerritory(_PlayerID, _TerritoryID);</p><p>-- Entfernt alle Territorien einer Partei aus der Liste der entdeckten</p><p>-- Territorien. Als Nebeneffekt gild die Partei als unentdeckt.</p><p>-- <p><b>Alias:</b> UndiscoverTerritories</p></p><p>-- @param _PlayerID [number] Spieler-ID</p><p>-- @param _TargetPlayerID [number] Zielpartei</p><p>-- @within Anwenderfunktionen</p><p>function API.UndiscoverTerritories(_PlayerID, _TargetPlayerID)</p><p>    if GUI then</p><p>        API.Bridge("API.UndiscoverTerritories(" .._PlayerID.. ", ".._TargetPlayerID.. ")")</p><p>        return;</p><p>    end</p><p>    return BundlePlayerHelperFunctions.Global:UndiscoverTerritories(_PlayerID, _TargetPlayerID);</p><p>-- Setzt die Einnahmen für alle Stadtgebäude eines Spielers. Stadtgebäude</p><p>-- können nur Einnahmen zwischen 0 und 100 Talern haben.</p><p>-- <p><b>Alias:</b> SetPlayerEarnings</p></p><p>-- @param _PlayerID [number] Partei oder nil für alle</p><p>-- @param _Earnings [number] Einnahmen [0 | 100]</p><p>-- @within Anwenderfunktionen</p><p>function API.SetEarningsOfPlayerCity(_PlayerID, _Earnings)</p><p>    if GUI then</p><p>        API.Bridge("API.SetEarningsOfPlayerCity(" .._PlayerID.. ", " .._Earnings.. ")");</p><p>        return;</p><p>    end</p><p>    if _PlayerID ~= -1 and Logic.GetStoreHouse(_PlayerID) == 0 then</p><p>        API.Fatal("API.SetEarningsOfPlayerCity: Player " .._PlayerID.. " is dead! :(");</p><p>        return;</p><p>    end</p><p>    if _Earnings == nil or (_Earnings < 0 or _Earnings > 100) then</p><p>        API.Fatal("API.SetEarningsOfPlayerCity: _Earnings must be between 0 and 100!");</p><p>        return;</p><p>    end</p><p>    return BundlePlayerHelperFunctions.Global:SetEarningsOfPlayerCity(_PlayerID, _Earnings);</p><p>-- Setzt den Befriedigungsstatus eines Bedürfnisses für alle Gebäude</p><p>-- des angegebenen Spielers. Der Befriedigungsstatus ist eine Zahl</p><p>-- zwischen 0.0 und 1.0.</p><p>-- <p><b>Alias:</b> SetNeedSatisfactionLevel</p></p><p>-- @param _Need [number] Bedürfnis</p><p>-- @param _State [number] Erfüllung des Bedürfnisses</p><p>-- @param _PlayerID [number] Partei oder -1 für alle</p><p>-- @within Anwenderfunktionen</p><p>function API.SetNeedSatisfaction(_Need, _State, _PlayerID)</p><p>    if GUI then</p><p>        API.Bridge("API.SetNeedSatisfaction(" .._Need.. ", " .._State.. ", " .._PlayerID.. ")")</p><p>        return;</p><p>    end</p><p>    if _PlayerID ~= -1 and Logic.GetStoreHouse(_PlayerID) == 0 then</p><p>        API.Fatal("API.SetNeedSatisfaction: Player " .._PlayerID.. " is dead! :(");</p><p>        return;</p><p>    end</p><p>    if _State < 0 or _State > 1 then</p><p>        API.Fatal("API.SetNeedSatisfaction: _State must be between 0 and 1!");</p><p>        return;</p><p>    end</p><p>    return BundlePlayerHelperFunctions.Global:SetNeedSatisfactionLevel(_Need, _State, _PlayerID);</p><p>-- Diese Funktion ermöglicht das sichere Entsperren eines gesperrten Titels.</p><p>-- <p><b>Alias:</b> UnlockTitleForPlayer</p></p><p>-- @param _PlayerID [number] Zielpartei</p><p>-- @param _KnightTitle [number] Titel zum Entsperren</p><p>-- @within Anwenderfunktionen</p><p>function API.UnlockTitleForPlayer(_PlayerID, _KnightTitle)</p><p>    if GUI then</p><p>        API.Bridge("API.UnlockTitleForPlayer(" .._PlayerID.. ", " .._KnightTitle.. ")")</p><p>        return;</p><p>    end</p><p>    return BundlePlayerHelperFunctions.Global:UnlockTitleForPlayer(_PlayerID, _KnightTitle);</p><p>-- Startet ein Fest für den Spieler. Ist dieser Typ von Fest für</p><p>-- den Spieler verboten, wird er automatisch erlaubt.</p><p>-- <p><b>Alias:</b> StartNormalFestival</p></p><p>-- @param _PlayerID [number] Spieler</p><p>-- @within Anwenderfunktionen</p><p>function API.StartNormalFestival(_PlayerID)</p><p>    if GUI then</p><p>        API.Bridge("API.StartNormalFestival(".. _PlayerID ..")");</p><p>        return;</p><p>    end</p><p>    BundlePlayerHelperFunctions.Global:RestrictFestivalForPlayer(_PlayerID, 0, false);</p><p>    Logic.StartFestival(_PlayerID, 0);</p><p>-- Startet ein Beförderungsfest für den Spieler. Ist dieser Typ</p><p>-- von Fest für den Spieler verboten, wird er automatisch erlaubt.</p><p>-- <p><b>Alias:</b> StartCityUpgradeFestival</p></p><p>-- @param _PlayerID [number] Spieler</p><p>-- @within Anwenderfunktionen</p><p>function API.StartCityUpgradeFestival(_PlayerID)</p><p>    if GUI then</p><p>        API.Bridge("API.StartCityUpgradeFestival(".. _PlayerID ..")");</p><p>        return;</p><p>    end</p><p>    BundlePlayerHelperFunctions.Global:RestrictFestivalForPlayer(_PlayerID, 1, false);</p><p>    Logic.StartFestival(_PlayerID, 1);</p><p>-- Verbietet ein normales Fest und sperrt die Technologie.</p><p>-- <p><b>Alias:</b> ForbidFestival</p></p><p>-- @param _PlayerID [number] Spieler</p><p>-- @within Anwenderfunktionen</p><p>function API.ForbidFestival(_PlayerID)</p><p>    if GUI then</p><p>        API.Bridge("API.ForbidFestival(".. _PlayerID ..")");</p><p>        return;</p><p>    end</p><p>    local KnightTitle = Logic.GetKnightTitle(_PlayerID)</p><p>    local Technology = Technologies.R_Festival;</p><p>    local State = TechnologyStates.Locked;</p><p>    if KnightTitleNeededForTechnology[Technology] == nil or KnightTitle >= KnightTitleNeededForTechnology[Technology] then</p><p>        State = TechnologyStates.Prohibited;</p><p>    end</p><p>    Logic.TechnologySetState(_PlayerID, Technology, State);</p><p>    BundlePlayerHelperFunctions.Global:RestrictFestivalForPlayer(_PlayerID, 0, true);</p><p>    API.Bridge("BundlePlayerHelperFunctions.Local.Data.NormalFestivalLockedForPlayer[" .._PlayerID.. "] = true");</p><p>-- Erlaubt ein normales Fest und gibt die Technologie frei.</p><p>-- <p><b>Alias:</b> AllowFestival</p></p><p>-- @param _PlayerID [number] Spieler</p><p>-- @within Anwenderfunktionen</p><p>function API.AllowFestival(_PlayerID)</p><p>    if GUI then</p><p>        API.Bridge("API.AllowFestival(".. _PlayerID ..")");</p><p>        return;</p><p>    end</p><p>    BundlePlayerHelperFunctions.Global:RestrictFestivalForPlayer(_PlayerID, 0, false);</p><p>    local KnightTitle = Logic.GetKnightTitle(_PlayerID)</p><p>    local Technology = Technologies.R_Festival;</p><p>    local State = TechnologyStates.Unlocked;</p><p>    if KnightTitleNeededForTechnology[Technology] == nil or KnightTitle >= KnightTitleNeededForTechnology[Technology] then</p><p>        State = TechnologyStates.Researched;</p><p>    end</p><p>    Logic.TechnologySetState(_PlayerID, Technology, State);</p><p>    API.Bridge("BundlePlayerHelperFunctions.Local.Data.NormalFestivalLockedForPlayer[" .._PlayerID.. "] = false");</p><p>-- Wechselt die Spieler ID des menschlichen Spielers. Die neue ID muss</p><p>-- einen Primärritter haben. Diese Funktion kann nicht im Multiplayer</p><p>-- Mode verwendet werden.</p><p>-- <p><b>Alias:</b> PlayerSetPlayerID</p></p><p>-- @param _OldID [number] Alte ID des menschlichen Spielers</p><p>-- @param _NewID [number] Neue ID des menschlichen Spielers</p><p>-- @param _NewName [string] Name in der Statistik</p><p>-- @param _RetainKnight [boolean] Ritter mitnehmen</p><p>-- @within Anwenderfunktionen</p><p>function API.SetControllingPlayer(_OldID, _NewID, _NewName, _RetainKnight)</p><p>    if GUI then</p><p>        API.Bridge("API.SetControllingPlayer(".. _OldID ..", ".. _NewID ..", '".. _NewName .."', ".. tostring(_RetainKnight) ..")");</p><p>        return;</p><p>    end</p><p>    return BundlePlayerHelperFunctions.Global:SetControllingPlayer(_OldID, _NewID, _NewName, _RetainKnight);</p><p>-- Gibt die ID des kontrollierenden Spielers zurück. Der erste als menschlich</p><p>-- definierte Spieler wird als kontrollierender Spieler angenommen.</p><p>-- <p><b>Alias:</b> PlayerGetPlayerID</p></p><p>-- @return [number] PlayerID</p><p>-- @within Anwenderfunktionen</p><p>function API.GetControllingPlayer()</p><p>    if not GUI then</p><p>        return BundlePlayerHelperFunctions.Global:GetControllingPlayer();</p><p>    else</p><p>        return GUI.GetPlayerID();</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {</p><p>        Data = {</p><p>            FestivalBlacklist = {},</p><p>            DiscoveredTerritories = {};</p><p>        }</p><p>    },</p><p>    Local = {</p><p>        Data = {</p><p>            NormalFestivalLockedForPlayer = {},</p><p>        }</p><p>    },</p><p>-- Global Script ---------------------------------------------------------------</p><p>-- Initalisiert das Bundle im globalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    API.AddSaveGameAction(BundlePlayerHelperFunctions.Global.OnSaveGameLoaded);</p><p>-- Überschreibt Logic.StartFestival, sodass das Feierverhalten der KI gesteuert</p><p>-- werden kann.</p><p>-- @within Internal</p><p>-- @local</p><p>    if not Logic.StartFestival_Orig_NothingToCelebrate then</p><p>        Logic.StartFestival_Orig_NothingToCelebrate = Logic.StartFestival;</p><p>    end</p><p>    Logic.StartFestival = function(_PlayerID, _Index)</p><p>        if BundlePlayerHelperFunctions.Global.Data.FestivalBlacklist[_PlayerID] then</p><p>            if BundlePlayerHelperFunctions.Global.Data.FestivalBlacklist[_PlayerID][_Index] then</p><p>                return;</p><p>            end</p><p>        end</p><p>        Logic.StartFestival_Orig_NothingToCelebrate(_PlayerID, _Index);</p><p>    end</p><p>-- Entfernt ein Territorium für den angegebenen Spieler aus der Liste</p><p>-- der entdeckten Territorien.</p><p>-- @param _PlayerID [number] Spieler-ID</p><p>-- @param _TerritoryID [number] Territorium-ID</p><p>-- @within Internal</p><p>-- @local</p><p>    if self.Data.DiscoveredTerritories[_PlayerID] == nil then</p><p>        self.Data.DiscoveredTerritories[_PlayerID] = {};</p><p>    end</p><p>    for i=1, #self.Data.DiscoveredTerritories[_PlayerID], 1 do</p><p>        if self.Data.DiscoveredTerritories[_PlayerID][i] == _TerritoryID then</p><p>            table.remove(self.Data.DiscoveredTerritories[_PlayerID], i);</p><p>            break;</p><p>        end</p><p>    end</p><p>-- Entfernt alle Territorien einer Partei aus der Liste der entdeckten</p><p>-- Territorien. Als Nebeneffekt gild die Partei als unentdeckt-</p><p>-- @param _PlayerID [number] Spieler-ID</p><p>-- @param _TargetPlayerID [number] Zielpartei</p><p>-- @within Internal</p><p>-- @local</p><p>    if self.Data.DiscoveredTerritories[_PlayerID] == nil then</p><p>        self.Data.DiscoveredTerritories[_PlayerID] = {};</p><p>    end</p><p>    local Discovered = {};</p><p>    for k, v in pairs(self.Data.DiscoveredTerritories[_PlayerID]) do</p><p>        local OwnerPlayerID = Logic.GetTerritoryPlayerID(v);</p><p>        if OwnerPlayerID ~= _TargetPlayerID then</p><p>            table.insert(Discovered, v);</p><p>            break;</p><p>        end</p><p>    end</p><p>    self.Data.DiscoveredTerritories[_PlayerID][i] = Discovered;</p><p>-- Setzt die Einnahmen für alle Stadtgebäude eines Spielers. Stadtgebäude</p><p>-- können nur Einnahmen zwischen 0 und 100 Talern haben.</p><p>-- <b>Alias:</b> SetPlayerEarnings</p><p>-- @param _PlayerID [number] Partei oder nil für alle</p><p>-- @param _Earnings [number] Einnahmen [0 | 100]</p><p>-- @within Internal</p><p>-- @local</p><p>    if _PlayerID == -1 then</p><p>        for i=1, 8, 1 do</p><p>            self:SetEarningsOfPlayerCity(i, _Earnings);</p><p>        end</p><p>    else</p><p>        local City = {Logic.GetPlayerEntitiesInCategory(_PlayerID, EntityCategories.CityBuilding)};</p><p>        for i=1, #City, 1 do</p><p>            Logic.SetBuildingEarnings(City[i], _Earnings);</p><p>        end</p><p>    end</p><p>-- Setzt den Befriedigungsstatus eines Bedürfnisses für alle Gebäude</p><p>-- des angegebenen Spielers. Der Befriedigungsstatus ist eine Zahl</p><p>-- zwischen 0.0 und 1.0.</p><p>-- @param _Need [number] Bedürfnis</p><p>-- @param _State [number] Erfüllung des Bedürfnisses</p><p>-- @param _PlayerID [number] Partei oder -1 für alle</p><p>-- @within Internal</p><p>-- @local</p><p>    if _PlayerID == -1 then</p><p>        for i=1, 8, 1 do</p><p>            self:SetNeedSatisfactionLevel(_Need, _State, i);</p><p>        end</p><p>    else</p><p>        local City = {Logic.GetPlayerEntitiesInCategory(_PlayerID, EntityCategories.CityBuilding)};</p><p>        if _Need == Needs.Nutrition or _Need == Needs.Medicine then</p><p>            local Rim = {Logic.GetPlayerEntitiesInCategory(_PlayerID, EntityCategories.OuterRimBuilding)};</p><p>            City = Array_Append(City, Rim);</p><p>        end</p><p>        for j=1, #City, 1 do</p><p>            if Logic.IsNeedActive(City[j], _Need) then</p><p>                Logic.SetNeedState(City[j], _Need, _State);</p><p>            end</p><p>        end</p><p>    end</p><p>-- Entsperrt einen gesperrten Titel für den Spieler.</p><p>-- @param _PlayerID [number] Zielpartei</p><p>-- @param _KnightTitle [number] Titel zum Entsperren</p><p>-- @within Internal</p><p>-- @local</p><p>    if LockedKnightTitles[_PlayerID] == _KnightTitle</p><p>    then</p><p>        LockedKnightTitles[_PlayerID] = nil;</p><p>        for KnightTitle= _KnightTitle, #NeedsAndRightsByKnightTitle</p><p>        do</p><p>            local TechnologyTable = NeedsAndRightsByKnightTitle[KnightTitle][4];</p><p>            if TechnologyTable ~= nil</p><p>            then</p><p>                for i=1, #TechnologyTable</p><p>                do</p><p>                    local TechnologyType = TechnologyTable[i];</p><p>                    Logic.TechnologySetState(_PlayerID, TechnologyType, TechnologyStates.Unlocked);</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>-- Erlaubt oder verbietet ein Fest für den angegebenen Spieler.</p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @param _Index    Index des Fest</p><p>-- @param _Flag [boolean] Erlauben/verbieten</p><p>-- @within Internal</p><p>-- @local</p><p>    self:InitFestival();</p><p>    if not self.Data.FestivalBlacklist[_PlayerID]</p><p>    then</p><p>        self.Data.FestivalBlacklist[_PlayerID] = {};</p><p>    end</p><p>    self.Data.FestivalBlacklist[_PlayerID][_Index] = _Flag == true;</p><p>-- Wechselt die Spieler ID des menschlichen Spielers. Die neue ID muss</p><p>-- einen Primärritter haben. Diese Funktion kann nicht im Multiplayer</p><p>-- Mode verwendet werden.</p><p>-- @param _oldPlayerID [number]Alte ID des menschlichen Spielers</p><p>-- @param _newPlayerID [number]Neue ID des menschlichen Spielers</p><p>-- @param _newNameForStatistics [string]Name in der Statistik</p><p>-- @param _retainPrimaryKnight [boolean]Ritter mitnehmen</p><p>-- @within Internal</p><p>-- @local</p><p>    assert(type(_oldPlayerID) == "number");</p><p>    assert(type(_newPlayerID) == "number");</p><p>    _newNameForStatistics = _newNameForStatistics or "";</p><p>    _retainPrimaryKnight = (_retainPrimaryKnight and true) or false;</p><p>    local eID,eName,eType;</p><p>    if _retainPrimaryKnight then</p><p>        eID   = Logic.GetKnightID(_oldPlayerID);</p><p>        eName = Logic.GetEntityName(eID);</p><p>        eType = Logic.GetEntityType(eID);</p><p>        Logic.ChangeEntityPlayerID(eID,_newPlayerID);</p><p>        Logic.SetPrimaryKnightID(_newPlayerID,GetID(eName));</p><p>    else</p><p>        eID   = Logic.GetKnightID(_newPlayerID);</p><p>        eName = Logic.GetEntityName(eID);</p><p>        eType = Logic.GetEntityType(eID);</p><p>    end</p><p>    Logic.PlayerSetIsHumanFlag(_oldPlayerID, 0);</p><p>    Logic.PlayerSetIsHumanFlag(_newPlayerID, 1);</p><p>    Logic.PlayerSetGameStateToPlaying(_newPlayerID);</p><p>    self.Data.HumanKnightType = eType;</p><p>    self.Data.HumanPlayerID = _newPlayerID;</p><p>    GameCallback_PlayerLost = function( _PlayerID )</p><p>        if _PlayerID == self:GetControllingPlayer() then</p><p>            QuestTemplate:TerminateEventsAndStuff()</p><p>            if MissionCallback_Player1Lost then</p><p>                MissionCallback_Player1Lost()</p><p>            end</p><p>        end</p><p>    end</p><p>    Logic.ExecuteInLuaLocalState([[</p><p>        GUI.ClearSelection()</p><p>        GUI.SetControlledPlayer(]].._newPlayerID..[[)</p><p>        for k,v in pairs(Buffs)do</p><p>            GUI_Buffs.UpdateBuffsInInterface(]].._newPlayerID..[[,v)</p><p>            GUI.ResetMiniMap()</p><p>        end</p><p>        if IsExisting(Logic.GetKnightID(GUI.GetPlayerID())) then</p><p>            local portrait = GetKnightActor(]]..eType..[[)</p><p>            g_PlayerPortrait[GUI.GetPlayerID()] = portrait</p><p>            LocalSetKnightPicture()</p><p>        end</p><p>        local newName = "]].._newNameForStatistics..[["</p><p>        if newName ~= "" then</p><p>            GUI_MissionStatistic.PlayerNames[GUI.GetPlayerID()] = newName</p><p>        end</p><p>        HideOtherMenus()</p><p>        function GUI_Knight.GetTitleNameByTitleID(_KnightType, _TitleIndex)</p><p>            local KeyName = "Title_" .. GetNameOfKeyInTable(KnightTitles, _TitleIndex) .. "_" .. KnightGender[]]..eType..[[]</p><p>            local String = XGUIEng.GetStringTableText("UI_ObjectNames/" .. KeyName)</p><p>            if String == nil or String == "" then</p><p>                String = "Knight not in Gender Table? (localscript.lua)"</p><p>            end</p><p>            return String</p><p>        end</p><p>    ]]);</p><p>    self.Data.HumanPlayerChangedOnce = true;</p><p>-- Gibt die ID des kontrollierenden Spielers zurück. Der erste als menschlich</p><p>-- definierte Spieler wird als kontrollierender Spieler angenommen.</p><p>-- @return [number] PlayerID</p><p>-- @within Internal</p><p>-- @local</p><p>    local pID = 1;</p><p>    for i=1,8 do</p><p>        if Logic.PlayerGetIsHumanFlag(i) == true then</p><p>            pID = i;</p><p>            break;</p><p>        end</p><p>    end</p><p>    return pID;</p><p>-- Stellt nicht-persistente Änderungen nach dem laden wieder her.</p><p>-- @within Internal</p><p>-- @local</p><p>    -- Feste sperren --</p><p>    Logic.StartFestival_Orig_NothingToCelebrate = nil;</p><p>    BundlePlayerHelperFunctions.Global:InitFestival();</p><p>    -- Menschlichen Spieler ändern --</p><p>    if BundlePlayerHelperFunctions.Global.Data.HumanPlayerChangedOnce then</p><p>        Logic.ExecuteInLuaLocalState([[</p><p>            GUI.SetControlledPlayer(]]..BundlePlayerHelperFunctions.Global.Data.HumanPlayerID..[[)</p><p>            for k,v in pairs(Buffs)do</p><p>                GUI_Buffs.UpdateBuffsInInterface(]]..BundlePlayerHelperFunctions.Global.Data.HumanPlayerID..[[,v)</p><p>                GUI.ResetMiniMap()</p><p>            end</p><p>            if IsExisting(Logic.GetKnightID(GUI.GetPlayerID())) then</p><p>                local portrait = GetKnightActor(]]..BundlePlayerHelperFunctions.Global.Data.HumanKnightType..[[)</p><p>                g_PlayerPortrait[]]..BundlePlayerHelperFunctions.Global.Data.HumanPlayerID..[[] = portrait</p><p>                LocalSetKnightPicture()</p><p>            end</p><p>        ]]);</p><p>    end</p><p>-- Local Script ------------------------------------------------------------- --</p><p>    self:InitForbidFestival();</p><p>    self:OverrideQuestLogPlayerIcon();</p><p>    self:OverrideQuestPlayerIcon();</p><p>-- Überschreibt den Button zum Start eines Festes, sodass er nicht angezeigt</p><p>-- wird, wenn Feste verboten sind.</p><p>-- @within Internal</p><p>-- @local</p><p>    NewStartFestivalUpdate = function()</p><p>        local WidgetID = XGUIEng.GetCurrentWidgetID();</p><p>        local PlayerID = GUI.GetPlayerID();</p><p>        if BundlePlayerHelperFunctions.Local.Data.NormalFestivalLockedForPlayer[PlayerID] then</p><p>            XGUIEng.ShowWidget(WidgetID, 0);</p><p>            return true;</p><p>        end</p><p>    end</p><p>    Core:StackFunction("GUI_BuildingButtons.StartFestivalUpdate", NewStartFestivalUpdate);</p><p>-- </p><p>-- @within Internal</p><p>-- @local</p><p>    GUI_Interaction.SetPlayerIcon_Orig_BundlePlayerHelperFunctions = GUI_Interaction.SetPlayerIcon;</p><p>    GUI_Interaction.SetPlayerIcon = function(_PlayerIconContainer, _PlayerID)</p><p>        if _PlayerID == GUI.GetPlayerID() then</p><p>            GUI_Interaction.SetPlayerIcon_Orig_BundlePlayerHelperFunctions(_PlayerIconContainer, _PlayerID);</p><p>            return;</p><p>        end</p><p>        -- Icon</p><p>        local PlayerIcon;</p><p>        local LogoWidget = _PlayerIconContainer .. "/Logo";</p><p>        local PatternWidget = _PlayerIconContainer .. "/Pattern";</p><p>        local PlayerCategory = GetPlayerCategoryType(_PlayerID);</p><p>        local PlayerIcon = g_TexturePositions.PlayerCategories[PlayerCategory];</p><p>        if Mission_Callback_OverridePlayerIconForQuest then</p><p>            PlayerIcon = Mission_Callback_OverridePlayerIconForQuest(_PlayerID) or PlayerIcon;</p><p>        end</p><p>        if PlayerIcon == nil then</p><p>            PlayerIcon = {13, 7};</p><p>        end</p><p>        SetIcon(LogoWidget, PlayerIcon);</p><p>        -- Background</p><p>        SetIcon(PatternWidget, {14, 1});</p><p>        local R, G, B = GUI.GetPlayerColor(_PlayerID);</p><p>        if PlayerCategory == PlayerCategories.Harbour then</p><p>            R, G, B = 255, 255, 255;</p><p>        end</p><p>        XGUIEng.SetMaterialColor(PatternWidget, 0, R, G, B, 255);</p><p>    end</p><p>-- </p><p>-- @within Internal</p><p>-- @local</p><p>    QuestLog.PushQuestGiverLogo_Orig_BundlePlayerHelperFunctions = QuestLog.PushQuestGiverLogo;</p><p>    QuestLog.PushQuestGiverLogo = function(_widgetlist, _PlayerID)</p><p>        local Frame = "Icons.png";</p><p>        local IconSize = 44;</p><p>        local PlayerCategory = GetPlayerCategoryType(_PlayerID);</p><p>        local Coordinates = g_TexturePositions.PlayerCategories[PlayerCategory];</p><p>        </p><p>        if Coordinates ~= nil or Mission_Callback_OverridePlayerIconForQuest then</p><p>            QuestLog.PushQuestGiverLogo_Orig_BundlePlayerHelperFunctions(_widgetlist, _PlayerID);</p><p>            return;</p><p>        end</p><p>        Coordinates = {13, 7};</p><p>        local u0 = (Coordinates[1] - 1) * IconSize;</p><p>        local v0 = (Coordinates[2] - 1) * IconSize;</p><p>        local u1 = Coordinates[1] * IconSize;</p><p>        local v1 = Coordinates[2] * IconSize;</p><p>        if Coordinates[3] and Coordinates[3] == 1 then</p><p>            Frame = "Icons2.png";</p><p>        end</p><p>        XGUIEng.ListBoxPushItemEx(_widgetlist, "", Frame, nil, u0, v0, u1, v1);</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundlequestgeneration.lua.html">
            <div class='doclink'>
                <div>BundleQuestGeneration</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia BundleQuestGeneration                                        # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Mit diesem Bundle können Aufträge per Skript erstellt werden.</p><p>-- Normaler Weise werden Aufträge im Questassistenten erzeugt. Dies ist aber</p><p>-- statisch und das Kopieren von Aufträgen ist nicht möglich. Wenn Aufträge</p><p>-- im Skript erzeugt werden, verschwinden alle diese Nachteile. Aufträge</p><p>-- können im Skript kopiert und angepasst werden. Es ist ebenfalls machbar,</p><p>-- die Aufträge in Sequenzen zu erzeugen.</p><p>-- <p><a href="#API.CreateQuest">Quests erzeugen</a></p></p><p>-- @within Modulbeschreibung</p><p>-- @set sort=false</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Erstellt einen Quest.</p><p>-- Ein Quest braucht immer wenigstens ein Goal und einen Trigger. Hat ein Quest</p><p>-- keinen Namen, erhält er automatisch einen mit fortlaufender Nummerierung.</p><p>-- Ein Quest besteht aus verschiedenen Eigenschaften und Behavior, die nicht</p><p>-- alle zwingend gesetzt werden müssen. Behavior werden einfach nach den</p><p>-- Eigenschaften nacheinander angegeben.</p><p>-- <p><u>Eigenschaften:</u></p></p><p>-- <ul></p><p>-- <li>Name: Der eindeutige Name des Quests</li></p><p>-- <li>Sender: PlayerID des Auftraggeber (Default 1)</li></p><p>-- <li>Receiver: PlayerID des Auftragnehmer (Default 1)</li></p><p>-- <li>Suggestion: Vorschlagnachricht des Quests</li></p><p>-- <li>Success: Erfolgsnachricht des Quest</li></p><p>-- <li>Failure: Fehlschlagnachricht des Quest</li></p><p>-- <li>Description: Aufgabenbeschreibung (Nur bei Custom)</li></p><p>-- <li>Time: Zeit bis zu, Fehlschlag/Abschluss</li></p><p>-- <li>Loop: Funktion, die während der Laufzeit des Quests aufgerufen wird</li></p><p>-- <li>Callback: Funktion, die nach Abschluss aufgerufen wird</li></p><p>-- </ul></p><p>-- <p><b>Alias:</b> AddQuest</p></p><p>-- @param _Data [table] Questdefinition</p><p>-- @return [string] Name des Quests</p><p>-- @return [number] Gesamtzahl Quests</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- AddQuest {</p><p>--     Name        = "ExampleQuest",</p><p>--     Suggestion  = "Wir müssen das Kloster finden.",</p><p>--     Success     = "Dies sind die berümten Heilermönche.",</p><p>--     Goal_DiscoverPlayer(4),</p><p>--     Reward_Diplomacy(1, 4, "EstablishedContact"),</p><p>--     Trigger_Time(0),</p><p>-- }</p><p>function API.CreateQuest(_Data)</p><p>    if GUI then</p><p>        API.Fatal("API.CreateQuest: Could not execute in local script!");</p><p>        return;</p><p>    end</p><p>    return BundleQuestGeneration.Global:QuestCreateNewQuest(_Data);</p><p>-- Erzeugt eine Nachricht im Questfenster.</p><p>-- Der erzeugte Quest wird immer fehlschlagen. Der angezeigte Test ist die</p><p>-- Failure Message. Der Quest wird immer nach Ablauf der Wartezeit nach</p><p>-- Abschluss des Ancestor Quest gestartet bzw. unmittelbar, wenn es keinen</p><p>-- Ancestor Quest gibt. Das Callback ist eine Funktion, die zur Anzeigezeit</p><p>-- des Quests ausgeführt wird.</p><p>-- Alle Paramater sind optional und können von rechts nach links weggelassen</p><p>-- oder mit nil aufgefüllt werden.</p><p>-- <b>Alias</b>: QuestMessage</p><p>-- @param _Text       [string] Anzeigetext der Nachricht</p><p>-- @param _Sender     [number] Sender der Nachricht</p><p>-- @param _Receiver   [number] Receiver der Nachricht</p><p>-- @param _AncestorWt [number] Wartezeit</p><p>-- @param _Callback   [function] Callback</p><p>-- @param _Ancestor   [string] Vorgänger-Quest</p><p>-- @return [string] QuestName</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.CreateQuestMessage("Das ist ein Text", 4, 1);</p><p>function API.CreateQuestMessage(_Text, _Sender, _Receiver, _AncestorWt, _Callback, _Ancestor)</p><p>    if GUI then</p><p>        API.Fatal("API.CreateQuestMessage: Could not execute in local script!");</p><p>        return;</p><p>    end</p><p>    return BundleQuestGeneration.Global:QuestMessage(_Text, _Sender, _Receiver, _AncestorWt, _Callback, _Ancestor);</p><p>-- Erzeugt aus einer Table mit Daten eine Reihe von Nachrichten, die nach</p><p>-- einander angezeigt werden.</p><p>-- Der Vorgänger-Quest und die Wartezeit müssen als Felder gesondert</p><p>-- angegeben werden. Ab dem zweiten Eintrag werden sie ermittelt, sollten</p><p>-- sie nicht angegeben sein. Es können Einträge von rechts nach links</p><p>-- weggelassen werden.</p><p>-- Diese Funktion ist geeignet um Dialoge zu konfigurieren!</p><p>-- <b>Alias</b>: QuestDialog</p><p>-- Einzelne Einträge pro Quest:</p><p>-- <ul></p><p>-- <li>Anzeigetext der Nachricht</li></p><p>-- <li>PlayerID des Sender der Nachricht</li></p><p>-- <li>PlayerID des Empfängers der Nachricht</li></p><p>-- <li>Name des vorangegangenen Quest</li></p><p>-- <li>Wartezeit bis zum Start</li></p><p>-- </ul></p><p>-- @param _Messages [table] Liste der anzuzeigenden Nachrichten</p><p>-- @return [string] Name des letzten Quest</p><p>-- @return [table] Namensliste der Quests</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.CreateQuestDialog{</p><p>--     Name = "DialogName",</p><p>--     Ancestor = "SomeQuestName",</p><p>--     Delay = 12,</p><p>--     {"Hallo, wie geht es dir?", 4, 1},</p><p>--     {"Mir geht es gut, wie immer!", 1, 1},</p><p>--     {"Das ist doch schön.", 4, 1},</p><p>-- };</p><p>function API.CreateQuestDialog(_Messages)</p><p>    if GUI then</p><p>        API.Fatal("API.CreateQuestDialog: Could not execute in local script!");</p><p>        return;</p><p>    end</p><p>    table.insert(_Messages, {"KEY(NO_MESSAGE)", 1, 1});</p><p>    local QuestName;</p><p>    local GeneratedQuests = {};</p><p>    for i= 1, #_Messages, 1 do</p><p>        _Messages[i][4] = _Messages[i][4] or 12;</p><p>        if i > 1 then</p><p>            _Messages[i][6] = _Messages[i][6] or QuestName;</p><p>        else</p><p>            _Messages[i][6] = _Messages[i][6] or _Messages.Ancestor;</p><p>            _Messages[i][4] = _Messages.Delay or 0;</p><p>        end</p><p>        if i == #_Messages and #_Messages[i-1] then</p><p>            _Messages[i][7] = _Messages.Name;</p><p>            _Messages[i][4] = _Messages[i-1][4];</p><p>        end</p><p>        QuestName = BundleQuestGeneration.Global:QuestMessage(unpack(_Messages[i]));</p><p>        table.insert(GeneratedQuests, QuestName);</p><p>    end</p><p>    -- Benannte Dialoge für spätere Zugriffe speichern.</p><p>    if _Messages.Name then</p><p>        QSB.GeneratedQuestDialogs[_Messages.Name] = GeneratedQuests;</p><p>    end</p><p>    return GeneratedQuests[#GeneratedQuests], GeneratedQuests;</p><p>-- Unterbricht einen laufenden oder noch nicht gestarteten Quest-Dialog.</p><p>-- Die Funktion kann entweder anhand eines Dialognamen den Dialog zurücksetzen</p><p>-- oder direkt die Table der erzeugten Quests annehmen.</p><p>-- <b>Alias</b>: QuestDialogInterrupt</p><p>-- @param _Dialog [string|table] Dialog der neu gestartet wird</p><p>-- @within Anwenderfunktionen</p><p>function API.InterruptQuestDialog(_Dialog)</p><p>    if GUI then</p><p>        API.Fatal("API.InterruptQuestDialog: Could not execute in local script!");</p><p>        return;</p><p>    end</p><p>    local QuestDialog = _Dialog;</p><p>    if type(QuestDialog) == "string" then</p><p>        QuestDialog = QSB.GeneratedQuestDialogs[QuestDialog];</p><p>    end</p><p>    if QuestDialog == nil then</p><p>        API.Fatal("API.InterruptQuestDialog: Dialog is invalid!");</p><p>        return;</p><p>    end</p><p>    for i= 1, #QuestDialog-1, 1 do</p><p>        API.StopQuest(QuestDialog[i], true);</p><p>    end</p><p>    API.WinQuest(QuestDialog[#QuestDialog], true);</p><p>-- Setzt einen Quest-Dialog zurück sodass er erneut gestartet werden kann.</p><p>-- Die Funktion kann entweder anhand eines Dialognamen den Dialog zurücksetzen</p><p>-- oder direkt die Table der erzeugten Quests annehmen.</p><p>-- <b>Alias</b>: QuestDialogRestart</p><p>-- @param _Dialog [string|table] Dialog der neu gestartet wird</p><p>-- @within Anwenderfunktionen</p><p>function API.RestartQuestDialog(_Dialog)</p><p>    if GUI then</p><p>        API.Fatal("API.ResetQuestDialog: Could not execute in local script!");</p><p>        return;</p><p>    end</p><p>    local QuestDialog = _Dialog;</p><p>    if type(QuestDialog) == "string" then</p><p>        QuestDialog = QSB.GeneratedQuestDialogs[QuestDialog];</p><p>    end</p><p>    if QuestDialog == nil then</p><p>        API.Fatal("API.ResetQuestDialog: Dialog is invalid!");</p><p>        return;</p><p>    end</p><p>    for i= 1, #QuestDialog, 1 do</p><p>        Quests[GetQuestID(QuestDialog[i])].Triggers[1][2][1].WaitTimeTimer = nil;</p><p>        API.RestartQuest(QuestDialog[i], true);</p><p>    end</p><p>    Quests[GetQuestID(QuestDialog[1])]:Trigger();</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {</p><p>        Data = {</p><p>            QuestMessageID = 0,</p><p>        }</p><p>    },</p><p>-- Global Script ---------------------------------------------------------------</p><p>-- Initalisiert das Bundle im globalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>-- Erzeugt eine Nachricht im Questfenster.</p><p>-- Der erzeugte Quest wird immer fehlschlagen. Der angezeigte Test ist die</p><p>-- Failure Message. Der Quest wird immer nach Ablauf der Wartezeit nach</p><p>-- Abschluss des Ancestor Quest gestartet bzw. unmittelbar, wenn es keinen</p><p>-- Ancestor Quest gibt. Das Callback ist eine Funktion, die zur Anzeigezeit</p><p>-- des Quests ausgeführt wird.</p><p>-- Alle Paramater sind optional und können von rechts nach links weggelassen</p><p>-- oder mit nil aufgefüllt werden.</p><p>-- @param _Text       [string] Anzeigetext der Nachricht</p><p>-- @param _Sender     [number] Sender der Nachricht</p><p>-- @param _Receiver   [number] Receiver der Nachricht</p><p>-- @param _AncestorWt [number] Wartezeit</p><p>-- @param _Callback   [function] Callback</p><p>-- @param _Ancestor   [string] Vorgänger-Quest</p><p>-- @param _QuestName  [string] Name des Auftrags</p><p>-- @return [string] QuestName</p><p>-- @within Internal</p><p>-- @local</p><p>    self.Data.QuestMessageID = self.Data.QuestMessageID +1;</p><p>    -- Trigger-Nachbau</p><p>    local OnQuestOver = {</p><p>        Triggers.Custom2, {</p><p>            {QuestName = _Ancestor, WaitTime = _AncestorWt or 1,},</p><p>                function(_Data)</p><p>                local QuestID = GetQuestID(_Data.QuestName);</p><p>                if not _Data.QuestName then</p><p>                    return true;</p><p>                end</p><p>                if (Quests[QuestID] and Quests[QuestID].State == QuestState.Over and Quests[QuestID].Result ~= QuestResult.Interrupted) then</p><p>                    _Data.WaitTimeTimer = _Data.WaitTimeTimer or API.RealTimeGetSecondsPassedSinceGameStart();</p><p>                    if API.RealTimeGetSecondsPassedSinceGameStart() >= _Data.WaitTimeTimer + _Data.WaitTime then</p><p>                        return true;</p><p>                    end</p><p>                end</p><p>                return false;</p><p>            end</p><p>        }</p><p>    };</p><p>    -- Lokalisierung</p><p>    local Language = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>    if type(_Text) == "table" then</p><p>        _Text = _Text[Language];</p><p>    end</p><p>    -- Quest erzeugen</p><p>    local _, CreatedQuest = QuestTemplate:New(</p><p>        (_QuestName ~= nil and _QuestName) or "QSB_QuestMessage_" ..self.Data.QuestMessageID,</p><p>        (_Sender or 1),</p><p>        (_Receiver or 1),</p><p>        { {Objective.Dummy} },</p><p>        { OnQuestOver },</p><p>        0, nil, nil, _Callback, nil, false, (_Text ~= nil), nil, nil, _Text, nil</p><p>    );</p><p>    return CreatedQuest.Identifier;</p><p>-- Erzeugt einen Quest.</p><p>-- @param _Data [table] Daten des Quest.</p><p>-- @return [string] Name des erzeugten Quests</p><p>-- @within Internal</p><p>-- @local</p><p>    if not _Data.Name then</p><p>        QSB.AutomaticQuestNameCounter = (QSB.AutomaticQuestNameCounter or 0) +1;</p><p>        _Data.Name = string.format("AutoNamed_Quest_d", QSB.AutomaticQuestNameCounter);</p><p>    end</p><p>    if not Core:CheckQuestName(_Data.Name) then</p><p>        dbg("Quest '"..tostring(_Data.Name).."': invalid questname! Contains forbidden characters!");</p><p>        return;</p><p>    end</p><p>    local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>    -- Questdaten erzeugen</p><p>    local QuestData = {</p><p>        _Data.Name,</p><p>        (_Data.Sender ~= nil and _Data.Sender) or 1,</p><p>        (_Data.Receiver ~= nil and _Data.Receiver) or 1,</p><p>        {},</p><p>        {},</p><p>        (_Data.Time ~= nil and _Data.Time) or 0,</p><p>        {},</p><p>        {},</p><p>        _Data.Callback,</p><p>        _Data.Loop,</p><p>        _Data.Visible == true or _Data.Suggestion ~= nil,</p><p>        _Data.EndMessage == true or (_Data.Failure ~= nil or _Data.Success ~= nil),</p><p>        (type(_Data.Description) == "table" and _Data.Description[lang]) or _Data.Description,</p><p>        (type(_Data.Suggestion) == "table" and _Data.Suggestion[lang]) or _Data.Suggestion,</p><p>        (type(_Data.Success) == "table" and _Data.Success[lang]) or _Data.Success,</p><p>        (type(_Data.Failure) == "table" and _Data.Failure[lang]) or _Data.Failure</p><p>    };</p><p>    -- Daten validieren</p><p>    if not self:QuestValidateQuestData(QuestData) then</p><p>        API.Fatal("AddQuest: Error while creating quest. Table has been copied to log.");</p><p>        API.DumpTable(QuestData, "Quest");</p><p>        return;</p><p>    end</p><p>    -- Behaviour</p><p>    for k,v in pairs(_Data) do</p><p>        if tonumber(k) ~= nil then</p><p>            if type(v) == "table" then</p><p>                if v.GetGoalTable then</p><p>                    table.insert(QuestData[4], v:GetGoalTable());</p><p>                    local Idx = #QuestData[4];</p><p>                    QuestData[4][Idx].Context            = v;</p><p>                    QuestData[4][Idx].FuncOverrideIcon   = QuestData[4][Idx].Context.GetIcon;</p><p>                    QuestData[4][Idx].FuncOverrideMsgKey = QuestData[4][Idx].Context.GetMsgKey;</p><p>                elseif v.GetReprisalTable then</p><p>                    table.insert(QuestData[8], v:GetReprisalTable());</p><p>                elseif v.GetRewardTable then</p><p>                    table.insert(QuestData[7], v:GetRewardTable());</p><p>                else</p><p>                    table.insert(QuestData[5], v:GetTriggerTable());</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>    -- Quest erzeugen</p><p>    local QuestID, Quest = QuestTemplate:New(unpack(QuestData, 1, 16));</p><p>    Quest.MsgTableOverride = _Data.MSGKeyOverwrite;</p><p>    Quest.IconOverride = _Data.IconOverwrite;</p><p>    Quest.Arguments = (_Data.Arguments ~= nil and API.InstanceTable(_Data.Arguments)) or {};</p><p>    return _Data.Name;</p><p>-- Validiert die Felder eines Quests.</p><p>-- @param _Data [table] Daten des Quest.</p><p>-- @return [boolean] Quest OK</p><p>-- @within Internal</p><p>-- @local</p><p>    return (</p><p>        (type(_Data[1]) == "string" and self:QuestValidateQuestName(_Data[1])) and</p><p>        (type(_Data[2]) == "number" and _Data[2] >= 1 and _Data[2] <= 8) and</p><p>        (type(_Data[3]) == "number" and _Data[3] >= 1 and _Data[3] <= 8) and</p><p>        (type(_Data[6]) == "number" and _Data[6] >= 0) and</p><p>        ((_Data[9] ~= nil and type(_Data[9]) == "function") or (_Data[9] == nil)) and</p><p>        ((_Data[10] ~= nil and type(_Data[10]) == "function") or (_Data[10] == nil)) and</p><p>        (type(_Data[11]) == "boolean") and</p><p>        (type(_Data[12]) == "boolean") and</p><p>        ((_Data[13] ~= nil and type(_Data[13]) == "string") or (_Data[13] == nil)) and</p><p>        ((_Data[14] ~= nil and type(_Data[14]) == "string") or (_Data[14] == nil)) and</p><p>        ((_Data[15] ~= nil and type(_Data[15]) == "string") or (_Data[15] == nil)) and</p><p>        ((_Data[16] ~= nil and type(_Data[16]) == "string") or (_Data[16] == nil))</p><p>    );</p><p>-- Validiert den Namen eines Quests.</p><p>-- @param _Name [string] Name des Quest.</p><p>-- @return [boolean] Name OK</p><p>-- @within Internal</p><p>-- @local</p><p>    return string.find(_Name, "^[A-Za-z0-9_]+$") ~= nil;</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundlesymfoniabehaviors.lua.html">
            <div class='doclink'>
                <div>BundleSymfoniaBehaviors</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia BundleSymfoniaBehaviors                                      # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Dieses Bundle enthält einige weitere nützliche Standard-Behavior.</p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Hier gibt es keine Funktionen!</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Goals                                                                      --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ein Entity muss sich zu einem Ziel bewegen und eine Distanz unterschreiten.</p><p>-- Optional kann das Ziel mit einem Marker markiert werden.</p><p>-- @param _ScriptName Skriptname des Entity</p><p>-- @param _Target     Skriptname des Ziels</p><p>-- @param _Distance   Entfernung</p><p>-- @param _UseMarker  Ziel markieren</p><p>-- @within Goal</p><p>    return b_Goal_MoveToPosition:new(...);</p><p>Goal_MoveToPosition</p><p>    Name = "Goal_MoveToPosition",</p><p>    Description = {</p><p>        en = "Goal: A entity have to moved as close as the distance to another entity. The target can be marked with a static marker.",</p><p>        de = "Ziel: Eine Entity muss sich einer anderen bis auf eine bestimmte Distanz nähern. Die Lupe wird angezeigt, das Ziel kann markiert werden.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Entity",   de = "Entity" },</p><p>        { ParameterType.ScriptName, en = "Target",   de = "Ziel" },</p><p>        { ParameterType.Number,     en = "Distance", de = "Entfernung" },</p><p>        { ParameterType.Custom,     en = "Marker",   de = "Ziel markieren" },</p><p>    },</p><p>    return {Objective.Distance, self.Entity, self.Target, self.Distance, self.Marker}</p><p>    if (_Index == 0) then</p><p>        self.Entity = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.Target = _Parameter</p><p>    elseif (_Index == 2) then</p><p>        self.Distance = _Parameter * 1</p><p>    elseif (_Index == 3) then</p><p>        self.Marker = AcceptAlternativeBoolean(_Parameter)</p><p>    end</p><p>    local Data = {};</p><p>    if _Index == 3 then</p><p>        Data = {"true", "false"}</p><p>    end</p><p>    return Data</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der Spieler muss einen bestimmten Quest abschließen.</p><p>-- @param _QuestName Name des Quest</p><p>-- @within Goal</p><p>    return b_Goal_WinQuest:new(...);</p><p>Goal_WinQuest</p><p>    Name = "Goal_WinQuest",</p><p>    Description = {</p><p>        en = "Goal: The player has to win a given quest",</p><p>        de = "Ziel: Der Spieler muss eine angegebene Quest erfolgreich abschliessen.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.QuestName, en = "Quest Name",      de = "Questname" },</p><p>    },</p><p>    return {Objective.Custom2, {self, self.CustomFunction}};</p><p>    if (_Index == 0) then</p><p>        self.Quest = _Parameter;</p><p>    end</p><p>    local quest = Quests[GetQuestID(self.Quest)];</p><p>    if quest then</p><p>        if quest.Result == QuestResult.Failure then</p><p>            return false;</p><p>        end</p><p>        if quest.Result == QuestResult.Success then</p><p>            return true;</p><p>        end</p><p>    end</p><p>    return nil;</p><p>    if Quests[GetQuestID(self.Quest)] == nil then</p><p>        dbg(_Quest.Identifier .. ": " .. self.Name .. ": Quest '"..self.Quest.."' does not exist!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- <p>Der Spieler muss eine bestimmte Menge Gold mit Dieben stehlen.</p></p><p>-- <p>Dabei ist es egal von welchem Spieler. Diebe können Gold nur aus</p><p>-- Stadtgebäude stehlen.</p></p><p>-- <p><b>Hinweis</b>:Das Behavior cheatet allen Zielspielern Einnahmen in den</p><p>-- Gebäuden, damit der Quest stets erfüllbar bleibt.</p></p><p>-- @param _Amount       Menge an Gold</p><p>-- @param _ShowProgress Fortschritt ausgeben</p><p>-- @within Goal</p><p>    return b_Goal_StealGold:new(...)</p><p>Goal_StealGold</p><p>    Name = "Goal_StealGold",</p><p>    Description = {</p><p>        en = "Goal: Steal an explicit amount of gold from a players or any players city buildings.",</p><p>        de = "Ziel: Diebe sollen eine bestimmte Menge Gold aus feindlichen Stadtgebäuden stehlen.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Number,   en = "Amount on Gold", de = "Zu stehlende Menge" },</p><p>        { ParameterType.Custom,   en = "Target player",  de = "Spieler von dem gestohlen wird" },</p><p>        { ParameterType.Custom,   en = "Print progress", de = "Fortschritt ausgeben" },</p><p>    },</p><p>    return {Objective.Custom2, {self, self.CustomFunction}};</p><p>    if (_Index == 0) then</p><p>        self.Amount = _Parameter * 1;</p><p>    elseif (_Index == 1) then</p><p>        local PlayerID = tonumber(_Paramater) or -1;</p><p>        self.Target = PlayerID * 1;</p><p>    elseif (_Index == 2) then</p><p>        _Parameter = _Parameter or "true"</p><p>        self.Printout = AcceptAlternativeBoolean(_Parameter);</p><p>    end</p><p>    self.StohlenGold = 0;</p><p>    if _Index == 1 then</p><p>        return { "-", 1, 2, 3, 4, 5, 6, 7, 8 };</p><p>    elseif _Index == 2 then</p><p>        return { "true", "false" };</p><p>    end</p><p>    local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>    local TargetPlayerName = (lang == "de" and " anderen Spielern ") or " different parties";</p><p>    if self.Target ~= -1 then</p><p>        TargetPlayerName = GetPlayerName(self.Target);</p><p>        if TargetPlayerName == nil or TargetPlayerName == "" then</p><p>            TargetPlayerName = " PLAYER_NAME_MISSING ";</p><p>        end</p><p>    end</p><p>    -- Cheat earnings</p><p>    local PlayerIDs = {self.Target};</p><p>    if self.Target == -1 then</p><p>        PlayerIDs = {1, 2, 3, 4, 5, 6, 7, 8};</p><p>    end</p><p>    for i= 1, #PlayerIDs, 1 do</p><p>        if i ~= _Quest.ReceivingPlayer and Logic.GetStoreHouse(i) ~= 0 then</p><p>            local CityBuildings = {Logic.GetPlayerEntitiesInCategory(i, EntityCategories.CityBuilding)};</p><p>            for j= 1, #CityBuildings, 1 do</p><p>                local CurrentEarnings = Logic.GetBuildingProductEarnings(CityBuildings[j]);</p><p>                if CurrentEarnings < 45 and Logic.GetTime()  5 == 0 then</p><p>                    Logic.SetBuildingEarnings(CityBuildings[j], CurrentEarnings +1);</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>    local amount = self.Amount-self.StohlenGold;</p><p>    amount = (amount > 0 and amount) or 0;</p><p>    local text = {</p><p>        de = "Gold von s stehlen {cr}{cr}Aus Stadtgebäuden zu stehlende Goldmenge: d",</p><p>        en = "Steal gold from s {cr}{cr}Amount on gold to steal from city buildings: d",</p><p>    };</p><p>    return "{center}" ..string.format(text[lang], TargetPlayerName, amount);</p><p>    Core:ChangeCustomQuestCaptionText(self:SetDescriptionOverwrite(_Quest), _Quest);</p><p>    if self.StohlenGold >= self.Amount then</p><p>        return true;</p><p>    end</p><p>    return nil;</p><p>    return {5,13};</p><p>    if tonumber(self.Amount) == nil and self.Amount < 0 then</p><p>        dbg(_Quest.Identifier .. ": " .. self.Name .. ": amount can not be negative!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>    self.StohlenGold = 0;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- <p>Der Spieler muss ein bestimmtes Stadtgebäude bestehlen.</p></p><p>-- <p>Eine Kirche wird immer Sabotiert. Ein Lagerhaus verhält sich ähnlich zu</p><p>-- einer Burg.</p></p><p>-- <p><b>Hinweis</b>:Das Behavior cheatet in dem Zielgebäude einnahmen, damit</p><p>-- ein Dieb entsandt werden kann.</p></p><p>-- @param _ScriptName Skriptname des Gebäudes</p><p>-- @within Goal</p><p>    return b_Goal_StealBuilding:new(...)</p><p>Goal_StealBuilding</p><p>    Name = "Goal_StealBuilding",</p><p>    Description = {</p><p>        en = "Goal: The player has to steal from a building. Not a castle and not a village storehouse!",</p><p>        de = "Ziel: Der Spieler muss ein bestimmtes Gebäude bestehlen. Dies darf keine Burg und kein Dorflagerhaus sein!",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Building", de = "Gebäude" },</p><p>    },</p><p>    return {Objective.Custom2, {self, self.CustomFunction}};</p><p>    if (_Index == 0) then</p><p>        self.Building = _Parameter</p><p>    end</p><p>    self.RobberList = {};</p><p>    if _Index == 1 then</p><p>        return { "true", "false" };</p><p>    end</p><p>    local isCathedral = Logic.IsEntityInCategory(GetID(self.Building), EntityCategories.Cathedrals) == 1;</p><p>    local isWarehouse = Logic.GetEntityType(GetID(self.Building)) == Entities.B_StoreHouse;</p><p>    local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>    local text;</p><p>    if isCathedral then</p><p>        text = {</p><p>            de = "Sabotage {cr}{cr} Sabotiert die mit Pfeil markierte Kirche.",</p><p>            en = "Sabotage {cr}{cr} Sabotage the Church of the opponent.",</p><p>        };</p><p>    elseif isWarehouse then</p><p>        text = {</p><p>            de = "Lagerhaus bestehlen {cr}{cr} Sendet einen Dieb in das markierte Lagerhaus.",</p><p>            en = "Steal from storehouse {cr}{cr} Steal from the marked storehouse.",</p><p>        };</p><p>    else</p><p>        text = {</p><p>            de = "Gebäude bestehlen {cr}{cr} Bestehlt das durch einen Pfeil markierte Gebäude.",</p><p>            en = "Steal from building {cr}{cr} Steal from the building marked by an arrow.",</p><p>        };</p><p>    end</p><p>    return "{center}" .. text[lang];</p><p>    if not IsExisting(self.Building) then</p><p>        if self.Marker then</p><p>            Logic.DestroyEffect(self.Marker);</p><p>        end</p><p>        return false;</p><p>    end</p><p>    if not self.Marker then</p><p>        local pos = GetPosition(self.Building);</p><p>        self.Marker = Logic.CreateEffect(EGL_Effects.E_Questmarker, pos.X, pos.Y, 0);</p><p>    end</p><p>    -- Cheat earnings</p><p>    local BuildingID = GetID(self.Building);</p><p>    if  Logic.IsEntityInCategory(BuildingID, EntityCategories.CityBuilding) == 1</p><p>    and Logic.GetBuildingEarnings(BuildingID) < 10 then</p><p>        Logic.SetBuildingEarnings(BuildingID, 10);</p><p>    end</p><p>    if self.SuccessfullyStohlen then</p><p>        Logic.DestroyEffect(self.Marker);</p><p>        return true;</p><p>    end</p><p>    return nil;</p><p>    return {5,13};</p><p>    local eTypeName = Logic.GetEntityTypeName(Logic.GetEntityType(GetID(self.Building)));</p><p>    local IsHeadquarter = Logic.IsEntityInCategory(GetID(self.Building), EntityCategories.Headquarters) == 1;</p><p>    if Logic.IsBuilding(GetID(self.Building)) == 0 then</p><p>        dbg(_Quest.Identifier .. ": " .. self.Name .. ": target is not a building");</p><p>        return true;</p><p>    elseif not IsExisting(self.Building) then</p><p>        dbg(_Quest.Identifier .. ": " .. self.Name .. ": target is destroyed :(");</p><p>        return true;</p><p>    elseif string.find(eTypeName, "B_NPC_BanditsHQ") or string.find(eTypeName, "B_NPC_Cloister") or string.find(eTypeName, "B_NPC_StoreHouse") then</p><p>        dbg(_Quest.Identifier .. ": " .. self.Name .. ": village storehouses are not allowed!");</p><p>        return true;</p><p>    elseif IsHeadquarter then</p><p>        dbg(_Quest.Identifier .. ": " .. self.Name .. ": use Goal_StealInformation for headquarters!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>    self.SuccessfullyStohlen = false;</p><p>    self.RobberList = {};</p><p>    self.Marker = nil;</p><p>    Logic.DestroyEffect(self.Marker);</p><p>-- -------------------------------------------------------------------------- --</p><p>-- <p>Der Spieler muss ein Gebäude mit einem Dieb ausspoinieren.</p></p><p>-- <p>Der Quest ist erfolgreich, sobald der Dieb in das Gebäude eindringt. Es</p><p>-- muss sich um ein Gebäude handeln, das bestohlen werden kann (Burg, Lager,</p><p>-- Kirche, Stadtgebäude mit Einnahmen)!</p></p><p>-- <p>Optional kann der Dieb nach Abschluss gelöscht werden. Diese Option macht</p><p>-- es einfacher ihn durch z.B. einen Abfahrenden U_ThiefCart zu ersetzen.</p></p><p>-- <p><b>Hinweis</b>:Das Behavior cheatet in dem Zielgebäude einnahmen, damit</p><p>-- ein Dieb entsandt werden kann.</p></p><p>-- @param _ScriptName  Skriptname des Gebäudes</p><p>-- @param _DeleteThief Dieb nach Abschluss löschen</p><p>-- @within Goal</p><p>    return b_Goal_SpyBuilding:new(...)</p><p>Goal_SpyBuilding</p><p>    Name = "Goal_SpyBuilding",</p><p>    IconOverwrite = {5,13},</p><p>    Description = {</p><p>        en = "Goal: Infiltrate a building with a thief. A thief must be able to steal from the target building.",</p><p>        de = "Ziel: Infiltriere ein Gebäude mit einem Dieb. Nur mit Gebaueden möglich, die bestohlen werden koennen.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Target Building", de = "Zielgebäude" },</p><p>        { ParameterType.Custom,     en = "Destroy Thief", de = "Dieb löschen" },</p><p>    },</p><p>    return {Objective.Custom2, {self, self.CustomFunction}};</p><p>    if (_Index == 0) then</p><p>        self.Building = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        _Parameter = _Parameter or "true"</p><p>        self.Delete = AcceptAlternativeBoolean(_Parameter)</p><p>    end</p><p>    if _Index == 1 then</p><p>        return { "true", "false" };</p><p>    end</p><p>    if not _Quest.QuestDescription then</p><p>        local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>        local text = {</p><p>            de = "Gebäude infriltrieren {cr}{cr}Spioniere das markierte Gebäude mit einem Dieb aus!",</p><p>            en = "Infiltrate building {cr}{cr}Spy on the highlighted buildings with a thief!",</p><p>        };</p><p>        return text[lang];</p><p>    else</p><p>        return _Quest.QuestDescription;</p><p>    end</p><p>    if not IsExisting(self.Building) then</p><p>        if self.Marker then</p><p>            Logic.DestroyEffect(self.Marker);</p><p>        end</p><p>        return false;</p><p>    end</p><p>    if not self.Marker then</p><p>        local pos = GetPosition(self.Building);</p><p>        self.Marker = Logic.CreateEffect(EGL_Effects.E_Questmarker, pos.X, pos.Y, 0);</p><p>    end</p><p>    -- Cheat earnings</p><p>    local BuildingID = GetID(self.Building);</p><p>    if  Logic.IsEntityInCategory(BuildingID, EntityCategories.CityBuilding) == 1</p><p>    and Logic.GetBuildingEarnings(BuildingID) < 10 then</p><p>        Logic.SetBuildingEarnings(BuildingID, 10);</p><p>    end</p><p>    if self.Infiltrated then</p><p>        Logic.DestroyEffect(self.Marker);</p><p>        return true;</p><p>    end</p><p>    return nil;</p><p>    return self.IconOverwrite;</p><p>    if Logic.IsBuilding(GetID(self.Building)) == 0 then</p><p>        dbg(_Quest.Identifier .. ": " .. self.Name .. ": target is not a building");</p><p>        return true;</p><p>    elseif not IsExisting(self.Building) then</p><p>        dbg(_Quest.Identifier .. ": " .. self.Name .. ": target is destroyed :(");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>    self.Infiltrated = false;</p><p>    self.Marker = nil;</p><p>    Logic.DestroyEffect(self.Marker);</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Es muss eine Menge an Munition in der Kriegsmaschine erreicht werden.</p><p>-- <u>Relationen</u></p><p>-- <ul></p><p>-- <li>>= - Anzahl als Mindestmenge</li></p><p>-- <li>< - Weniger als Anzahl</li></p><p>-- </ul></p><p>-- @param _ScriptName  Name des Kriegsgerät</p><p>-- @param _Relation    Mengenrelation</p><p>-- @param _Amount      Menge an Munition</p><p>-- @within Goal</p><p>    return b_Goal_AmmunitionAmount:new(...);</p><p>Goal_AmmunitionAmount</p><p>    Name = "Goal_AmmunitionAmount",</p><p>    Description = {</p><p>        en = "Goal: Reach a smaller or bigger value than the given amount of ammunition in a war machine.",</p><p>        de = "Ziel: Ueber- oder unterschreite die angegebene Anzahl Munition in einem Kriegsgerät.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Script name", de = "Skriptname" },</p><p>        { ParameterType.Custom, en = "Relation", de = "Relation" },</p><p>        { ParameterType.Number, en = "Amount", de = "Menge" },</p><p>    },</p><p>    return { Objective.Custom2, {self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.Scriptname = _Parameter</p><p>    elseif (_Index == 1) then</p><p>        self.bRelSmallerThan = tostring(_Parameter) == "true" or _Parameter == "<"</p><p>    elseif (_Index == 2) then</p><p>        self.Amount = _Parameter * 1</p><p>    end</p><p>    local EntityID = GetID(self.Scriptname);</p><p>    if not IsExisting(EntityID) then</p><p>        return false;</p><p>    end</p><p>    local HaveAmount = Logic.GetAmmunitionAmount(EntityID);</p><p>    if ( self.bRelSmallerThan and HaveAmount < self.Amount ) or ( not self.bRelSmallerThan and HaveAmount >= self.Amount ) then</p><p>        return true;</p><p>    end</p><p>    return nil;</p><p>    if self.Amount < 0 then</p><p>        dbg(_Quest.Identifier .. ": Error in " .. self.Name .. ": Amount is negative");</p><p>        return true</p><p>    end</p><p>    if _Index == 1 then</p><p>        return {"<", ">="};</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Reprisals                                                                  --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ändert die Position eines Siedlers oder eines Gebäudes.</p><p>-- Optional kann das Entity in einem bestimmten Abstand zum Ziel platziert</p><p>-- werden und das Ziel anschauen. Die Entfernung darf nicht kleiner sein</p><p>-- als 50!</p><p>-- @param _ScriptName Skriptname des Entity</p><p>-- @param _Target     Skriptname des Ziels</p><p>-- @param _LookAt     Gegenüberstellen</p><p>-- @param _Distance   Relative Entfernung (nur mit _LookAt)</p><p>-- @within Reprisal</p><p>    return b_Reprisal_SetPosition:new(...);</p><p>Reprisal_SetPosition</p><p>    Name = "Reprisal_SetPosition",</p><p>    Description = {</p><p>        en = "Reprisal: Places an entity relative to the position of another. The entity can look the target.",</p><p>        de = "Vergeltung: Setzt eine Entity relativ zur Position einer anderen. Die Entity kann zum Ziel ausgerichtet werden.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Entity",             de = "Entity", },</p><p>        { ParameterType.ScriptName, en = "Target position", de = "Zielposition", },</p><p>        { ParameterType.Custom,     en = "Face to face",     de = "Ziel ansehen", },</p><p>        { ParameterType.Number,     en = "Distance",         de = "Zielentfernung", },</p><p>    },</p><p>    return { Reprisal.Custom, { self, self.CustomFunction } }</p><p>    if (_Index == 0) then</p><p>        self.Entity = _Parameter;</p><p>    elseif (_Index == 1) then</p><p>        self.Target = _Parameter;</p><p>    elseif (_Index == 2) then</p><p>        self.FaceToFace = AcceptAlternativeBoolean(_Parameter)</p><p>    elseif (_Index == 3) then</p><p>        self.Distance = (_Parameter ~= nil and tonumber(_Parameter)) or 100;</p><p>    end</p><p>    if not IsExisting(self.Entity) or not IsExisting(self.Target) then</p><p>        return;</p><p>    end</p><p>    local entity = GetID(self.Entity);</p><p>    local target = GetID(self.Target);</p><p>    local x,y,z = Logic.EntityGetPos(target);</p><p>    if Logic.IsBuilding(target) == 1 then</p><p>        x,y = Logic.GetBuildingApproachPosition(target);</p><p>    end</p><p>    local ori = Logic.GetEntityOrientation(target)+90;</p><p>    if self.FaceToFace then</p><p>        x = x + self.Distance * math.cos( math.rad(ori) );</p><p>        y = y + self.Distance * math.sin( math.rad(ori) );</p><p>        Logic.DEBUG_SetSettlerPosition(entity, x, y);</p><p>        LookAt(self.Entity, self.Target);</p><p>    else</p><p>        if Logic.IsBuilding(target) == 1 then</p><p>            x,y = Logic.GetBuildingApproachPosition(target);</p><p>        end</p><p>        Logic.DEBUG_SetSettlerPosition(entity, x, y);</p><p>    end</p><p>    if _Index == 3 then</p><p>        return { "true", "false" }</p><p>    end</p><p>    if self.FaceToFace then</p><p>        if tonumber(self.Distance) == nil or self.Distance < 50 then</p><p>            dbg(_Quest.Identifier.. " " ..self.Name.. ": Distance is nil or to short!");</p><p>            return true;</p><p>        end</p><p>    end</p><p>    if not IsExisting(self.Entity) or not IsExisting(self.Target) then</p><p>        dbg(_Quest.Identifier.. " " ..self.Name.. ": Mover entity or target entity does not exist!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ändert den Eigentümer des Entity oder des Battalions.</p><p>-- @param _ScriptName Skriptname des Entity</p><p>-- @param _NewOwner   PlayerID des Eigentümers</p><p>-- @within Reprisal</p><p>    return b_Reprisal_ChangePlayer:new(...)</p><p>Reprisal_ChangePlayer</p><p>    Name = "Reprisal_ChangePlayer",</p><p>    Description = {</p><p>        en = "Reprisal: Changes the owner of the entity or a battalion.",</p><p>        de = "Vergeltung: Aendert den Besitzer einer Entity oder eines Battalions.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Entity",     de = "Entity", },</p><p>        { ParameterType.Custom,     en = "Player",     de = "Spieler", },</p><p>    },</p><p>    return { Reprisal.Custom, { self, self.CustomFunction } }</p><p>    if (_Index == 0) then</p><p>        self.Entity = _Parameter;</p><p>    elseif (_Index == 1) then</p><p>        self.Player = tostring(_Parameter);</p><p>    end</p><p>    if not IsExisting(self.Entity) then</p><p>        return;</p><p>    end</p><p>    local eID = GetID(self.Entity);</p><p>    if Logic.IsLeader(eID) == 1 then</p><p>        Logic.ChangeSettlerPlayerID(eID, self.Player);</p><p>    else</p><p>        Logic.ChangeEntityPlayerID(eID, self.Player);</p><p>    end</p><p>    if _Index == 1 then</p><p>        return {"0", "1", "2", "3", "4", "5", "6", "7", "8"}</p><p>    end</p><p>    if not IsExisting(self.Entity) then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": entity '"..  self.Entity .. "' does not exist!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ändert die Sichtbarkeit eines Entity.</p><p>-- @param _ScriptName Skriptname des Entity</p><p>-- @param _Visible    Sichtbarkeit an/aus</p><p>-- @within Reprisal</p><p>    return b_Reprisal_SetVisible:new(...)</p><p>Reprisal_SetVisible</p><p>    Name = "Reprisal_SetVisible",</p><p>    Description = {</p><p>        en = "Reprisal: Changes the visibility of an entity. If the entity is a spawner the spawned entities will be affected.",</p><p>        de = "Strafe: Setzt die Sichtbarkeit einer Entity. Handelt es sich um einen Spawner werden auch die gespawnten Entities beeinflusst.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Entity",     de = "Entity", },</p><p>        { ParameterType.Custom,     en = "Visible",     de = "Sichtbar", },</p><p>    },</p><p>    return { Reprisal.Custom, { self, self.CustomFunction } }</p><p>    if (_Index == 0) then</p><p>        self.Entity = _Parameter;</p><p>    elseif (_Index == 1) then</p><p>        self.Visible = AcceptAlternativeBoolean(_Parameter)</p><p>    end</p><p>    if not IsExisting(self.Entity) then</p><p>        return;</p><p>    end</p><p>    local eID = GetID(self.Entity);</p><p>    local pID = Logic.EntityGetPlayer(eID);</p><p>    local eType = Logic.GetEntityType(eID);</p><p>    local tName = Logic.GetEntityTypeName(eType);</p><p>    if string.find(tName, "S_") or string.find(tName, "B_NPC_Bandits")</p><p>    or string.find(tName, "B_NPC_Barracks") then</p><p>        local spawned = {Logic.GetSpawnedEntities(eID)};</p><p>        for i=1, #spawned do</p><p>            if Logic.IsLeader(spawned[i]) == 1 then</p><p>                local soldiers = {Logic.GetSoldiersAttachedToLeader(spawned[i])};</p><p>                for j=2, #soldiers do</p><p>                    Logic.SetVisible(soldiers[j], self.Visible);</p><p>                end</p><p>            else</p><p>                Logic.SetVisible(spawned[i], self.Visible);</p><p>            end</p><p>        end</p><p>    else</p><p>        if Logic.IsLeader(eID) == 1 then</p><p>            local soldiers = {Logic.GetSoldiersAttachedToLeader(eID)};</p><p>            for j=2, #soldiers do</p><p>                Logic.SetVisible(soldiers[j], self.Visible);</p><p>            end</p><p>        else</p><p>            Logic.SetVisible(eID, self.Visible);</p><p>        end</p><p>    end</p><p>    if _Index == 1 then</p><p>        return { "true", "false" }</p><p>    end</p><p>    if not IsExisting(self.Entity) then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": entity '"..  self.Entity .. "' does not exist!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Macht das Entity verwundbar oder unverwundbar.</p><p>-- Bei einem Battalion wirkt sich das Behavior auf alle Soldaten und den</p><p>-- (unsichtbaren) Leader aus. Wird das Behavior auf ein Spawner Entity </p><p>-- angewendet, werden die gespawnten Entities genommen.</p><p>-- @param _ScriptName Skriptname des Entity</p><p>-- @param _Vulnerable Verwundbarkeit an/aus</p><p>-- @within Reprisal</p><p>    return b_Reprisal_SetVulnerability:new(...);</p><p>Reprisal_SetVulnerability</p><p>    Name = "Reprisal_SetVulnerability",</p><p>    Description = {</p><p>        en = "Reprisal: Changes the vulnerability of the entity. If the entity is a spawner the spawned entities will be affected.",</p><p>        de = "Vergeltung: Macht eine Entity verwundbar oder unverwundbar. Handelt es sich um einen Spawner, sind die gespawnten Entities betroffen",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Entity",              de = "Entity", },</p><p>        { ParameterType.Custom,     en = "Vulnerability",      de = "Verwundbar", },</p><p>    },</p><p>    return { Reprisal.Custom, { self, self.CustomFunction } }</p><p>    if (_Index == 0) then</p><p>        self.Entity = _Parameter;</p><p>    elseif (_Index == 1) then</p><p>        self.Vulnerability = AcceptAlternativeBoolean(_Parameter)</p><p>    end</p><p>    if not IsExisting(self.Entity) then</p><p>        return;</p><p>    end</p><p>    local eID = GetID(self.Entity);</p><p>    local eType = Logic.GetEntityType(eID);</p><p>    local tName = Logic.GetEntityTypeName(eType);</p><p>    local EntitiesToCheck = {eID};</p><p>    if string.find(tName, "S_") or string.find(tName, "B_NPC_Bandits")</p><p>    or string.find(tName, "B_NPC_Barracks") then</p><p>        EntitiesToCheck = {Logic.GetSpawnedEntities(eID)};</p><p>    end</p><p>    local MethodToUse = "MakeInvulnerable";</p><p>    if self.Vulnerability then</p><p>        MethodToUse = "MakeVulnerable";</p><p>    end</p><p>    for i= 1, #EntitiesToCheck, 1 do</p><p>        if Logic.IsLeader(EntitiesToCheck[i]) == 1 then</p><p>            local Soldiers = {Logic.GetSoldiersAttachedToLeader(EntitiesToCheck[i])};</p><p>            for j=2, #Soldiers, 1 do</p><p>                _G[MethodToUse](Soldiers[j]);</p><p>            end</p><p>        end</p><p>        _G[MethodToUse](EntitiesToCheck[i]);</p><p>    end</p><p>    if _Index == 1 then</p><p>        return { "true", "false" }</p><p>    end</p><p>    if not IsExisting(self.Entity) then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": entity '"..  self.Entity .. "' does not exist!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ändert das Model eines Entity.</p><p>-- In Verbindung mit Reward_SetVisible oder Reprisal_SetVisible können</p><p>-- Script Entites ein neues Model erhalten und sichtbar gemacht werden.</p><p>-- Das hat den Vorteil, das Script Entities nicht überbaut werden können.</p><p>-- @param _ScriptName Skriptname des Entity</p><p>-- @param _Model      Neues Model</p><p>-- @within Reprisal</p><p>    return b_Reprisal_SetModel:new(...);</p><p>Reprisal_SetModel</p><p>    Name = "Reprisal_SetModel",</p><p>    Description = {</p><p>        en = "Reprisal: Changes the model of the entity. Be careful, some models crash the game.",</p><p>        de = "Vergeltung: Aendert das Model einer Entity. Achtung: Einige Modelle fuehren zum Absturz.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Entity",     de = "Entity", },</p><p>        { ParameterType.Custom,     en = "Model",     de = "Model", },</p><p>    },</p><p>    return { Reprisal.Custom, { self, self.CustomFunction } }</p><p>    if (_Index == 0) then</p><p>        self.Entity = _Parameter;</p><p>    elseif (_Index == 1) then</p><p>        self.Model = _Parameter;</p><p>    end</p><p>    if not IsExisting(self.Entity) then</p><p>        return;</p><p>    end</p><p>    local eID = GetID(self.Entity);</p><p>    Logic.SetModel(eID, Models[self.Model]);</p><p>    if _Index == 1 then</p><p>        local Data = {};</p><p>        for k,v in pairs(Models) do</p><p>            if  not string.find(k,"Animals_") and not string.find(k,"Banners_") and not string.find(k,"Goods_") and not string.find(k,"goods_")</p><p>            and not string.find(k,"Heads_") and not string.find(k,"MissionMap_") and not string.find(k,"R_Fish") and not string.find(k,"Units_")</p><p>            and not string.find(k,"XD_") and not string.find(k,"XS_") and not string.find(k,"XT_") and not string.find(k,"Z_") then</p><p>                table.insert(Data,k);</p><p>            end</p><p>        end</p><p>        return Data;</p><p>    end</p><p>    if not IsExisting(self.Entity) then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": entity '"..  self.Entity .. "' does not exist!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Rewards                                                                    --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ändert die Position eines Siedlers oder eines Gebäudes.</p><p>-- Optional kann das Entity in einem bestimmten Abstand zum Ziel platziert</p><p>-- werden und das Ziel anschauen. Die Entfernung darf nicht kleiner sein</p><p>-- als 50!</p><p>-- @param _ScriptName Skriptname des Entity</p><p>-- @param _Target     Skriptname des Ziels</p><p>-- @param _LookAt     Gegenüberstellen</p><p>-- @param _Distance   Relative Entfernung (nur mit _LookAt)</p><p>-- @within Reward</p><p>    return b_Reward_SetPosition:new(...);</p><p>Reward_SetPosition = API.InstanceTable(b_Reprisal_SetPositi</p><p>Reward_SetPosition.Name = "Reward_SetPositi</p><p>Reward_SetPosition.Description.en = "Reward: Places an entity relative to the position of another. The entity can look the targe</p><p>Reward_SetPosition.Description.de = "Lohn: Setzt eine Entity relativ zur Position einer anderen. Die Entity kann zum Ziel ausgerichtet werde</p><p>Reward_SetPosition.GetReprisalTable = </p><p>Reward_SetPosition.GetRewardTable = function(self, _Qu</p><p>    return { Reward.Custom, { self, self.CustomFunction } };</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ändert den Eigentümer des Entity oder des Battalions.</p><p>-- @param _ScriptName Skriptname des Entity</p><p>-- @param _NewOwner   PlayerID des Eigentümers</p><p>-- @within Reward</p><p>    return b_Reward_ChangePlayer:new(...);</p><p>Reward_ChangePlayer = API.InstanceTable(b_Reprisal_ChangePlay</p><p>Reward_ChangePlayer.Name = "Reward_ChangePlay</p><p>Reward_ChangePlayer.Description.en = "Reward: Changes the owner of the entity or a battalio</p><p>Reward_ChangePlayer.Description.de = "Lohn: Aendert den Besitzer einer Entity oder eines Battalion</p><p>Reward_ChangePlayer.GetReprisalTable = </p><p>Reward_ChangePlayer.GetRewardTable = function(self, _Qu</p><p>    return { Reward.Custom, { self, self.CustomFunction } };</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Bewegt einen Siedler relativ zu einem Zielpunkt.</p><p>-- Der Siedler wird sich zum Ziel ausrichten und in der angegeben Distanz</p><p>-- und dem angegebenen Winkel Position beziehen.</p><p>-- <p><b>Hinweis:</b> Funktioniert ähnlich wie MoveEntityToPositionToAnotherOne.</p><p>-- </p></p><p>-- @param _ScriptName  Skriptname des Entity</p><p>-- @param _Destination Skriptname des Ziels</p><p>-- @param _Distance    Entfernung</p><p>-- @param _Angle       Winkel</p><p>-- @within Reward</p><p>    return b_Reward_MoveToPosition:new(...);</p><p>Reward_MoveToPosition</p><p>    Name = "Reward_MoveToPosition",</p><p>    Description = {</p><p>        en = "Reward: Moves an entity relative to another entity. If angle is zero the entities will be standing directly face to face.",</p><p>        de = "Lohn: Bewegt eine Entity relativ zur Position einer anderen. Wenn Winkel 0 ist, stehen sich die Entities direkt gegen�ber.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Settler", de = "Siedler" },</p><p>        { ParameterType.ScriptName, en = "Destination", de = "Ziel" },</p><p>        { ParameterType.Number,     en = "Distance", de = "Entfernung" },</p><p>        { ParameterType.Number,     en = "Angle", de = "Winkel" },</p><p>    },</p><p>    return { Reward.Custom, {self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.Entity = _Parameter;</p><p>    elseif (_Index == 1) then</p><p>        self.Target = _Parameter;</p><p>    elseif (_Index == 2) then</p><p>        self.Distance = _Parameter * 1;</p><p>    elseif (_Index == 3) then</p><p>        self.Angle = _Parameter * 1;</p><p>    end</p><p>    if not IsExisting(self.Entity) or not IsExisting(self.Target) then</p><p>        return;</p><p>    end</p><p>    self.Angle = self.Angle or 0;</p><p>    local entity = GetID(self.Entity);</p><p>    local target = GetID(self.Target);</p><p>    local orientation = Logic.GetEntityOrientation(target);</p><p>    local x,y,z = Logic.EntityGetPos(target);</p><p>    if Logic.IsBuilding(target) == 1 then</p><p>        x, y = Logic.GetBuildingApproachPosition(target);</p><p>        orientation = orientation -90;</p><p>    end</p><p>    x = x + self.Distance * math.cos( math.rad(orientation+self.Angle) );</p><p>    y = y + self.Distance * math.sin( math.rad(orientation+self.Angle) );</p><p>    Logic.MoveSettler(entity, x, y);</p><p>    StartSimpleJobEx( function(_entityID, _targetID)</p><p>        if Logic.IsEntityMoving(_entityID) == false then</p><p>            LookAt(_entityID, _targetID);</p><p>            return true;</p><p>        end</p><p>    end, entity, target);</p><p>    if tonumber(self.Distance) == nil or self.Distance < 50 then</p><p>        dbg(_Quest.Identifier.. " " ..self.Name.. ": Distance is nil or to short!");</p><p>        return true;</p><p>    elseif not IsExisting(self.Entity) or not IsExisting(self.Target) then</p><p>        dbg(_Quest.Identifier.. " " ..self.Name.. ": Mover entity or target entity does not exist!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Der Spieler gewinnt das Spiel mit einem animierten Siegesfest.</p><p>-- Es ist nicht möglich weiterzuspielen!</p><p>-- @within Reward</p><p>    return b_Reward_VictoryWithParty:new();</p><p>Reward_VictoryWithParty</p><p>    Name = "Reward_VictoryWithParty",</p><p>    Description = {</p><p>        en = "Reward: The player wins the game with an animated festival on the market.",</p><p>        de = "Lohn: Der Spieler gewinnt das Spiel mit einer animierten Siegesfeier.",</p><p>    },</p><p>    Parameter =    {}</p><p>    return {Reward.Custom, {self, self.CustomFunction}};</p><p>    Victory(g_VictoryAndDefeatType.VictoryMissionComplete);</p><p>    local pID = _Quest.ReceivingPlayer;</p><p>    local market = Logic.GetMarketplace(pID);</p><p>    if IsExisting(market) then</p><p>        local pos = GetPosition(market)</p><p>        Logic.CreateEffect(EGL_Effects.FXFireworks01,pos.X,pos.Y,0);</p><p>        Logic.CreateEffect(EGL_Effects.FXFireworks02,pos.X,pos.Y,0);</p><p>        local PossibleSettlerTypes = {</p><p>            Entities.U_SmokeHouseWorker,</p><p>            Entities.U_Butcher,</p><p>            Entities.U_Carpenter,</p><p>            Entities.U_Tanner,</p><p>            Entities.U_Blacksmith,</p><p>            Entities.U_CandleMaker,</p><p>            Entities.U_Baker,</p><p>            Entities.U_DairyWorker,</p><p>            Entities.U_SpouseS01,</p><p>            Entities.U_SpouseS02,</p><p>            Entities.U_SpouseS02,</p><p>            Entities.U_SpouseS03,</p><p>            Entities.U_SpouseF01,</p><p>            Entities.U_SpouseF01,</p><p>            Entities.U_SpouseF02,</p><p>            Entities.U_SpouseF03,</p><p>        };</p><p>        VictoryGenerateFestivalAtPlayer(pID, PossibleSettlerTypes);</p><p>        Logic.ExecuteInLuaLocalState([[</p><p>            if IsExisting(]]..market..[[) then</p><p>                CameraAnimation.AllowAbort = false</p><p>                CameraAnimation.QueueAnimation( CameraAnimation.SetCameraToEntity, ]]..market..[[)</p><p>                CameraAnimation.QueueAnimation( CameraAnimation.StartCameraRotation,  5 )</p><p>                CameraAnimation.QueueAnimation( CameraAnimation.Stay ,  9999 )</p><p>            end</p><p>            XGUIEng.ShowWidget("/InGame/InGame/MissionEndScreen/ContinuePlaying", 0);</p><p>        ]]);</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ändert die Sichtbarkeit eines Entity.</p><p>-- @param _ScriptName Skriptname des Entity</p><p>-- @param _Visible    Sichtbarkeit an/aus</p><p>-- @within Reprisal</p><p>    return b_Reward_SetVisible:new(...)</p><p>Reward_SetVisible = API.InstanceTable(b_Reprisal_SetVisib</p><p>Reward_SetVisible.Name = "Reward_SetVisib</p><p>Reward_SetVisible.Description.en = "Reward: Changes the visibility of an entity. If the entity is a spawner the spawned entities will be affecte</p><p>Reward_SetVisible.Description.de = "Lohn: Setzt die Sichtbarkeit einer Entity. Handelt es sich um einen Spawner werden auch die gespawnten Entities beeinfluss</p><p>Reward_SetVisible.GetReprisalTable = </p><p>Reward_SetVisible.GetRewardTable = function(self, _Qu</p><p>    return { Reward.Custom, { self, self.CustomFunction } }</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Gibt oder entzieht einem KI-Spieler die Kontrolle über ein Entity.</p><p>-- @param _ScriptName Skriptname des Entity</p><p>-- @param _Controlled Durch KI kontrollieren an/aus</p><p>-- @within Reward</p><p>    return b_Reward_AI_SetEntityControlled:new(...);</p><p>Reward_AI_SetEntityControlled</p><p>    Name = "Reward_AI_SetEntityControlled",</p><p>    Description = {</p><p>        en = "Reward: Bind or Unbind an entity or a battalion to/from an AI player. The AI player must be activated!",</p><p>        de = "Lohn: Die KI kontrolliert die Entity oder der KI die Kontrolle entziehen. Die KI muss aktiv sein!",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Entity",               de = "Entity", },</p><p>        { ParameterType.Custom,     en = "AI control entity", de = "KI kontrolliert Entity", },</p><p>    },</p><p>    return { Reward.Custom, { self, self.CustomFunction } }</p><p>    if (_Index == 0) then</p><p>        self.Entity = _Parameter;</p><p>    elseif (_Index == 1) then</p><p>        self.Hidden = AcceptAlternativeBoolean(_Parameter)</p><p>    end</p><p>    if not IsExisting(self.Entity) then</p><p>        return;</p><p>    end</p><p>    local eID = GetID(self.Entity);</p><p>    local pID = Logic.EntityGetPlayer(eID);</p><p>    local eType = Logic.GetEntityType(eID);</p><p>    local tName = Logic.GetEntityTypeName(eType);</p><p>    if string.find(tName, "S_") or string.find(tName, "B_NPC_Bandits")</p><p>    or string.find(tName, "B_NPC_Barracks") then</p><p>        local spawned = {Logic.GetSpawnedEntities(eID)};</p><p>        for i=1, #spawned do</p><p>            if Logic.IsLeader(spawned[i]) == 1 then</p><p>                AICore.HideEntityFromAI(pID, spawned[i], not self.Hidden);</p><p>            end</p><p>        end</p><p>    else</p><p>        AICore.HideEntityFromAI(pID, eID, not self.Hidden);</p><p>    end</p><p>    if _Index == 1 then</p><p>        return { "false", "true" }</p><p>    end</p><p>    if not IsExisting(self.Entity) then</p><p>        dbg(_Quest.Identifier .. " " .. self.Name .. ": entity '"..  self.Entity .. "' does not exist!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Macht das Entity verwundbar oder unverwundbar.</p><p>-- Bei einem Battalion wirkt sich das Behavior auf alle Soldaten und den</p><p>-- (unsichtbaren) Leader aus. Wird das Behavior auf ein Spawner Entity </p><p>-- angewendet, werden die gespawnten Entities genommen.</p><p>-- @param _ScriptName Skriptname des Entity</p><p>-- @param _Vulnerable Verwundbarkeit an/aus</p><p>-- @within Reward</p><p>    return b_Reward_SetVulnerability:new(...);</p><p>Reward_SetVulnerability = API.InstanceTable(b_Reprisal_SetVulnerabili</p><p>Reward_SetVulnerability.Name = "Reward_SetVulnerabili</p><p>Reward_SetVulnerability.Description.en = "Reward: Changes the vulnerability of the entity. If the entity is a spawner the spawned entities will be affecte</p><p>Reward_SetVulnerability.Description.de = "Lohn: Macht eine Entity verwundbar oder unverwundbar. Handelt es sich um einen Spawner, sind die gespawnten Entities betroffe</p><p>Reward_SetVulnerability.GetReprisalTable = </p><p>Reward_SetVulnerability.GetRewardTable = function(self, _Qu</p><p>    return { Reward.Custom, { self, self.CustomFunction } }</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Ändert das Model eines Entity.</p><p>-- In Verbindung mit Reward_SetVisible oder Reprisal_SetVisible können</p><p>-- Script Entites ein neues Model erhalten und sichtbar gemacht werden.</p><p>-- Das hat den Vorteil, das Script Entities nicht überbaut werden können.</p><p>-- @param _ScriptName Skriptname des Entity</p><p>-- @param _Model      Neues Model</p><p>-- @within Reward</p><p>    return b_Reward_SetModel:new(...);</p><p>Reward_SetModel = API.InstanceTable(b_Reprisal_SetMod</p><p>Reward_SetModel.Name = "Reward_SetMod</p><p>Reward_SetModel.Description.en = "Reward: Changes the model of the entity. Be careful, some models crash the gam</p><p>Reward_SetModel.Description.de = "Lohn: Aendert das Model einer Entity. Achtung: Einige Modelle fuehren zum Abstur</p><p>Reward_SetModel.GetReprisalTable = </p><p>Reward_SetModel.GetRewardTable = function(self, _Qu</p><p>    return { Reward.Custom, { self, self.CustomFunction } }</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Füllt die Munition in der Kriegsmaschine vollständig auf.</p><p>-- @param _ScriptName Skriptname des Entity</p><p>-- @within Reward</p><p>    return b_Reward_RefillAmmunition:new(...);</p><p>Reward_RefillAmmunition</p><p>    Name = "Reward_RefillAmmunition",</p><p>    Description = {</p><p>        en = "Reward: Refills completely the ammunition of the entity.",</p><p>        de = "Lohn: Fuellt die Munition der Entity vollständig auf.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.ScriptName, en = "Script name", de = "Skriptname" },</p><p>    },</p><p>    return { Reward.Custom, {self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.Scriptname = _Parameter</p><p>    end</p><p>    local EntityID = GetID(self.Scriptname);</p><p>    if not IsExisting(EntityID) then</p><p>        return;</p><p>    end</p><p>    local Ammunition = Logic.GetAmmunitionAmount(EntityID);</p><p>    while (Ammunition < 10)</p><p>    do</p><p>        Logic.RefillAmmunitions(EntityID);</p><p>        Ammunition = Logic.GetAmmunitionAmount(EntityID);</p><p>    end</p><p>    if not IsExisting(self.Scriptname) then</p><p>        dbg(_Quest.Identifier .. ": Error in " .. self.Name .. ": '"..self.Scriptname.."' is destroyed!");</p><p>        return true</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Trigger                                                                    --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet den Quest, sobald mindestens X von Y Quests fehlgeschlagen sind.</p><p>-- @param _MinAmount Mindestens zu verlieren (max. 5)</p><p>-- @param _QuestAmount Anzahl geprüfter Quests (max. 5 und >= _MinAmount)</p><p>-- @param _Quest1      Name des 1. Quest</p><p>-- @param _Quest2      Name des 2. Quest</p><p>-- @param _Quest3      Name des 3. Quest</p><p>-- @param _Quest4      Name des 4. Quest</p><p>-- @param _Quest5      Name des 5. Quest</p><p>-- @within Trigger</p><p>    return b_Trigger_OnAtLeastXOfYQuestsFailed:new(...);</p><p>Trigger_OnAtLeastXOfYQuestsFailed</p><p>    Name = "Trigger_OnAtLeastXOfYQuestsFailed",</p><p>    Description = {</p><p>        en = "Trigger: if at least X of Y given quests has been finished successfully.",</p><p>        de = "Ausloeser: wenn X von Y angegebener Quests fehlgeschlagen sind.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Custom, en = "Least Amount", de = "Mindest Anzahl" },</p><p>        { ParameterType.Custom, en = "Quest Amount", de = "Quest Anzahl" },</p><p>        { ParameterType.QuestName, en = "Quest name 1", de = "Questname 1" },</p><p>        { ParameterType.QuestName, en = "Quest name 2", de = "Questname 2" },</p><p>        { ParameterType.QuestName, en = "Quest name 3", de = "Questname 3" },</p><p>        { ParameterType.QuestName, en = "Quest name 4", de = "Questname 4" },</p><p>        { ParameterType.QuestName, en = "Quest name 5", de = "Questname 5" },</p><p>    },</p><p>    return { Triggers.Custom2,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.LeastAmount = tonumber(_Parameter)</p><p>    elseif (_Index == 1) then</p><p>        self.QuestAmount = tonumber(_Parameter)</p><p>    elseif (_Index == 2) then</p><p>        self.QuestName1 = _Parameter</p><p>    elseif (_Index == 3) then</p><p>        self.QuestName2 = _Parameter</p><p>    elseif (_Index == 4) then</p><p>        self.QuestName3 = _Parameter</p><p>    elseif (_Index == 5) then</p><p>        self.QuestName4 = _Parameter</p><p>    elseif (_Index == 6) then</p><p>        self.QuestName5 = _Parameter</p><p>    end</p><p>    local least = 0</p><p>    for i = 1, self.QuestAmount do</p><p>        if IsValidQuest(QuestID) then</p><p>        end</p><p>    end</p><p>    return false</p><p>    local leastAmount = self.LeastAmount</p><p>    local questAmount = self.QuestAmount</p><p>    if leastAmount <= 0 or leastAmount >5 then</p><p>        dbg(_Quest.Identifier .. ": Error in " .. self.Name .. ": LeastAmount is wrong")</p><p>        return true</p><p>    elseif questAmount <= 0 or questAmount > 5 then</p><p>        dbg(_Quest.Identifier .. ": Error in " .. self.Name .. ": QuestAmount is wrong")</p><p>        return true</p><p>    elseif leastAmount > questAmount then</p><p>        dbg(_Quest.Identifier .. ": Error in " .. self.Name .. ": LeastAmount is greater than QuestAmount")</p><p>        return true</p><p>    end</p><p>    for i = 1, questAmount do</p><p>        if not IsValidQuest(self["QuestName"..i]) then</p><p>            dbg(_Quest.Identifier .. ": Error in " .. self.Name .. ": Quest ".. self["QuestName"..i] .. " not found")</p><p>            return true</p><p>        end</p><p>    end</p><p>    return false</p><p>    if (_Index == 0) or (_Index == 1) then</p><p>        return {"1", "2", "3", "4", "5"}</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet den Quest, sobald die Munition in der Kriegsmaschine erschöpft ist.</p><p>-- @param _ScriptName Skriptname des Entity</p><p>-- @within Trigger</p><p>    return b_Trigger_AmmunitionDepleted:new(...);</p><p>Trigger_AmmunitionDepleted</p><p>    Name = "Trigger_AmmunitionDepleted",</p><p>    Description = {</p><p>        en = "Trigger: if the ammunition of the entity is depleted.",</p><p>        de = "Ausloeser: wenn die Munition der Entity aufgebraucht ist.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Scriptname, en = "Script name", de = "Skriptname" },</p><p>    },</p><p>    return { Triggers.Custom2,{self, self.CustomFunction} }</p><p>    if (_Index == 0) then</p><p>        self.Scriptname = _Parameter</p><p>    end</p><p>    if not IsExisting(self.Scriptname) then</p><p>        return false;</p><p>    end</p><p>    local EntityID = GetID(self.Scriptname);</p><p>    if Logic.GetAmmunitionAmount(EntityID) > 0 then</p><p>        return false;</p><p>    end</p><p>    return true;</p><p>    if not IsExisting(self.Scriptname) then</p><p>        dbg(_Quest.Identifier .. ": Error in " .. self.Name .. ": '"..self.Scriptname.."' is destroyed!");</p><p>        return true</p><p>    end</p><p>    return false</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet den Quest, wenn exakt einer von beiden Quests erfolgreich ist.</p><p>-- @param _QuestName1 Name des ersten Quest</p><p>-- @param _QuestName2 Name des zweiten Quest</p><p>-- @within Trigger</p><p>    return b_Trigger_OnExactOneQuestIsWon:new(...);</p><p>Trigger_OnExactOneQuestIsWon</p><p>    Name = "Trigger_OnExactOneQuestIsWon",</p><p>    Description = {</p><p>        en = "Trigger: if one of two given quests has been finished successfully, but NOT both.",</p><p>        de = "Ausloeser: wenn eine von zwei angegebenen Quests (aber NICHT beide) erfolgreich abgeschlossen wurde.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.QuestName, en = "Quest Name 1", de = "Questname 1" },</p><p>        { ParameterType.QuestName, en = "Quest Name 2", de = "Questname 2" },</p><p>    },</p><p>    return {Triggers.Custom2, {self, self.CustomFunction}};</p><p>    self.QuestTable = {};</p><p>    if (_Index == 0) then</p><p>        self.Quest1 = _Parameter;</p><p>    elseif (_Index == 1) then</p><p>        self.Quest2 = _Parameter;</p><p>    end</p><p>    local Quest1 = Quests[GetQuestID(self.Quest1)];</p><p>    local Quest2 = Quests[GetQuestID(self.Quest2)];</p><p>    if Quest2 and Quest1 then</p><p>        local Quest1Succeed = (Quest1.State == QuestState.Over and Quest1.Result == QuestResult.Success);</p><p>        local Quest2Succeed = (Quest2.State == QuestState.Over and Quest2.Result == QuestResult.Success);</p><p>        if (Quest1Succeed and not Quest2Succeed) or (not Quest1Succeed and Quest2Succeed) then</p><p>            return true;</p><p>        end</p><p>    end</p><p>    return false;</p><p>    if self.Quest1 == self.Quest2 then</p><p>        dbg(_Quest.Identifier..": "..self.Name..": Both quests are identical!");</p><p>        return true;</p><p>    elseif not IsValidQuest(self.Quest1) then</p><p>        dbg(_Quest.Identifier..": "..self.Name..": Quest '"..self.Quest1.."' does not exist!");</p><p>        return true;</p><p>    elseif not IsValidQuest(self.Quest2) then</p><p>        dbg(_Quest.Identifier..": "..self.Name..": Quest '"..self.Quest2.."' does not exist!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet den Quest, wenn exakt einer von beiden Quests erfolgreich ist.</p><p>-- @param _QuestName1 Name des ersten Quest</p><p>-- @param _QuestName2 Name des zweiten Quest</p><p>-- @within Trigger</p><p>    return b_Trigger_OnExactOneQuestIsLost:new(...);</p><p>Trigger_OnExactOneQuestIsLost</p><p>    Name = "Trigger_OnExactOneQuestIsLost",</p><p>    Description = {</p><p>        en = "Trigger: If one of two given quests has been lost, but NOT both.",</p><p>        de = "Ausloeser: Wenn einer von zwei angegebenen Quests (aber NICHT beide) fehlschlägt.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.QuestName, en = "Quest Name 1", de = "Questname 1" },</p><p>        { ParameterType.QuestName, en = "Quest Name 2", de = "Questname 2" },</p><p>    },</p><p>    return {Triggers.Custom2, {self, self.CustomFunction}};</p><p>    self.QuestTable = {};</p><p>    if (_Index == 0) then</p><p>        self.Quest1 = _Parameter;</p><p>    elseif (_Index == 1) then</p><p>        self.Quest2 = _Parameter;</p><p>    end</p><p>    local Quest1 = Quests[GetQuestID(self.Quest1)];</p><p>    local Quest2 = Quests[GetQuestID(self.Quest2)];</p><p>    if Quest2 and Quest1 then</p><p>        local Quest1Succeed = (Quest1.State == QuestState.Over and Quest1.Result == QuestResult.Failure);</p><p>        local Quest2Succeed = (Quest2.State == QuestState.Over and Quest2.Result == QuestResult.Failure);</p><p>        if (Quest1Succeed and not Quest2Succeed) or (not Quest1Succeed and Quest2Succeed) then</p><p>            return true;</p><p>        end</p><p>    end</p><p>    return false;</p><p>    if self.Quest1 == self.Quest2 then</p><p>        dbg(_Quest.Identifier..": "..self.Name..": Both quests are identical!");</p><p>        return true;</p><p>    elseif not IsValidQuest(self.Quest1) then</p><p>        dbg(_Quest.Identifier..": "..self.Name..": Quest '"..self.Quest1.."' does not exist!");</p><p>        return true;</p><p>    elseif not IsValidQuest(self.Quest2) then</p><p>        dbg(_Quest.Identifier..": "..self.Name..": Quest '"..self.Quest2.."' does not exist!");</p><p>        return true;</p><p>    end</p><p>    return false;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {},</p><p>    Local = {}</p><p>-- Global Script ---------------------------------------------------------------</p><p>-- Initialisiert das Bundle im globalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p><p>    -- Theif observation</p><p>    --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p><p>    GameCallback_OnThiefDeliverEarnings_Orig_QSB_SymfoniaBehaviors = GameCallback_OnThiefDeliverEarnings;</p><p>    GameCallback_OnThiefDeliverEarnings = function(_ThiefPlayerID, _ThiefID, _BuildingID, _GoodAmount)</p><p>        GameCallback_OnThiefDeliverEarnings_Orig_QSB_SymfoniaBehaviors(_ThiefPlayerID, _ThiefID, _BuildingID, _GoodAmount);</p><p>        for i=1, Quests[0] do</p><p>            if Quests[i] and Quests[i].State == QuestState.Active then</p><p>                for j=1, Quests[i].Objectives[0] do</p><p>                    if Quests[i].Objectives[j].Type == Objective.Custom2 then</p><p>                        if Quests[i].Objectives[j].Data[1].Name == "Goal_StealBuilding" then</p><p>                            local found;</p><p>                            for k=1, #Quests[i].Objectives[j].Data[1].RobberList do</p><p>                                local stohlen = Quests[i].Objectives[j].Data[1].RobberList[k];</p><p>                                if stohlen[1] == GetID(Quests[i].Objectives[j].Data[1].Building) and stohlen[2] == _ThiefID then</p><p>                                    found = true;</p><p>                                    break;</p><p>                                end</p><p>                            end</p><p>                            if found then</p><p>                                Quests[i].Objectives[j].Data[1].SuccessfullyStohlen = true;</p><p>                            end</p><p>                        elseif Quests[i].Objectives[j].Data[1].Name == "Goal_StealGold" then</p><p>                            local CurrentObjective = Quests[i].Objectives[j].Data[1];</p><p>                            local TargetPlayerID = Logic.EntityGetPlayer(_BuildingID);</p><p>                            if CurrentObjective.Target ~= -1 and CurrentObjective.Target ~= TargetPlayerID then</p><p>                                return;</p><p>                            end</p><p>                            Quests[i].Objectives[j].Data[1].StohlenGold = Quests[i].Objectives[j].Data[1].StohlenGold + _GoodAmount;</p><p>                            if CurrentObjective.Printout then</p><p>                                local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>                                local msg  = {de = "Talern gestohlen",en = "gold stolen",};</p><p>                                local curr = CurrentObjective.StohlenGold;</p><p>                                local need = CurrentObjective.Amount;</p><p>                                API.Note(string.format("d/d s", curr, need, msg[lang]));</p><p>                            end</p><p>                        end</p><p>                    end</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>    GameCallback_OnThiefStealBuilding_Orig_QSB_SymfoniaBehaviors = GameCallback_OnThiefStealBuilding;</p><p>    GameCallback_OnThiefStealBuilding = function(_ThiefID, _ThiefPlayerID, _BuildingID, _BuildingPlayerID)</p><p>        GameCallback_OnThiefStealBuilding_Orig_QSB_SymfoniaBehaviors(_ThiefID, _ThiefPlayerID, _BuildingID, _BuildingPlayerID);</p><p>        for i=1, Quests[0] do</p><p>            if Quests[i] and Quests[i].State == QuestState.Active then</p><p>                for j=1, Quests[i].Objectives[0] do</p><p>                    if Quests[i].Objectives[j].Type == Objective.Custom2 then</p><p>                        if Quests[i].Objectives[j].Data[1].Name == "Goal_SpyBuilding" then</p><p>                            if  GetID(Quests[i].Objectives[j].Data[1].Building) == _BuildingID and Quests[i].ReceivingPlayer == _ThiefPlayerID then</p><p>                                Quests[i].Objectives[j].Data[1].Infiltrated = true;</p><p>                                if Quests[i].Objectives[j].Data[1].Delete then</p><p>                                    DestroyEntity(_ThiefID);</p><p>                                end</p><p>                            end</p><p>                        elseif Quests[i].Objectives[j].Data[1].Name == "Goal_StealBuilding" then</p><p>                            local found;</p><p>                            local isCathedral = Logic.IsEntityInCategory(_BuildingID, EntityCategories.Cathedrals) == 1;</p><p>                            local isWarehouse = Logic.GetEntityType(_BuildingID) == Entities.B_StoreHouse;</p><p>                            if isWarehouse or isCathedral then</p><p>                                Quests[i].Objectives[j].Data[1].SuccessfullyStohlen = true;</p><p>                            else</p><p>                                for k=1, #Quests[i].Objectives[j].Data[1].RobberList do</p><p>                                    local stohlen = Quests[i].Objectives[j].Data[1].RobberList[k];</p><p>                                    if stohlen[1] == _BuildingID and stohlen[2] == _ThiefID then</p><p>                                        found = true;</p><p>                                        break;</p><p>                                    end</p><p>                                end</p><p>                            end</p><p>                            if not found then</p><p>                                table.insert(Quests[i].Objectives[j].Data[1].RobberList, {_BuildingID, _ThiefID});</p><p>                            end</p><p>                        end</p><p>                    end</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>    --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p><p>    -- Objectives</p><p>    --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p><p>    QuestTemplate.IsObjectiveCompleted_Orig_QSB_SymfoniaBehaviors = QuestTemplate.IsObjectiveCompleted;</p><p>    QuestTemplate.IsObjectiveCompleted = function(self, objective)</p><p>        local objectiveType = objective.Type;</p><p>        local data = objective.Data;</p><p>        if objective.Completed ~= nil then</p><p>            return objective.Completed;</p><p>        end</p><p>        if objectiveType == Objective.Distance then</p><p>            -- Distance with parameter</p><p>            local IDdata2 = GetID(data[1]);</p><p>            local IDdata3 = GetID(data[2]);</p><p>            data[3] = data[3] or 2500;</p><p>            if not (Logic.IsEntityDestroyed(IDdata2) or Logic.IsEntityDestroyed(IDdata3)) then</p><p>                if Logic.GetDistanceBetweenEntities(IDdata2,IDdata3) <= data[3] then</p><p>                    DestroyQuestMarker(IDdata3);</p><p>                    objective.Completed = true;</p><p>                end</p><p>            else</p><p>                DestroyQuestMarker(IDdata3);</p><p>                objective.Completed = false;</p><p>            end</p><p>        else</p><p>            return self:IsObjectiveCompleted_Orig_QSB_SymfoniaBehaviors(objective);</p><p>        end</p><p>    end</p><p>    --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p><p>    -- Questmarkers</p><p>    --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p><p>    function QuestTemplate:RemoveQuestMarkers()</p><p>        for i=1, self.Objectives[0] do</p><p>            if self.Objectives[i].Type == Objective.Distance then</p><p>                if self.Objectives[i].Data[4] then</p><p>                    DestroyQuestMarker(self.Objectives[i].Data[2]);</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>    function QuestTemplate:ShowQuestMarkers()</p><p>        for i=1, self.Objectives[0] do</p><p>            if self.Objectives[i].Type == Objective.Distance then</p><p>                if self.Objectives[i].Data[4] then</p><p>                    ShowQuestMarker(self.Objectives[i].Data[2]);</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>    function ShowQuestMarker(_Entity)</p><p>        local eID = GetID(_Entity);</p><p>        local x,y = Logic.GetEntityPosition(eID);</p><p>        local Marker = EGL_Effects.E_Questmarker_low;</p><p>        if Logic.IsBuilding(eID) == 1 then</p><p>            Marker = EGL_Effects.E_Questmarker;</p><p>        end</p><p>        Questmarkers[eID] = Logic.CreateEffect(Marker, x,y,0);</p><p>    end</p><p>    function DestroyQuestMarker(_Entity)</p><p>        local eID = GetID(_Entity);</p><p>        if Questmarkers[eID] ~= nil then</p><p>            Logic.DestroyEffect(Questmarkers[eID]);</p><p>            Questmarkers[eID] = nil;</p><p>        end</p><p>    end</p><p>-- Local Script ----------------------------------------------------------------</p><p>-- Initialisiert das Bundle im lokalen Skript.</p><p>-- @within Internal</p><p>-- @local</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundletimeline.lua.html">
            <div class='doclink'>
                <div>BundleTimeLine</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia BundleTimeLine                                               # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Dieses Bundle ermöglicht es Aktionen in einer zeitlichen Abfolge zu</p><p>-- gliedern.</p><p>-- Die Bezeichnung "Time Line" (Zeitstrahl) wird z.B. in der Filmindustrie</p><p>-- verwendet und beschreibt einen Ablauf von aufeinander folgenden Ereignissen.</p><p>-- Diese Ereignisse sind zeitlich gegliedert.</p><p>-- Du kannst mit der Implementation eines solchen Zeitstrahls Lua-Funktionen</p><p>-- im Abstand einer oder mehrerer Sekunden ausführen lassen. Ein solcher</p><p>-- Zeitstrahl verfügt über eine ID, mit der er angesprochen werden kann. So</p><p>-- kann er abgebrochen, pausiert, fortgesetzt und neu gestartet werden.</p><p>-- <a href="#API.TimeLineStart">Zeitstrahl erstellen</a><br>Eine Abfolge von</p><p>-- Aktionen definieren, die zu gewissen Zeitpunkten ausgelöst werden.</p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet einen Zeitstrahl. Ein Zeitstrahl hat Stationen,</p><p>-- an denen eine Aktion ausgeführt wird. Jede Station muss mindestens eine</p><p>-- Sekunde nach der vorherigen liegen.</p><p>-- Jede Aktion eines Zeitstrahls erhält die Table des aktuellen Ereignisses</p><p>-- als Argument. So können Parameter an die Funktion übergeben werden.</p><p>-- <p><b>Alias:</b> QSB.TimeLine:Start<br></p></p><p>-- @param _Description [table] Beschreibung</p><p>-- @return [number] ID des Zeitstrahls</p><p>-- @within Anwenderfunktionen</p><p>-- @usage MyTimeLine = API.TimeLineStart {</p><p>--     {Time = 1, Action = MyFirstAction},</p><p>--     -- MySecondAction erhält "BOCKWURST" als Parameter</p><p>--     {Time = 3, Action = MySecondAction, "BOCKWURST"},</p><p>--     -- Inline-Funktion</p><p>--     {Time = 9, Action = function() end},</p><p>-- }</p><p>function API.TimeLineStart(_Description)</p><p>    return BundleTimeLine.Shared.TimeLine:Start(_Description);</p><p>-- Startet einen Zeitstrahl erneut. Ist der Zeitstrahl noch nicht</p><p>-- beendet, beginnt er dennoch von vorn.</p><p>-- <p><b>Alias:</b> QSB.TimeLine:Restart<br></p></p><p>-- @param _ID [table] ID des Zeitstrahl</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.TimeLineRestart(MyTimeLine);</p><p>function API.TimeLineRestart(_ID)</p><p>    return BundleTimeLine.Shared.TimeLine:Restart(_ID)</p><p>-- Prüft, ob der Zeitstrahl noch nicht durchgelaufen ist.</p><p>-- <p><b>Alias:</b> QSB.TimeLine:IsRunning<br></p></p><p>-- @param _ID [table] ID des Zeitstrahl</p><p>-- @return [boolean] Zeitstrahl ist aktiv</p><p>-- @within Anwenderfunktionen</p><p>-- @usage local IsRunning = API.TimeLineIsRunning(MyTimeLine);</p><p>function API.TimeLineIsRunning(_ID)</p><p>    return BundleTimeLine.Shared.TimeLine:IsRunning(_ID);</p><p>-- Hält einen Zeitstrahl an.</p><p>-- <p><b>Alias:</b> QSB.TimeLine:Yield<br></p></p><p>-- @param _ID [table] ID des Zeitstrahl</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.TimeLineYield(MyTimeLine);</p><p>function API.TimeLineYield(_ID)</p><p>    return BundleTimeLine.Shared.TimeLine:Yield(_ID);</p><p>-- Stößt einen angehaltenen Zeitstrahl wieder an.</p><p>-- <p><b>Alias:</b> QSB.TimeLine:Resume<br></p></p><p>-- @param _ID [table] ID des Zeitstrahl</p><p>-- @within Anwenderfunktionen</p><p>-- @usage API.TimeLineResume(MyTimeLine);</p><p>function API.TimeLineResume(_ID)</p><p>    return BundleTimeLine.Shared.TimeLine:Resume(_ID);</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {</p><p>        Data = {}</p><p>    },</p><p>    Local = {</p><p>        Data = {}</p><p>    },</p><p>    Shared = {</p><p>        TimeLine = {</p><p>            Data = {</p><p>                TimeLineUniqueJobID = 1,</p><p>                TimeLineJobs = {},</p><p>            }</p><p>        }</p><p>    }</p><p>-- Global Script ---------------------------------------------------------------</p><p>-- Initalisiert das Bundle im globalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    QSB.TimeLine = BundleTimeLine.Shared.TimeLine;</p><p>    TimeLine = QSB.TimeLine;</p><p>-- Local Script ----------------------------------------------------------------</p><p>-- Initalisiert das Bundle im lokalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    QSB.TimeLine = BundleTimeLine.Shared.TimeLine;</p><p>    TimeLine = QSB.TimeLine;</p><p>-- Shared Script ------------------------------------------------------------ --</p><p>-- Startet einen Zeitstrahl. Ein Zeitstrahl hat bestimmte Stationen,</p><p>-- an denen eine Aktion ausgeführt wird.</p><p>-- <p><b>Alias:</b> QSB.TimeLine:Start<br></p></p><p>-- @param _description [table] Beschreibung</p><p>-- @return [number] ID des Zeitstrahl</p><p>-- @within QSB.TimeLine</p><p>-- @local</p><p>    local JobID = self.Data.TimeLineUniqueJobID;</p><p>    self.Data.TimeLineUniqueJobID = JobID +1;</p><p>    _description.Running = true;</p><p>    _description.StartTime = Logic.GetTime();</p><p>    _description.Iterator = 1;</p><p>    -- Check auf sinnvolle Zeitabstände</p><p>    local Last = 0;</p><p>    for i=1, #_description, 1 do</p><p>        if _description[i].Time < Last then</p><p>            _description[i].Time = Last+1;</p><p>            Last = _description[i].Time;</p><p>        end</p><p>    end</p><p>    self.Data.TimeLineJobs[JobID] = _description;</p><p>    if not self.Data.ControlerID then</p><p>        local Controler = StartSimpleJobEx( BundleTimeLine.Shared.TimeLine.TimeLineControler );</p><p>        self.Data.ControlerID = Controler;</p><p>    end</p><p>    return JobID;</p><p>-- Startet einen Zeitstrahl erneut. Ist der Zeitstrahl noch nicht</p><p>-- beendet, beginnt er dennoch von vorn.</p><p>-- <p><b>Alias:</b> QSB.TimeLine:Restart<br></p></p><p>-- @param _ID [table] ID des Zeitstrahl</p><p>-- @within QSB.TimeLine</p><p>-- @local</p><p>    if not self.Data.TimeLineJobs[_ID] then</p><p>        return;</p><p>    end</p><p>    self.Data.TimeLineJobs[_ID].Running = true;</p><p>    self.Data.TimeLineJobs[_ID].StartTime = Logic.GetTime();</p><p>    self.Data.TimeLineJobs[_ID].Iterator = 1;</p><p>-- Prüft, ob der Zeitstrahl noch nicht durchgelaufen ist.</p><p>-- <p><b>Alias:</b> QSB.TimeLine:IsRunning<br></p></p><p>-- @param _ID [table] ID des Zeitstrahl</p><p>-- @return [boolean] Zeistrahl ist aktiv</p><p>-- @within QSB.TimeLine</p><p>-- @local</p><p>    if self.Data.TimeLineJobs[_ID] then</p><p>        return self.Data.TimeLineJobs[_ID].Running == true;</p><p>    end</p><p>    return false;</p><p>-- Hält einen Zeitstrahl an.</p><p>-- Der Zeitstempel wird gespeichert.</p><p>-- <p><b>Alias:</b> QSB.TimeLine:Yield<br></p></p><p>-- @param _ID [table] ID des Zeitstrahl</p><p>-- @within QSB.TimeLine</p><p>-- @local</p><p>    if not self.Data.TimeLineJobs[_ID] then</p><p>        return;</p><p>    end</p><p>    self.Data.TimeLineJobs[_ID].YieldTime = Logic.GetTime();</p><p>    self.Data.TimeLineJobs[_ID].Running = false;</p><p>-- Stößt einen angehaltenen Zeitstrahl wieder an.</p><p>-- Die Zeit, die seit der Pausierung vergangen ist, wird zur Startzeit</p><p>-- addiert um Trigger Fehler zu vermeiden.</p><p>-- <p><b>Alias:</b> QSB.TimeLine:Resume<br></p></p><p>-- @param _ID [table] ID des Zeitstrahl</p><p>-- @within QSB.TimeLine</p><p>-- @local</p><p>    if not self.Data.TimeLineJobs[_ID] then</p><p>        return;</p><p>    end</p><p>    if self.Data.TimeLineJobs[_ID].YieldTime then</p><p>        local OldStartTime = self.Data.TimeLineJobs[_ID].StartTime;</p><p>        local TimeYielded = Logic.GetTime() - self.Data.TimeLineJobs[_ID].YieldTime;</p><p>        self.Data.TimeLineJobs[_ID].StartTime = OldStartTime + TimeYielded;</p><p>        self.Data.TimeLineJobs[_ID].YieldTime = nil;</p><p>    end</p><p>    self.Data.TimeLineJobs[_ID].Running = true;</p><p>-- Steuert alle Zeitstrahlen.</p><p>-- @within QSB.TimeLine</p><p>-- @local</p><p>    for k,v in pairs(BundleTimeLine.Shared.TimeLine.Data.TimeLineJobs) do</p><p>        if v.Iterator > #v then</p><p>            BundleTimeLine.Shared.TimeLine.Data.TimeLineJobs[k].Running = false;</p><p>        end</p><p>        if v.Running then</p><p>            if (v[v.Iterator].Time + v.StartTime) <= Logic.GetTime() then</p><p>                v[v.Iterator].Action(unpack(v[v.Iterator]));</p><p>                BundleTimeLine.Shared.TimeLine.Data.TimeLineJobs[k].Iterator = v.Iterator +1;</p><p>            end</p><p>        end</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundletradinganalysis.lua.html">
            <div class='doclink'>
                <div>BundleTradingAnalysis</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia BundleTradingAnalysis                                        # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Dieses Bundle bietet einige Funktionen zum untersuchen und</p><p>-- zur Manipulation von Handelsangeboten. Die bekannten Funktionen, wie z.B.</p><p>-- AddOffer, werden erweitert, sodass sie Angebote für einen Spieler mit einer</p><p>-- anderen ID als 1 erstellen können. Ein kann Händler nicht mehr</p><p>-- mehrere Angebote des gleichen Typs anbieten. Außerdem werden einige</p><p>-- Preise und Erneuerungsraten hinzugefügt.</p><p>-- Das wichtigste auf einen Blick:</p><p>-- <ul></p><p>-- <li><a href="#API.GetOfferCount">Angebote zählen</a></li></p><p>-- <li><a href="#API.IsGoodOrUnitOffered">Angebote prüfen</a></li></p><p>-- <li><a href="#API.RemoveTradeOffer">Angebote einzeln löschen</a></li></p><p>-- <li><a href="#API.ModifyTradeOffer">Angebote modifizieren</a></li></p><p>-- </ul></p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>    GoodTrader        = 0,</p><p>    MercenaryTrader   = 1,</p><p>    EntertainerTrader = 2,</p><p>    Unknown           = 3,</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Gibt die Handelsinformationen des Spielers aus. In dem Objekt stehen</p><p>-- ID des Spielers, ID des Lagerhaus, Menge an Angeboten insgesamt und</p><p>-- alle Angebote der Händlertypen.</p><p>-- @param _PlayerID [number] Player ID</p><p>-- @return [table] Angebotsinformationen</p><p>-- @within Anwenderfunktionen</p><p>-- @usage local Info = API.GetOfferInformation(2);</p><p>-- -- Info enthält:</p><p>-- -- Info = {</p><p>-- --      Player = 2,</p><p>-- --      Storehouse = 26796.</p><p>-- --      OfferCount = 2,</p><p>-- --      {</p><p>-- --          Händler-ID, Angebots-ID, Angebotstyp, Wagenladung, Angebotsmenge</p><p>-- --          {0, 0, Goods.G_Gems, 9, 2},</p><p>-- --          {0, 1, Goods.G_Milk, 9, 4},</p><p>-- --      },</p><p>-- -- };</p><p>function API.GetOfferInformation(_PlayerID)</p><p>    if GUI then</p><p>        API.Log("Can not execute API.GetOfferInformation in local script!");</p><p>        return;</p><p>    end</p><p>    return BundleTradingAnalysis.Global:GetStorehouseInformation(_PlayerID);</p><p>-- Gibt die Menge an Angeboten im Lagerhaus des Spielers zurück. Wenn</p><p>-- der Spieler kein Lagerhaus hat, wird 0 zurückgegeben.</p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @return [number] Anzahl angebote</p><p>-- @within Anwenderfunktionen</p><p>-- @usage -- Angebote von Spieler 5 zählen</p><p>-- local Count = API.GetOfferCount(5);</p><p>function API.GetOfferCount(_PlayerID)</p><p>    if GUI then</p><p>        API.Log("Can not execute API.GetOfferCount in local script!");</p><p>        return;</p><p>    end</p><p>    return BundleTradingAnalysis.Global:GetOfferCount(_PlayerID);</p><p>-- Gibt zurück, ob das Angebot vom angegebenen Spieler im Lagerhaus zum</p><p>-- Verkauf angeboten wird.</p><p>-- @param _PlayerID [number] Player ID</p><p>-- @param _GoodOrEntityType [number] Warentyp oder Entitytyp</p><p>-- @return [boolean] Ware wird angeboten</p><p>-- @within Anwenderfunktionen</p><p>-- @usage -- Wird die Ware angeboten?</p><p>-- if API.IsGoodOrUnitOffered(4, Goods.G_Bread) then</p><p>--     API.Note("Brot wird von Spieler 4 angeboten.");</p><p>-- end</p><p>function API.IsGoodOrUnitOffered(_PlayerID, _GoodOrEntityType)</p><p>    if GUI then</p><p>        API.Log("Can not execute API.IsGoodOrUnitOffered in local script!");</p><p>        return;</p><p>    end</p><p>    local OfferID, TraderID = BundleTradingAnalysis.Global:GetOfferAndTrader(_PlayerID, _GoodOrEntityType);</p><p>    return OfferID ~= 1 and TraderID ~= 1;</p><p>-- Entfernt das Angebot vom Lagerhaus des Spielers, wenn es vorhanden</p><p>-- ist. Es wird immer nur das erste Angebot des Typs entfernt.</p><p>-- @param _PlayerID [number] Player ID</p><p>-- @param _GoodOrEntityType [number] Warentyp oder Entitytyp</p><p>-- @within Anwenderfunktionen</p><p>-- @usage -- Keinen Käse mehr verkaufen</p><p>-- API.RemoveTradeOffer(7, Goods.G_Cheese);</p><p>function API.RemoveTradeOffer(_PlayerID, _GoodOrEntityType)</p><p>    if GUI then</p><p>        API.Bridge("API.RemoveTradeOffer(" .._PlayerID.. ", " .._GoodOrEntityType.. ")");</p><p>        return;</p><p>    end</p><p>    return BundleTradingAnalysis.Global:RemoveTradeOffer(_PlayerID, _GoodOrEntityType);</p><p>-- Ändert die aktuelle Menge des Angebots im Händelrgebäude.</p><p>-- Es kann ein beliebiger positiver Wert gesetzt werden. Es gibt keine</p><p>-- Beschränkungen.</p><p>-- <b>Hinweis</b>: Wird eine höherer Wert gesetzt, als das ursprüngliche</p><p>-- Maximum, regenerieren sich die zusätzlichen Angebote nicht.</p><p>-- @param _PlayerID	[number] Händlergebäude</p><p>-- @param _GoodOrEntityType	[number] ID des Händlers im Gebäude</p><p>-- @param _NewAmount [number] Neue Menge an Angeboten</p><p>-- @within Anwenderfunktionen</p><p>-- @usage -- Angebote voll auffüllen</p><p>-- API.ModifyTradeOffer(7, Goods.G_Cheese, -1);</p><p>-- API.ModifyTradeOffer(7, Goods.U_MilitarySword);</p><p>-- -- 2 Angebote auffüllen</p><p>-- API.ModifyTradeOffer(7, Goods.G_Dye, 2);</p><p>function API.ModifyTradeOffer(_PlayerID, _GoodOrEntityType, _NewAmount)</p><p>    if GUI then</p><p>        API.Bridge("API.ModifyTradeOffer(" .._PlayerID.. ", " .._GoodOrEntityType.. ", " .._NewAmount.. ")");</p><p>        return;</p><p>    end</p><p>    return BundleTradingAnalysis.Global:ModifyTradeOffer(_PlayerID, _GoodOrEntityType, _NewAmount);</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {</p><p>        Data = {</p><p>            PlayerOffersAmount = {</p><p>                [1] = {}, [2] = {}, [3] = {}, [4] = {}, [5] = {}, [6] = {}, [7] = {}, [8] = {},</p><p>            };</p><p>        },</p><p>    },</p><p>-- Global Script ---------------------------------------------------------------</p><p>-- Initialisiert das Bundle im globalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    self.OverwriteOfferFunctions();</p><p>    self.OverwriteBasePricesAndRefreshRates();</p><p>-- Überschreibt die Funktionen für Standardangebote.</p><p>-- @within Internal</p><p>-- @local</p><p>    ---</p><p>    -- Erzeugt ein Handelsangebot für Waren und gibt die ID zurück.</p><p>    --</p><p>    -- <b>Hinweis</b>: Jeder Angebotstyp kann nur 1 Mal pro Lagerhaus</p><p>    -- angeboten werden.</p><p>    --</p><p>    -- @param _Merchant [number] Handelsgebäude</p><p>    -- @param _NumberOfOffers [number] Anzahl an Angeboten</p><p>    -- @param _GoodType [number] Warentyp</p><p>    -- @param _RefreshRate [number] Erneuerungsrate</p><p>    -- @param _optionalPlayersPlayerID [number] Optionale Spieler-ID</p><p>    -- @return [number] Offer ID</p><p>    -- @within Originalfunktionen</p><p>    --</p><p>    AddOffer = function(_Merchant, _NumberOfOffers, _GoodType, _RefreshRate, _optionalPlayersPlayerID)</p><p>        local MerchantID = GetID(_Merchant);</p><p>        if type(_GoodType) == "string" then</p><p>            _GoodType = Goods[_GoodType];</p><p>        else</p><p>            _GoodType = _GoodType;</p><p>        end</p><p>        local PlayerID = Logic.EntityGetPlayer(MerchantID);</p><p>        local OfferID, TraderID = BundleTradingAnalysis.Global:GetOfferAndTrader(PlayerID, _GoodType);</p><p>        if OfferID ~= -1 and TraderID ~= -1 then</p><p>            API.Warn("Good offer for good type " .._GoodType.. " already exists for player " ..PlayerID.. "!");</p><p>            return;</p><p>        end</p><p>        AddGoodToTradeBlackList(PlayerID, _GoodType);</p><p>        local MarketerType = Entities.U_Marketer;</p><p>        if _GoodType == Goods.G_Medicine then</p><p>            MarketerType = Entities.U_Medicus;</p><p>        end</p><p>        if _RefreshRate == nil then</p><p>            _RefreshRate = MerchantSystem.RefreshRates[_GoodType];</p><p>            if _RefreshRate == nil then</p><p>                _RefreshRate = 0;</p><p>            end</p><p>        end</p><p>        if _optionalPlayersPlayerID == nil then</p><p>            _optionalPlayersPlayerID = 1;</p><p>        end</p><p>        local offerAmount = 9;</p><p>        BundleTradingAnalysis.Global.Data.PlayerOffersAmount[PlayerID][_GoodType] = _NumberOfOffers;</p><p>        return Logic.AddGoodTraderOffer(MerchantID,_NumberOfOffers,Goods.G_Gold,0,_GoodType,offerAmount,_optionalPlayersPlayerID,_RefreshRate,MarketerType,Entities.U_ResourceMerchant);</p><p>    end</p><p>    ---</p><p>    -- Erzeugt ein Handelsangebot für Söldner und gibt die ID zurück.</p><p>    --</p><p>    -- <b>Hinweis</b>: Jeder Angebotstyp kann nur 1 Mal pro Lagerhaus</p><p>    -- angeboten werden.</p><p>    --</p><p>    -- @param _Mercenary [number] Handelsgebäude</p><p>    -- @param _Amount [number] Anzahl an Angeboten</p><p>    -- @param _Type [number] Soldatentyp</p><p>    -- @param _RefreshRate [number] Erneuerungsrate</p><p>    -- @param _optionalPlayersPlayerID [number] Optionale Spieler-ID</p><p>    -- @return [number] Offer ID</p><p>    -- @within Originalfunktionen</p><p>    --</p><p>    AddMercenaryOffer = function(_Mercenary, _Amount, _Type, _RefreshRate, _optionalPlayersPlayerID)</p><p>        local MercenaryID = GetID(_Mercenary);</p><p>        if _Type == nil then</p><p>            _Type = Entities.U_MilitaryBandit_Melee_ME;</p><p>        end</p><p>        if _RefreshRate == nil then</p><p>            _RefreshRate = MerchantSystem.RefreshRates[_Type];</p><p>            if _RefreshRate == nil then</p><p>                _RefreshRate = 0;</p><p>            end</p><p>        end</p><p>        local PlayerID = Logic.EntityGetPlayer(MercenaryID);</p><p>        local OfferID, TraderID = BundleTradingAnalysis.Global:GetOfferAndTrader(PlayerID, _Type);</p><p>        if OfferID ~= -1 and TraderID ~= -1 then</p><p>            API.Warn("Mercenary offer for type " .._Type.. " already exists for player " ..PlayerID.. "!");</p><p>            return;</p><p>        end</p><p>        local amount = 3;</p><p>        local typeName = Logic.GetEntityTypeName(_Type);</p><p>        if string.find(typeName,"MilitaryBow") or string.find(typeName,"MilitarySword") then</p><p>            amount = 6;</p><p>        elseif string.find(typeName,"Cart") then</p><p>            amount = 0;</p><p>        end</p><p>        if _optionalPlayersPlayerID == nil then</p><p>            _optionalPlayersPlayerID = 1;</p><p>        end</p><p>        BundleTradingAnalysis.Global.Data.PlayerOffersAmount[PlayerID][_Type] = _Amount;</p><p>        return Logic.AddMercenaryTraderOffer(MercenaryID, _Amount, Goods.G_Gold, 3, _Type ,amount,_optionalPlayersPlayerID,_RefreshRate);</p><p>    end</p><p>    ---</p><p>    -- Erzeugt ein Handelsangebot für Entertainer und gibt die</p><p>    -- ID zurück.</p><p>    --</p><p>    -- <b>Hinweis</b>: Jeder Angebotstyp kann nur 1 Mal pro Lagerhaus</p><p>    -- angeboten werden.</p><p>    --</p><p>    -- @param _Merchant [number] Handelsgebäude</p><p>    -- @param _EntertainerType [number] Typ des Entertainer</p><p>    -- @param _optionalPlayersPlayerID [number] Optionale Spieler-ID</p><p>    -- @return [number] Offer ID</p><p>    -- @within Originalfunktionen</p><p>    --</p><p>    AddEntertainerOffer = function(_Merchant, _EntertainerType, _optionalPlayersPlayerID)</p><p>        local MerchantID = GetID(_Merchant);</p><p>        local NumberOfOffers = 1;</p><p>        local PlayerID = Logic.EntityGetPlayer(MerchantID);</p><p>        local OfferID, TraderID = BundleTradingAnalysis.Global:GetOfferAndTrader(PlayerID, _EntertainerType);</p><p>        if OfferID ~= -1 and TraderID ~= -1 then</p><p>            API.Warn("Entertainer offer for type " .._EntertainerType.. " already exists for player " ..PlayerID.. "!");</p><p>            return;</p><p>        end</p><p>        if _EntertainerType == nil then</p><p>            _EntertainerType = Entities.U_Entertainer_NA_FireEater;</p><p>        end</p><p>        if _optionalPlayersPlayerID == nil then</p><p>            _optionalPlayersPlayerID = 1;</p><p>        end</p><p>        BundleTradingAnalysis.Global.Data.PlayerOffersAmount[PlayerID][_EntertainerType] = 1;</p><p>        return Logic.AddEntertainerTraderOffer(MerchantID,NumberOfOffers,Goods.G_Gold,0,_EntertainerType, _optionalPlayersPlayerID,0);</p><p>    end</p><p>-- Fügt fehlende Einträge für Militäreinheiten bei den Basispreisen</p><p>-- und Erneuerungsraten hinzu, damit diese gehandelt werden können.</p><p>-- @within Internal</p><p>-- @local</p><p>    MerchantSystem.BasePrices[Entities.U_CatapultCart] = MerchantSystem.BasePrices[Entities.U_CatapultCart] or 1000;</p><p>    MerchantSystem.BasePrices[Entities.U_BatteringRamCart] = MerchantSystem.BasePrices[Entities.U_BatteringRamCart] or 450;</p><p>    MerchantSystem.BasePrices[Entities.U_SiegeTowerCart] = MerchantSystem.BasePrices[Entities.U_SiegeTowerCart] or 600;</p><p>    MerchantSystem.BasePrices[Entities.U_AmmunitionCart] = MerchantSystem.BasePrices[Entities.U_AmmunitionCart] or 180;</p><p>    MerchantSystem.BasePrices[Entities.U_MilitarySword_RedPrince] = MerchantSystem.BasePrices[Entities.U_MilitarySword_RedPrince] or 150;</p><p>    MerchantSystem.BasePrices[Entities.U_MilitarySword] = MerchantSystem.BasePrices[Entities.U_MilitarySword] or 150;</p><p>    MerchantSystem.BasePrices[Entities.U_MilitaryBow_RedPrince] = MerchantSystem.BasePrices[Entities.U_MilitaryBow_RedPrince] or 220;</p><p>    MerchantSystem.BasePrices[Entities.U_MilitaryBow] = MerchantSystem.BasePrices[Entities.U_MilitaryBow] or 220;</p><p>    MerchantSystem.RefreshRates[Entities.U_CatapultCart] = MerchantSystem.RefreshRates[Entities.U_CatapultCart] or 270;</p><p>    MerchantSystem.RefreshRates[Entities.U_BatteringRamCart] = MerchantSystem.RefreshRates[Entities.U_BatteringRamCart] or 190;</p><p>    MerchantSystem.RefreshRates[Entities.U_SiegeTowerCart] = MerchantSystem.RefreshRates[Entities.U_SiegeTowerCart] or 220;</p><p>    MerchantSystem.RefreshRates[Entities.U_AmmunitionCart] = MerchantSystem.RefreshRates[Entities.U_AmmunitionCart] or 150;</p><p>    MerchantSystem.RefreshRates[Entities.U_MilitaryBow_RedPrince] = MerchantSystem.RefreshRates[Entities.U_MilitarySword_RedPrince] or 150;</p><p>    MerchantSystem.RefreshRates[Entities.U_MilitarySword] = MerchantSystem.RefreshRates[Entities.U_MilitarySword] or 150;</p><p>    MerchantSystem.RefreshRates[Entities.U_MilitaryBow_RedPrince] = MerchantSystem.RefreshRates[Entities.U_MilitaryBow_RedPrince] or 150;</p><p>    MerchantSystem.RefreshRates[Entities.U_MilitaryBow] = MerchantSystem.RefreshRates[Entities.U_MilitaryBow] or 150;</p><p>    if g_GameExtraNo >= 1 then</p><p>        MerchantSystem.BasePrices[Entities.U_MilitaryBow_Khana] = MerchantSystem.BasePrices[Entities.U_MilitaryBow_Khana] or 220;</p><p>        MerchantSystem.RefreshRates[Entities.U_MilitaryBow_Khana] = MerchantSystem.RefreshRates[Entities.U_MilitaryBow_Khana] or 150;</p><p>        MerchantSystem.BasePrices[Entities.U_MilitarySword_Khana] = MerchantSystem.BasePrices[Entities.U_MilitarySword_Khana] or 150;</p><p>        MerchantSystem.RefreshRates[Entities.U_MilitaryBow_Khana] = MerchantSystem.RefreshRates[Entities.U_MilitarySword_Khana] or 150;</p><p>    end</p><p>-- Gibt die Handelsinformationen des Spielers aus. In dem Objekt stehen</p><p>-- ID des Spielers, ID des Lagerhaus, Menge an Angeboten insgesamt und</p><p>-- alle Angebote der Händlertypen.</p><p>-- @param _PlayerID [number] Player ID</p><p>-- @return [table] Angebotsinformationen</p><p>-- @within Internal</p><p>-- @local</p><p>-- @usage BundleTradingAnalysis.Global:GetStorehouseInformation(2);</p><p>-- -- Ausgabe:</p><p>-- -- Info = {</p><p>-- --      Player = 2,</p><p>-- --      Storehouse = 26796.</p><p>-- --      OfferCount = 2,</p><p>-- --      {</p><p>-- --          Händler-ID, Angebots-ID, Angebotstyp, Wagenladung, Angebotsmenge</p><p>-- --          {0, 0, Goods.G_Gems, 9, 2},</p><p>-- --          {0, 1, Goods.G_Milk, 9, 4},</p><p>-- --      },</p><p>-- -- }</p><p>    local BuildingID = Logic.GetStoreHouse(_PlayerID);</p><p>    local StorehouseData = {</p><p>        Player      = _PlayerID,</p><p>        Storehouse  = BuildingID,</p><p>        OfferCount  = 0,</p><p>        {},</p><p>    };</p><p>    local NumberOfMerchants = Logic.GetNumberOfMerchants(Logic.GetStoreHouse(2));</p><p>    local AmountOfOffers = 0;</p><p>    if BuildingID ~= 0 then</p><p>        for Index = 0, NumberOfMerchants, 1 do</p><p>            local Offers = {Logic.GetMerchantOfferIDs(BuildingID, Index, _PlayerID)};</p><p>            for i= 1, #Offers, 1 do</p><p>                local type, goodAmount, offerAmount, prices = 0, 0, 0, 0;</p><p>                if Logic.IsGoodTrader(BuildingID, Index) then</p><p>                    type, goodAmount, offerAmount, prices = Logic.GetGoodTraderOffer(BuildingID, Offers[i], _PlayerID);</p><p>                    if type == Goods.G_Sheep or type == Goods.G_Cow then</p><p>                        goodAmount = 5;</p><p>                    end</p><p>                elseif Logic.IsMercenaryTrader(BuildingID, Index) then</p><p>                    type, goodAmount, offerAmount, prices = Logic.GetMercenaryOffer(BuildingID, Offers[i], _PlayerID);</p><p>                elseif Logic.IsEntertainerTrader(BuildingID, Index) then</p><p>                    type, goodAmount, offerAmount, prices = Logic.GetEntertainerTraderOffer(BuildingID, Offers[i], _PlayerID);</p><p>                end</p><p>                AmountOfOffers = AmountOfOffers +1;</p><p>                local OfferData = {Index, Offers[i], type, goodAmount, offerAmount};</p><p>                table.insert(StorehouseData[1], OfferData);</p><p>            end</p><p>        end</p><p>    end</p><p>    StorehouseData.OfferCount = AmountOfOffers;</p><p>    return StorehouseData;</p><p>-- Gibt die Menge an Angeboten im Lagerhaus des Spielers zurück. Wenn</p><p>-- der Spieler kein Lagerhaus hat, wird 0 zurückgegeben.</p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @return [number]</p><p>-- @within Internal</p><p>-- @local</p><p>    local Offers = self:GetStorehouseInformation(_PlayerID);</p><p>    if Info then</p><p>        return Offers.OfferCount;</p><p>    end</p><p>    return 0;</p><p>-- Gibt Offer ID und Trader ID und ID des Lagerhaus des Angebots für</p><p>-- den Spieler zurück. Es wird immer das erste Angebot zurückgegeben.</p><p>-- @param _PlayerID [number] Player ID</p><p>-- @param _GoodOrEntityType [number] Warentyp oder Entitytyp</p><p>-- @return [number] Offer ID</p><p>-- @return [number] Trader ID</p><p>-- @return [number] Storehouse ID</p><p>-- @within Internal</p><p>-- @local</p><p>    local Info = self:GetStorehouseInformation(_PlayerID);</p><p>    if Info then</p><p>        for j=1, #Info[1], 1 do</p><p>            if Info[1][j][3] == _GoodOrEntityType then</p><p>                return Info[1][j][2], Info[1][j][1], Info.Storehouse;</p><p>            end</p><p>        end</p><p>    end</p><p>    return -1, -1, -1;</p><p>-- Gibt den Typ des Händlers mit der ID im Gebäude zurück.</p><p>-- @param _BuildingID [number] Building ID</p><p>-- @param _TraderID [number] Trader ID</p><p>-- @return number</p><p>-- @within Internal</p><p>-- @local</p><p>    if Logic.IsGoodTrader(BuildingID, _TraderID) == true then</p><p>        return QSB.TraderTypes.GoodTrader;</p><p>    elseif Logic.IsMercenaryTrader(BuildingID, _TraderID) == true then</p><p>        return QSB.TraderTypes.MercenaryTrader;</p><p>    elseif Logic.IsEntertainerTrader(BuildingID, _TraderID) == true then</p><p>        return QSB.TraderTypes.EntertainerTrader;</p><p>    else</p><p>        return QSB.TraderTypes.Unknown;</p><p>    end</p><p>-- Entfernt das Angebot vom Lagerhaus des Spielers, wenn es vorhanden ist.</p><p>-- Es wird immer nur das erste Angebot des Typs entfernt.</p><p>-- @param _PlayerID [number] Player ID</p><p>-- @param _GoodOrEntityType [number] Warentyp oder Entitytyp</p><p>-- @within Internal</p><p>-- @local</p><p>    local OfferID, TraderID, BuildingID = self:GetOfferAndTrader(_PlayerID, _GoodOrEntityType);</p><p>    if not IsExisting(BuildingID) then</p><p>        return;</p><p>    end</p><p>    -- Wird benötigt, weil bei RemoveOffer die Trader-IDs vertauscht sind.</p><p>    local MappedTraderID = (TraderID == 1 and 2) or (TraderID == 2 and 1) or 0;</p><p>    Logic.RemoveOffer(BuildingID, MappedTraderID, OfferID);</p><p>-- Ändert die aktuelle Menge des Angebots im Händelrgebäude.</p><p>-- Der eingetragene Wert darf die maximale Menge an Angeboten des Typs im</p><p>-- Lagerhaus nicht überschreiten.</p><p>-- <b>Hinweis</b>: Wird eine höherer Wert gesetzt, als das ursprüngliche</p><p>-- Maximum, regenerieren sich die zusätzlichen Angebote nicht.</p><p>-- @param _PlayerID	[number] Händlergebäude</p><p>-- @param _GoodOrEntityType	[number] ID des Händlers im Gebäude</p><p>-- @param _NewAmount [number] Neue Menge an Angeboten</p><p>-- @within Internal</p><p>-- @local</p><p>    local OfferID, TraderID, BuildingID = self:GetOfferAndTrader(_PlayerID, _GoodOrEntityType);</p><p>    if not IsExisting(BuildingID) then</p><p>        return;</p><p>    end</p><p>    -- Menge == -1 oder Menge == nil bedeutet Maximum</p><p>    if _NewAmount == nil or _NewAmount == -1 then</p><p>        _NewAmount = self.Data.PlayerOffersAmount[_PlayerID][_GoodOrEntityType];</p><p>    end</p><p>    -- Werte größer als das Maximum werden nicht erneuert!</p><p>    if self.Data.PlayerOffersAmount[_PlayerID][_GoodOrEntityType] and self.Data.PlayerOffersAmount[_PlayerID][_GoodOrEntityType] < _NewAmount then</p><p>        _NewAmount = self.Data.PlayerOffersAmount[_PlayerID][_GoodOrEntityType];</p><p>    end</p><p>    Logic.ModifyTraderOffer(BuildingID, OfferID, _NewAmount, TraderID);</p><p>-- -------------------------------------------------------------------------- --</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundletravelingsalesman.lua.html">
            <div class='doclink'>
                <div>BundleTravelingSalesman</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia BundleTravelingSalesman                                       # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Mit diesem Bundle wird ein Fahrender Händler angeboten der periodisch den</p><p>-- Hafen mit einem Schiff anfährt. Dabei kann der Fahrtweg frei mit Wegpunkten</p><p>-- bestimmt werden. Es können auch mehrere Spieler zu Händlern gemacht werden.</p><p>-- <p><a href="#API.TravelingSalesmanActivate">Schiffshändler aktivieren</a></p></p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Erstellt einen fahrender Händler mit zufälligen Angeboten.</p><p>-- Soll immer das selbe angeboten werden, darf nur ein Angebotsblock</p><p>-- definiert werden.</p><p>-- Es kann mehr als einen fahrender Händler auf der Map geben.</p><p>-- <b>Alias</b>: ActivateTravelingSalesman</p><p>-- @param _PlayerID [number] Spieler-ID des Händlers</p><p>-- @param _Offers [table] Liste an Angeboten</p><p>-- @param _Waypoints [table] Wegpunktliste Anfahrt</p><p>-- @param _Reversed [table] Wegpunktliste Abfahrt</p><p>-- @param _Appearance [table] Ankunft und Abfahrt</p><p>-- @param _RotationMode [boolean] Angebote werden der Reihe nach durchgegangen</p><p>-- @within Anwenderfunktionen</p><p>-- @usage -- Angebote deklarieren</p><p>-- local Offers = {</p><p>--     {</p><p>--         {"G_Gems", 5,},</p><p>--         {"G_Iron", 5,},</p><p>--         {"G_Beer", 2,},</p><p>--     },</p><p>--     {</p><p>--         {"G_Stone", 5,},</p><p>--         {"G_Sheep", 1,},</p><p>--         {"G_Cheese", 2,},</p><p>--         {"G_Milk", 5,},</p><p>--     },</p><p>--     {</p><p>--         {"G_Grain", 5,},</p><p>--         {"G_Broom", 2,},</p><p>--         {"G_Sheep", 1,},</p><p>--     },</p><p>--     {</p><p>--         {"U_CatapultCart", 1,},</p><p>--         {"U_MilitarySword", 3,},</p><p>--         {"U_MilitaryBow", 3,},</p><p>--     },</p><p>-- };</p><p>-- -- Es sind maximal 4 Angebote pro Block erlaubt. Es können Waren, Soldaten</p><p>-- -- oder Entertainer angeboten werden. Es wird immer automatisch 1 Block</p><p>-- -- selektiert und die ANgebote gesetzt.</p><p>-- -- Wegpunkte deklarieren</p><p>-- local Waypoints = {"WP1", "WP2", "WP3", "WP4"};</p><p>-- -- Es gibt nun zwei Möglichkeiten:</p><p>-- -- 1. Durch weglassen des Reversed Path werden die Wegpunkte durch das</p><p>-- -- Schiff bei der Abfahrt automatisch rückwärts abgefahren.</p><p>-- -- 2. Es wird ein anderer Pfad für die Abfahrt deklariert.</p><p>-- -- Anfahrt und Abfanrtsmonate deklarieren</p><p>-- local Appearance = {{4, 6}, {8, 10}};</p><p>-- -- Auch hier gibt es 2 Möglichkeiten:</p><p>-- -- 1. Neue Anfahrts- und Abfahrtszeiten setzen.</p><p>-- -- 2. _Apperance weglassen / nil setzen und den Standard verwenden</p><p>-- -- (März bis Mai und August bis Oktober)</p><p>-- -- Jetzt kann ein fahrender Händler erzeugt werden</p><p>-- API.TravelingSalesmanActivate(2, Offers, Waypoints, nil, Appearance);</p><p>-- -- Hier ist der Rückweg automatisch die Umkehr des Hinwegs (_Reversed = nil).</p><p>-- -- _Reversed und _Apperance können in den meisten Fällen immer weggelassen</p><p>-- -- bzw. nil sein!</p><p>-- API.TravelingSalesmanActivate(2, Offers, Waypoints);</p><p>function API.TravelingSalesmanActivate(_PlayerID, _Offers, _Waypoints, _Reversed, _Appearance, _RotationMode)</p><p>    if GUI then</p><p>        API.Log("Can not execute API.TravelingSalesmanActivate in local script!");</p><p>        return;</p><p>    end</p><p>    return BundleTravelingSalesman.Global:TravelingSalesman_Create(_PlayerID, _Offers, _Appearance, _Waypoints, _Reversed, _RotationMode);</p><p>-- Zerstört den fahrender Händler. Der Spieler wird dabei natürlich</p><p>-- nicht zerstört.</p><p>-- <b>Alias</b>: DeactivateTravelingSalesman</p><p>-- @param _PlayerID [number] Spieler-ID des Händlers</p><p>-- @within Anwenderfunktionen</p><p>-- @usage -- Fahrenden Händler von Spieler 2 löschen</p><p>-- API.TravelingSalesmanDeactivate(2)</p><p>function API.TravelingSalesmanDeactivate(_PlayerID)</p><p>    if GUI then</p><p>        API.Bridge("API.TravelingSalesmanDeactivate(" .._PlayerID.. ")");</p><p>        return;</p><p>    end</p><p>    return BundleTravelingSalesman.Global:TravelingSalesman_Disband(_PlayerID);</p><p>-- Legt fest, ob die diplomatischen Beziehungen zwischen dem Spieler und dem</p><p>-- Hafen überschrieben werden.</p><p>-- Die diplomatischen Beziehungen werden überschrieben, wenn sich ein Schiff</p><p>-- im Hafen befinden und wenn es abreist. Der Hafen ist "Handelspartner", wenn</p><p>-- ein Schiff angelegt hat, sonst "Bekannt".</p><p>-- Bei diplomatischen Beziehungen geringer als "Bekannt", kann es zu Fehlern</p><p>-- kommen. Dann werden Handelsangebote angezeigt, konnen aber nicht durch</p><p>-- den Spieler erworben werden.</p><p>-- <b>Hinweis</b>: Standardmäßig als aktiv voreingestellt.</p><p>-- <b>Alias</b>: TravelingSalesmanDiplomacyOverride</p><p>-- @param _PlayerID [number] Spieler-ID des Händlers</p><p>-- @param _Flag [boolean] Diplomatie überschreiben</p><p>-- @within Anwenderfunktionen</p><p>-- @usage -- Spieler 2 überschreibt nicht mehr die Diplomatie</p><p>-- API.TravelingSalesmanDiplomacyOverride(2, false)</p><p>function API.TravelingSalesmanDiplomacyOverride(_PlayerID, _Flag)</p><p>    if GUI then</p><p>        API.Bridge("API.TravelingSalesmanDiplomacyOverride(" .._PlayerID.. ", " ..tostring(_Flag).. ")");</p><p>        return;</p><p>    end</p><p>    return BundleTravelingSalesman.Global:TravelingSalesman_AlterDiplomacyFlag(_PlayerID, _Flag);</p><p>-- Legt fest, ob die Angebote der Reihe nach durchgegangen werden (beginnt von</p><p>-- vorn, wenn am Ende angelangt) oder zufällig ausgesucht werden.</p><p>-- <b>Alias</b>: TravelingSalesmanRotationMode</p><p>-- @param _PlayerID [number] Spieler-ID des Händlers</p><p>-- @param _Flag [boolean] Angebotsrotation einschalten</p><p>-- @within Anwenderfunktionen</p><p>-- @usage -- Spieler 2 geht Angebote der Reihe nach durch.</p><p>-- API.TravelingSalesmanRotationMode(2, true)</p><p>function API.TravelingSalesmanRotationMode(_PlayerID, _Flag)</p><p>    if GUI then</p><p>        API.Bridge("API.TravelingSalesmanRotationMode(" .._PlayerID.. ", " ..tostring(_Flag).. ")");</p><p>        return;</p><p>    end</p><p>    if not QSB.TravelingSalesman.Harbors[_PlayerID] then</p><p>        return;</p><p>    end</p><p>    QSB.TravelingSalesman.Harbors[_PlayerID].RotationMode = _Flag == true;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {</p><p>        Data = {},</p><p>    },</p><p>-- Global Script ---------------------------------------------------------------</p><p>-- Initialisiert das Bundle im globalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    TravelingSalesman_Control = BundleTravelingSalesman.Global.TravelingSalesman_Control;</p><p>-- Gibt den ersten menschlichen Spieler zurück. Ist das globale</p><p>-- Gegenstück zu GUI.GetPlayerID().</p><p>-- @return number</p><p>-- @within Internal</p><p>-- @local</p><p>    local pID = 1;</p><p>    for i=1,8 do</p><p>        if Logic.PlayerGetIsHumanFlag(1) == true then</p><p>            pID = i;</p><p>            break;</p><p>        end</p><p>    end</p><p>    return pID;</p><p>-- Erstellt einen fahrender Händler mit zufälligen Angeboten. Soll</p><p>-- immer das selbe angeboten werden, muss nur ein Angebotsblock</p><p>-- definiert werden.</p><p>-- Es kann mehrere fahrende Händler auf der Map geben.</p><p>-- @param _PlayerID [number] Spieler-ID des Händlers</p><p>-- @param _Offers [table] Liste an Angeboten</p><p>-- @param _Appearance [table] Wartezeit</p><p>-- @param _Waypoints [table] Wegpunktliste Anfahrt</p><p>-- @param _Reversed [table] Wegpunktliste Abfahrt</p><p>-- @param _RotationMode [boolean] Wegpunktliste Abfahrt</p><p>-- @within Internal</p><p>-- @local</p><p>    assert(type(_PlayerID) == "number");</p><p>    assert(type(_Offers) == "table");</p><p>    _Appearance = _Appearance or {{3,5},{8,10}};</p><p>    assert(type(_Appearance) == "table");</p><p>    assert(type(_Waypoints) == "table");</p><p>    if not _Reversed then</p><p>        _Reversed = {};</p><p>        for i=#_Waypoints, 1, -1 do</p><p>            _Reversed[#_Waypoints+1 - i] = _Waypoints[i];</p><p>        end</p><p>    end</p><p>    if not QSB.TravelingSalesman.Harbors[_PlayerID] then</p><p>        QSB.TravelingSalesman.Harbors[_PlayerID] = {};</p><p>        QSB.TravelingSalesman.Harbors[_PlayerID].Waypoints = _Waypoints;</p><p>        QSB.TravelingSalesman.Harbors[_PlayerID].Reversed = _Reversed;</p><p>        QSB.TravelingSalesman.Harbors[_PlayerID].SpawnPos = _Waypoints[1];</p><p>        QSB.TravelingSalesman.Harbors[_PlayerID].Destination = _Reversed[1];</p><p>        QSB.TravelingSalesman.Harbors[_PlayerID].Appearance = _Appearance;</p><p>        QSB.TravelingSalesman.Harbors[_PlayerID].Status = 0;</p><p>        QSB.TravelingSalesman.Harbors[_PlayerID].Offer = _Offers;</p><p>        QSB.TravelingSalesman.Harbors[_PlayerID].LastOffer = 0;</p><p>        QSB.TravelingSalesman.Harbors[_PlayerID].AlterDiplomacy = true;</p><p>        QSB.TravelingSalesman.Harbors[_PlayerID].RotationMode = _RotationMode == true;</p><p>    end</p><p>    math.randomseed(Logic.GetTimeMs());</p><p>    if not QSB.TravelingSalesman.JobID then</p><p>        QSB.TravelingSalesman.JobID = StartSimpleJob("TravelingSalesman_Control");</p><p>    end</p><p>-- Zerstört den fahrender Händler. Der Spieler wird dabei natürlich</p><p>-- nicht zerstört.</p><p>-- @param _PlayerID [number] Spieler-ID des Händlers</p><p>-- @within Internal</p><p>-- @local</p><p>    assert(type(_PlayerID) == "number");</p><p>    QSB.TravelingSalesman.Harbors[_PlayerID] = nil;</p><p>    Logic.RemoveAllOffers(Logic.GetStoreHouse(_PlayerID));</p><p>    DestroyEntity("TravelingSalesmanShip_Player" .._PlayerID);</p><p>-- Legt fest, ob die diplomatischen Beziehungen zwischen dem Spieler und dem</p><p>-- Hafen überschrieben werden.</p><p>-- Die diplomatischen Beziehungen werden überschrieben, wenn sich ein Schiff</p><p>-- im Hafen befinden und wenn es abreist. Der Hafen ist "Handelspartner", wenn</p><p>-- ein Schiff angelegt hat, sonst "Bekannt".</p><p>-- Bei diplomatischen Beziehungen geringer als "Bekannt", kann es zu Fehlern</p><p>-- kommen. Dann werden Handelsangebote angezeigt, konnen aber nicht durch</p><p>-- den Spieler erworben werden.</p><p>-- <b>Hinweis</b>: Standardmäßig als aktiv voreingestellt.</p><p>-- @param _PlayerID [number] Spieler-ID des Händlers</p><p>-- @param _Flag [boolean] Diplomatie überschreiben</p><p>-- @within Internal</p><p>-- @local</p><p>    assert(type(_PlayerID) == "number");</p><p>    assert(QSB.TravelingSalesman.Harbors[_PlayerID]);</p><p>    QSB.TravelingSalesman.Harbors[_PlayerID].AlterDiplomacy = _Flag == true;</p><p>-- Gibt das nächste Angebot des Hafens des Spielers zurück.</p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @within Internal</p><p>-- @local</p><p>    local NextOffer;</p><p>    -- Angebote werden der Reihe nach durchlaufen und wiederholen sich.</p><p>    if QSB.TravelingSalesman.Harbors[_PlayerID].RotationMode then</p><p>        QSB.TravelingSalesman.Harbors[_PlayerID].LastOffer = QSB.TravelingSalesman.Harbors[_PlayerID].LastOffer +1</p><p>        local OfferIndex = QSB.TravelingSalesman.Harbors[_PlayerID].LastOffer;</p><p>        if OfferIndex > #QSB.TravelingSalesman.Harbors[_PlayerID].Offer then</p><p>            QSB.TravelingSalesman.Harbors[_PlayerID].LastOffer = 1;</p><p>            OfferIndex = 1;</p><p>        end</p><p>        NextOffer = QSB.TravelingSalesman.Harbors[_PlayerID].Offer[OfferIndex];</p><p>    -- Angebote werden zufällig ausgelost, ohne direkte Doppelung.</p><p>    else</p><p>        local RandomIndex = 1;</p><p>        if #QSB.TravelingSalesman.Harbors[_PlayerID].Offer > 1 then</p><p>            repeat</p><p>                RandomIndex = math.random(1,#QSB.TravelingSalesman.Harbors[_PlayerID].Offer);</p><p>            until (RandomIndex ~= QSB.TravelingSalesman.Harbors[_PlayerID].LastOffer);</p><p>        end</p><p>        QSB.TravelingSalesman.Harbors[_PlayerID].LastOffer = RandomIndex;</p><p>        NextOffer = QSB.TravelingSalesman.Harbors[_PlayerID].Offer[RandomIndex];</p><p>    end</p><p>    return NextOffer;</p><p>-- Informiert den Spieler über die Ankunft eines Schiffes am Hafen.</p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @within Internal</p><p>-- @local</p><p>    if ((IsBriefingActive and not IsBriefingActive()) or true) then</p><p>        -- Prüfe, ob schon existiert und starte ggf. neu</p><p>        -- (Konsistenz von Questnamen erhalten!)</p><p>        local InfoQuest = Quests[GetQuestID("TravelingSalesman_Info_P" .._PlayerID)];</p><p>        if InfoQuest then</p><p>            API.RestartQuest("TravelingSalesman_Info_P" .._PlayerID, true);</p><p>            InfoQuest:SetMsgKeyOverride();</p><p>            InfoQuest:SetIconOverride();</p><p>            InfoQuest:Trigger();</p><p>            return;</p><p>        end</p><p>        -- Erzeuge neuen Quest</p><p>        -- (Quest existiert nicht und kann gefahrlos erzeugt werden.)</p><p>        local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>        local Text = { de = "Ein Schiff hat angelegt. Es bringt Güter von weit her.",</p><p>                       en = "A ship is at the pier. It deliver goods from far away."};</p><p>        QuestTemplate:New(</p><p>            "TravelingSalesman_Info_P" .._PlayerID,</p><p>            _PlayerID,</p><p>            self:TravelingSalesman_GetHumanPlayer(),</p><p>            {{ Objective.Dummy,}},</p><p>            {{ Triggers.Time, 0 }},</p><p>            0,</p><p>            nil, nil, nil, nil, false, true,</p><p>            nil, nil,</p><p>            Text[lang],</p><p>            nil</p><p>        );</p><p>    end</p><p>-- Setzt die Angebote für den aktuellen Besuch des fahrenden Händlers.</p><p>-- @param _PlayerID [number] Spieler-ID des Händlers</p><p>-- @within Internal</p><p>-- @local</p><p>    MerchantSystem.TradeBlackList[_PlayerID] = {};</p><p>    MerchantSystem.TradeBlackList[_PlayerID][0] = #MerchantSystem.TradeBlackList[3];</p><p>    local traderId = Logic.GetStoreHouse(_PlayerID);</p><p>    local offer = self:TravelingSalesman_NextOffer(_PlayerID);</p><p>    Logic.RemoveAllOffers(traderId);</p><p>    if #offer > 0 then</p><p>        for i=1,#offer,1 do</p><p>            local offerType = offer[i][1];</p><p>            local isGoodType = false</p><p>            for k,v in pairs(Goods)do</p><p>                if k == offerType then</p><p>                    isGoodType = true</p><p>                end</p><p>            end</p><p>            if isGoodType then</p><p>                local amount = offer[i][2];</p><p>                AddOffer(traderId,amount,Goods[offerType], 9999);</p><p>            else</p><p>                if Logic.IsEntityTypeInCategory(Entities[offerType],EntityCategories.Military)== 0 then</p><p>                    AddEntertainerOffer(traderId,Entities[offerType]);</p><p>                else</p><p>                    local amount = offer[i][2];</p><p>                    AddMercenaryOffer(traderId,amount,Entities[offerType], 9999);</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>    if QSB.TravelingSalesman.Harbors[_PlayerID].AlterDiplomacy then</p><p>        SetDiplomacyState(self:TravelingSalesman_GetHumanPlayer(), _PlayerID, DiplomacyStates.TradeContact);</p><p>    end</p><p>    ActivateMerchantPermanentlyForPlayer(Logic.GetStoreHouse(_PlayerID), self:TravelingSalesman_GetHumanPlayer());</p><p>    self:TravelingSalesman_DisplayMessage(_PlayerID);</p><p>-- Steuert alle fahrender Händler auf der Map.</p><p>-- @within Internal</p><p>-- @local</p><p>    for k,v in pairs(QSB.TravelingSalesman.Harbors) do</p><p>        if QSB.TravelingSalesman.Harbors[k] ~= nil then</p><p>            if v.Status == 0 then</p><p>                local month = Logic.GetCurrentMonth();</p><p>                local start = false;</p><p>                for i=1, #v.Appearance,1 do</p><p>                    if month == v.Appearance[i][1] then</p><p>                        start = true;</p><p>                    end</p><p>                end</p><p>                if start then</p><p>                    local orientation = Logic.GetEntityOrientation(GetID(v.SpawnPos))</p><p>                    local ID = CreateEntity(0,Entities.D_X_TradeShip,GetPosition(v.SpawnPos),"TravelingSalesmanShip_Player"..k,orientation);</p><p>                    Path:new(ID,v.Waypoints, nil, nil, nil, nil, true, nil, nil, 300);</p><p>                    v.Status = 1;</p><p>                end</p><p>            elseif v.Status == 1 then</p><p>                if IsNear("TravelingSalesmanShip_Player"..k,v.Destination,400) then</p><p>                    BundleTravelingSalesman.Global:TravelingSalesman_AddOffer(k)</p><p>                    v.Status = 2;</p><p>                end</p><p>            elseif v.Status == 2 then</p><p>                local month = Logic.GetCurrentMonth();</p><p>                local stop = false;</p><p>                for i=1, #v.Appearance,1 do</p><p>                    if month == v.Appearance[i][2] then</p><p>                        stop = true;</p><p>                    end</p><p>                end</p><p>                if stop then</p><p>                    if QSB.TravelingSalesman.Harbors[k].AlterDiplomacy then</p><p>                        SetDiplomacyState(BundleTravelingSalesman.Global:TravelingSalesman_GetHumanPlayer(),k,DiplomacyStates.EstablishedContact);</p><p>                    end</p><p>                    Path:new(GetID("TravelingSalesmanShip_Player"..k),v.Reversed, nil, nil, nil, nil, true, nil, nil, 300);</p><p>                    Logic.RemoveAllOffers(Logic.GetStoreHouse(k));</p><p>                    v.Status = 3;</p><p>                end</p><p>            elseif v.Status == 3 then</p><p>                if IsNear("TravelingSalesmanShip_Player"..k,v.SpawnPos,400) then</p><p>                    DestroyEntity("TravelingSalesmanShip_Player"..k);</p><p>                    v.Status = 0;</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/addoncastlestore.lua.html">
            <div class='doclink'>
                <div>AddOnCastleStore</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia AddOnCastleStore                                             # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Dieses Bundle stellt ein Burglager zur Verfügung, das sich ähnlich wie das</p><p>-- normale Lager verhält. Das Burglager ist von der Ausbaustufe der Burg</p><p>-- abhängig. Je weiter die Burg ausgebaut wird, desto höher ist das Limit.</p><p>-- Eine Ware wird dann im Burglager eingelagert, wenn das eingestellte Limit</p><p>-- der Ware im Lagerhaus erreicht wird.</p><p>-- Der Spieler kann das allgemeine Verhalten des Lagers für alle Waren wählen</p><p>-- und zusätzlich für einzelne Waren andere Verhalten bestimmen. Waren können</p><p>-- eingelagert und ausgelagert werden. Eingelagerte Waren können zusätzlich</p><p>-- gesperrt werden. Eine gesperrte Ware wird nicht wieder ausgelagert, auch</p><p>-- wenn Platz im Lager frei wird.</p><p>-- Muss ein Spieler einen Tribut aus dem lagerhaus begleichen, eine bestimmte</p><p>-- Menge an Waren erreichen oder die Kosten Zur aktivierung eines interaktien</p><p>-- Objektes bezahlen, werden die Güter im Burglager automatisch mit einbezogen,</p><p>-- wenn sie nicht gesperrt wurden.</p><p>-- Das wichtigste Auf einen Blick:</p><p>-- <ul></p><p>-- <li></p><p>-- <a href="#API.CastleStoreCreate">Burglager in der Burg anlegen</a></p><p>-- </li></p><p>-- <li></p><p>-- <a href="#API.CastleStoreCountGood">Warenmenge in der Burg abfragen</a></p><p>-- </li></p><p>-- <li></p><p>-- <a href="#API.CastleStoreAddGood">Waren dem Burglager hinzufügen</a></p><p>-- </li></p><p>-- <li></p><p>-- <a href="#API.CastleStoreRemoveGood">Waren aus der Burg entfernen</a></p><p>-- </li></p><p>-- </ul></p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Erstellt ein Burglager für den angegebenen Spieler.</p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @return [table] Burglager-Instanz</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.CastleStoreCreate(1);</p><p>function API.CastleStoreCreate(_PlayerID)</p><p>    if GUI then</p><p>        API.Bridge("API.CastleStoreCreate(" .._PlayerID.. ")");</p><p>        return;</p><p>    end</p><p>    return QSB.CastleStore:New(_PlayerID);</p><p>-- Zerstört das Burglager des angegebenen Spielers.</p><p>-- Alle Waren im Burglager werden dabei unwiederuflich gelöscht!</p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.CastleStoreDestroy(1)</p><p>function API.CastleStoreDestroy(_PlayerID)</p><p>    if GUI then</p><p>        API.Bridge("API.CastleStoreCreate(" .._PlayerID.. ")");</p><p>        return;</p><p>    end</p><p>    local Store = QSB.CastleStore:GetInstance(_PlayerID);</p><p>    if Store then</p><p>        Store:Dispose();</p><p>    end</p><p>-- Fügt dem Burglager des Spielers eine Menga an Waren hinzu.</p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @param _Good [number] Typ der Ware</p><p>-- @param _Amount [number] Menge der Ware</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.CastleStoreAddGood(1, Goods.G_Wood, 50);</p><p>function API.CastleStoreAddGood(_PlayerID, _Good, _Amount)</p><p>    if GUI then</p><p>        API.Bridge("API.CastleStoreAddGood(" .._PlayerID.. "," .._Good.. "," .._Amount.. ")");</p><p>        return;</p><p>    end</p><p>    local Store = QSB.CastleStore:GetInstance(_PlayerID);</p><p>    if Store then</p><p>        Store:Add(_Good, _Amount);</p><p>    end</p><p>-- Entfernt eine Menge von Waren aus dem Burglager des Spielers.</p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @param _Good [number] Typ der Ware</p><p>-- @param _Amount [number] Menge der Ware</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.CastleStoreRemoveGood(1, Goods.G_Iron, 15);</p><p>function API.CastleStoreRemoveGood(_PlayerID, _Good, _Amount)</p><p>    if GUI then</p><p>        API.Bridge("API.CastleStoreRemoveGood(" .._PlayerID.. "," .._Good.. "," .._Amount.. ")");</p><p>        return;</p><p>    end</p><p>    local Store = QSB.CastleStore:GetInstance(_PlayerID);</p><p>    if Store then</p><p>        Store:Remove(_Good, _Amount);</p><p>    end</p><p>-- Gibt die Menge an Waren des Typs im Burglager des Spielers zurück.</p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @param _Good [number] Typ der Ware</p><p>-- @return [number] Menge an Waren</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- local Amount = API.CastleStoreCountGood(1, Goods.G_Milk);</p><p>function API.CastleStoreGetGoodAmount(_PlayerID, _Good)</p><p>    if GUI then</p><p>        return QSB.CastleStore:GetAmount(_PlayerID, _Good);</p><p>    end</p><p>    local Store = QSB.CastleStore:GetInstance(_PlayerID);</p><p>    if Store then</p><p>        return Store:GetAmount(_Good);</p><p>    end</p><p>    return 0;</p><p>-- Gibt die Gesamtmenge aller Waren im Burglager zurück.</p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @return [number] Menge an Waren</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- local Amount = API.CastleStoreTotalAmount(1);</p><p>function API.CastleStoreGetTotalAmount(_PlayerID)</p><p>    if GUI then</p><p>        return QSB.CastleStore:GetTotalAmount(_PlayerID);</p><p>    end</p><p>    local Store = QSB.CastleStore:GetInstance(_PlayerID);</p><p>    if Store then</p><p>        return Store:GetTotalAmount();</p><p>    end</p><p>    return 0;</p><p>-- Gibt die maximale Kapazität des Burglagers zurück.</p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @return [number] Große des Lagers</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- local Size = API.CastleStoreGetSize(1);</p><p>function API.CastleStoreGetSize(_PlayerID)</p><p>    if GUI then</p><p>        return QSB.CastleStore:GetLimit(_PlayerID);</p><p>    end</p><p>    local Store = QSB.CastleStore:GetInstance(_PlayerID);</p><p>    if Store then</p><p>        return Store:GetLimit();</p><p>    end</p><p>    return 0;</p><p>-- Setzt die Basiskapazität des Burglagers.</p><p>-- Die Basiskapazität ist das Limit der ersten Stufe der Burg. Mit jedem</p><p>-- Ausbau wird dieser Wert verdoppelt.</p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @param _Capacity [number] Basisgröße des Lagers</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- -- -> [150, 300, 600, 1200]</p><p>-- API.CastleStoreSetBaseCapacity(1, 150);</p><p>function API.CastleStoreSetBaseCapacity(_PlayerID, _Capacity)</p><p>    if GUI then</p><p>        API.Bridge("API.CastleStoreSetBaseCapacity(" .._PlayerID.. "," .._Capacity.. ")");</p><p>        return;</p><p>    end</p><p>    local Store = QSB.CastleStore:GetInstance(_PlayerID);</p><p>    if Store then</p><p>        Store:SetStorageLimit(_Capacity);</p><p>    end</p><p>-- Setzt die Obergrenze ab der ins Burglager ausgelagert wird.</p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @param _Good [number] Warentyp</p><p>-- @param _Limit [number] Obergrenze</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.CastleStoreSetOutsourceBoundary(1, Goods.G_Milk, 50);</p><p>function API.CastleStoreSetOutsourceBoundary(_PlayerID, _Good, _Limit)</p><p>    if GUI then</p><p>        API.Bridge("API.CastleStoreOutsourceBoundary(" .._PlayerID.. "," .._Good.. "," .._Limit.. ")");</p><p>        return;</p><p>    end</p><p>    local Store = QSB.CastleStore:GetInstance(_PlayerID);</p><p>    if Store then</p><p>        Stores:SetUperLimitInStorehouseForGoodType(_Good, _Limit)</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {</p><p>        Data = {</p><p>            UpdateCastleStore = false,</p><p>            CastleStoreObjects = {},</p><p>        },</p><p>        CastleStore = {</p><p>            Data = {</p><p>                CapacityBase = 75,</p><p>                Goods = {</p><p>                    -- [Ware] = {Menge, Einlager-Flag, Gesperrt-Flag, Untergrenze}</p><p>                    [Goods.G_Wood]      = {0, true, false, 35},</p><p>                    [Goods.G_Stone]     = {0, true, false, 35},</p><p>                    [Goods.G_Iron]      = {0, true, false, 35},</p><p>                    [Goods.G_Carcass]   = {0, true, false, 15},</p><p>                    [Goods.G_Grain]     = {0, true, false, 15},</p><p>                    [Goods.G_RawFish]   = {0, true, false, 15},</p><p>                    [Goods.G_Milk]      = {0, true, false, 15},</p><p>                    [Goods.G_Herb]      = {0, true, false, 15},</p><p>                    [Goods.G_Wool]      = {0, true, false, 15},</p><p>                    [Goods.G_Honeycomb] = {0, true, false, 15},</p><p>                }</p><p>            },</p><p>        },</p><p>    },</p><p>    Local = {</p><p>        Data = {},</p><p>        CastleStore = {</p><p>            Data = {}</p><p>        },</p><p>        Description = {</p><p>            ShowCastle = {</p><p>                Text = {</p><p>                    de = "Finanzansicht",</p><p>                    en = "Financial view",</p><p>                },</p><p>            },</p><p>            ShowCastleStore = {</p><p>                Text = {</p><p>                    de = "Lageransicht",</p><p>                    en = "Storeage view",</p><p>                },</p><p>            },</p><p>            GoodButtonDisabled = {</p><p>                Text = {</p><p>                    de = "Diese Ware wird nicht angenommen.",</p><p>                    en = "This good will not be stored.",</p><p>                },</p><p>            },</p><p>            CityTab = {</p><p>                Title = {</p><p>                    de = "Güter verwaren",</p><p>                    en = "Keep goods",</p><p>                },</p><p>                Text = {</p><p>                    de = "[UMSCHALT + N]{cr}- Lagert Waren im Burglager ein {cr}- Waren verbleiben auch im Lager, wenn Platz vorhanden ist",</p><p>                    en = "[SHIFT + N]{cr}- Stores goods inside the vault {cr}- Goods also remain in the warehouse when space is available",</p><p>                },</p><p>            },</p><p>            StorehouseTab = {</p><p>                Title = {</p><p>                    de = "Güter zwischenlagern",</p><p>                    en = "Store in vault",</p><p>                },</p><p>                Text = {</p><p>                    de = "[UMSCHALT + B]{cr}- Lagert Waren im Burglager ein {cr}- Lagert waren wieder aus, sobald Platz frei wird",</p><p>                    en = "[SHIFT + B]{cr}- Stores goods inside the vault {cr}- Allows to extrac goods as soon as space becomes available",</p><p>                },</p><p>            },</p><p>            MultiTab = {</p><p>                Title = {</p><p>                    de = "Lager räumen",</p><p>                    en = "Clear store",</p><p>                },</p><p>                Text = {</p><p>                    de = "[UMSCHALT + M]{cr}- Lagert alle Waren aus {cr}- Benötigt Platz im Lagerhaus",</p><p>                    en = "[Shift + M]{cr}- Removes all goods {cr}- Requires space in the storehouse",</p><p>                },</p><p>            },</p><p>        },</p><p>    },</p><p>-- Global Script ---------------------------------------------------------------</p><p>-- Initalisiert das Bundle im globalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    QSB.CastleStore = self.CastleStore;</p><p>    self:OverwriteGameFunctions()</p><p>    API.AddSaveGameAction(self.OnSaveGameLoaded);</p><p>-- Erzeugt ein neues Burglager-Objekt und gibt es zurück.</p><p>-- <p><b>Alias</b>: QSB.CastleStore:New</p></p><p>-- @param _PlayerID [number] PlayerID des Spielers</p><p>-- @return [table] QSB.CastleStore Instanz</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>-- @usage</p><p>-- -- Erstellt ein Burglager für Spieler 1</p><p>-- local Store = QSB.CastleStore:new(1);</p><p>    assert(self == AddOnCastleStore.Global.CastleStore, "Can not be used from instance!");</p><p>    local Store = API.InstanceTable(self);</p><p>    Store.Data.PlayerID = _PlayerID;</p><p>    AddOnCastleStore.Global.Data.CastleStoreObjects[_PlayerID] = Store;</p><p>    if not self.Data.UpdateCastleStore then</p><p>        self.Data.UpdateCastleStore = true;</p><p>        StartSimpleJobEx(AddOnCastleStore.Global.CastleStore.UpdateStores);</p><p>    end</p><p>    Logic.ExecuteInLuaLocalState([[</p><p>        QSB.CastleStore:CreateStore(]] ..Store.Data.PlayerID.. [[);</p><p>    ]])</p><p>    return Store;</p><p>-- Gibt die Burglagerinstanz für den Spieler zurück.</p><p>-- Wurde kein Burglager für den Spieler erstellt, wird nil zurückgegeben.</p><p>-- <p><b>Alias</b>: QSB.CastleStore:GetInstance</p></p><p>-- @param _PlayerID [number] PlayerID des Spielers</p><p>-- @return [table] QSB.CastleStore Instanz</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>-- @usage</p><p>-- -- Ermittelt das Burglager von Spieler 1</p><p>-- local Store = QSB.CastleStore:GetInstance(1);</p><p>    assert(self == AddOnCastleStore.Global.CastleStore, "Can not be used from instance!");</p><p>    return AddOnCastleStore.Global.Data.CastleStoreObjects[_PlayerID];</p><p>-- Gibt die Menge an Waren des Spielers zurück, eingeschlossen</p><p>-- der Waren im Burglager. Hat der Spieler kein Burglager, wird</p><p>-- nur die Menge im Lagerhaus zurückgegeben.</p><p>-- <p><b>Alias</b>: QSB.CastleStore:GetGoodAmountWithCastleStore</p></p><p>-- @param _Good [number] Warentyp</p><p>-- @param _PlayerIDvID des Spielers</p><p>-- @return [number] Warenmenge mit Menge in Burglager</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>-- @usage</p><p>-- -- Menge an Holz in beiden Lagern</p><p>-- local WoodAmount = QSB.CastleStore:GetGoodAmountWithCastleStore(Goods.G_Wood, 1);</p><p>    assert(self == AddOnCastleStore.Global.CastleStore, "Can not be used from instance!");</p><p>    local CastleStore = self:GetInstance(_PlayerID);</p><p>    local Amount = GetPlayerGoodsInSettlement(_Good, _PlayerID, true);</p><p>    if CastleStore ~= nil and _Good ~= Goods.G_Gold and Logic.GetGoodCategoryForGoodType(_Good) == GoodCategories.GC_Resource then</p><p>        Amount = Amount + CastleStore:GetAmount(_Good);</p><p>    end</p><p>    return Amount;</p><p>-- Zerstört das Burglager.</p><p>-- Die Burg wird dabei natürlich nicht zerstört.</p><p>-- <p><b>Alias</b>: QSB.CastleStore:Dispose</p></p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>-- @usage</p><p>-- -- Löschen des Burglagers von Spieler 1 ohne Referenz</p><p>-- QSB.CastleStore:GetInstance(1):Dispose();</p><p>-- -- Loschen mit Referenzvariable (z.B. Store)</p><p>-- Store:Dispose();</p><p>    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");</p><p>    Logic.ExecuteInLuaLocalState([[</p><p>        QSB.CastleStore:DeleteStore(]] ..self.Data.PlayerID.. [[);</p><p>    ]])</p><p>    AddOnCastleStore.Global.Data.CastleStoreObjects[self.Data.PlayerID] = nil;</p><p>-- Setzt die Obergrenze für eine Ware, ab der ins Burglager</p><p>-- ausgelagert wird.</p><p>-- <p><b>Alias</b>: QSB.CastleStore:SetUperLimitInStorehouseForGoodType</p></p><p>-- @param _Good [number] Warentyp</p><p>-- @param _Limit [number] Obergrenze</p><p>-- @return self</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");</p><p>    self.Data.Goods[_Good][4] = _Limit;</p><p>    Logic.ExecuteInLuaLocalState([[</p><p>        AddOnCastleStore.Local.Data.CastleStore[]] ..self.Data.PlayerID.. [[].Goods[]] .._Good.. [[][4] = ]] .._Limit.. [[</p><p>    ]])</p><p>    return self;</p><p>-- Setzt den Basiswert für die maximale Kapazität des Burglagers.</p><p>-- Der Basiswert dient zur Berechnung der Kapazität für die Ausbaustufen und</p><p>-- muss durch 2 teilbar sein.</p><p>-- Ist also der Basiswert 150, ergibt sich daraus:</p><p>-- <code></p><p>-- 150, 300, 600, 1200</p><p>-- </code></p><p>-- <p><b>Alias</b>: QSB.CastleStore:SetStorageLimit</p></p><p>-- @param _Limit [number] Maximale Kapazität</p><p>-- @return self</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>-- @usage</p><p>-- -- Basiswert auf 100 setzen.</p><p>-- -- -> [100, 200, 400, 800]</p><p>-- QSB.CastleStore:GetInstance(1):SetStorageLimit(100);</p><p>    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");</p><p>    self.Data.CapacityBase = math.floor(_Limit/2);</p><p>    Logic.ExecuteInLuaLocalState([[</p><p>        AddOnCastleStore.Local.Data.CastleStore[]] ..self.Data.PlayerID.. [[].CapacityBase = ]] ..math.floor(_Limit/2).. [[</p><p>    ]])</p><p>    return self;</p><p>-- Gibt die Menge an Waren des Typs im Burglager zurück.</p><p>-- <p><b>Alias</b>: QSB.CastleStore:GetAmount</p></p><p>-- @param _Good [number] Warentyp</p><p>-- @return [number] Menge an Waren im Burglager</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");</p><p>    if self.Data.Goods[_Good] then</p><p>        return self.Data.Goods[_Good][1];</p><p>    end</p><p>    return 0;</p><p>-- Gibt die Gesamtmenge aller Waren im Burglager zurück.</p><p>-- <p><b>Alias</b>: QSB.CastleStore:GetTotalAmount</p></p><p>-- @return [number] Gesamtmenge aller Waren</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");</p><p>    local TotalAmount = 0;</p><p>    for k, v in pairs(self.Data.Goods) do</p><p>        TotalAmount = TotalAmount + v[1];</p><p>    end</p><p>    return TotalAmount;</p><p>-- Gibt das aktuelle Lagerlimit zurück.</p><p>-- <p><b>Alias</b>: QSB.CastleStore:GetLimit</p></p><p>-- @return [number] Lagerlimt in der Burg</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");</p><p>    local Level = 0;</p><p>    local Headquarters = Logic.GetHeadquarters(self.Data.PlayerID);</p><p>    if Headquarters ~= 0 then</p><p>        Level = Logic.GetUpgradeLevel(Headquarters);</p><p>    end</p><p>    local Capacity = self.Data.CapacityBase;</p><p>    for i= 1, (Level+1), 1 do</p><p>        Capacity = Capacity * 2;</p><p>    end</p><p>    return Capacity;</p><p>-- Gibt zurück, ob die Ware akzeptiert wird.</p><p>-- <p><b>Alias</b>: QSB.CastleStore:IsGoodAccepted</p></p><p>-- @param _Good [number] Warentyp</p><p>-- @return [boolean] Ware wird akzeptiert</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");</p><p>    return self.Data.Goods[_Good][2] == true;</p><p>-- Setzt, ob die Ware akzeptiert wird.</p><p>-- <p><b>Alias</b>: QSB.CastleStore:SetGoodAccepted</p></p><p>-- @param _Good [number] Watentyp</p><p>-- @param _Flag [boolean] Akzeptanz-Flag</p><p>-- @return self</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");</p><p>    self.Data.Goods[_Good][2] = _Flag == true;</p><p>    Logic.ExecuteInLuaLocalState([[</p><p>        QSB.CastleStore:SetAccepted(</p><p>            ]] ..self.Data.PlayerID.. [[, ]] .._Good.. [[, ]] ..tostring(_Flag == true).. [[</p><p>        )</p><p>    ]])</p><p>    return self;</p><p>-- Gibt zurück, ob die Ware gesperrt ist.</p><p>-- <p><b>Alias</b>: QSB.CastleStore:IsGoodLocked</p></p><p>-- @param _Good [number] Warentyp</p><p>-- @return [boolean] Ware ist gesperrt</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");</p><p>    return self.Data.Goods[_Good][3] == true;</p><p>-- Setzt ob die Ware gesperrt ist, also nicht ausgelagert wird.</p><p>-- <p><b>Alias</b>: QSB.CastleStore:SetGoodLocked</p></p><p>-- @param _Good [number] Watentyp</p><p>-- @param _Flag [boolean] Akzeptanz-Flag</p><p>-- @return self</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");</p><p>    self.Data.Goods[_Good][3] = _Flag == true;</p><p>    Logic.ExecuteInLuaLocalState([[</p><p>        QSB.CastleStore:SetLocked(</p><p>            ]] ..self.Data.PlayerID.. [[, ]] .._Good.. [[, ]] ..tostring(_Flag == true).. [[</p><p>        )</p><p>    ]])</p><p>    return self;</p><p>-- Setzt den Modus "Zwischenlagerung", als ob der Tab geklickt wird.</p><p>-- <p><b>Alias</b>: QSB.CastleStore:ActivateTemporaryMode</p></p><p>-- @return self</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");</p><p>    Logic.ExecuteInLocalLuaState([[</p><p>        QSB.CastleStore.OnStorehouseTabClicked(QSB.CastleStore, ]] ..self.Data.PlayerID.. [[)</p><p>    ]])</p><p>    return self;</p><p>-- Setzt den Modus "Verwahrung", als ob der Tab geklickt wird.</p><p>-- <p><b>Alias</b>: QSB.CastleStore:ActivateStockMode</p></p><p>-- @return self</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");</p><p>    Logic.ExecuteInLocalLuaState([[</p><p>        QSB.CastleStore.OnCityTabClicked(QSB.CastleStore, ]] ..self.Data.PlayerID.. [[)</p><p>    ]])</p><p>    return self;</p><p>-- Setzt den Modus "Auslagerung", als ob der Tab geklickt wird.</p><p>-- <p><b>Alias</b>: QSB.CastleStore:ActivateOutsourceMode</p></p><p>-- @return self</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");</p><p>    Logic.ExecuteInLocalLuaState([[</p><p>        QSB.CastleStore.OnMultiTabClicked(QSB.CastleStore, ]] ..self.Data.PlayerID.. [[)</p><p>    ]])</p><p>    return self;</p><p>-- Lagert eine Menge von Waren im Burglager ein.</p><p>-- <p>Die Ware wird eingelagert wenn die Ware angenommen wird und noch</p><p>-- Platz im Burglager vorhanden ist.</p></p><p>-- <p><b>Alias</b>: QSB.CastleStore:Store</p></p><p>-- @param _Good [number] Watentyp</p><p>-- @param _Amount [number] Menge</p><p>-- @return self</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");</p><p>    if self:IsGoodAccepted(_Good) then</p><p>        if self:GetLimit() >= self:GetTotalAmount() + _Amount then</p><p>            local Level = Logic.GetUpgradeLevel(Logic.GetHeadquarters(self.Data.PlayerID));</p><p>            if GetPlayerResources(_Good, self.Data.PlayerID) > (self.Data.Goods[_Good][4] * (Level+1)) then</p><p>                AddGood(_Good, _Amount * (-1), self.Data.PlayerID);</p><p>                self.Data.Goods[_Good][1] = self.Data.Goods[_Good][1] + _Amount;</p><p>                Logic.ExecuteInLuaLocalState([[</p><p>                    QSB.CastleStore:SetAmount(</p><p>                        ]] ..self.Data.PlayerID.. [[, ]] .._Good.. [[, ]] ..self.Data.Goods[_Good][1].. [[</p><p>                    )</p><p>                ]]);</p><p>            end</p><p>        end</p><p>    end</p><p>    return self;</p><p>-- Lagert eine Menge von Waren aus dem Burglager aus.</p><p>-- <p>Die Ware wird ausgelagert wenn noch Platz im Lagerhaus vorhanden ist.</p></p><p>-- <p><b>Alias</b>: QSB.CastleStore:Outsource</p></p><p>-- @param _Good [number] Watentyp</p><p>-- @param _Amount [number] Menge</p><p>-- @return self</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");</p><p>    local Level = Logic.GetUpgradeLevel(Logic.GetHeadquarters(self.Data.PlayerID));</p><p>    if Logic.GetPlayerUnreservedStorehouseSpace(self.Data.PlayerID) >= _Amount then</p><p>        if self:GetAmount(_Good) >= _Amount then</p><p>            AddGood(_Good, _Amount, self.Data.PlayerID);</p><p>            self.Data.Goods[_Good][1] = self.Data.Goods[_Good][1] - _Amount;</p><p>            Logic.ExecuteInLuaLocalState([[</p><p>                QSB.CastleStore:SetAmount(</p><p>                    ]] ..self.Data.PlayerID.. [[, ]] .._Good.. [[, ]] ..self.Data.Goods[_Good][1].. [[</p><p>                )</p><p>            ]]);</p><p>        end</p><p>    end</p><p>    return self;</p><p>-- Fügt eine Menge an Waren dem Burglager hinzu, solange noch</p><p>-- Platz vorhanden ist.</p><p>-- <p><b>Alias</b>: QSB.CastleStore:Add</p></p><p>-- @param _Good [number] Watentyp</p><p>-- @param _Amount [number] Menge</p><p>-- @return self</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");</p><p>    for i= 1, _Amount, 1 do</p><p>        if self:GetLimit() > self:GetTotalAmount() then</p><p>            self.Data.Goods[_Good][1] = self.Data.Goods[_Good][1] + 1;</p><p>        end</p><p>    end</p><p>    Logic.ExecuteInLuaLocalState([[</p><p>        QSB.CastleStore:SetAmount(</p><p>            ]] ..self.Data.PlayerID.. [[, ]] .._Good.. [[, ]] ..self.Data.Goods[_Good][1].. [[</p><p>        )</p><p>    ]]);</p><p>    return self;</p><p>-- Entfernt eine Menge an Waren aus dem Burglager ohne sie ins</p><p>-- Lagerhaus zu legen.</p><p>-- <p><b>Alias</b>: QSB.CastleStore:Remove</p></p><p>-- @param _Good [number] Watentyp</p><p>-- @param _Amount [number] Menge</p><p>-- @return self</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");</p><p>    if self:GetAmount(_Good) > 0 then</p><p>        local ToRemove = (_Amount <= self:GetAmount(_Good) and _Amount) or self:GetAmount(_Good);</p><p>        self.Data.Goods[_Good][1] = self.Data.Goods[_Good][1] - ToRemove;</p><p>        Logic.ExecuteInLuaLocalState([[</p><p>            QSB.CastleStore:SetAmount(</p><p>                ]] ..self.Data.PlayerID.. [[, ]] .._Good.. [[, ]] ..self.Data.Goods[_Good][1].. [[</p><p>            )</p><p>        ]]);</p><p>    end</p><p>    return self;</p><p>-- Aktualisiert die Waren im Lager und im Burglager.</p><p>-- <p><b>Alias</b>: QSB.CastleStore.UpdateStores</p></p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self == nil, "This method is only procedural!");</p><p>    for k, v in pairs(AddOnCastleStore.Global.Data.CastleStoreObjects) do</p><p>        if v ~= nil then</p><p>            local Level = Logic.GetUpgradeLevel(Logic.GetHeadquarters(v.Data.PlayerID));</p><p>            for kk, vv in pairs(v.Data.Goods) do</p><p>                if vv ~= nil then</p><p>                    -- Ware wird angenommen</p><p>                    if vv[2] == true then</p><p>                        local AmountInStore  = GetPlayerResources(kk, v.Data.PlayerID)</p><p>                        local AmountInCastle = v:GetAmount(kk)</p><p>                        -- Auslagern, wenn möglich</p><p>                        if AmountInStore < (v.Data.Goods[kk][4] * (Level+1)) then</p><p>                            if vv[3] == false then</p><p>                                local Amount = (v.Data.Goods[kk][4] * (Level+1)) - AmountInStore;</p><p>                                Amount = (Amount > 10 and 10) or Amount;</p><p>                                for i= 1, Amount, 1 do</p><p>                                    v:Outsource(kk, 1);</p><p>                                end</p><p>                            end</p><p>                        -- Einlagern, falls möglich</p><p>                        else</p><p>                            local Amount = (AmountInStore > 10 and 10) or AmountInStore;</p><p>                            for i= 1, Amount, 1 do</p><p>                                v:Store(kk, 1);</p><p>                            end</p><p>                        end</p><p>                    -- Ware ist gebannt</p><p>                    else</p><p>                        local Amount = (v:GetAmount(kk) >= 10 and 10) or v:GetAmount(kk);</p><p>                        for i= 1, Amount, 1 do</p><p>                            v:Outsource(kk, 1);</p><p>                        end</p><p>                    end</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>-- Wirt ausgeführt, nachdem ein Spielstand geladen wurde. Diese Funktion Stellt</p><p>-- alle nicht persistenten Änderungen wieder her.</p><p>-- @within Internal</p><p>-- @local</p><p>    API.Bridge("AddOnCastleStore.Local:OverwriteGetStringTableText()")</p><p>    API.Bridge("AddOnCastleStore.Local.CastleStore:ActivateHotkeys()")</p><p>-- Überschreibt die globalen Spielfunktionen, die mit dem Burglager in</p><p>-- Konfilckt stehen.</p><p>-- @within Internal</p><p>-- @local</p><p>    QuestTemplate.IsObjectiveCompleted_Orig_QSB_CastleStore = QuestTemplate.IsObjectiveCompleted;</p><p>    QuestTemplate.IsObjectiveCompleted = function(self, objective)</p><p>        local objectiveType = objective.Type;</p><p>        local data = objective.Data;</p><p>        if objective.Completed ~= nil then</p><p>            return objective.Completed;</p><p>        end</p><p>        if objectiveType == Objective.Produce then</p><p>            local GoodAmount = GetPlayerGoodsInSettlement(data[1], self.ReceivingPlayer, true);</p><p>            local CastleStore = QSB.CastleStore:GetInstance(self.ReceivingPlayer);</p><p>            if CastleStore and Logic.GetGoodCategoryForGoodType(data[1]) == GoodCategories.GC_Resource then</p><p>                GoodAmount = GoodAmount + CastleStore:GetAmount(data[1]);</p><p>            end</p><p>            if (not data[3] and GoodAmount >= data[2]) or (data[3] and GoodAmount < data[2]) then</p><p>                objective.Completed = true;</p><p>            end</p><p>        else</p><p>            return QuestTemplate.IsObjectiveCompleted_Orig_QSB_CastleStore(self, objective);</p><p>        end</p><p>    end</p><p>    QuestTemplate.SendGoods = function(self)</p><p>        for i=1, self.Objectives[0] do</p><p>            if self.Objectives[i].Type == Objective.Deliver then</p><p>                if self.Objectives[i].Data[3] == nil then</p><p>                    local goodType = self.Objectives[i].Data[1]</p><p>                    local goodQuantity = self.Objectives[i].Data[2]</p><p>                    local amount = QSB.CastleStore:GetGoodAmountWithCastleStore(goodType, self.ReceivingPlayer, true);</p><p>                    if amount >= goodQuantity then</p><p>                        local Sender = self.ReceivingPlayer</p><p>                        local Target = self.Objectives[i].Data[6] and self.Objectives[i].Data[6] or self.SendingPlayer</p><p>                        local expectedMerchant = {}</p><p>                        expectedMerchant.Good = goodType</p><p>                        expectedMerchant.Amount = goodQuantity</p><p>                        expectedMerchant.PlayerID = Target</p><p>                        expectedMerchant.ID = nil</p><p>                        self.Objectives[i].Data[5] = expectedMerchant</p><p>                        self.Objectives[i].Data[3] = 1</p><p>                        QuestMerchants[#QuestMerchants+1] = expectedMerchant</p><p>                        if goodType == Goods.G_Gold then</p><p>                            local BuildingID = Logic.GetHeadquarters(Sender)</p><p>                            if BuildingID == 0 then</p><p>                                BuildingID = Logic.GetStoreHouse(Sender)</p><p>                            end</p><p>                            self.Objectives[i].Data[3] = Logic.CreateEntityAtBuilding(Entities.U_GoldCart, BuildingID, 0, Target)</p><p>                            Logic.HireMerchant(self.Objectives[i].Data[3], Target, goodType, goodQuantity, self.ReceivingPlayer)</p><p>                            Logic.RemoveGoodFromStock(BuildingID,goodType,goodQuantity)</p><p>                            if MapCallback_DeliverCartSpawned then</p><p>                                MapCallback_DeliverCartSpawned( self, self.Objectives[i].Data[3], goodType )</p><p>                            end</p><p>                        elseif goodType == Goods.G_Water then</p><p>                            local BuildingID = Logic.GetMarketplace(Sender)</p><p>                            self.Objectives[i].Data[3] = Logic.CreateEntityAtBuilding(Entities.U_Marketer, BuildingID, 0, Target)</p><p>                            Logic.HireMerchant(self.Objectives[i].Data[3], Target, goodType, goodQuantity, self.ReceivingPlayer)</p><p>                            Logic.RemoveGoodFromStock(BuildingID,goodType,goodQuantity)</p><p>                            if MapCallback_DeliverCartSpawned then</p><p>                                MapCallback_DeliverCartSpawned( self, self.Objectives[i].Data[3], goodType )</p><p>                            end</p><p>                        else</p><p>                            if Logic.GetGoodCategoryForGoodType(goodType) == GoodCategories.GC_Resource then</p><p>                                local StorehouseID = Logic.GetStoreHouse(Target)</p><p>                                local NumberOfGoodTypes = Logic.GetNumberOfGoodTypesOnOutStock(StorehouseID)</p><p>                                if NumberOfGoodTypes ~= nil then</p><p>                                    for j = 0, NumberOfGoodTypes-1 do</p><p>                                        local StoreHouseGoodType = Logic.GetGoodTypeOnOutStockByIndex(StorehouseID,j)</p><p>                                        local Amount = Logic.GetAmountOnOutStockByIndex(StorehouseID, j)</p><p>                                        if Amount >= goodQuantity then</p><p>                                            Logic.RemoveGoodFromStock(StorehouseID, StoreHouseGoodType, goodQuantity, false)</p><p>                                        end</p><p>                                    end</p><p>                                end</p><p>                                local SenderStorehouse = Logic.GetStoreHouse(Sender);</p><p>                                local AmountInStorehouse = GetPlayerResources(goodType, Sender);</p><p>                                if AmountInStorehouse < goodQuantity then</p><p>                                    -- Entferne aus Lager</p><p>                                    local AmountDifference = goodQuantity - AmountInStorehouse;</p><p>                                    AddGood(goodType, AmountInStorehouse * (-1), Sender);</p><p>                                    -- Entferne aus Burg</p><p>                                    local StoreInstance = QSB.CastleStore:GetInstance(self.ReceivingPlayer);</p><p>                                    if StoreInstance then</p><p>                                        StoreInstance:Remove(goodType, AmountDifference);</p><p>                                    end</p><p>                                else</p><p>                                    -- Entferne aus Lager</p><p>                                    AddGood(goodType, goodQuantity * (-1), Sender);</p><p>                                end</p><p>                                self.Objectives[i].Data[3] = Logic.CreateEntityAtBuilding(Entities.U_ResourceMerchant, SenderStorehouse, 0, Target);</p><p>                                Logic.HireMerchant(self.Objectives[i].Data[3], Target, goodType, goodQuantity, self.ReceivingPlayer);</p><p>                            else</p><p>                                Logic.StartTradeGoodGathering(Sender, Target, goodType, goodQuantity, 0)</p><p>                            end</p><p>                        end</p><p>                    end</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>-- Local Script ----------------------------------------------------------------</p><p>-- Initalisiert das Bundle im lokalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    QSB.CastleStore = self.CastleStore;</p><p>    self:OverwriteGameFunctions();</p><p>    self:OverwriteGetStringTableText();</p><p>    self:OverwriteInteractiveObject();</p><p>-- Erzeugt eine neue lokale Referenz zum Burglager des Spielers.</p><p>-- <p><b>Alias</b>: QSB.CastleStore:CreateStore</p></p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");</p><p>    local Store = {</p><p>        StoreMode = 1,</p><p>        CapacityBase = 75,</p><p>        Goods = {</p><p>            [Goods.G_Wood]      = {0, true, false, 35},</p><p>            [Goods.G_Stone]     = {0, true, false, 35},</p><p>            [Goods.G_Iron]      = {0, true, false, 35},</p><p>            [Goods.G_Carcass]   = {0, true, false, 15},</p><p>            [Goods.G_Grain]     = {0, true, false, 15},</p><p>            [Goods.G_RawFish]   = {0, true, false, 15},</p><p>            [Goods.G_Milk]      = {0, true, false, 15},</p><p>            [Goods.G_Herb]      = {0, true, false, 15},</p><p>            [Goods.G_Wool]      = {0, true, false, 15},</p><p>            [Goods.G_Honeycomb] = {0, true, false, 15},</p><p>        }</p><p>    }</p><p>    self.Data[_PlayerID] = Store;</p><p>    </p><p>    self:ActivateHotkeys();</p><p>    self:DescribeHotkeys();</p><p>-- Entfernt eine lokale Referenz auf ein Burglager des Spielers.</p><p>-- <p><b>Alias</b>: QSB.CastleStore:DeleteStore</p></p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");</p><p>    self.Data[_PlayerID] = nil;</p><p>-- Gibt die Menge an Waren des Typs zurück.</p><p>-- <p><b>Alias</b>: QSB.CastleStore:GetAmount</p></p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @param _Good [number] Warentyp</p><p>-- @return [number] Menge an Waren</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");</p><p>    if not self:HasCastleStore(_PlayerID) then</p><p>        return 0;</p><p>    end</p><p>    return self.Data[_PlayerID].Goods[_Good][1];</p><p>-- Gibt die Menge an Waren des Spielers zurück, eingeschlossen</p><p>-- der Waren im Burglager. Hat der Spieler kein Burglager, wird</p><p>-- nur die Menge im Lagerhaus zurückgegeben.</p><p>-- <p><b>Alias</b>: QSB.CastleStore:GetGoodAmountWithCastleStore</p></p><p>-- @param _Good [number] Warentyp</p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @return [number] Menge an Waren</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");</p><p>    local Amount = GetPlayerGoodsInSettlement(_Good, _PlayerID, true);</p><p>    if self:HasCastleStore(_PlayerID) then</p><p>        if _Good ~= Goods.G_Gold and Logic.GetGoodCategoryForGoodType(_Good) == GoodCategories.GC_Resource then</p><p>            Amount = Amount + self:GetAmount(_PlayerID, _Good);</p><p>        end</p><p>    end</p><p>    return Amount;</p><p>-- Gibt die Gesamtmenge aller Waren im Burglager zurück.</p><p>-- <p><b>Alias</b>: QSB.CastleStore:GetTotalAmount</p></p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @return [number] Absolute Menge im Burglager</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");</p><p>    if not self:HasCastleStore(_PlayerID) then</p><p>        return 0;</p><p>    end</p><p>    local TotalAmount = 0;</p><p>    for k, v in pairs(self.Data[_PlayerID].Goods) do</p><p>        TotalAmount = TotalAmount + v[1];</p><p>    end</p><p>    return TotalAmount;</p><p>-- Ändert die Menge an Waren des Typs.</p><p>-- <p><b>Alias</b>: QSB.CastleStore:SetAmount</p></p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @param _Good [number] Warentyp</p><p>-- @param _Amount [number] Warenmenge</p><p>-- @return self</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");</p><p>    if not self:HasCastleStore(_PlayerID) then</p><p>        return;</p><p>    end</p><p>    self.Data[_PlayerID].Goods[_Good][1] = _Amount;</p><p>    return self;</p><p>-- Gibt zurück, ob die Ware des Typs akzeptiert wird.</p><p>-- <p><b>Alias</b>: QSB.CastleStore:IsAccepted</p></p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @param _Good [number] Warentyp</p><p>-- @return [boolean] Ware wird angenommen</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");</p><p>    if not self:HasCastleStore(_PlayerID) then</p><p>        return false;</p><p>    end</p><p>    if not self.Data[_PlayerID].Goods[_Good] then</p><p>        return false;</p><p>    end</p><p>    return self.Data[_PlayerID].Goods[_Good][2] == true;</p><p>-- Setzt eine Ware als akzeptiert.</p><p>-- <p><b>Alias</b>: QSB.CastleStore:SetAccepted</p></p><p>-- @param _PlayerIDvID des Spielers</p><p>-- @param _Good [number] Warentyp</p><p>-- @param _Flag [boolean] Akzeptanz-Flag</p><p>-- @return self</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");</p><p>    if self:HasCastleStore(_PlayerID) then</p><p>        if self.Data[_PlayerID].Goods[_Good] then</p><p>            self.Data[_PlayerID].Goods[_Good][2] = _Flag == true;</p><p>        end</p><p>    end</p><p>    return self;</p><p>-- Gibt zurück, ob die Ware des Typs gesperrt ist.</p><p>-- <p><b>Alias</b>: QSB.CastleStore:IsLocked</p></p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @param _Good [number] Warentyp</p><p>-- @return [boolean] Ware ist gesperrt</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");</p><p>    if not self:HasCastleStore(_PlayerID) then</p><p>        return true;</p><p>    end</p><p>    if not self.Data[_PlayerID].Goods[_Good] then</p><p>        return false;</p><p>    end</p><p>    return self.Data[_PlayerID].Goods[_Good][3] == true;</p><p>-- Setzt eine Ware als gesperrt.</p><p>-- <p><b>Alias</b>: QSB.CastleStore:SetLocked</p></p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @param _Good [number] Warentyp</p><p>-- @param _Flag [boolean] Akzeptanz-Flag</p><p>-- @return self</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");</p><p>    if self:HasCastleStore(_PlayerID) then</p><p>        if self.Data[_PlayerID].Goods[_Good] then</p><p>            self.Data[_PlayerID].Goods[_Good][3] = _Flag == true;</p><p>        end</p><p>    end</p><p>    return self;</p><p>-- Gibt zurück, ob der Spieler ein Burglager hat.</p><p>-- <p><b>Alias</b>: QSB.CastleStore:HasCastleStore</p></p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @return [boolean] Spieler hat ein Burglager</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");</p><p>    return self.Data[_PlayerID] ~= nil;</p><p>-- Gibt die Referenz des Burglagers des Spielers zurück.</p><p>-- <p><b>Alias</b>: QSB.CastleStore:GetStore</p></p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @return [table] Instanz des Burglagers</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");</p><p>    return self.Data[_PlayerID];</p><p>-- Gibt das aktuelle Lagerlimit des Burglagers zurück.</p><p>-- <p><b>Alias</b>: QSB.CastleStore:GetLimit</p></p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");</p><p>    local Level = 0;</p><p>    local Headquarters = Logic.GetHeadquarters(_PlayerID);</p><p>    if Headquarters ~= 0 then</p><p>        Level = Logic.GetUpgradeLevel(Headquarters);</p><p>    end</p><p>    local Capacity = self.Data[_PlayerID].CapacityBase;</p><p>    for i= 1, (Level+1), 1 do</p><p>        Capacity = Capacity * 2;</p><p>    end</p><p>    return Capacity;</p><p>-- "Waren einlagern" wurde geklickt.</p><p>-- <p><b>Alias</b>: QSB.CastleStore:OnStorehouseTabClicked</p></p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");</p><p>    self.Data[_PlayerID].StoreMode = 1;</p><p>    self:UpdateBehaviorTabs(_PlayerID);</p><p>    GUI.SendScriptCommand([[</p><p>        local Store = QSB.CastleStore:GetInstance(]] .._PlayerID.. [[);</p><p>        for k, v in pairs(Store.Data.Goods) do</p><p>            Store:SetGoodAccepted(k, true);</p><p>            Store:SetGoodLocked(k, false);</p><p>        end</p><p>    ]]);</p><p>-- "Waren verwahren" wurde gedrückt.</p><p>-- <p><b>Alias</b>: QSB.CastleStore:OnCityTabClicked</p></p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");</p><p>    self.Data[_PlayerID].StoreMode = 2;</p><p>    self:UpdateBehaviorTabs(_PlayerID);</p><p>    GUI.SendScriptCommand([[</p><p>        local Store = QSB.CastleStore:GetInstance(]] .._PlayerID.. [[);</p><p>        for k, v in pairs(Store.Data.Goods) do</p><p>            Store:SetGoodAccepted(k, true);</p><p>            Store:SetGoodLocked(k, true);</p><p>        end</p><p>    ]]);</p><p>-- "Lager räumen" wurde gedrückt.</p><p>-- <p><b>Alias</b>: QSB.CastleStore:OnMultiTabClicked</p></p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");</p><p>    self.Data[_PlayerID].StoreMode = 3;</p><p>    self:UpdateBehaviorTabs(_PlayerID);</p><p>    GUI.SendScriptCommand([[</p><p>        local Store = QSB.CastleStore:GetInstance(]] .._PlayerID.. [[);</p><p>        for k, v in pairs(Store.Data.Goods) do</p><p>            Store:SetGoodLocked(k, false);</p><p>            Store:SetGoodAccepted(k, false);</p><p>        end</p><p>    ]]);</p><p>-- Ein GoodType-Button wurde geklickt.</p><p>-- <p><b>Alias</b>: QSB.CastleStore:GoodClicked</p></p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @param _GoodType [number] Warentyp</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");</p><p>    if self:HasCastleStore(_PlayerID) then</p><p>        local CurrentWirgetID = XGUIEng.GetCurrentWidgetID();</p><p>        GUI.SendScriptCommand([[</p><p>            local Store = QSB.CastleStore:GetInstance(]] .._PlayerID.. [[);</p><p>            local Accepted = Store:IsGoodAccepted(]] .._GoodType.. [[)</p><p>            local Locked   = Store:IsGoodLocked(]] .._GoodType.. [[)</p><p>            </p><p>            if Accepted and not Locked then</p><p>                Store:SetGoodLocked(]] .._GoodType.. [[, true);</p><p>                Store:SetGoodAccepted(]] .._GoodType.. [[, true);</p><p>            elseif Accepted and Locked then</p><p>                Store:SetGoodLocked(]] .._GoodType.. [[, false);</p><p>                Store:SetGoodAccepted(]] .._GoodType.. [[, false);</p><p>            elseif not Accepted and not Locked then</p><p>                Store:SetGoodAccepted(]] .._GoodType.. [[, true);</p><p>            else</p><p>                Store:SetGoodLocked(]] .._GoodType.. [[, false);</p><p>                Store:SetGoodAccepted(]] .._GoodType.. [[, true);</p><p>            end</p><p>        ]]);</p><p>    end</p><p>-- Der Spieler wechselt zwischen den Ansichten in der Burg.</p><p>-- <p><b>Alias</b>: QSB.CastleStore:DestroyGoodsClicked</p></p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");</p><p>    if self:HasCastleStore(_PlayerID) then</p><p>        QSB.CastleStore.ToggleStore();</p><p>    end</p><p>-- Aktualisiert das Burgmenü, sobald sich die Selektion ändert.</p><p>-- <p><b>Alias</b>: QSB.CastleStore:SelectionChanged</p></p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");</p><p>    if self:HasCastleStore(_PlayerID) then</p><p>        local SelectedID = GUI.GetSelectedEntity();</p><p>        if Logic.GetHeadquarters(_PlayerID) == SelectedID then</p><p>            self:ShowCastleMenu();</p><p>        else</p><p>            self:RestoreStorehouseMenu();</p><p>        end</p><p>    end</p><p>-- Aktualisiert die Burglager-Tabs.</p><p>-- <p><b>Alias</b>: QSB.CastleStore:UpdateBehaviorTabs</p></p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");</p><p>    if not QSB.CastleStore:HasCastleStore(GUI.GetPlayerID()) then</p><p>        return;</p><p>    end</p><p>    XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/TabButtons", 0);</p><p>    if self.Data[_PlayerID].StoreMode == 1 then</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/TabButtons/StorehouseTabButtonUp", 1);</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/TabButtons/CityTabButtonDown", 1);</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/TabButtons/Tab03Down", 1);</p><p>    elseif self.Data[_PlayerID].StoreMode == 2 then</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/TabButtons/StorehouseTabButtonDown", 1);</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/TabButtons/CityTabButtonUp", 1);</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/TabButtons/Tab03Down", 1);</p><p>    else</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/TabButtons/StorehouseTabButtonDown", 1);</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/TabButtons/CityTabButtonDown", 1);</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/TabButtons/Tab03Up", 1);</p><p>    end</p><p>-- Aktualisiert die Mengenanzeige der Waren im Burglager.</p><p>-- <p><b>Alias</b>: QSB.CastleStore:UpdateGoodsDisplay</p></p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");</p><p>    if not self:HasCastleStore(_PlayerID) then</p><p>        return;</p><p>    end</p><p>    local MotherContainer  = "/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/InStorehouse/Goods";</p><p>    local WarningColor = "";</p><p>    if self:GetLimit(_PlayerID) == self:GetTotalAmount(_PlayerID) then</p><p>        WarningColor = "{@color:255,32,32,255}";</p><p>    end</p><p>    for k, v in pairs(self.Data[_PlayerID].Goods) do</p><p>        local GoodTypeName = Logic.GetGoodTypeName(k);</p><p>        local AmountWidget = MotherContainer.. "/" ..GoodTypeName.. "/Amount";</p><p>        local ButtonWidget = MotherContainer.. "/" ..GoodTypeName.. "/Button";</p><p>        local BGWidget = MotherContainer.. "/" ..GoodTypeName.. "/BG";</p><p>        XGUIEng.SetText(AmountWidget, "{center}" .. WarningColor .. v[1]);</p><p>        XGUIEng.DisableButton(ButtonWidget, 0)</p><p>        -- Ware ist gesperrt</p><p>        if self:IsAccepted(_PlayerID, k) and self:IsLocked(_PlayerID, k) then</p><p>            XGUIEng.SetMaterialColor(ButtonWidget, 0, 230, 180, 120, 255);</p><p>            XGUIEng.SetMaterialColor(ButtonWidget, 1, 230, 180, 120, 255);</p><p>            XGUIEng.SetMaterialColor(ButtonWidget, 7, 230, 180, 120, 255);</p><p>        -- Ware wird nicht angenommen</p><p>        elseif not self:IsAccepted(_PlayerID, k) and not self:IsLocked(_PlayerID, k) then</p><p>            XGUIEng.SetMaterialColor(ButtonWidget, 0, 190, 90, 90, 255);</p><p>            XGUIEng.SetMaterialColor(ButtonWidget, 1, 190, 90, 90, 255);</p><p>            XGUIEng.SetMaterialColor(ButtonWidget, 7, 190, 90, 90, 255);</p><p>        -- Ware wird eingelagert</p><p>        else</p><p>            XGUIEng.SetMaterialColor(ButtonWidget, 0, 255, 255, 255, 255);</p><p>            XGUIEng.SetMaterialColor(ButtonWidget, 1, 255, 255, 255, 255);</p><p>            XGUIEng.SetMaterialColor(ButtonWidget, 7, 255, 255, 255, 255);</p><p>        end</p><p>    end</p><p>-- Aktualisiert die Lagerauslastungsanzeige des Burglagers.</p><p>-- <p><b>Alias</b>: QSB.CastleStore:UpdateStorageLimit</p></p><p>-- @param _PlayerID [number] ID des Spielers</p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");</p><p>    if not self:HasCastleStore(_PlayerID) then</p><p>        return;</p><p>    end</p><p>    local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();</p><p>    local PlayerID = GUI.GetPlayerID();</p><p>    local StorageUsed = QSB.CastleStore:GetTotalAmount(PlayerID);</p><p>    local StorageLimit = QSB.CastleStore:GetLimit(PlayerID);</p><p>    local StorageLimitText = XGUIEng.GetStringTableText("UI_Texts/StorageLimit_colon");</p><p>    local Text = "{center}" ..StorageLimitText.. " " ..StorageUsed.. "/" ..StorageLimit;</p><p>    XGUIEng.SetText(CurrentWidgetID, Text);</p><p>-- Wechselt zwischen der Finanzansicht und dem Burglager.</p><p>-- <p><b>Alias</b>: QSB.CastleStore:ToggleStore</p></p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    assert(self == nil, "This function is procedural!");</p><p>    if QSB.CastleStore:HasCastleStore(GUI.GetPlayerID()) then</p><p>        if Logic.GetHeadquarters(GUI.GetPlayerID()) == GUI.GetSelectedEntity() then</p><p>            if XGUIEng.IsWidgetShown("/InGame/Root/Normal/AlignBottomRight/Selection/Castle") == 1 then</p><p>                QSB.CastleStore.ShowCastleStoreMenu(QSB.CastleStore);</p><p>            else</p><p>                QSB.CastleStore.ShowCastleMenu(QSB.CastleStore);</p><p>            end</p><p>        end</p><p>    end</p><p>-- Stellt das normale Lagerhausmenü wieder her.</p><p>-- <p><b>Alias</b>: QSB.CastleStore:RestoreStorehouseMenu</p></p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/TabButtons", 1);</p><p>    XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/InCity/Goods", 1);</p><p>    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/InCity", 0);</p><p>    SetIcon("/InGame/Root/Normal/AlignBottomRight/DialogButtons/PlayerButtons/DestroyGoods", {16, 8});</p><p>    local MotherPath = "/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/TabButtons/";</p><p>    SetIcon(MotherPath.. "StorehouseTabButtonUp/up/B_StoreHouse", {3, 13});</p><p>    SetIcon(MotherPath.. "StorehouseTabButtonDown/down/B_StoreHouse", {3, 13});</p><p>    SetIcon(MotherPath.. "CityTabButtonUp/up/CityBuildingsNumber", {8, 1});</p><p>    SetIcon(MotherPath.. "TabButtons/CityTabButtonDown/down/CityBuildingsNumber", {8, 1});</p><p>    SetIcon(MotherPath.. "TabButtons/Tab03Up/up/B_Castle_ME", {3, 14});</p><p>    SetIcon(MotherPath.. "Tab03Down/down/B_Castle_ME", {3, 14});</p><p>    for k, v in ipairs {"G_Carcass", "G_Grain", "G_Milk", "G_RawFish", "G_Iron","G_Wood", "G_Stone", "G_Honeycomb", "G_Herb", "G_Wool"} do</p><p>        local MotherPath = "/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/InStorehouse/Goods/";</p><p>        XGUIEng.SetMaterialColor(MotherPath.. v.. "/Button", 0, 255, 255, 255, 255);</p><p>        XGUIEng.SetMaterialColor(MotherPath.. v.. "/Button", 1, 255, 255, 255, 255);</p><p>        XGUIEng.SetMaterialColor(MotherPath.. v.. "/Button", 7, 255, 255, 255, 255);</p><p>    end</p><p>-- Das normale Burgmenü wird angezeigt.</p><p>-- <p><b>Alias</b>: QSB.CastleStore:ShowCastleMenu</p></p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    local MotherPath = "/InGame/Root/Normal/AlignBottomRight/";</p><p>    XGUIEng.ShowWidget(MotherPath.. "Selection/BGBig", 0)</p><p>    XGUIEng.ShowWidget(MotherPath.. "Selection/Storehouse", 0)</p><p>    XGUIEng.ShowWidget(MotherPath.. "Selection/BGSmall", 1)</p><p>    XGUIEng.ShowWidget(MotherPath.. "Selection/Castle", 1)</p><p>    if g_HideSoldierPayment ~= nil then</p><p>        XGUIEng.ShowWidget(MotherPath.. "Selection/Castle/Treasury/Payment", 0)</p><p>        XGUIEng.ShowWidget(MotherPath.. "Selection/Castle/LimitSoldiers", 0)</p><p>    end</p><p>    GUI_BuildingInfo.PaymentLevelSliderUpdate()</p><p>    GUI_BuildingInfo.TaxationLevelSliderUpdate()</p><p>    GUI_Trade.StorehouseSelected()</p><p>    local AnchorInfoForSmallX, AnchorInfoForSmallY = XGUIEng.GetWidgetLocalPosition(MotherPath.. "Selection/AnchorInfoForSmall")</p><p>    XGUIEng.SetWidgetLocalPosition(MotherPath.. "Selection/Info", AnchorInfoForSmallX, AnchorInfoForSmallY)</p><p>    XGUIEng.ShowWidget(MotherPath.. "DialogButtons/PlayerButtons", 1)</p><p>    XGUIEng.ShowWidget(MotherPath.. "DialogButtons/PlayerButtons/DestroyGoods", 1)</p><p>    XGUIEng.DisableButton(MotherPath.. "DialogButtons/PlayerButtons/DestroyGoods", 0)</p><p>    SetIcon(MotherPath.. "DialogButtons/PlayerButtons/DestroyGoods", {10, 9})</p><p>-- Das Burglager wird angezeigt.</p><p>-- <p><b>Alias</b>: QSB.CastleStore:ShowCastleStoreMenu</p></p><p>-- @within QSB.CastleStore</p><p>-- @local</p><p>    local MotherPath = "/InGame/Root/Normal/AlignBottomRight/";</p><p>    XGUIEng.ShowWidget(MotherPath.. "Selection/Selection/BGSmall", 0);</p><p>    XGUIEng.ShowWidget(MotherPath.. "Selection/Castle", 0);</p><p>    XGUIEng.ShowWidget(MotherPath.. "Selection/BGSmall", 0);</p><p>    XGUIEng.ShowWidget(MotherPath.. "Selection/BGBig", 1);</p><p>    XGUIEng.ShowWidget(MotherPath.. "Selection/Storehouse", 1);</p><p>    XGUIEng.ShowWidget(MotherPath.. "Selection/Storehouse/AmountContainer", 0);</p><p>    XGUIEng.ShowAllSubWidgets(MotherPath.. "Selection/Storehouse/TabButtons", 1);</p><p>    GUI_Trade.StorehouseSelected()</p><p>    local AnchorInfoForBigX, AnchorInfoForBigY = XGUIEng.GetWidgetLocalPosition(MotherPath.. "Selection/AnchorInfoForBig")</p><p>    XGUIEng.SetWidgetLocalPosition(MotherPath.. "Selection/Info", AnchorInfoForBigX, AnchorInfoForBigY)</p><p>    XGUIEng.ShowWidget(MotherPath.. "DialogButtons/PlayerButtons", 1)</p><p>    XGUIEng.ShowWidget(MotherPath.. "DialogButtons/PlayerButtons/DestroyGoods", 1)</p><p>    XGUIEng.ShowWidget(MotherPath.. "Selection/Storehouse/InStorehouse", 1)</p><p>    XGUIEng.ShowWidget(MotherPath.. "Selection/Storehouse/InMulti", 0)</p><p>    XGUIEng.ShowWidget(MotherPath.. "Selection/Storehouse/InCity", 1)</p><p>    XGUIEng.ShowAllSubWidgets(MotherPath.. "Selection/Storehouse/InCity/Goods", 0);</p><p>    XGUIEng.ShowWidget(MotherPath.. "Selection/Storehouse/InCity/Goods/G_Beer", 1)</p><p>    XGUIEng.DisableButton(MotherPath.. "DialogButtons/PlayerButtons/DestroyGoods", 0)</p><p>    local MotherPathDialog = MotherPath.. "DialogButtons/PlayerButtons/";</p><p>    local MotherPathTabs = MotherPath.. "Selection/Storehouse/TabButtons/";</p><p>    SetIcon(MotherPathDialog.. "DestroyGoods", {3, 14});</p><p>    SetIcon(MotherPathTabs.. "StorehouseTabButtonUp/up/B_StoreHouse", {10, 9});</p><p>    SetIcon(MotherPathTabs.. "StorehouseTabButtonDown/down/B_StoreHouse", {10, 9});</p><p>    SetIcon(MotherPathTabs.. "CityTabButtonUp/up/CityBuildingsNumber", {15, 6});</p><p>    SetIcon(MotherPathTabs.. "CityTabButtonDown/down/CityBuildingsNumber", {15, 6});</p><p>    SetIcon(MotherPathTabs.. "Tab03Up/up/B_Castle_ME", {7, 1});</p><p>    SetIcon(MotherPathTabs.. "Tab03Down/down/B_Castle_ME", {7, 1});</p><p>    self:UpdateBehaviorTabs(GUI.GetPlayerID());</p><p>-- Überschreibt den Bezahlvorgang der Kosten eines interaktiven Objektes.</p><p>-- @within Internal</p><p>-- @local</p><p>    function BundleInteractiveObjects.Local:CanBeBought(_PlayerID, _Good, _Amount)</p><p>        local AmountOfGoods = GetPlayerGoodsInSettlement(_Good, _PlayerID, true);</p><p>        if AddOnCastleStore.Local.CastleStore:HasCastleStore(_PlayerID) then</p><p>            if Logic.GetGoodCategoryForGoodType(_Good) == GoodCategories.GC_Resource and _Good ~= Goods.G_Gold then</p><p>                local AmountInCastle = AddOnCastleStore.Local.CastleStore:GetAmount(_PlayerID, _Good);</p><p>                AmountOfGoods = AmountOfGoods + AmountInCastle;</p><p>            end</p><p>        end</p><p>        if AmountOfGoods < _Amount then</p><p>            return false;</p><p>        end</p><p>        return true;</p><p>    end</p><p>    function BundleInteractiveObjects.Local:BuyObject(_PlayerID, _Good, _Amount)</p><p>        if Logic.GetGoodCategoryForGoodType(_Good) ~= GoodCategories.GC_Resource and _Good ~= Goods.G_Gold then</p><p>            local buildings = GetPlayerEntities(_PlayerID,0);</p><p>            local goodAmount = _Amount;</p><p>            for i=1,#buildings do</p><p>                if Logic.IsBuilding(buildings[i]) == 1 and goodAmount > 0 then</p><p>                    if Logic.GetBuildingProduct(buildings[i]) == _Good then</p><p>                        local goodAmountInBuilding = Logic.GetAmountOnOutStockByIndex(buildings[i],0);</p><p>                        for j=1,goodAmountInBuilding do</p><p>                            API.Bridge("Logic.RemoveGoodFromStock("..buildings[i]..",".._Good..",1)");</p><p>                            goodAmount = goodAmount -1;</p><p>                        end</p><p>                    end</p><p>                end</p><p>            end</p><p>        else</p><p>            local AmountInStore = GetPlayerGoodsInSettlement(_Good, _PlayerID, true);</p><p>            local GoodsToRemove = ((AmountInStore - _Amount) >= 0 and _Amount) or AmountInStore;</p><p>            API.Bridge("AddGood(".._Good..", "..(GoodsToRemove*(-1))..", ".._PlayerID..")");</p><p>            if AddOnCastleStore.Local.CastleStore:HasCastleStore(_PlayerID) then</p><p>                _Amount = _Amount - GoodsToRemove;</p><p>                if _Amount > 0 then</p><p>                    API.Bridge("QSB.CastleStore:GetInstance(" .._PlayerID.. "):Remove(" .._Good.. ", " .._Amount.. ")");</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>-- Hotkey-Callback für den Modus "Waren einlagern".</p><p>-- @within Internal</p><p>-- @local</p><p>    local PlayerID = GUI.GetPlayerID();</p><p>    if AddOnCastleStore.Local.CastleStore:HasCastleStore(PlayerID) == false then </p><p>        return;</p><p>    end</p><p>    AddOnCastleStore.Local.CastleStore:OnStorehouseTabClicked(PlayerID);</p><p>-- Hotkey-Callback für den Modus "Waren sperren".</p><p>-- @within Internal</p><p>-- @local</p><p>    local PlayerID = GUI.GetPlayerID();</p><p>    if AddOnCastleStore.Local.CastleStore:HasCastleStore(PlayerID) == false then </p><p>        return;</p><p>    end</p><p>    AddOnCastleStore.Local.CastleStore:OnCityTabClicked(PlayerID);</p><p>-- Hotkey-Callback für den Modus "Lager räumen".</p><p>-- @within Internal</p><p>-- @local</p><p>    local PlayerID = GUI.GetPlayerID();</p><p>    if AddOnCastleStore.Local.CastleStore:HasCastleStore(PlayerID) == false then </p><p>        return;</p><p>    end</p><p>    AddOnCastleStore.Local.CastleStore:OnMultiTabClicked(PlayerID);</p><p>-- Versieht die Hotkeys des Burglagers mit ihren Funktionen.</p><p>-- @within Internal</p><p>-- @local</p><p>    -- Waren einlagern</p><p>    Input.KeyBindDown(</p><p>        Keys.ModifierShift + Keys.B,</p><p>        "AddOnCastleStore.Local.CastleStore:HotkeyStoreGoods()",</p><p>        2,</p><p>        false</p><p>    );</p><p>    -- Waren verwahren</p><p>    Input.KeyBindDown(</p><p>        Keys.ModifierShift + Keys.N,</p><p>        "AddOnCastleStore.Local.CastleStore:HotkeyLockGoods()",</p><p>        2,</p><p>        false</p><p>    );</p><p>    </p><p>    -- Lager räumen</p><p>    Input.KeyBindDown(</p><p>        Keys.ModifierShift + Keys.M,</p><p>        "AddOnCastleStore.Local.CastleStore:HotkeyEmptyStore()",</p><p>        2,</p><p>        false</p><p>    );</p><p>-- Fügt die Beschreibung der Hotkeys der Hotkey-Tabelle hinzu.</p><p>-- @within Internal</p><p>-- @local</p><p>    if not self.HotkeysAddToList then</p><p>        API.AddHotKey("Umschalt + B", {de = "Burglager: Waren einlagern", en = "Vault: Store goods"});</p><p>        API.AddHotKey("Umschalt + N", {de = "Burglager: Waren sperren", en = "Vault: Lock goods"});</p><p>        API.AddHotKey("Umschalt + M", {de = "Burglager: Lager räumen", en = "Vault: Empty store"});</p><p>        self.HotkeysAddToList = true;</p><p>    end</p><p>-- Überschreibt die Textausgabe mit den eigenen Texten.</p><p>-- @within Internal</p><p>-- @local</p><p>    GetStringTableText_Orig_QSB_CatsleStore = XGUIEng.GetStringTableText;</p><p>    XGUIEng.GetStringTableText = function(_key)</p><p>        local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>        local SelectedID = GUI.GetSelectedEntity();</p><p>        local PlayerID = GUI.GetPlayerID();</p><p>        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();</p><p>        if _key == "UI_ObjectNames/DestroyGoods" then</p><p>            if Logic.GetHeadquarters(PlayerID) == SelectedID then</p><p>                if XGUIEng.IsWidgetShown("/InGame/Root/Normal/AlignBottomRight/Selection/Castle") == 1 then</p><p>                    return AddOnCastleStore.Local.Description.ShowCastleStore.Text[lang];</p><p>                else</p><p>                    return AddOnCastleStore.Local.Description.ShowCastle.Text[lang];</p><p>                end</p><p>            end</p><p>        end</p><p>        if _key == "UI_ObjectDescription/DestroyGoods" then</p><p>            return "";</p><p>        end</p><p>        if _key == "UI_ObjectNames/CityBuildingsNumber" then</p><p>            if Logic.GetHeadquarters(PlayerID) == SelectedID then</p><p>                return AddOnCastleStore.Local.Description.CityTab.Title[lang];</p><p>            end</p><p>        end</p><p>        if _key == "UI_ObjectDescription/CityBuildingsNumber" then</p><p>            if Logic.GetHeadquarters(PlayerID) == SelectedID then</p><p>                return AddOnCastleStore.Local.Description.CityTab.Text[lang];</p><p>            end</p><p>        end</p><p>        if _key == "UI_ObjectNames/B_StoreHouse" then</p><p>            if Logic.GetHeadquarters(PlayerID) == SelectedID then</p><p>                return AddOnCastleStore.Local.Description.StorehouseTab.Title[lang];</p><p>            end</p><p>        end</p><p>        if _key == "UI_ObjectDescription/B_StoreHouse" then</p><p>            if Logic.GetHeadquarters(PlayerID) == SelectedID then</p><p>                return AddOnCastleStore.Local.Description.StorehouseTab.Text[lang];</p><p>            end</p><p>        end</p><p>        if _key == "UI_ObjectNames/B_Castle_ME" then</p><p>            local WidgetMotherName = "/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/TabButtons/";</p><p>            local WidgetDownButton = WidgetMotherName.. "Tab03Down/down/B_Castle_ME";</p><p>            local WidgetUpButton = WidgetMotherName.. "Tab03Up/up/B_Castle_ME";</p><p>            if XGUIEng.GetWidgetPathByID(CurrentWidgetID) == WidgetDownButton or XGUIEng.GetWidgetPathByID(CurrentWidgetID) == WidgetUpButton then</p><p>                if Logic.GetHeadquarters(PlayerID) == SelectedID then</p><p>                    return AddOnCastleStore.Local.Description.MultiTab.Title[lang];</p><p>                end</p><p>            end</p><p>        end</p><p>        if _key == "UI_ObjectDescription/B_Castle_ME" then</p><p>            if Logic.GetHeadquarters(PlayerID) == SelectedID then</p><p>                return AddOnCastleStore.Local.Description.MultiTab.Text[lang];</p><p>            end</p><p>        end</p><p>        if _key == "UI_ButtonDisabled/NotEnoughGoods" then</p><p>            if Logic.GetHeadquarters(PlayerID) == SelectedID then</p><p>                return AddOnCastleStore.Local.Description.GoodButtonDisabled.Text[lang];</p><p>            end</p><p>        end</p><p>        return GetStringTableText_Orig_QSB_CatsleStore(_key);</p><p>    end</p><p>-- Überschreibt die lokalen Spielfunktionen, die benötigt werden, damit das</p><p>-- Burglager funktioniert.</p><p>-- @within Internal</p><p>-- @local</p><p>    GameCallback_GUI_SelectionChanged_Orig_QSB_CastleStore = GameCallback_GUI_SelectionChanged;</p><p>    GameCallback_GUI_SelectionChanged = function(_Source)</p><p>        GameCallback_GUI_SelectionChanged_Orig_QSB_CastleStore(_Source);</p><p>        QSB.CastleStore:SelectionChanged(GUI.GetPlayerID());</p><p>    end</p><p>    GUI_Trade.GoodClicked_Orig_QSB_CastleStore = GUI_Trade.GoodClicked;</p><p>    GUI_Trade.GoodClicked = function()</p><p>        local GoodType = Goods[XGUIEng.GetWidgetNameByID(XGUIEng.GetWidgetsMotherID(XGUIEng.GetCurrentWidgetID()))];</p><p>        local SelectedID = GUI.GetSelectedEntity();</p><p>        local PlayerID   = GUI.GetPlayerID();</p><p>        if Logic.IsEntityInCategory(SelectedID, EntityCategories.Storehouse) == 1 then</p><p>            GUI_Trade.GoodClicked_Orig_QSB_CastleStore();</p><p>            return;</p><p>        end</p><p>        QSB.CastleStore:GoodClicked(PlayerID, GoodType);</p><p>    end</p><p>    GUI_Trade.DestroyGoodsClicked_Orig_QSB_CastleStore = GUI_Trade.DestroyGoodsClicked;</p><p>    GUI_Trade.DestroyGoodsClicked = function()</p><p>        local SelectedID = GUI.GetSelectedEntity();</p><p>        local PlayerID   = GUI.GetPlayerID();</p><p>        if Logic.IsEntityInCategory(SelectedID, EntityCategories.Storehouse) == 1 then</p><p>            GUI_Trade.DestroyGoodsClicked_Orig_QSB_CastleStore();</p><p>            return;</p><p>        end</p><p>        QSB.CastleStore:DestroyGoodsClicked(PlayerID);</p><p>    end</p><p>    GUI_Trade.SellUpdate_Orig_QSB_CastleStore = GUI_Trade.SellUpdate;</p><p>    GUI_Trade.SellUpdate = function()</p><p>        local SelectedID = GUI.GetSelectedEntity();</p><p>        local PlayerID   = GUI.GetPlayerID();</p><p>        if Logic.IsEntityInCategory(SelectedID, EntityCategories.Storehouse) == 1 then</p><p>            GUI_Trade.SellUpdate_Orig_QSB_CastleStore();</p><p>            return;</p><p>        end</p><p>        QSB.CastleStore:UpdateGoodsDisplay(PlayerID);</p><p>    end</p><p>    GUI_Trade.CityTabButtonClicked_Orig_QSB_CastleStore = GUI_Trade.CityTabButtonClicked;</p><p>    GUI_Trade.CityTabButtonClicked = function()</p><p>        local SelectedID = GUI.GetSelectedEntity();</p><p>        local PlayerID   = GUI.GetPlayerID();</p><p>        if Logic.IsEntityInCategory(SelectedID, EntityCategories.Storehouse) == 1 then</p><p>            GUI_Trade.CityTabButtonClicked_Orig_QSB_CastleStore();</p><p>            return;</p><p>        end</p><p>        QSB.CastleStore:OnCityTabClicked(PlayerID);</p><p>    end</p><p>    GUI_Trade.StorehouseTabButtonClicked_Orig_QSB_CastleStore = GUI_Trade.StorehouseTabButtonClicked;</p><p>    GUI_Trade.StorehouseTabButtonClicked = function()</p><p>        local SelectedID = GUI.GetSelectedEntity();</p><p>        local PlayerID   = GUI.GetPlayerID();</p><p>        if Logic.IsEntityInCategory(SelectedID, EntityCategories.Storehouse) == 1 then</p><p>            GUI_Trade.StorehouseTabButtonClicked_Orig_QSB_CastleStore();</p><p>            return;</p><p>        end</p><p>        QSB.CastleStore:OnStorehouseTabClicked(PlayerID);</p><p>    end</p><p>    GUI_Trade.MultiTabButtonClicked_Orig_QSB_CastleStore = GUI_Trade.MultiTabButtonClicked;</p><p>    GUI_Trade.MultiTabButtonClicked = function()</p><p>        local SelectedID = GUI.GetSelectedEntity();</p><p>        local PlayerID   = GUI.GetPlayerID();</p><p>        if Logic.IsEntityInCategory(SelectedID, EntityCategories.Storehouse) == 1 then</p><p>            GUI_Trade.MultiTabButtonClicked_Orig_QSB_CastleStore();</p><p>            return;</p><p>        end</p><p>        QSB.CastleStore:OnMultiTabClicked(PlayerID);</p><p>    end</p><p>    GUI_BuildingInfo.StorageLimitUpdate_Orig_QSB_CastleStore = GUI_BuildingInfo.StorageLimitUpdate;</p><p>    GUI_BuildingInfo.StorageLimitUpdate = function()</p><p>        local SelectedID = GUI.GetSelectedEntity();</p><p>        local PlayerID   = GUI.GetPlayerID();</p><p>        if Logic.IsEntityInCategory(SelectedID, EntityCategories.Storehouse) == 1 then</p><p>            GUI_BuildingInfo.StorageLimitUpdate_Orig_QSB_CastleStore();</p><p>            return;</p><p>        end</p><p>        QSB.CastleStore:UpdateStorageLimit(PlayerID);</p><p>    end</p><p>    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</p><p>    GUI_Interaction.SendGoodsClicked = function()</p><p>        local Quest, QuestType = GUI_Interaction.GetPotentialSubQuestAndType(g_Interaction.CurrentMessageQuestIndex);</p><p>        if not Quest then</p><p>            return;</p><p>        end</p><p>        local QuestIndex = GUI_Interaction.GetPotentialSubQuestIndex(g_Interaction.CurrentMessageQuestIndex);</p><p>        local GoodType = Quest.Objectives[1].Data[1];</p><p>        local GoodAmount = Quest.Objectives[1].Data[2];</p><p>        local Costs = {GoodType, GoodAmount};</p><p>        local CanBuyBoolean, CanNotBuyString = AreCostsAffordable(Costs, true);</p><p>        local PlayerID = GUI.GetPlayerID();</p><p>        if Logic.GetGoodCategoryForGoodType(GoodType) == GoodCategories.GC_Resource then</p><p>            CanNotBuyString = XGUIEng.GetStringTableText("Feedback_TextLines/TextLine_NotEnough_Resources");</p><p>            CanBuyBoolean = false;</p><p>            if QSB.CastleStore:IsLocked(PlayerID, GoodType) then</p><p>                CanBuyBoolean = GetPlayerResources(GoodType, PlayerID) >= GoodAmount;</p><p>            else</p><p>                CanBuyBoolean = (GetPlayerResources(GoodType, PlayerID) + QSB.CastleStore:GetAmount(PlayerID, GoodType)) >= GoodAmount;</p><p>            end</p><p>        end</p><p>        local TargetPlayerID = Quest.Objectives[1].Data[6] and Quest.Objectives[1].Data[6] or Quest.SendingPlayer;</p><p>        local PlayerSectorType = PlayerSectorTypes.Thief;</p><p>        local IsReachable = CanEntityReachTarget(TargetPlayerID, Logic.GetStoreHouse(GUI.GetPlayerID()), Logic.GetStoreHouse(TargetPlayerID), nil, PlayerSectorType);</p><p>        if IsReachable == false then</p><p>            local MessageText = XGUIEng.GetStringTableText("Feedback_TextLines/TextLine_GenericUnreachable");</p><p>            Message(MessageText);</p><p>            return</p><p>        end</p><p>        if CanBuyBoolean == true then</p><p>            Sound.FXPlay2DSound( "ui\\menu_click");</p><p>            GUI.QuestTemplate_SendGoods(QuestIndex);</p><p>            GUI_FeedbackSpeech.Add("SpeechOnly_CartsSent", g_FeedbackSpeech.Categories.CartsUnderway, nil, nil);</p><p>        else</p><p>            Message(CanNotBuyString);</p><p>        end</p><p>    end</p><p>    GUI_Tooltip.SetCosts = function(_TooltipCostsContainer, _Costs, _GoodsInSettlementBoolean)</p><p>        local TooltipCostsContainerPath = XGUIEng.GetWidgetPathByID(_TooltipCostsContainer);</p><p>        local Good1ContainerPath = TooltipCostsContainerPath .. "/1Good";</p><p>        local Goods2ContainerPath = TooltipCostsContainerPath .. "/2Goods";</p><p>        local NumberOfValidAmounts = 0;</p><p>        local Good1Path;</p><p>        local Good2Path;</p><p>        for i = 2, #_Costs, 2 do</p><p>            if _Costs[i] ~= 0 then</p><p>                NumberOfValidAmounts = NumberOfValidAmounts + 1;</p><p>            end</p><p>        end</p><p>        if NumberOfValidAmounts == 0 then</p><p>            XGUIEng.ShowWidget(Good1ContainerPath, 0);</p><p>            XGUIEng.ShowWidget(Goods2ContainerPath, 0);</p><p>            return</p><p>        elseif NumberOfValidAmounts == 1 then</p><p>            XGUIEng.ShowWidget(Good1ContainerPath, 1);</p><p>            XGUIEng.ShowWidget(Goods2ContainerPath, 0);</p><p>            Good1Path = Good1ContainerPath .. "/Good1Of1";</p><p>        elseif NumberOfValidAmounts == 2 then</p><p>            XGUIEng.ShowWidget(Good1ContainerPath, 0);</p><p>            XGUIEng.ShowWidget(Goods2ContainerPath, 1);</p><p>            Good1Path = Goods2ContainerPath .. "/Good1Of2";</p><p>            Good2Path = Goods2ContainerPath .. "/Good2Of2";</p><p>        elseif NumberOfValidAmounts > 2 then</p><p>            GUI.AddNote("Debug: Invalid Costs table. Not more than 2 GoodTypes allowed.");</p><p>        end</p><p>        local ContainerIndex = 1;</p><p>        for i = 1, #_Costs, 2 do</p><p>            if _Costs[i + 1] ~= 0 then</p><p>                local CostsGoodType = _Costs[i];</p><p>                local CostsGoodAmount = _Costs[i + 1];</p><p>                local IconWidget;</p><p>                local AmountWidget;</p><p>                if ContainerIndex == 1 then</p><p>                    IconWidget = Good1Path .. "/Icon";</p><p>                    AmountWidget = Good1Path .. "/Amount";</p><p>                else</p><p>                    IconWidget = Good2Path .. "/Icon";</p><p>                    AmountWidget = Good2Path .. "/Amount";</p><p>                end</p><p>                SetIcon(IconWidget, g_TexturePositions.Goods[CostsGoodType], 44);</p><p>                local PlayerID = GUI.GetPlayerID();</p><p>                local PlayersGoodAmount = GetPlayerGoodsInSettlement(CostsGoodType, PlayerID, _GoodsInSettlementBoolean);</p><p>                if Logic.GetGoodCategoryForGoodType(CostsGoodType) == GoodCategories.GC_Resource and CostsGoodType ~= Goods.G_Gold then</p><p>                    if not QSB.CastleStore:IsLocked(PlayerID, CostsGoodType) then</p><p>                        PlayersGoodAmount = PlayersGoodAmount + QSB.CastleStore:GetAmount(PlayerID, CostsGoodType);</p><p>                    end</p><p>                end</p><p>                local Color = "";</p><p>                if PlayersGoodAmount < CostsGoodAmount then</p><p>                    Color = "{@script:ColorRed}";</p><p>                end</p><p>                if CostsGoodAmount > 0 then</p><p>                    XGUIEng.SetText(AmountWidget, "{center}" .. Color .. CostsGoodAmount);</p><p>                else</p><p>                    XGUIEng.SetText(AmountWidget, "");</p><p>                end</p><p>                ContainerIndex = ContainerIndex + 1;</p><p>            end</p><p>        end</p><p>    end</p><p>-- -------------------------------------------------------------------------- --</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/addongamecutscenes.lua.html">
            <div class='doclink'>
                <div>AddOnGameCutscenes</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia AddOnGameCutscenes                                           # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- <p>Dieses Bundle verwaltet den Aufruf der mit dem SCA-Tool erstellten</p><p>-- Cutscenes. Ausserdem ermöglicht es das direkte Erfassen der</p><p>-- Kamerapositionen aus der Map heraus.</p></p><p>-- <p><a href="#CS.StartCutscene">Cutscene starten</a></p></p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Startet eine Cutscene.</p><p>-- @param _cutscene [string] Name der Cutscene</p><p>-- @return [boolean] Cutscene gestartet</p><p>-- @within Anwenderfunktionen</p><p>    if not GUI then</p><p>        API.Bridge("CS.StartCutscene('".._cutscene.."')")</p><p>        return</p><p>    end</p><p>    if not CS.IsCutsceneActive() then</p><p>        if BriefingSystem then</p><p>            BriefingSystem.isActive = true</p><p>        end</p><p>        AddOnGameCutscenes.Local.Data.Active = true</p><p>        AddOnGameCutscenes.Local:StartCutscene(_cutscene)</p><p>        return true</p><p>    else</p><p>        if BriefingSystem then</p><p>            if BriefingSystem.IsBriefingActive() then</p><p>                return false</p><p>            end</p><p>        else</p><p>            AddOnGameCutscenes.Local:AddToWaitList(_cutscene)</p><p>        end</p><p>    end</p><p>-- Prüft, ob eine Cutscene aktiv ist.</p><p>-- @return [boolean] Cutscene ist aktiv</p><p>-- @within Anwenderfunktionen</p><p>    if not GUI then</p><p>        assert(false, "CS.IsCutsceneActive : is local function.")</p><p>        return</p><p>    end</p><p>    return AddOnGameCutscenes.Local:IsCutsceneActive()</p><p>-- Erstellen einer Cutscene, um diese mit dem SCA Tool in eine cs Datei umzuwandeln</p><p>-- @within Anwenderfunktionen</p><p>    if GUI then</p><p>        API.Bridge("CS.CreateCutscene_DEV_ONLY()")</p><p>        return</p><p>    end</p><p>    AddOnGameCutscenes.Global:StartCutsceneMaker()</p><p>-- Erstellen einer Echtzeit Cutscene, um diese mit dem SCA Tool in eine cs Datei umzuwandeln</p><p>-- @within Anwenderfunktionen</p><p>    if GUI then</p><p>        API.Bridge("CS.CreateCutsceneRealtime_DEV_ONLY()")</p><p>        return</p><p>    end</p><p>    AddOnGameCutscenes.Global.Data.csMaker.realtime = true</p><p>    API.Bridge("AddOnGameCutscenes.Local.Data.csMakerRealtime = true")</p><p>    AddOnGameCutscenes.Global:StartCutsceneMaker()</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {</p><p>        Data = {</p><p>            csMaker = {</p><p>                coord = {},</p><p>                mouse = {},</p><p>            },</p><p>        },</p><p>    },</p><p>    Local = {</p><p>        Data = {</p><p>            Language = "de",</p><p>            Active = false,</p><p>            WaitList = {},</p><p>            Positions = {},</p><p>        },</p><p>    },</p><p>-- Global Script ---------------------------------------------------------------</p><p>-- Initalisiert das Bundle im globalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    self.Data.csMaker.coord = {</p><p>    	xLook = 0, -- x position of the camera look at</p><p>    	yLook = 0, -- y position of the camera look at</p><p>    	zLook = 0, -- z position of the camera look at</p><p>    	xCam = 0, -- x position of the camera</p><p>    	yCam = 0, -- y position of the camera</p><p>    	zCam = 0, -- z position of the camera</p><p>    	r = 0, -- rotation of the camera</p><p>    	a = 0, -- angle of the camera</p><p>    	d = 100, -- distance of the camera</p><p>    	s = 30, -- speed of the camera</p><p>    	src = -90, --standard rotation correction</p><p>    }</p><p>    -- previous mouse position on the screen</p><p>    self.Data.csMaker.mouse = {</p><p>    	currentX = 0, -- left to right</p><p>    	currentY = 0, -- top to bottom</p><p>    	savedX = 0,</p><p>    	savedY = 0,</p><p>    	maxX = 0,</p><p>    	maxY = 0,</p><p>    }</p><p>-- Startet den CutsceneMaker</p><p>-- @within Internal</p><p>-- @local</p><p>    self.Data.csMaker.pages = {}</p><p>    self:CurrentMousePosition()</p><p>    if AddOnGameCutscenes.Global.Data.csMaker.realtime then</p><p>        self.Data.csMaker.lastTime = Logic.GetTime()</p><p>    end</p><p>    API.Bridge("AddOnGameCutscenes.Local:StartCutsceneMaker()")</p><p>-- Beendet den CutsceneMaker</p><p>-- @within Internal</p><p>-- @local</p><p>    EndJob(self.Data.csMaker.job)</p><p>    API.Bridge("AddOnGameCutscenes.Local:CurrentMousePosition()")</p><p>-- checks the change in the mouse position to put it on display</p><p>    AddOnGameCutscenes.Global:CurrentMousePosition()</p><p>    local savedX = AddOnGameCutscenes.Global.Data.csMaker.mouse.savedX</p><p>    local savedY = AddOnGameCutscenes.Global.Data.csMaker.mouse.savedY</p><p>    local currentX = AddOnGameCutscenes.Global.Data.csMaker.mouse.currentX</p><p>    local currentY = AddOnGameCutscenes.Global.Data.csMaker.mouse.currentY</p><p>-- transforms the mouse displacement into a rotation value</p><p>-- transforms the mouse displacement into an angle value</p><p>-- sets a new position for the camera depending on an angle that represents forward/backward/left/right</p><p>-- sets the camera position</p><p>-- makes the movement speed bigger</p><p>-- makes the movement speed smaller</p><p>-- add a new duration to the duration table</p><p>-- emtpy the values in the duration table, to be able to refill it from beginning</p><p>-- gives the current duration</p><p>-- gives the current duration while deleting the content of the duration table</p><p>-- This creates a new JumpTo page</p><p>    if AddOnGameCutscenes.Global.Data.csMaker.realtime then</p><p>        local time = Logic.GetTime()</p><p>        duration = time - self.Data.csMaker.lastTime</p><p>        self.Data.csMaker.lastTime = time</p><p>    else</p><p>        duration = self:GetDurationDestructive()</p><p>    end</p><p>    self:SavePageToProfile(pageData)</p><p>    if AddOnGameCutscenes.Global.Data.csMaker.realtime then</p><p>        local time = Logic.GetTime()</p><p>        duration = time - self.Data.csMaker.lastTime</p><p>        self.Data.csMaker.lastTime = time</p><p>    else</p><p>        duration = self:GetDurationDestructive()</p><p>    end</p><p>    self:SavePageToProfile(pageData)</p><p>    API.Bridge("AddOnGameCutscenes.Local:EndCutsceneMaker()")</p><p>        barStyle = "small",</p><p>        restoreCamera = true,</p><p>        skipAll = true,</p><p>        hideFoW = true,</p><p>        showSky = true,</p><p>        hideBorderPins = true</p><p>    };</p><p>    local AP = AddPages(cutscene)</p><p>    cutscene.finished = function()</p><p>    end</p><p>    return StartCutscene(cutscene)</p><p>-- Local Script ----------------------------------------------------------------</p><p>-- Initalisiert das Bundle im lokalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    self.Data.Language = (Network.GetDesiredLanguage() == "de" and "de") or "en";</p><p>    local _, screenY = GUI.GetScreenSize()</p><p>    local xp, yp = XGUIEng.GetWidgetScreenPosition("/InGame/ThroneRoom/Main/MissionBriefing/Text")</p><p>    self.Data.Positions.Text = {X = xp, Y = yp}</p><p>    local _, ys = XGUIEng.GetWidgetSize("/InGame/ThroneRoomBars_2/BarBottom")</p><p>    self.Data.Positions.TextSmall = {X = xp, Y = screenY - ys + 30}</p><p>    local xp, yp = XGUIEng.GetWidgetScreenPosition("/InGame/ThroneRoom/Main/DialogTopChooseKnight/ChooseYourKnight")</p><p>    self.Data.Positions.Title = {X = xp, Y = yp}</p><p>    local _, ys = XGUIEng.GetWidgetSize("/InGame/ThroneRoomBars_2/BarTop")</p><p>    self.Data.Positions.TitleSmall = {X = xp, Y = ys / 2 - 30}</p><p>    self.Data.GameCallback_Escape = GameCallback_Escape;</p><p>    GameCallback_Escape = function()</p><p>        if not self.Data.Active then</p><p>            self.Data.GameCallback_Escape();</p><p>        end</p><p>    end</p><p>-- Prüft, ob eine Cutscene oder ein Briefing activ ist.</p><p>-- @within Internal</p><p>-- @local</p><p>    if BriefingSystem then</p><p>        if BriefingSystem.IsBriefingActive() then</p><p>            return true</p><p>        end</p><p>    end</p><p>    return self.Data.Active</p><p>-- Fügt eine Cutscene zur warteliste hinzu.</p><p>-- @param _cutscene Name der Cutscene</p><p>-- @within Internal</p><p>-- @local</p><p>    table.insert(self.Data.WaitList, _cutscene)</p><p>-- Prüf, ob eine Cutscene in der Warteliste steht und führt diese gegebenenfalls aus.</p><p>-- @within Internal</p><p>-- @local</p><p>    self.Data.Name = nil</p><p>    if #self.Data.WaitList > 0 then</p><p>        AddOnGameCutscenes.Local:StartCutscene(table.remove(self.Data.WaitList))</p><p>    else</p><p>        self.Data.Active = false</p><p>        AddOnGameCutscenes.Local:UndoCutsceneOptic()</p><p>        if BriefingSystem then</p><p>            BriefingSystem.isActive = false</p><p>        end</p><p>    end</p><p>-- Bereitet die Daten für die kommende Cutscene vor und startet diese dann.</p><p>-- @param _cutscene String, name der cutscene</p><p>-- @within Internal</p><p>-- @local</p><p>    AddOnGameCutscenes.Local:StartCutsceneOptic()</p><p>    Camera.StartCutscene(_cutscene)</p><p>-- Bereitet die UI für die Cutscene vor.</p><p>-- @within Internal</p><p>-- @local</p><p>    Display.SetRenderBorderPins(0)</p><p>    Display.SetRenderSky(1)</p><p>    Display.SetUserOptionOcclusionEffect(0)</p><p>    Display.SetRenderFogOfWar(0)</p><p>    XGUIEng.ShowWidget("/InGame/Root/Normal", 0)</p><p>    local isLoadScreenVisible = XGUIEng.IsWidgetShownEx("/LoadScreen/LoadScreen") == 1</p><p>    if isLoadScreenVisible then</p><p>        XGUIEng.PopPage()</p><p>    end</p><p>    XGUIEng.ShowWidget("/InGame/Root/3dOnScreenDisplay", 0)</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom", 1)</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/Skip", 0)</p><p>    XGUIEng.PushPage("/InGame/ThroneRoomBars", false)</p><p>    XGUIEng.PushPage("/InGame/ThroneRoomBars_2", false)</p><p>    XGUIEng.PushPage("/InGame/ThroneRoom/Main", false)</p><p>    XGUIEng.PushPage("/InGame/ThroneRoomBars_Dodge", false)</p><p>    XGUIEng.PushPage("/InGame/ThroneRoomBars_2_Dodge", false)</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogTopChooseKnight", 1)</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogTopChooseKnight/Frame", 0)</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogTopChooseKnight/DialogBG", 0)</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogTopChooseKnight/FrameEdges", 0)</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogBottomRight3pcs", 0)</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/KnightInfoButton", 0)</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/Briefing", 0)</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/BackButton", 0)</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/TitleContainer", 0)</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/StartButton", 0)</p><p>    XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Text", " ")</p><p>    XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Title", " ")</p><p>    XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Objectives", " ")</p><p>    -- page.information Text</p><p>    local screen = {GUI.GetScreenSize()}</p><p>    local yAlign = 350 * (screen[2]/1080)</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom/KnightInfo", 1)</p><p>    XGUIEng.ShowAllSubWidgets("/InGame/ThroneRoom/KnightInfo", 0)</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom/KnightInfo/Text", 1)</p><p>    XGUIEng.PushPage("/InGame/ThroneRoom/KnightInfo", false)</p><p>    XGUIEng.SetText("/InGame/ThroneRoom/KnightInfo/Text", "")</p><p>    XGUIEng.SetTextColor("/InGame/ThroneRoom/KnightInfo/Text", 255, 255, 255, 255)</p><p>    XGUIEng.SetWidgetScreenPosition("/InGame/ThroneRoom/KnightInfo/Text", 100, yAlign)</p><p>    self.Data.timeFactor = Game.GameTimeGetFactor()</p><p>    Game.GameTimeSetFactor(GUI.GetPlayerID(), 1)</p><p>    self.Data.cameraRestore = {Camera.RTS_GetLookAtPosition()}</p><p>    self.Data.selectedEntities = {GUI.GetSelectedEntities()}</p><p>    GUI.ClearSelection();</p><p>    GUI.ForbidContextSensitiveCommandsInSelectionState()</p><p>    GUI.ActivateCutSceneState()</p><p>    GUI.SetFeedbackSoundOutputState(0)</p><p>    GUI.EnableBattleSignals(false)</p><p>    Mouse.CursorHide()</p><p>    Input.CutsceneMode()</p><p>    if isLoadScreenVisible then</p><p>        XGUIEng.PushPage("/LoadScreen/LoadScreen", false);</p><p>    end</p><p>    AddOnGameCutscenes.Local:ShowText()</p><p>-- Stellt die UI für das Spiel wieder her.</p><p>-- @within Internal</p><p>-- @local</p><p>    Display.SetRenderBorderPins(1)</p><p>    Display.SetRenderSky(0)</p><p>    if Options.GetIntValue("Display", "Occlusion", 0) > 0 then</p><p>        Display.SetUserOptionOcclusionEffect(1)</p><p>    end</p><p>    Display.SetRenderFogOfWar(1)</p><p>    XGUIEng.PopPage()</p><p>    Display.UseStandardSettings()</p><p>    Input.GameMode()</p><p>    Mouse.CursorShow()</p><p>    GUI.EnableBattleSignals(true)</p><p>    GUI.SetFeedbackSoundOutputState(1)</p><p>    GUI.ActivateSelectionState()</p><p>    GUI.PermitContextSensitiveCommandsInSelectionState()</p><p>    XGUIEng.ShowWidget("/InGame/Root/Normal", 1)</p><p>    XGUIEng.SetWidgetScreenPosition("/InGame/ThroneRoom/Main/DialogTopChooseKnight/ChooseYourKnight", self.Data.Positions.Title.X, self.Data.Positions.Title.Y)</p><p>    XGUIEng.SetWidgetScreenPosition("/InGame/ThroneRoom/Main/MissionBriefing/Text", self.Data.Positions.Text.X, self.Data.Positions.Text.Y)</p><p>    for _, v in ipairs(self.Data.selectedEntities) do</p><p>        if not Logic.IsEntityDestroyed(v) then</p><p>            GUI.SelectEntity(v)</p><p>        end</p><p>    end</p><p>    Camera.RTS_SetLookAtPosition(unpack(self.Data.cameraRestore))</p><p>    Game.GameTimeSetFactor(GUI.GetPlayerID(), self.Data.timeFactor)</p><p>    XGUIEng.PopPage()</p><p>    XGUIEng.PopPage()</p><p>    XGUIEng.PopPage()</p><p>    XGUIEng.PopPage()</p><p>    XGUIEng.PopPage()</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom", 0)</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoomBars", 0)</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2", 0)</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_Dodge", 0)</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2_Dodge", 0)</p><p>    XGUIEng.ShowWidget("/InGame/Root/3dOnScreenDisplay", 1)</p><p>-- Verwaltet die Anzeige der Texte.</p><p>-- @param _text Text der angezeigt werden soll</p><p>-- @param _title Titel der angezeigt werden soll</p><p>-- @param _centered true wenn der Text zentriert sein soll</p><p>-- @param _show true wenn bar gezeigt werden soll</p><p>-- @param _big true wenn breiter Balken</p><p>-- @param _black true wenn Schwarz</p><p>-- @within Internal</p><p>-- @local</p><p>    local text = _text or ""</p><p>    local title = _title or ""</p><p>    local centered = _centered or false</p><p>    local showBars = _showBars or false</p><p>    local big = _big or false</p><p>    local black = _black or false</p><p>    local alpha = not black and 100 or 255</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoomBars", (showBars and big) and 1 or 0)</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_Dodge", (showBars and big) and 1 or 0)</p><p>    XGUIEng.SetMaterialAlpha("/InGame/ThroneRoomBars/BarBottom", 1, alpha)</p><p>    XGUIEng.SetMaterialAlpha("/InGame/ThroneRoomBars/BarTop", 1, alpha)</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2", (showBars and not big) and 1 or 0)</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2_Dodge", (showBars and not big) and 1 or 0)</p><p>    XGUIEng.SetMaterialAlpha("/InGame/ThroneRoomBars_2/BarBottom", 1, alpha)</p><p>    XGUIEng.SetMaterialAlpha("/InGame/ThroneRoomBars_2/BarTop", 1, alpha)</p><p>    if centered then</p><p>        local Height = 0;</p><p>        local Length = string.len(text)</p><p>        Height = Height + math.ceil((Length/80))</p><p>        local CarriageReturn = 0</p><p>        local s,e = string.find(text, "{cr}")</p><p>        while (e) do</p><p>            CarriageReturn = CarriageReturn + 1</p><p>            s,e = string.find(text, "{cr}", e+1)</p><p>        end</p><p>        Height = Height + math.floor((CarriageReturn/2))</p><p>        local Screen = {GUI.GetScreenSize()}</p><p>        Height = (Screen[2]/2) - (Height*10)</p><p>        XGUIEng.SetWidgetScreenPosition("/InGame/ThroneRoom/Main/DialogTopChooseKnight/ChooseYourKnight", self.Data.Positions.Title.X, 0 + Height)</p><p>        XGUIEng.SetWidgetScreenPosition("/InGame/ThroneRoom/Main/MissionBriefing/Text", self.Data.Positions.Text.X, 38 + Height)</p><p>    else</p><p>        local xTitle = self.Data.Positions.Title.X</p><p>        local xText = self.Data.Positions.Text.X</p><p>        if big then</p><p>            local yTitle = self.Data.Positions.Title.Y</p><p>            local yText = self.Data.Positions.Text.Y</p><p>            XGUIEng.SetWidgetScreenPosition("/InGame/ThroneRoom/Main/DialogTopChooseKnight/ChooseYourKnight", xTitle, yTitle)</p><p>            XGUIEng.SetWidgetScreenPosition("/InGame/ThroneRoom/Main/MissionBriefing/Text", xText, yText)</p><p>        else</p><p>            local yTitle = self.Data.Positions.TitleSmall.Y</p><p>            local yText = self.Data.Positions.TextSmall.Y</p><p>            XGUIEng.SetWidgetScreenPosition("/InGame/ThroneRoom/Main/DialogTopChooseKnight/ChooseYourKnight", xTitle, yTitle)</p><p>            XGUIEng.SetWidgetScreenPosition("/InGame/ThroneRoom/Main/MissionBriefing/Text", xText, yText)</p><p>        end</p><p>    end</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/MissionBriefing/Text", 1)</p><p>    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogTopChooseKnight/ChooseYourKnight", 1)</p><p>    XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Text", "{center}"..text)</p><p>    XGUIEng.SetText("/InGame/ThroneRoom/Main/DialogTopChooseKnight/ChooseYourKnight", "{center}{darkshadow}{@color:244,184,0,255}"..title)</p><p>-- Startet den Cutscene Maker</p><p>-- @within Internal</p><p>-- @local</p><p>    Profile.SetString("CutsceneAssistent", "pages", "")</p><p>    local x, y = Camera.RTS_GetLookAtPosition()</p><p>    local z = Display.GetTerrainHeight(x, y) + 1000</p><p>    API.Bridge("AddOnGameCutscenes.Global.Data.csMaker.coord.xLook = "..x)</p><p>    API.Bridge("AddOnGameCutscenes.Global.Data.csMaker.coord.yLook = "..y)</p><p>    API.Bridge("AddOnGameCutscenes.Global.Data.csMaker.coord.zLook = "..z)</p><p>    Display.SetUserOptionOcclusionEffect(0)</p><p>    Display.SetRenderSky(1)</p><p>    Game.GameTimeSetFactor(GUI.GetPlayerID(), 1)</p><p>    Camera.SwitchCameraBehaviour(5)</p><p>    Display.SetRenderFogOfWar(0)</p><p>    GUI.MiniMap_SetRenderFogOfWar(0)</p><p>    GUI.ActivateCutSceneState()</p><p>    local width, height = GUI.GetScreenSize()</p><p>    API.Bridge("AddOnGameCutscenes.Global.Data.csMaker.mouse.maxX = "..width.." - 5")</p><p>    API.Bridge("AddOnGameCutscenes.Global.Data.csMaker.mouse.maxY = "..height.." - 5")</p><p>    Input.KeyBindDown( Keys.Up,       'API.Bridge("AddOnGameCutscenes.Global:PressedUp()")',       2, true)</p><p>    Input.KeyBindDown( Keys.Down,     'API.Bridge("AddOnGameCutscenes.Global:PressedDown()")',     2, true)</p><p>    Input.KeyBindDown( Keys.Left,     'API.Bridge("AddOnGameCutscenes.Global:PressedLeft()")',     2, true)</p><p>    Input.KeyBindDown( Keys.Right,    'API.Bridge("AddOnGameCutscenes.Global:PressedRight()")',    2, true)</p><p>    Input.KeyBindDown( Keys.W,        'API.Bridge("AddOnGameCutscenes.Global:PressedUp()")',       2, true)</p><p>    Input.KeyBindDown( Keys.S,        'API.Bridge("AddOnGameCutscenes.Global:PressedDown()")',     2, true)</p><p>    Input.KeyBindDown( Keys.A,        'API.Bridge("AddOnGameCutscenes.Global:PressedLeft()")',     2, true)</p><p>    Input.KeyBindDown( Keys.D,        'API.Bridge("AddOnGameCutscenes.Global:PressedRight()")',    2, true)</p><p>    Input.KeyBindDown( Keys.Add,      'API.Bridge("AddOnGameCutscenes.Global:PressedAdd()")',      2, true)</p><p>    Input.KeyBindDown( Keys.Subtract, 'API.Bridge("AddOnGameCutscenes.Global:PressedSubtract()")', 2, true)</p><p>    Input.KeyBindDown( Keys.Space,    'API.Bridge("AddOnGameCutscenes.Global:PressedSpace()")',    2, true)</p><p>    Input.KeyBindDown( Keys.Y,        'API.Bridge("AddOnGameCutscenes.Global:PressedGoDown()")',   2, true)</p><p>    Input.KeyBindDown( Keys.J,        'API.Bridge("AddOnGameCutscenes.Global:PressedJump()")',     2, true)</p><p>    Input.KeyBindDown( Keys.F,        'API.Bridge("AddOnGameCutscenes.Global:PressedFly()")',      2, true)</p><p>    Input.KeyBindDown( Keys.P,        'API.Bridge("AddOnGameCutscenes.Global:PressedPreview()")',  2, true)</p><p>    if not AddOnGameCutscenes.Local.Data.csMakerRealtime then</p><p>        Input.KeyBindDown( Keys.Back,    'API.Bridge("AddOnGameCutscenes.Global:PressedEmptyDuration()")', 2, true)</p><p>        Input.KeyBindDown( Keys.NumPad0, 'API.Bridge("AddOnGameCutscenes.Global:PressedAddDuration(0)")',  2, true)</p><p>        Input.KeyBindDown( Keys.NumPad1, 'API.Bridge("AddOnGameCutscenes.Global:PressedAddDuration(1)")',  2, true)</p><p>        Input.KeyBindDown( Keys.NumPad2, 'API.Bridge("AddOnGameCutscenes.Global:PressedAddDuration(2)")',  2, true)</p><p>        Input.KeyBindDown( Keys.NumPad3, 'API.Bridge("AddOnGameCutscenes.Global:PressedAddDuration(3)")',  2, true)</p><p>        Input.KeyBindDown( Keys.NumPad4, 'API.Bridge("AddOnGameCutscenes.Global:PressedAddDuration(4)")',  2, true)</p><p>        Input.KeyBindDown( Keys.NumPad5, 'API.Bridge("AddOnGameCutscenes.Global:PressedAddDuration(5)")',  2, true)</p><p>        Input.KeyBindDown( Keys.NumPad6, 'API.Bridge("AddOnGameCutscenes.Global:PressedAddDuration(6)")',  2, true)</p><p>        Input.KeyBindDown( Keys.NumPad7, 'API.Bridge("AddOnGameCutscenes.Global:PressedAddDuration(7)")',  2, true)</p><p>        Input.KeyBindDown( Keys.NumPad8, 'API.Bridge("AddOnGameCutscenes.Global:PressedAddDuration(8)")',  2, true)</p><p>        Input.KeyBindDown( Keys.NumPad9, 'API.Bridge("AddOnGameCutscenes.Global:PressedAddDuration(9)")',  2, true)</p><p>    end</p><p>    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/MapFrame/Minimap/MinimapOverlay", 0)</p><p>-- Beendet den CutsceneMaker</p><p>-- @within Internal</p><p>-- @local</p><p>    Display.SetRenderSky(0)</p><p>    Game.GameTimeSetFactor(GUI.GetPlayerID(), 1)</p><p>    Camera.SwitchCameraBehaviour(0)</p><p>    Display.SetRenderFogOfWar(1)</p><p>    GUI.MiniMap_SetRenderFogOfWar(1)</p><p>    XGUIEng.ShowWidget("/InGame/Root/Normal", 1)</p><p>    Input.KeyBindDown( Keys.Up , 'KeyBindings_EnableDebugMode(0)', 2)</p><p>    Input.KeyBindDown( Keys.Down , 'KeyBindings_EnableDebugMode(0)', 2)</p><p>    Input.KeyBindDown( Keys.Left , 'KeyBindings_EnableDebugMode(0)', 2)</p><p>    Input.KeyBindDown( Keys.Right , 'KeyBindings_EnableDebugMode(0)', 2)</p><p>    Input.KeyBindDown( Keys.W , 'KeyBindings_EnableDebugMode(0)', 2)</p><p>    Input.KeyBindDown( Keys.S , 'KeyBindings_EnableDebugMode(0)', 2)</p><p>    Input.KeyBindDown( Keys.A , 'KeyBindings_EnableDebugMode(0)', 2)</p><p>    Input.KeyBindDown( Keys.D , 'KeyBindings_EnableDebugMode(0)', 2)</p><p>    Input.KeyBindDown( Keys.Add , 'KeyBindings_EnableDebugMode(0)', 2)</p><p>    Input.KeyBindDown( Keys.Subtract , 'KeyBindings_EnableDebugMode(0)', 2)</p><p>    Input.KeyBindDown( Keys.Space , 'KeyBindings_EnableDebugMode(0)', 2)</p><p>    Input.KeyBindDown( Keys.Y , 'KeyBindings_EnableDebugMode(0)', 2)</p><p>    Input.KeyBindDown( Keys.J , 'KeyBindings_EnableDebugMode(0)', 2)</p><p>    Input.KeyBindDown( Keys.F , 'KeyBindings_EnableDebugMode(0)', 2)</p><p>    Input.KeyBindDown( Keys.P , 'KeyBindings_EnableDebugMode(0)', 2)</p><p>    Input.KeyBindDown( Keys.Back , 'KeyBindings_EnableDebugMode(0)', 2)</p><p>    Input.KeyBindDown( Keys.NumPad0 , 'KeyBindings_EnableDebugMode(0)', 2)</p><p>    Input.KeyBindDown( Keys.NumPad1 , 'KeyBindings_EnableDebugMode(0)', 2)</p><p>    Input.KeyBindDown( Keys.NumPad2 , 'KeyBindings_EnableDebugMode(0)', 2)</p><p>    Input.KeyBindDown( Keys.NumPad3 , 'KeyBindings_EnableDebugMode(0)', 2)</p><p>    Input.KeyBindDown( Keys.NumPad4 , 'KeyBindings_EnableDebugMode(0)', 2)</p><p>    Input.KeyBindDown( Keys.NumPad5 , 'KeyBindings_EnableDebugMode(0)', 2)</p><p>    Input.KeyBindDown( Keys.NumPad6 , 'KeyBindings_EnableDebugMode(0)', 2)</p><p>    Input.KeyBindDown( Keys.NumPad7 , 'KeyBindings_EnableDebugMode(0)', 2)</p><p>    Input.KeyBindDown( Keys.NumPad8 , 'KeyBindings_EnableDebugMode(0)', 2)</p><p>    Input.KeyBindDown( Keys.NumPad9 , 'KeyBindings_EnableDebugMode(0)', 2)</p><p>    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/MapFrame/Minimap/MinimapOverlay", 1)</p><p>    local x, y = GUI.GetMousePosition()</p><p>    API.Bridge("AddOnGameCutscenes.Global.Data.csMaker.mouse.currentX = "..x)</p><p>    API.Bridge("AddOnGameCutscenes.Global.Data.csMaker.mouse.currentY = "..y)</p><p>    local previous = Profile.GetString("CutsceneAssistent", "pages")</p><p>-- -------------------------------------------------------------------------- --</p><p> </p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/addoninteractiveobjecttemplates.lua.html">
            <div class='doclink'>
                <div>AddOnInteractiveObjectTemplates</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia AddOnInteractiveObjectTemplates                              # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Dieses Bundle bietet fertige Schablonen für interaktive Objekte. Mit diesen</p><p>-- Schablonen können komplexere interaktive Objekte einfach erstellt und durch</p><p>-- den Mapper genutzt werden.</p><p>-- <p></p><p>-- <b>Interaktive Baustellen:</b><br></p><p>-- Ermöglicht es den Spieler auf einem beliebigen Territorium einer Partei</p><p>-- ein Gebäude bauen zu lassen.</p><p>-- <br>Die Baustelle muss durch den Helden aktiviert</p><p>-- werden. Ein Siedler wird aus dem Lagerhaus kommen und das Gebäude bauen.</p><p>-- <br><a href="API.CreateIOBuildingSite">Eine Baustelle anlegen</a></p><p>-- </p></p><p>-- <p></p><p>-- <b>Interaktive Schatztruhen:</b><br></p><p>-- Es werden Schatztruhen mit zufälligem Inhalt erzeugt. Diese Truhen werden</p><p>-- aktiviert und der Inhalt wird in einem Karren abtransportiert.</p><p>-- <br><a href="API.CreateRandomChest">Eine Schatztruhe anlegen</a></p><p>-- </p></p><p>-- <p></p><p>-- <b>Interaktive Minen:</b><br></p><p>-- Der Spieler kann eine Stein- oder Eisenmine erzeugen, die zuerst durch</p><p>-- Begleichen der Kosten aufgebaut werden muss, bevor sie genutzt werden kann.</p><p>-- <br>Optional kann die Mine einstürzen, wenn sie erschöpft wurde.</p><p>-- <br><a href="API.CreateIOMine">Eine Mine anlegen</a></p><p>-- </p></p><p>-- <p></p><p>-- <b>Trebuchet-Baustellen:</b><br></p><p>-- Der Spieler kann Trebuchet mieten. Das Trebuchet fährt als Karren vor,</p><p>-- wird aufgebaut und kann anschließend benutzt werden.<br> Das Trebuchet fährt</p><p>-- ab, wenn die Munition alle ist oder der Spieler das Trebuchet abbaut.<br></p><p>-- Sobald ein Trebuchet zerstört wird oder sein Karren wieder am Lagerhaus</p><p>-- ankommt, wird die Baustelle wieder freigegeben.</p><p>-- <br><a href="API.CreateTrebuchetConstructionSite">Eine Baustelle anlegen</a></p><p>-- </p></p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Erstelle eine verschüttete Mine eines bestimmten Typs. Es können zudem eine</p><p>-- Bedingung und zwei verschiedene Callbacks vereinbart werden.</p><p>-- Minen können als "nicht auffüllbar" markiert werden. In diesem Fall werden</p><p>-- sie zusammenstützen, sobald die Rohstoffe verbraucht sind.</p><p>-- Verschüttete Minen können durch einen Helden in normale Minen umgewandelt</p><p>-- werden. FÜr diese Umwandlung können Kosten anfallen, müssen aber nicht. Es</p><p>-- dürfen immer maximal 2 Waren als Kosten verwendet werden.</p><p>-- Es können weitere Funktionen hinzugefügt werden, um die Mine anzupassen:</p><p>-- <ul></p><p>-- <li><u>Bedingung:</u> Eine Funktion, die true oder false zurückgeben muss.</p><p>-- Mit dieser Funktion wird bestimmt, ob die Mine gebaut werden darf.</li></p><p>-- <li><u>Callback Aktivierung:</u> Eine Funktion, die ausgeführt wird, wenn</p><p>-- die Mine erfolgreich aktiviert wurde (evtl. Kosten bezahlt und/oder</p><p>-- Bedingung erfüllt).</li></p><p>-- <li><u>Callback Erschöpft:</u> Eine Funktion, die ausgeführt wird, sobald</p><p>-- die Rohstoffe der Mine erschöpft sind.</li></p><p>-- </ul></p><p>-- <p><b>Alias</b>: CreateIOMine</p></p><p>-- @param _Position [string] Script Entity, die mit Mine ersetzt wird</p><p>-- @param _Type [number] Typ der Mine</p><p>-- @param _Costs [table] (optional) Kostentabelle</p><p>-- @param _NotRefillable [boolean] (optional) Die Mine wird weiterhin überwacht</p><p>-- @param _Condition [function] (optional) Bedingungsfunktion</p><p>-- @param _CreationCallback (optional) Funktion nach Kauf ausführen</p><p>-- @param _CallbackDepleted (optional) Funktion nach Ausbeutung ausführen</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- -- Beispiel für eine Mine</p><p>-- API.CreateIOMine("mine", Entities.B_IronMine, {Goods.G_Wood, 20}, true)</p><p>-- -- Die Mine kann für 20 Holz erschlossen werden. Sobald die Rohstoffe</p><p>-- -- erschöpft sind, stürzt die Mine zusammen.</p><p>function API.CreateIOMine(_Position, _Type, _Costs, _NotRefillable, _Condition, _CreationCallback, _CallbackDepleted)</p><p>    if GUI then</p><p>        API.Dbg("API.CreateIOMine: Can not be used from local script!");</p><p>        return;</p><p>    end</p><p>    AddOnInteractiveObjectTemplates.Global:CreateIOMine(_Position, _Type, _Costs, _NotRefillable, _Condition, _CreationCallback, _CallbackDepleted);</p><p>-- Erstelle eine verschüttete Eisenmine.</p><p>-- <p><b>Alias</b>: CreateIOIronMine</p></p><p>-- @param _Position [string] Script Entity, die mit Mine ersetzt wird</p><p>-- @param _Cost1Type [number] (optional) Kostenware 1</p><p>-- @param _Cost1Amount [number] (optional) Kostenmenge 1</p><p>-- @param _Cost2Type [number] (optional) Kostenware 2</p><p>-- @param _Cost2Amount [number] (optional) Kostenmenge 2</p><p>-- @param _NotRefillable [boolean] (optional) Mine wird nach Ausbeutung zerstört</p><p>-- @within Anwenderfunktionen</p><p>-- @see API.CreateIOMine</p><p>-- @usage</p><p>-- -- Beispiel für eine Mine</p><p>-- API.CreateIOMine("mine", Goods.G_Wood, 20)</p><p>function API.CreateIOIronMine(_Position, _Cost1Type, _Cost1Amount, _Cost2Type, _Cost2Amount, _NotRefillable)</p><p>    if GUI then</p><p>        API.Dbg("API.CreateIOIronMine: Can not be used from local script!");</p><p>        return;</p><p>    end</p><p>    AddOnInteractiveObjectTemplates.Global:CreateIOIronMine(_Position, _Cost1Type, _Cost1Amount, _Cost2Type, _Cost2Amount, _NotRefillable);</p><p>-- Erstelle eine verschüttete Steinmine.</p><p>-- <p><b>Alias</b>: CreateIOStoneMine</p></p><p>-- @param _Position [string] Script Entity, die mit Mine ersetzt wird</p><p>-- @param _Cost1Type [number] (optional) Kostenware 1</p><p>-- @param _Cost1Amount [number] (optional) Kostenmenge 1</p><p>-- @param _Cost2Type [number] (optional) Kostenware 2</p><p>-- @param _Cost2Amount [number] (optional) Kostenmenge 2</p><p>-- @param _NotRefillable [boolean] (optional) Mine wird nach Ausbeutung zerstört</p><p>-- @within Anwenderfunktionen</p><p>-- @see API.CreateIOMine</p><p>-- @usage</p><p>-- -- Beispiel für eine Mine</p><p>-- API.CreateIOMine("mine", Goods.G_Wood, 20)</p><p>function API.CreateIOStoneMine(_Position, _Cost1Type, _Cost1Amount, _Cost2Type, _Cost2Amount, _NotRefillable)</p><p>    if GUI then</p><p>        API.Dbg("API.CreateIOStoneMine: Can not be used from local script!");</p><p>        return;</p><p>    end</p><p>    AddOnInteractiveObjectTemplates.Global:CreateIOStoneMine(_Position, _Cost1Type, _Cost1Amount, _Cost2Type, _Cost2Amount, _NotRefillable);</p><p>-- Erzeugt eine Baustelle eines beliebigen Gebäudetyps an der Position.</p><p>-- Diese Baustelle kann durch einen Helden aktiviert werden. Dann wird ein</p><p>-- Siedler zur Baustelle eilen und das Gebäude aufbauen. Es ist egal, ob es</p><p>-- sich um ein Territorium des Spielers oder einer KI handelt.</p><p>-- Es ist dabei zu beachten, dass der Spieler, dem die Baustelle zugeordnet</p><p>-- wird, das Territorium besitzt, auf dem er bauen soll. Des weiteren muss</p><p>-- er über ein Lagerhaus/Hauptzelt verfügen.</p><p>-- <p><b>Hinweis:</b> Es kann vorkommen, dass das Model der Baustelle nicht</p><p>-- geladen wird. Dann ist der Boden der Baustelle schwarz. Sobald wenigstens</p><p>-- ein reguläres Gebäude gebaut wurde, sollte die Textur jedoch vorhanden sein.</p><p>-- </p></p><p>-- <p><b>Alias</b>: CreateIOBuildingSite</p></p><p>-- @param _Position [string] Zielpunkt</p><p>-- @param _PlayerID Besitzer des Gebäudes</p><p>-- @param _Type [number] Typ des Gebäudes</p><p>-- @param _Costs [table] (optional) Eigene Gebäudekosten</p><p>-- @param _Distance [number] (optional) Aktivierungsentfernung</p><p>-- @param _Icon [table] (optional) Icon des Schalters</p><p>-- @param _Title [string] (optional) Titel der Beschreibung</p><p>-- @param _Text [string] (optional) Text der Beschreibung</p><p>-- @param _Callback [function] (optional) Funktion nach Fertigstellung</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- -- Erzeugt eine Baustelle ohne besondere Einstellungen</p><p>-- API.CreateIOBuildingSite("haus", 1, Entities.B_Bakery)</p><p>-- -- Baustelle mit Kosten und Aktivierungsdistanz</p><p>-- API.CreateIOBuildingSite("haus", 1, Entities.B_Bakery, {Goods.G_Wood, 4}, 1000)</p><p>function API.CreateIOBuildingSite(_Position, _PlayerID, _Type, _Costs, _Distance, _Icon, _Title, _Text, _Callback)</p><p>    if GUI then</p><p>        API.Dbg("API.CreateIOBuildingSite: Can not be used from local script!");</p><p>        return;</p><p>    end</p><p>    AddOnInteractiveObjectTemplates.Global:CreateIOBuildingSite(_Position, _PlayerID, _Type, _Costs, _Distance, _Icon, _Title, _Text, _Callback);</p><p>-- Erstellt eine Schatztruhe mit einer zufälligen Menge an Waren</p><p>-- des angegebenen Typs.</p><p>-- Die Menge der Ware ist dabei zufällig und liegt zwischen dem Minimalwert</p><p>-- und dem Maximalwert. Optional kann eine Funktion angegeben werden, die</p><p>-- ausgeführt wird, wenn die Truhe geöffnet wird. Diese Funktion verhält sich</p><p>-- wie das Callback eines interaktiven Objektes.</p><p>-- <p><b>Alias</b>: CreateRandomChest</p></p><p>-- @param _Name [string] Name der zu ersetzenden Script Entity</p><p>-- @param _Good [number] Warentyp</p><p>-- @param _Min [number] Mindestmenge</p><p>-- @param _Max [number] Maximalmenge</p><p>-- @param _Callback [function] Callback-Funktion</p><p>-- @within Anwenderfunktionen</p><p>-- @usage</p><p>-- API.CreateRandomChest("chest", Goods.G_Gems, 100, 300, OnChestOpened)</p><p>function API.CreateRandomChest(_Name, _Good, _Min, _Max, _Callback)</p><p>    if GUI then</p><p>        API.Dbg("API.CreateRandomChest: Can not be used from local script!");</p><p>        return;</p><p>    end</p><p>    AddOnInteractiveObjectTemplates.Global:CreateRandomChest(_Name, _Good, _Min, _Max, _Callback);</p><p>-- Erstellt eine Schatztruhe mit einer zufälligen Menge Gold.</p><p>-- <p><b>Alias</b>: CreateRandomGoldChest</p></p><p>-- @param _Name [string] Name der zu ersetzenden Script Entity</p><p>-- @within Anwenderfunktionen</p><p>function API.CreateRandomGoldChest(_Name)</p><p>    if GUI then</p><p>        API.Dbg("API.CreateRandomGoldChest('" .._Name.. "')");</p><p>        return;</p><p>    end</p><p>    AddOnInteractiveObjectTemplates.Global:CreateRandomChest(_Name, Goods.G_Gold, 300, 600);</p><p>-- Erstellt eine Schatztruhe mit einer zufälligen Art und Menge</p><p>-- an Gütern.</p><p>-- Güter können seien: Eisen, Fisch, Fleisch, Getreide, Holz,</p><p>-- Honig, Kräuter, Milch, Stein, Wolle.</p><p>-- <p><b>Alias</b>: CreateRandomResourceChest</p></p><p>-- @param _Name [string] Name der zu ersetzenden Script Entity</p><p>-- @within Anwenderfunktionen</p><p>function API.CreateRandomResourceChest(_Name)</p><p>    if GUI then</p><p>        API.Bridge("API.CreateRandomResourceChest('" .._Name.. "')");</p><p>        return;</p><p>    end</p><p>    AddOnInteractiveObjectTemplates.Global:CreateRandomResourceChest(_Name);</p><p>-- Erstellt eine Schatztruhe mit einer zufälligen Art und Menge</p><p>-- an Luxusgütern.</p><p>-- Luxusgüter können seien: Edelsteine, Farben, Musikinstrumente</p><p>-- Salz oder Weihrauch.</p><p>-- <p><b>Alias</b>: CreateRandomLuxuryChest</p></p><p>-- @param _Name [string] Name der zu ersetzenden Script Entity</p><p>-- @within Anwenderfunktionen</p><p>function API.CreateRandomLuxuryChest(_Name)</p><p>    if GUI then</p><p>        API.Bridge("API.CreateRandomLuxuryChest('" .._Name.. "')");</p><p>        return;</p><p>    end</p><p>    AddOnInteractiveObjectTemplates.Global:CreateRandomLuxuryChest(_Name);</p><p>-- Erstellt eine Trebuchet-Baustelle an der Position mit den</p><p>-- angegebenen Baukosten.</p><p>-- Das Trebuchet kann von einem Helden aufgebaut werden. Es wird ein Karren</p><p>-- aus dem Lagerhaus zur Baustelle fahren. Erreicht der Karren die Baustelle,</p><p>-- wird er durch ein Trebuchet ersetzt.</p><p>-- Das Trebuchet hat dann 10 Schuss. Sind diese aufgebraucht wird das Trebuchet</p><p>-- abgebaut und fährt in das Lagerhaus zurück. Sobald der Karren angekommen</p><p>-- ist, kann die Baustelle erneut aktiviert werden.</p><p>-- <b>Achtung:</b>Das Auffüllen von Trebuchets wird deaktiviert, sobald eine</p><p>-- Baustelle erzeugt wird. Es wird NICHT empfohlen dem Spieler beides, normale</p><p>-- Trebuchets und Trebuchetbaustellen, zur gleichen Zeit zu geben!</p><p>-- <p><b>Alias</b>: CreateTrebuchetConstructionSite</p></p><p>-- @param _Name [string] Skriptname Position</p><p>-- @param _GoldCost Goldkosten</p><p>-- @param _WoodCost Holzkosten</p><p>-- @within Anwenderfunktionen</p><p>function API.CreateTrebuchetConstructionSite(_Name, _GoldCost, _WoodCost)</p><p>    if GUI then</p><p>        API.Bridge("API.CreateTrebuchetConstructionSite('" .._Name.. "', " .._GoldCost.. ", " .._WoodCost.. ")");</p><p>        return;</p><p>    end</p><p>    AddOnInteractiveObjectTemplates.Global:CreateTrebuchetConstructionSite(_Name, _GoldCost, _WoodCost);</p><p>-- Zerstört eine Trebuchet-Baustelle, aber nicht die Skript Entity.</p><p>-- Die Baustelle wird in jedem möglichen Status zerstört. Es ist egal, ob das</p><p>-- Trebuchet aufgebaut ist, gerade ein Karren unterwegs ist, oder die Baustelle</p><p>-- noch nie berührt wurde.</p><p>-- <p><b>Alias</b>: DestroyTrebuchetConstructionSite</p></p><p>-- @param _Name [string] Skriptname Position</p><p>-- @within Anwenderfunktionen</p><p>function API.DestroyTrebuchetConstructionSite(_Name)</p><p>    if GUI then</p><p>        API.Bridge("API.DestroyTrebuchetConstructionSite('" .._Name.. "')");</p><p>        return;</p><p>    end</p><p>    AddOnInteractiveObjectTemplates.Global:DestroyTrebuchetConstructionSite(_Name);</p><p>-- Gibt die EntityID aufgebaute Trebuchet der Trebuchet-Baustelle zurück.</p><p>-- Sollte kein Trebuchet aufgebaut sein, wird 0 zurückgegeben.</p><p>-- @param _Name [string] Skriptname der Trebuchet-Baustelle</p><p>-- @return [number] EntityID des Trebuchet</p><p>-- @within Anwenderfunktionen</p><p>function API.GetTrebuchetByTrebuchetConstructionSite(_Name)</p><p>    if GUI then</p><p>        API.Dbg("API.GetTrebuchetByTrebuchetConstructionSite: Can only be used in global script!");</p><p>        return;</p><p>    end</p><p>    if not self.Data.Trebuchet.Sites[_Name] then</p><p>        API.Warn("API.GetTrebuchetByTrebuchetConstructionSite: Site '" ..tostring(_Name).. "' does not exist!");</p><p>        return 0;</p><p>    end</p><p>    return self.Data.Trebuchet.Sites[_Name].ConstructedTrebuchet;</p><p>-- Gibt die EntityID des Anforderungswagens der Trebuchet-Baustelle zurück.</p><p>-- Sollte kein Anforderungswagen unterwegs sein, wird 0 zurückgegeben.</p><p>-- @param _Name [string] Skriptname der Trebuchet-Baustelle</p><p>-- @return [number] EntityID des angeforderten Wagens</p><p>-- @within Anwenderfunktionen</p><p>function API.GetReturningCartByTrebuchetConstructionSite(_Name)</p><p>    if GUI then</p><p>        API.Dbg("API.GetReturningCartByTrebuchetConstructionSite: Can only be used in global script!");</p><p>        return;</p><p>    end</p><p>    if not self.Data.Trebuchet.Sites[_Name] then</p><p>        API.Warn("API.GetReturningCartByTrebuchetConstructionSite: Site '" ..tostring(_Name).. "' does not exist!");</p><p>        return 0;</p><p>    end</p><p>    return self.Data.Trebuchet.Sites[_Name].ReturningCart;</p><p>-- Gibt die EntityID des Abreisewagens der Trebuchet-Baustelle zurück. Sollte</p><p>-- kein Abreisewagens unterwegs sein, wird 0 zurückgegeben.</p><p>-- @param _Name [string] Skriptname der Trebuchet-Baustelle</p><p>-- @return [number] EntityID des angeforderten Wagens</p><p>-- @within Anwenderfunktionen</p><p>function API.GetConstructionCartByTrebuchetConstructionSite(_Name)</p><p>    if GUI then</p><p>        API.Dbg("API.GetConstructionCartByTrebuchetConstructionSite: Can only be used in global script!");</p><p>        return;</p><p>    end</p><p>    if not self.Data.Trebuchet.Sites[_Name] then</p><p>        API.Warn("API.GetConstructionCartByTrebuchetConstructionSite: Site '" ..tostring(_Name).. "' does not exist!");</p><p>        return 0;</p><p>    end</p><p>    return self.Data.Trebuchet.Sites[_Name].ConstructionCart;</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>    Global = {</p><p>        Data = {</p><p>            ConstructionSite = {</p><p>                Sites = {},</p><p>                Description = {</p><p>                    Title = {</p><p>                        de = "Gebäude bauen",</p><p>                        en = "Create building",</p><p>                    },</p><p>                    Text = {</p><p>                        de = "Beauftragt den Bau eines Gebäudes. Ein Siedler wird aus"..</p><p>                             " dem Lagerhaus kommen und mit dem Bau beginnen.",</p><p>                        en = "Order a building. A worker will come out of the"..</p><p>                             " storehouse and erect it.",</p><p>                    },</p><p>                    Unfulfilled = {</p><p>                        de = "Das Gebäude kann derzeit nicht gebaut werden.",</p><p>                        en = "The building can not be built at the moment.",</p><p>                    },</p><p>                }</p><p>            },</p><p>            Mines = {</p><p>                Description = {</p><p>                    Title = {</p><p>                        de = "Mine errichten",</p><p>                        en = "Build pit",</p><p>                    },</p><p>                    Text = {</p><p>                        de = "An diesem Ort könnt Ihr eine Mine errichten!",</p><p>                        en = "You're able to create a pit at this location!",</p><p>                    },</p><p>                    Unfulfilled = {</p><p>                        de = "Die Mine kann nicht umgewandelt werden!",</p><p>                        en = "The mine can not be transformed!",</p><p>                    },</p><p>                },</p><p>            },</p><p>            Chests = {</p><p>                Description = {</p><p>                    Title = {</p><p>                        de = "Schatztruhe",</p><p>                        en = "Treasure Chest",</p><p>                    },</p><p>                    Text = {</p><p>                        de = "Diese Truhe enthält einen geheimen Schatz. Öffnet sie um den Schatz zu bergen.",</p><p>                        en = "This chest contains a secred treasure. Open it to salvage the treasure.",</p><p>                    },</p><p>                },</p><p>            },</p><p>            Trebuchet = {</p><p>                Error = {</p><p>                    de = "Euer Ritter benötigt einen höheren Titel!",</p><p>                    en = "Your knight need a higher title to use this site!",</p><p>                },</p><p>                Description = {</p><p>                    Title = {</p><p>                        de = "Trebuchet anfordern",</p><p>                        en = "Order trebuchet",</p><p>                    },</p><p>                    Text = {</p><p>                        de = "- Fordert ein Trebuchet aus der Stadt an {cr}- Trebuchet wird gebaut, wenn Wagen Baustelle erreicht {cr}- Fährt zurück, wenn Munition aufgebraucht {cr}- Trebuchet kann manuell zurückgeschickt werden",</p><p>                        en = "- Order a trebuchet from your city {cr}- The trebuchet is build after the cart has arrived {cr}- Returns after ammunition is depleted {cr}- The trebuchet can be manually send back to the city",</p><p>                    },</p><p>                },</p><p>                Sites = {},</p><p>                NeededKnightTitle = 0,</p><p>                IsActive = false,</p><p>            },</p><p>        }</p><p>    },</p><p>    Local = {</p><p>        Data = {},</p><p>    },</p><p>-- Global ----------------------------------------------------------------------</p><p>-- Initalisiert das AddOn.</p><p>-- @within Internal</p><p>-- @local</p><p>-- Initialisiert die interaktiven Trebuchet-Baustellen.</p><p>-- @within Internal</p><p>-- @local</p><p>    if not self.Data.Trebuchet.IsActive then</p><p>        GameCallback_QSB_OnDisambleTrebuchet = AddOnInteractiveObjectTemplates.Global.OnTrebuchetDisambled;</p><p>        GameCallback_QSB_OnErectTrebuchet = function() end;</p><p>        StartSimpleJobEx(self.WatchTrebuchetsAndCarts);</p><p>        API.DisableRefillTrebuchet(true);</p><p>        self.Data.Trebuchet.IsActive = true;</p><p>    end</p><p>-- Prüft, ob der menschliche Spieler einen ausreichenden Titel</p><p>-- hat um Trebuchets zu bauen.</p><p>-- @return boolean: Titel hoch genug</p><p>-- @within Internal</p><p>-- @local</p><p>    local pID = 1;</p><p>    for i=1,8 do</p><p>        if Logic.PlayerGetIsHumanFlag(i) == 1 then</p><p>            pID = i;</p><p>            break;</p><p>        end</p><p>    end</p><p>    return Logic.GetKnightTitle(pID) >= AddOnInteractiveObjectTemplates.Global.Data.Trebuchet.NeededKnightTitle;</p><p>-- Setzt den mindestens benötigten Titel um Trebuchets zu bauen.</p><p>-- @param _KnightTitle Titel</p><p>-- @within Internal</p><p>-- @local</p><p>    self.Data.Trebuchet.NeededKnightTitle = _KnightTitle;</p><p>-- Erstellt eine Trebuchet-Baustelle an der Position mit den</p><p>-- angegebenen Baukosten.</p><p>-- @param _Name [string] Skriptname Position</p><p>-- @param _GoldCost Goldkosten</p><p>-- @param _WoodCost Holzkosten</p><p>-- @within Internal</p><p>-- @local</p><p>    self:TrebuchetActivate();</p><p>    _GoldCost = _GoldCost or 4500;</p><p>    _WoodCost = _WoodCost or 35;</p><p>    local eID = GetID(_Name);</p><p>    Logic.SetModel(eID, Models.Buildings_B_BuildingPlot_8x8);</p><p>    Logic.SetVisible(eID, true);</p><p>    self.Data.Trebuchet.Sites[_Name] = {</p><p>        ConstructedTrebuchet = 0,</p><p>        ConstructionCart = 0,</p><p>        ReturningCart = 0,</p><p>    }</p><p>    CreateObject {</p><p>        Name                    = _Name,</p><p>        Title                   = self.Data.Trebuchet.Description.Title,</p><p>        Text                    = self.Data.Trebuchet.Description.Text,</p><p>        Costs                   = {Goods.G_Gold, _GoldCost, Goods.G_Wood, _WoodCost},</p><p>        Distance                = 1000,</p><p>        State                   = 0,</p><p>        Condition               = self.TrebuchetHasSufficentTitle,</p><p>        ConditionUnfulfilled    = self.Data.Trebuchet.Error,</p><p>        Callback                = function(t, PlayerID)</p><p>            AddOnInteractiveObjectTemplates.Global:SpawnTrebuchetCart(PlayerID, t.Name);</p><p>        end,</p><p>    }</p><p>-- Zerstört eine Trebuchet-Baustelle.</p><p>-- @param _Name [string] Skriptname Position</p><p>-- @within Internal</p><p>-- @local</p><p>    local ConstructionCart = self.Data.Trebuchet.Sites[_Name].ConstructionCart;</p><p>    DestroyEntity(ConstructionCart);</p><p>    local ConstructedTrebuchet = self.Data.Trebuchet.Sites[_Name].ConstructedTrebuchet;</p><p>    DestroyEntity(ConstructedTrebuchet);</p><p>    local ReturningCart = self.Data.Trebuchet.Sites[_Name].ReturningCart;</p><p>    DestroyEntity(ReturningCart);</p><p>    self.Data.Trebuchet.Sites[_Name] = nil;</p><p>    Logic.SetVisible(GetID(_Name), false);</p><p>    RemoveInteractiveObject(_Name);</p><p>-- Erzeugt einen Trebuchetwagen für die Baustelle.</p><p>-- @param _PlayerID Besitzer</p><p>-- @param _Site     Baustelle</p><p>-- @within Internal</p><p>-- @local</p><p>    local StoreID = Logic.GetStoreHouse(_PlayerID);</p><p>    local x,y = Logic.GetBuildingApproachPosition(StoreID);</p><p>    local CartID = Logic.CreateEntity(Entities.U_SiegeEngineCart, x, y, 0, _PlayerID);</p><p>    Logic.SetEntitySelectableFlag(CartID, 0);</p><p>    self.Data.Trebuchet.Sites[_Site].ConstructionCart = CartID;</p><p>-- Erzeugt das Trebuchet an der Baustelle.</p><p>-- @param _PlayerID Besitzer</p><p>-- @param _Site     Baustelle</p><p>-- @within Internal</p><p>-- @local</p><p>    local pos = GetPosition(_Site);</p><p>    local TrebuchetID = Logic.CreateEntity(Entities.U_Trebuchet, pos.X, pos.Y, 0, _PlayerID);</p><p>    self.Data.Trebuchet.Sites[_Site].ConstructedTrebuchet = TrebuchetID;</p><p>-- Baut das Trebuchet zum Wagen zurück und lässt es wieder ins</p><p>-- Lagerhaus des Besitzers fahren.</p><p>-- @param _PlayerID  Besitzer</p><p>-- @param _Trebuchet Baustelle</p><p>-- @within Internal</p><p>-- @local</p><p>    local x,y,z = Logic.EntityGetPos(_Trebuchet);</p><p>    local CartID = Logic.CreateEntity(Entities.U_SiegeEngineCart, x, y, 0, _PlayerID);</p><p>    Logic.SetEntitySelectableFlag(CartID, 0);</p><p>    local SiteName;</p><p>    for k,v in pairs(self.Data.Trebuchet.Sites) do</p><p>        if v.ConstructedTrebuchet == _Trebuchet then</p><p>            SiteName = k;</p><p>        end</p><p>    end</p><p>    if SiteName then</p><p>        self.Data.Trebuchet.Sites[SiteName].ReturningCart = CartID;</p><p>        self.Data.Trebuchet.Sites[SiteName].ConstructedTrebuchet = 0;</p><p>        Logic.SetVisible(GetID(SiteName), true);</p><p>        DestroyEntity(_Trebuchet);</p><p>    else</p><p>        DestroyEntity(CartID);</p><p>    end</p><p>-- Callback: Ein Trebuchet wird manuell zurückgebaut.</p><p>-- @param _EntityID Entity-ID des Trebuchet</p><p>-- @param _PlayerID Besitzer</p><p>-- @param _x        X-Position</p><p>-- @param _y        Y-Position</p><p>-- @param _z        Z-Position</p><p>-- @within Internal</p><p>-- @local</p><p>    AddOnInteractiveObjectTemplates.Global:ReturnTrebuchetToStorehouse(_PlayerID, _EntityID);</p><p>-- Steuert die Trebuchet-Mechanik.</p><p>-- @within Internal</p><p>-- @local</p><p>    for k,v in pairs(AddOnInteractiveObjectTemplates.Global.Data.Trebuchet.Sites) do</p><p>        local SiteID = GetID(k);</p><p>        -- Stufe 1: Karren kommt</p><p>        if v.ConstructionCart ~= 0 then</p><p>            -- Bauwagen wurde zerstört</p><p>            if not IsExisting(v.ConstructionCart) then</p><p>                AddOnInteractiveObjectTemplates.Global.Data.Trebuchet.Sites[k].ConstructionCart = 0;</p><p>                API.InteractiveObjectActivate(k);</p><p>            end</p><p>            -- Bauwagen bewegt sich nicht zum Ziel</p><p>            if not Logic.IsEntityMoving(v.ConstructionCart) then</p><p>                local SiteID = GetID(k);</p><p>                local x,y,z = Logic.EntityGetPos(SiteID);</p><p>                Logic.MoveSettler(v.ConstructionCart, x, y);</p><p>            end</p><p>            -- Bauwagen ist angekommen</p><p>            if IsNear(v.ConstructionCart, k, 500) then</p><p>                local x,y,z = Logic.EntityGetPos(SiteID);</p><p>                local PlayerID = Logic.EntityGetPlayer(v.ConstructionCart);</p><p>                AddOnInteractiveObjectTemplates.Global:SpawnTrebuchet(PlayerID, k);</p><p>                DestroyEntity(v.ConstructionCart);</p><p>                AddOnInteractiveObjectTemplates.Global.Data.Trebuchet.Sites[k].ConstructionCart = 0;</p><p>                Logic.SetVisible(SiteID, false);</p><p>                Logic.CreateEffect(EGL_Effects.E_Shockwave01, x, y, 0);</p><p>            end</p><p>        end</p><p>        -- Stufe 2: Trebuchet steht</p><p>        if v.ConstructedTrebuchet ~= 0 then</p><p>            -- Trebuchet wurde zerstört</p><p>            if not IsExisting(v.ConstructedTrebuchet) then</p><p>                AddOnInteractiveObjectTemplates.Global.Data.Trebuchet.Sites[k].ConstructedTrebuchet = 0;</p><p>                Logic.SetVisible(SiteID, true);</p><p>                API.InteractiveObjectActivate(k);</p><p>            end</p><p>            -- Trebuchet hat keine Munition</p><p>            if Logic.GetAmmunitionAmount(v.ConstructedTrebuchet) == 0 and BundleEntitySelection.Local.Data.RefillTrebuchet == false then</p><p>                local PlayerID = Logic.EntityGetPlayer(v.ConstructedTrebuchet);</p><p>                AddOnInteractiveObjectTemplates.Global:ReturnTrebuchetToStorehouse(PlayerID, v.ConstructedTrebuchet);</p><p>            end</p><p>        end</p><p>        -- Stufe 3: Rückweg</p><p>        if v.ReturningCart ~= 0 then</p><p>            -- Rückkehrwagen wurde zerstört</p><p>            if not IsExisting(v.ReturningCart) then</p><p>                AddOnInteractiveObjectTemplates.Global.Data.Trebuchet.Sites[k].ReturningCart = 0;</p><p>                API.InteractiveObjectActivate(k);</p><p>            end</p><p>            local PlayerID = Logic.EntityGetPlayer(v.ReturningCart);</p><p>            local StoreID = Logic.GetStoreHouse(PlayerID);</p><p>            -- Rückkehrwagen muss sich zum Ziel bewegen</p><p>            if not Logic.IsEntityMoving(v.ReturningCart) then</p><p>                local x,y = Logic.GetBuildingApproachPosition(StoreID);</p><p>                Logic.MoveSettler(v.ReturningCart, x, y);</p><p>            end</p><p>            -- Rückkehrwagen kommt an</p><p>            if IsNear(v.ReturningCart, StoreID, 1100) then</p><p>                local PlayerID = Logic.EntityGetPlayer(v.ConstructionCart);</p><p>                DestroyEntity(v.ReturningCart);</p><p>            end</p><p>        end</p><p>    end</p><p>-- Erstellt eine Schatztruhe mit einer zufälligen Menge an Waren</p><p>-- des angegebenen Typs.</p><p>-- @param _Name [string] Name der zu ersetzenden Script Entity</p><p>-- @param _Good [number] Warentyp</p><p>-- @param _Min [number] Mindestmenge</p><p>-- @param _Max [number] Maximalmenge</p><p>-- @param _Callback [function] Callback-Funktion</p><p>-- @within Internal</p><p>-- @local</p><p>    _Min = (_Min ~= nil and _Min > 0 and _Min) or 1;</p><p>    _Max = (_Max ~= nil and _Max > 1 and _Max) or 2;</p><p>    if not _Callback then</p><p>        _Callback = function(t) end</p><p>    end</p><p>    assert(_Good ~= nil, "CreateRandomChest: Good does not exist!");</p><p>    assert(_Min < _Max, "CreateRandomChest: min amount must be smaller than max amount!");</p><p>    local eID = ReplaceEntity(_Name, Entities.XD_ScriptEntity, 0);</p><p>    Logic.SetModel(eID, Models.Doodads_D_X_ChestClose);</p><p>    Logic.SetVisible(eID, true);</p><p>    CreateObject {</p><p>        Name                    = _Name,</p><p>        Title                   = self.Data.Chests.Description.Title,</p><p>        Text                    = self.Data.Chests.Description.Text,</p><p>        Reward                  = {_Good, math.random(_Min, _Max)},</p><p>        Texture                 = {1, 6},</p><p>        Distance                = 650,</p><p>        State                   = 0,</p><p>        CallbackOpened          = _Callback,</p><p>        Callback                = function(_Data)</p><p>            ReplaceEntity(_Data.Name, Entities.D_X_ChestOpenEmpty);</p><p>            _Data.CallbackOpened(_Data);</p><p>        end,</p><p>    }</p><p>-- Erstellt eine Schatztruhe mit einer zufälligen Menge an Gold</p><p>-- des angegebenen Typs.</p><p>-- @param _Name [string] Name der zu ersetzenden Script Entity</p><p>-- @within Internal</p><p>-- @local</p><p>    AddOnInteractiveObjectTemplates.Global:CreateRandomChest(_Name, Goods.G_Gold, 300, 600);</p><p>-- Erstellt eine Schatztruhe mit einer zufälligen Art und Menge</p><p>-- an Gütern.</p><p>-- Güter können seien: Eisen, Fisch, Fleisch, Getreide, Holz,</p><p>-- Honig, Kräuter, Milch, Stein, Wolle.</p><p>-- @param _Name [string] Name der zu ersetzenden Script Entity</p><p>-- @within Internal</p><p>-- @local</p><p>    local PossibleGoods = {</p><p>        Goods.G_Iron, Goods.G_Stone, Goods.G_Wood, Goods.G_Wool,</p><p>        Goods.G_Carcass, Goods.G_Herb, Goods.G_Honeycomb,</p><p>        Goods.G_Milk, Goods.G_RawFish, Goods.G_Grain</p><p>    };</p><p>    local Good = PossibleGoods[math.random(1, #PossibleGoods)];</p><p>    AddOnInteractiveObjectTemplates.Global:CreateRandomChest(_Name, Good, 30, 60);</p><p>-- Erstellt eine Schatztruhe mit einer zufälligen Art und Menge</p><p>-- an Luxusgütern.</p><p>-- Luxusgüter können seien: Edelsteine, Farben, Musikinstrumente</p><p>-- Salz oder Weihrauch.</p><p>-- @param _Name [string] Name der zu ersetzenden Script Entity</p><p>-- @within Internal</p><p>-- @local</p><p>    local Luxury = {Goods.G_Salt, Goods.G_Dye};</p><p>    if g_GameExtraNo >= 1 then</p><p>        table.insert(Luxury, Goods.G_Gems);</p><p>        table.insert(Luxury, Goods.G_MusicalInstrument);</p><p>        table.insert(Luxury, Goods.G_Olibanum);</p><p>    end</p><p>    local Good = Luxury[math.random(1, #Luxury)];</p><p>    AddOnInteractiveObjectTemplates.Global:CreateRandomChest(_Name, Good, 50, 100);</p><p>-- Erstelle eine Mine eines bestimmten Typs. Es können zudem eine Bedingung</p><p>-- und zwei verschiedene Callbacks vereinbart werden.</p><p>-- @param _Position [string] Script Entity, die mit Mine ersetzt wird</p><p>-- @param _Type [number] Typ der Mine</p><p>-- @param _Costs [table] (optional) Kostentabelle</p><p>-- @param _NotRefillable [boolean] (optional) Die Mine wird weiterhin überwacht</p><p>-- @param _Condition [function] (optional) Bedingungsfunktion</p><p>-- @param _CreationCallback (optional) Funktion nach Kauf ausführen</p><p>-- @param _CallbackDepleted (optional) Funktion nach Ausbeutung ausführen</p><p>-- @within Internal</p><p>-- @local</p><p>    -- Objekt austauschen und Model anpassen</p><p>    local eID = ReplaceEntity(_Position, Entities.XD_ScriptEntity);</p><p>    local Model = Models.Doodads_D_SE_ResourceIron_Wrecked;</p><p>    if _Type == Entities.R_StoneMine then</p><p>        Model = Models.R_SE_ResorceStone_10;</p><p>    end</p><p>    Logic.SetVisible(eID, true);</p><p>    Logic.SetModel(eID, Model);</p><p>    local x, y, z = Logic.EntityGetPos(eID);</p><p>    local BlockerID = Logic.CreateEntity(Entities.D_ME_Rock_Set01_B_07, x, y, 0, 0);</p><p>    Logic.SetVisible(BlockerID, false);</p><p>    CreateObject {</p><p>        Name                 = _Position,</p><p>        Title                = self.Data.Mines.Description.Title,</p><p>        Text                 = self.Data.Mines.Description.Text,</p><p>        Type                 = _Type,</p><p>        Special              = _NotRefillable,</p><p>        Costs                = _Costs,</p><p>        InvisibleBlocker     = BlockerID,</p><p>        Distance             = 1500,</p><p>        Condition            = self.ConditionBuildIOMine,</p><p>        CustomCondition      = _Condition,</p><p>        ConditionUnfulfilled = self.Data.Mines.Description.Unfulfilled,</p><p>        CallbackCreate       = _CreationCallback,</p><p>        CallbackDepleted     = _CallbackDepleted,</p><p>        Callback             = self.ActionBuildIOMine,</p><p>    };</p><p>-- Erstelle eine verschüttete Eisenmine.</p><p>-- @param _Position [string] Script Entity, die mit Mine ersetzt wird</p><p>-- @param _Cost1Type [number] (optional) Kostenware 1</p><p>-- @param _Cost1Amount [number] (optional) Kostenmenge 1</p><p>-- @param _Cost2Type [number] (optional) Kostenware 2</p><p>-- @param _Cost2Amount [number] (optional) Kostenmenge 2</p><p>-- @param _NotRefillable [boolean] (optional) Mine wird nach Ausbeutung zerstört</p><p>-- @within Internal</p><p>-- @local</p><p>    assert(IsExisting(_Position));</p><p>    if _Cost1Type then</p><p>        assert(API.TraverseTable(_Cost1Type, Goods));</p><p>        assert(type(_Cost1Amount) == "number");</p><p>    end</p><p>    if _Cost2Type then</p><p>        assert(API.TraverseTable(_Cost2Type, Goods));</p><p>        assert(type(_Cost2Amount) == "number");</p><p>    end</p><p>    self:CreateIOMine(</p><p>        _Position, Entities.R_IronMine,</p><p>        {_Cost1Type, _Cost1Amount, _Cost2Type, _Cost2Amount},</p><p>        _NotRefillable</p><p>    );</p><p>-- Erstelle eine verschüttete Steinmine.</p><p>-- @param _Position [string] Script Entity, die mit Mine ersetzt wird</p><p>-- @param _Cost1Type [number] (optional) Kostenware 1</p><p>-- @param _Cost1Amount [number] (optional) Kostenmenge 1</p><p>-- @param _Cost2Type [number] (optional) Kostenware 2</p><p>-- @param _Cost2Amount [number] (optional) Kostenmenge 2</p><p>-- @param _NotRefillable [boolean] (optional) Mine wird nach Ausbeutung zerstört</p><p>-- @within Internal</p><p>-- @local</p><p>    assert(IsExisting(_Position));</p><p>    if _Cost1Type then</p><p>        assert(API.TraverseTable(_Cost1Type, Goods));</p><p>        assert(type(_Cost1Amount) == "number");</p><p>    end</p><p>    if _Cost2Type then</p><p>        assert(API.TraverseTable(_Cost2Type, Goods));</p><p>        assert(type(_Cost2Amount) == "number");</p><p>    end</p><p>    self:CreateIOMine(</p><p>        _Position, Entities.R_StoneMine,</p><p>        {_Cost1Type, _Cost1Amount, _Cost2Type, _Cost2Amount},</p><p>        _NotRefillable</p><p>    );</p><p>-- Testet die Bedingung, unter der die Mine errichtet werden kann.</p><p>-- @param _Data Daten des Objektes</p><p>-- @return boolean: Bedingung erfüllt</p><p>-- @within Internal</p><p>-- @local</p><p>    if _Data.CustomCondition then</p><p>        return _Data.CustomCondition(_Data) == true;</p><p>    end</p><p>    return true;</p><p>    ReplaceEntity(_Data.Name, _Data.Type);</p><p>    DestroyEntity(_Data.InvisibleBlocker);</p><p>    if type(_Data.CallbackCreate) == "function" then</p><p>        _Data.CallbackCreate(_Data);</p><p>    end</p><p>    Trigger.RequestTrigger( Events.LOGIC_EVENT_EVERY_SECOND, "", "ControlIOMine", 1, {}, { _Data.Name });</p><p>-- Prüft gebaute Minen ob diese ausgebeutet sind. Ist das der Fall</p><p>-- werden sie "zerstört" und ggf. das Callback ausgelöst.</p><p>-- @param _Mine Zu überwachende Mine</p><p>-- @return boolean: Job beendet</p><p>-- @within Internal</p><p>-- @local</p><p>    if not IO[_Mine] then</p><p>        return true;</p><p>    end</p><p>    if not IsExisting(_Mine) then</p><p>        return true;</p><p>    end</p><p>    local eID = GetID(_Mine);</p><p>    if Logic.GetResourceDoodadGoodAmount(eID) == 0 then</p><p>        if IO[_Mine].Special == true then</p><p>            local Model = Models.Doodads_D_SE_ResourceIron_Wrecked;</p><p>            if IO[_Mine].Type == Entities.R_StoneMine then</p><p>                Model = Models.R_ResorceStone_Scaffold_Destroyed;</p><p>            end</p><p>            eID = ReplaceEntity(eID, Entities.XD_ScriptEntity);</p><p>            Logic.SetVisible(eID, true);</p><p>            Logic.SetModel(eID, Model);</p><p>        end</p><p>        if type(IO[_Mine].CallbackDepleted) == "function" then</p><p>            IO[_Mine].CallbackDepleted(IO[_Mine]);</p><p>        end</p><p>        return true;</p><p>    end</p><p>-- Initialisiert die interaktiven Baustellen.</p><p>-- @within Internal</p><p>-- @local</p><p>    if self.Data.ConstructionSiteActivated then</p><p>        return;</p><p>    end</p><p>    self.Data.ConstructionSiteActivated = true;</p><p>    Core:AppendFunction(</p><p>        "GameCallback_OnBuildingConstructionComplete",</p><p>        self.OnConstructionComplete</p><p>    );</p><p>-- Ruft das Callback einer Baustelle auf, sofern eins definiert wurde.</p><p>-- @param _PlayerID Besitzer des Gebäudes</p><p>-- @param _EntityID Entity-ID des Gebäudes</p><p>-- @within Internal</p><p>-- @local</p><p>    local IO = AddOnInteractiveObjectTemplates.Global.Data.ConstructionSite.Sites[_EntityID];</p><p>    if IO ~= nil and IO.CompletedCallback then</p><p>        IO.CompletedCallback(IO, _EntityID);</p><p>    end</p><p>-- Erzeugt eine echte Baustelle an der Position. Ein Siedler wird das Gebäude</p><p>-- aufbauen.</p><p>-- @param _Position [string] Zielpunkt</p><p>-- @param _PlayerID Besitzer des Gebäudes</p><p>-- @param _Type [number] Typ des Gebäudes</p><p>-- @param _Costs [table] (optional) Eigene Gebäudekosten</p><p>-- @param _Distance [number] (optional) Aktivierungsentfernung</p><p>-- @param _Icon [table] (optional) Icon des Schalters</p><p>-- @param _Title [string] (optional) Titel der Beschreibung</p><p>-- @param _Text [string] (optional) Text der Beschreibung</p><p>-- @param _Callback [function] (optional) Funktion nach fertigstellung</p><p>-- @within Internal</p><p>-- @local</p><p>    AddOnInteractiveObjectTemplates.Global:ConstructionSiteActivate();</p><p>    local Costs = _Costs or {Logic.GetEntityTypeFullCost(_Type)};</p><p>    local Title = _Title or self.Data.ConstructionSite.Description.Title;</p><p>    local Text  = Text or self.Data.ConstructionSite.Description.Text;</p><p>    local eID = GetID(_Position);</p><p>    Logic.SetModel(eID, Models.Buildings_B_BuildingPlot_10x10);</p><p>    Logic.SetVisible(eID, true);</p><p>    CreateObject {</p><p>        Name                 = _Position,</p><p>        Title                = Title,</p><p>        Text                 = Text,</p><p>        Texture              = _Icon or {14, 10},</p><p>        Distance             = _Distance or 1500,</p><p>        Type                 = _Type,</p><p>        Costs                = Costs,</p><p>        Condition            = AddOnInteractiveObjectTemplates.Global.ConditionConstructionSite,</p><p>        ConditionUnfulfilled = AddOnInteractiveObjectTemplates.Global.Data.ConstructionSite.Description.Unfulfilled,</p><p>        PlayerID             = _PlayerID,</p><p>        CompletedCallback    = _Callback,</p><p>        Callback             = AddOnInteractiveObjectTemplates.Global.CallbackIOConstructionSite;</p><p>    };</p><p>-- Lässt einen Siedler die Baustelle zum Gebäude aufbauen.</p><p>-- @param _Data Daten des Objekt</p><p>-- @within Internal</p><p>-- @local</p><p>    local pos  = GetPosition(_Data.Name);</p><p>    local eID  = GetID(_Data.Name);</p><p>    local ori  = Logic.GetEntityOrientation(eID);</p><p>    local site = Logic.CreateConstructionSite(pos.X, pos.Y, ori, _Data.Type, _Data.PlayerID);</p><p>    Logic.SetVisible(eID, false);</p><p>    if (site == nil) then</p><p>        API.Dbg('AddOnInteractiveObjectTemplates.Global:CreateIOBuildingSite: Failed to place construction site!');</p><p>        return;</p><p>    end</p><p>    AddOnInteractiveObjectTemplates.Global.Data.ConstructionSite.Sites[site] = _Data;</p><p>    StartSimpleJobEx(AddOnInteractiveObjectTemplates.Global.ControlConstructionSite, site);</p><p>-- Prüft ob das Gebäude theoretisch gebaut werden kann.</p><p>-- @param _Data Daten des Objekt</p><p>-- @return boolean: Kann aktiviert werden</p><p>-- @within Internal</p><p>-- @local</p><p>    local eID = GetID(_Data.Name);</p><p>    local tID = GetTerritoryUnderEntity(eID);</p><p>    local pID = Logic.GetTerritoryPlayerID(tID);</p><p>    if Logic.GetStoreHouse(_Data.PlayerID) == 0 then</p><p>        return false;</p><p>    end</p><p>    if _Data.PlayerID ~= pID then</p><p>        return false;</p><p>    end</p><p>    return true;</p><p>-- Überwacht eine Gebäudebaustelle und reaktiviert sie falls nötig.</p><p>-- @param _eID EntityID des Gebäudes</p><p>-- @return boolean: Job beenden</p><p>-- @within Internal</p><p>-- @local</p><p>    if AddOnInteractiveObjectTemplates.Global.Data.ConstructionSite.Sites[_eID] == nil then</p><p>        return true;</p><p>    end</p><p>    if not IsExisting(_eID) then</p><p>        local Name = AddOnInteractiveObjectTemplates.Global.Data.ConstructionSite.Sites[_eID].Name;</p><p>        Logic.SetVisible(GetID(Name), true);</p><p>        API.InteractiveObjectActivate(Name);</p><p>        return true;</p><p>    end</p><p>-- Local -----------------------------------------------------------------------</p><p>-- Initalisiert das AddOn.</p><p>-- @within Internal</p><p>-- @local</p></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/addonquestdebug.lua.html">
            <div class='doclink'>
                <div>AddOnQuestDebug</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><p>-- -------------------------------------------------------------------------- --</p><p>-- ########################################################################## --</p><p>-- #  Symfonia AddOnQuestDebug                                              # --</p><p>-- ########################################################################## --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Erweitert den mitgelieferten Debug des Spiels um eine Vielzahl nützlicher</p><p>-- neuer Möglichkeiten.</p><p>-- Die wichtigste Neuerung ist die Konsole, die es erlaubt Quests direkt über</p><p>-- die Eingabe von Befehlen zu steuern, einzelne einfache Lua-Kommandos im</p><p>-- Spiel auszuführen und sogar komplette Skripte zu laden.</p><p>-- <p><a href="API.ActivateDebugMode">Debug starten</a></p></p><p>-- @within Modulbeschreibung</p><p>-- @set sort=true</p><p>    Global =  {</p><p>        Data = {},</p><p>    },</p><p>    Local = {</p><p>        Data = {},</p><p>    },</p><p>-- -------------------------------------------------------------------------- --</p><p>-- User-Space                                                                 --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Aktiviert den Debug.</p><p>-- Der Developing Mode bietet viele Hotkeys und eine Konsole. Die Konsole ist</p><p>-- ein mächtiges Werkzeug. Es ist möglich tief in das Spiel einzugreifen und</p><p>-- sogar Funktionen während des Spiels zu überschreiben.</p><p>-- Die Konsole kann über <b>SHIFT + ^</b> geöffnet werden.</p><p>-- <p><b>Alias:</b> ActivateDebugMode</p></p><p>-- <h3>Cheats</h3></p><p>-- <table border="1"></p><p>-- <tr></p><p>-- <td><b>Cheat</b></td></p><p>-- <td><b>Beschreibung</b></td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>SHIFT + ^</td></p><p>-- <td>Konsole öffnen</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>CTRL + C</td></p><p>-- <td>Zeitanzeige an/aus</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>CTRL + SHIFT + F</td></p><p>-- <td>Nebel des Krieges abschalten</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>STRG + G</td></p><p>-- <td>GUI ausschalten</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>ALT + F10</td></p><p>-- <td>Selektiertes Gebäude anzünden</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>ALT + F11</td></p><p>-- <td>Selektierte Einheit verwunden</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>ALT + F12</td></p><p>-- <td>Alle Rechte freigeben / wieder sperren</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>CTRL + SHIFT + 1</td></p><p>-- <td>FPS-Anzeige</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>CTRL + (Num) 4</td></p><p>-- <td>Bogenschützen unter der Maus spawnen</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>CTRL + (Num) 5</td></p><p>-- <td>Schwertkämpfer unter der Maus spawnen</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>CTRL + (Num) 6</td></p><p>-- <td>Katapultkarren unter der Maus spawnen</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>CTRL + (Num) 7</td></p><p>-- <td>Ramme unter der Maus spawnen</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>CTRL + (Num) 8</td></p><p>-- <td>Belagerungsturm unter der Maus spawnen</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>CTRL + (Num) 9</td></p><p>-- <td>Katapult unter der Maus spawnen</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>(Num) +</td></p><p>-- <td>Spiel beschleunigen</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>(Num) -</td></p><p>-- <td>Spiel verlangsamen</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>(Num) *</td></p><p>-- <td>Geschwindigkeit zurücksetzen</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>CTRL + F1</td></p><p>-- <td>+ 50 Gold</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>CTRL + F2</td></p><p>-- <td>+ 10 Holz</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>CTRL + F3</td></p><p>-- <td>+ 10 Stein</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>CTRL + F4</td></p><p>-- <td>+ 10 Getreide</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>CTRL + F5</td></p><p>-- <td>+ 10 Milch</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>CTRL + F6</td></p><p>-- <td>+ 10 Kräuter</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>CTRL + F7</td></p><p>-- <td>+ 10 Wolle</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>CTRL + F8</td></p><p>-- <td>+ 10 auf alle Waren</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>SHIFT + F1</td></p><p>-- <td>+ 10 Honig</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>SHIFT + F2</td></p><p>-- <td>+ 10 Eisen</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>SHIFT + F3</td></p><p>-- <td>+ 10 Fisch</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>SHIFT + F4</td></p><p>-- <td>+ 10 Wild</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>CTRL + SHIFT + F1</td></p><p>-- <td>+ 10 Brot</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>CTRL + SHIFT + F2</td></p><p>-- <td>+ 10 Seife</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>CTRL + SHIFT + F3</td></p><p>-- <td>+ 10 Met</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>CTRL + SHIFT + F4</td></p><p>-- <td>+ 10 Medizin</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>CTRL + SHIFT + F5</td></p><p>-- <td>+ 10 Käse</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>CTRL + SHIFT + F6</td></p><p>-- <td>+ 10 Wurst</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>CTRL + F9</td></p><p>-- <td>Nahrung für selektiertes Gebäude erhöhen</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>SHIFT + F9</td></p><p>-- <td>Nahrung für selektiertes Gebäude verringern</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>CTRL + F10</td></p><p>-- <td>Kleidung für selektiertes Gebäude erhöhen</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>SHIFT + F10</td></p><p>-- <td>Kleidung für selektiertes Gebäude verringern</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>CTRL + F11</td></p><p>-- <td>Hygiene für selektiertes Gebäude erhöhen</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>SHIFT + F11</td></p><p>-- <td>Hygiene für selektiertes Gebäude verringern</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>CTRL + F12</td></p><p>-- <td>Unterhaltung für selektiertes Gebäude erhöhen</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>SHIFT + F12</td></p><p>-- <td>Unterhaltung für selektiertes Gebäude verringern</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>ALT + CTRL + F10</td></p><p>-- <td>Einnahmen des selektierten Gebäudes erhöhen</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>ALT + (Num) 1</td></p><p>-- <td>Burg selektiert → Gold verringern, Werkstatt selektiert → Ware verringern</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>ALT + (Num) 2</td></p><p>-- <td>Burg selektiert → Gold erhöhen, Werkstatt selektiert → Ware erhöhen</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>CTRL + ALT + 1</td></p><p>-- <td>Kontrolle über Spieler 1</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>CTRL + ALT + 2</td></p><p>-- <td>Kontrolle über Spieler 2</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>CTRL + ALT + 3</td></p><p>-- <td>Kontrolle über Spieler 3</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>CTRL + ALT + 4</td></p><p>-- <td>Kontrolle über Spieler 4</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>CTRL + ALT + 5</td></p><p>-- <td>Kontrolle über Spieler 5</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>CTRL + ALT + 6</td></p><p>-- <td>Kontrolle über Spieler 6</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>CTRL + ALT + 7</td></p><p>-- <td>Kontrolle über Spieler 7</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>CTRL + ALT + 8</td></p><p>-- <td>Kontrolle über Spieler 8</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>CTRL + (Num) 0</td></p><p>-- <td>Kamera durchschalten</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>CTRL + (Num) 1</td></p><p>-- <td>Kamerasprünge im RTS-Mode</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>CTRL + SHIFT + V</td></p><p>-- <td>Territorien anzeigen</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>CTRL + SHIFT + B</td></p><p>-- <td>Blocking anzeigen</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>CTRL + SHIFT + N</td></p><p>-- <td>Gitter verstecken</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>CTRL + SHIFT + F9</td></p><p>-- <td>DEBUG-Ausgabe einschalten</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>ALT + F9</td></p><p>-- <td>Zufälligen Arbeiter verheiraten</td></p><p>-- </tr></p><p>-- </table></p><p>-- <h3>Konsolenbefehle</h3></p><p>-- <table border=1></p><p>-- <tr></p><p>-- <th><b>Befehl</b></th></p><p>-- <th><b>Parameter</b></th></p><p>-- <th><b>Beschreibung</b></th></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>clear</td></p><p>-- <td></td></p><p>-- <td>Entfernt alle Textnachrichten im Debug-Window.</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>diplomacy</td></p><p>-- <td>PlayerID1, PlayerID2, Diplomacy</td></p><p>-- <td>Ändert die Doplomatischen Beziehungen zwischen zwei Parteien</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>restartmap</td></p><p>-- <td></td></p><p>-- <td>Startet die Map sofort neu.</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>shareview</td></p><p>-- <td>PlayerID1, PlayerID2, ActiveFlag</td></p><p>-- <td>Teilt die Sicht zweier Parteien oder hebt es wieder auf.</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>setposition</td></p><p>-- <td>Entity, Target</td></p><p>-- <td>Versetzt ein Entity zu einer neuen Position.</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>version</td></p><p>-- <td></td></p><p>-- <td>Zeigt die Version der QSB an.</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>stop</td></p><p>-- <td>QuestName</td></p><p>-- <td>Unterbricht den angegebenen Quest.</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>start</td></p><p>-- <td>QuestName</td></p><p>-- <td>Startet den angegebenen Quest.</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>win</td></p><p>-- <td>QuestName</td></p><p>-- <td>Schließt den angegebenen Quest erfolgreich ab.</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>fail</td></p><p>-- <td>QuestName</td></p><p>-- <td>Lässt den angegebenen Quest fehlschlagen</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>restart</td></p><p>-- <td>QuestName</td></p><p>-- <td>Startet den angegebenen Quest neu.</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>printequal</td></p><p>-- <td>Pattern</td></p><p>-- <td>Gibt die Namen aller Quests aus, die das Pattern enthalten.</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>printactive</td></p><p>-- <td></td></p><p>-- <td>Gibt die namen aller aktiven Quests aus.</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>printdetail</td></p><p>-- <td>QuestName</td></p><p>-- <td>Zeigt genauere Informationen zum angegebenen Quest an.</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>gload</td></p><p>-- <td>Path</td></p><p>-- <td>Läd ein Skript zur Laufzeit ins globale Skript.</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>lload</td></p><p>-- <td>Path</td></p><p>-- <td>Läd ein Skript zur Laufzeit ins lokale Skript.</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>gexec</td></p><p>-- <td>Command</td></p><p>-- <td>Führt die Eingabe als Lua-Befahl im globalen Skript aus.</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>lexec</td></p><p>-- <td>Command</td></p><p>-- <td>Führt die Eingabe als Lua-Befahl im lokalen Skript aus.</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>collectgarbage</td></p><p>-- <td></td></p><p>-- <td>Löst die Garbage Collection von Lua aus.</td></p><p>-- </tr></p><p>-- <tr></p><p>-- <td>dumpmemory</td></p><p>-- <td></td></p><p>-- <td>Zeigt die Größe des Speichers an, der von Lua belegt wird.</td></p><p>-- </tr></p><p>-- </table></p><p>-- @param _CheckAtRun [boolean] Prüfe Quests zur Laufzeit</p><p>-- @param _TraceQuests [boolean] Aktiviert Questverfolgung</p><p>-- @param _DevelopingCheats [boolean] Aktiviert Cheats und Konsole</p><p>-- @param _DevelopingShell [boolean] Aktiviert Cheats und Konsole</p><p>-- @see Reward_DEBUG</p><p>-- @within Anwenderfunktionen</p><p>function API.ActivateDebugMode(_CheckAtRun, _TraceQuests, _DevelopingCheats, _DevelopingShell)</p><p>    if GUI then</p><p>        API.Bridge("API.ActivateDebugMode(" ..tostring(_CheckAtRun).. ", " ..tostring(_TraceQuests).. ", " ..tostring(_DevelopingCheats).. ", " ..tostring(_DevelopingShell).. ")");</p><p>        return;</p><p>    end</p><p>    AddOnQuestDebug.Global:ActivateDebug(_CheckAtRun, _TraceQuests, _DevelopingCheats, _DevelopingShell);</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Rewards                                                                    --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Aktiviert den Debug.</p><p>-- @param _CheckAtRun [boolean] Prüfe Quests zur Laufzeit</p><p>-- @param _TraceQuests [boolean] Aktiviert Questverfolgung</p><p>-- @param _DevelopingCheats [boolean] Aktiviert Cheats</p><p>-- @param _DevelopingShell [boolean] Aktiviert Konsole</p><p>-- @see API.ActivateDebugMode</p><p>-- @within Reward</p><p>    return b_Reward_DEBUG:new(...);</p><p>Reward_DEBUG</p><p>    Name = "Reward_DEBUG",</p><p>    Description = {</p><p>        en = "Reward: Start the debug mode. See documentation for more information.",</p><p>        de = "Lohn: Startet den Debug-Modus. Für mehr Informationen siehe Dokumentation.",</p><p>    },</p><p>    Parameter = {</p><p>        { ParameterType.Custom,     en = "Check quest while runtime", de = "Quests zur Laufzeit prüfen" },</p><p>        { ParameterType.Custom,     en = "Use quest trace", de = "Questverfolgung" },</p><p>        { ParameterType.Custom,     en = "Activate developing cheats", de = "Testmodus aktivieren" },</p><p>        { ParameterType.Custom,     en = "Activate developing shell", de = "Testmodus aktivieren" },</p><p>    },</p><p>    return { Reward.Custom, {self, self.CustomFunction} }</p><p>    if (_Index == 1) then</p><p>        self.CheckWhileRuntime = AcceptAlternativeBoolean(_Parameter)</p><p>    elseif (_Index == 2) then</p><p>        self.UseQuestTrace = AcceptAlternativeBoolean(_Parameter)</p><p>    elseif (_Index == 3) then</p><p>        self.DelepoingCheats = AcceptAlternativeBoolean(_Parameter)</p><p>    elseif (_Index == 3) then</p><p>        self.DelepoingShell = AcceptAlternativeBoolean(_Parameter)</p><p>    end</p><p>    API.ActivateDebugMode(self.CheckWhileRuntime, self.UseQuestTrace, self.DelepoingCheats, self.DelepoingShell);</p><p>    return {"true","false"};</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Application-Space                                                          --</p><p>-- -------------------------------------------------------------------------- --</p><p>-- Global Script ---------------------------------------------------------------</p><p>-- Initalisiert das Bundle im globalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>    AddOnQuestDebug.Global.Data.DebugCommands = {</p><p>        -- groupless commands</p><p>        {"clear",               AddOnQuestDebug.Global.Clear,},</p><p>        {"diplomacy",           AddOnQuestDebug.Global.Diplomacy,},</p><p>        {"restartmap",          AddOnQuestDebug.Global.RestartMap,},</p><p>        {"shareview",           AddOnQuestDebug.Global.ShareView,},</p><p>        {"setposition",         AddOnQuestDebug.Global.SetPosition,},</p><p>        {"version",             AddOnQuestDebug.Global.ShowVersion,},</p><p>        -- quest control</p><p>        {"win",                 AddOnQuestDebug.Global.QuestSuccess,      true,},</p><p>        {"winall",              AddOnQuestDebug.Global.QuestSuccess,      false,},</p><p>        {"fail",                AddOnQuestDebug.Global.QuestFailure,      true,},</p><p>        {"failall",             AddOnQuestDebug.Global.QuestFailure,      false,},</p><p>        {"stop",                AddOnQuestDebug.Global.QuestInterrupt,    true,},</p><p>        {"stopall",             AddOnQuestDebug.Global.QuestInterrupt,    false,},</p><p>        {"start",               AddOnQuestDebug.Global.QuestTrigger,      true,},</p><p>        {"startall",            AddOnQuestDebug.Global.QuestTrigger,      false,},</p><p>        {"restart",             AddOnQuestDebug.Global.QuestReset,        true,},</p><p>        {"restartall",          AddOnQuestDebug.Global.QuestReset,        false,},</p><p>        {"printequal",          AddOnQuestDebug.Global.PrintQuests,       1,},</p><p>        {"printactive",         AddOnQuestDebug.Global.PrintQuests,       2,},</p><p>        {"printdetail",         AddOnQuestDebug.Global.PrintQuests,       3,},</p><p>        -- loading scripts into running game and execute them</p><p>        {"lload",               AddOnQuestDebug.Global.LoadScript,        true},</p><p>        {"gload",               AddOnQuestDebug.Global.LoadScript,        false},</p><p>        -- execute short lua commands</p><p>        {"lexec",               AddOnQuestDebug.Global.ExecuteCommand,    true},</p><p>        {"gexec",               AddOnQuestDebug.Global.ExecuteCommand,    false},</p><p>        -- garbage collector printouts</p><p>        {"collectgarbage",      AddOnQuestDebug.Global.CollectGarbage,},</p><p>        {"dumpmemory",          AddOnQuestDebug.Global.CountLuaLoad,},</p><p>    }</p><p>    for k,v in pairs(_G) do</p><p>        if type(v) == "table" and v.Name and k == "b_"..v.Name and v.CustomFunction and not v.CustomFunction2 then</p><p>            v.CustomFunction2 = v.CustomFunction;</p><p>            v.CustomFunction = function(self, __quest_)</p><p>                if AddOnQuestDebug.Global.Data.CheckAtRun then</p><p>                    if self.DEBUG and not self.FOUND_ERROR and self:DEBUG(__quest_) then</p><p>                        self.FOUND_ERROR = true;</p><p>                    end</p><p>                end</p><p>                if not self.FOUND_ERROR then</p><p>                    return self:CustomFunction2(__quest_);</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>    self:OverwriteCreateQuests();</p><p>    API.AddSaveGameAction(self.OnSaveGameLoad);</p><p>-- Aktiviert den Debug.</p><p>-- Der Developing Mode bietet viele Hotkeys und eine Konsole. Die Konsole ist</p><p>-- ein mächtiges Werkzeug. Es ist möglich tief in das Spiel einzugreifen und</p><p>-- sogar Funktionen während des Spiels zu überschreiben.</p><p>-- @param _CheckAtRun [boolean] Prüfe Quests zur Laufzeit</p><p>-- @param _TraceQuests [boolean] Aktiviert Questverfolgung</p><p>-- @param _Cheats [boolean] Aktiviert Cheats</p><p>-- @param _Shell [boolean] Aktiviert Konsole</p><p>-- @within Internal</p><p>-- @local</p><p>    if self.Data.DebugModeIsActive then</p><p>        return;</p><p>    end</p><p>    self.Data.DebugModeIsActive = true;</p><p>    self.Data.CheckAtRun       = _CheckAtRun == true;</p><p>    self.Data.TraceQuests      = _TraceQuests == true;</p><p>    self.Data.DevelopingCheats = _Cheats == true;</p><p>    self.Data.DevelopingShell  = _Shell == true;</p><p>    self:ActivateQuestTrace();</p><p>    self:ActivateDevelopingCheats();</p><p>    self:ActivateDevelopingShell();</p><p>-- Aktiviert die Questverfolgung. Jede Statusänderung wird am Bildschirm</p><p>-- angezeigt.</p><p>-- @within Internal</p><p>-- @local</p><p>    if self.Data.TraceQuests then</p><p>        DEBUG_EnableQuestDebugKeys();</p><p>        DEBUG_QuestTrace(true);</p><p>    end</p><p>-- <p>Aktiviert die Cheats.</p></p><p>-- <p>Es werden die Development-Cheats benutzt und um einige neue erweitert.</p></p><p>-- @within Internal</p><p>-- @local</p><p>    if self.Data.DevelopingCheats then</p><p>        Logic.ExecuteInLuaLocalState("AddOnQuestDebug.Local:ActivateDevelopingCheats()");</p><p>    end</p><p>-- <p>Aktiviert die Shell.</p></p><p>-- <p>Der Debug stellt einige zusätzliche Tastenkombinationen bereit:</p></p><p>-- <p>Die Konsole des Debug wird mit SHIFT + ^ geöffnet.</p></p><p>-- <p>Die Konsole bietet folgende Kommandos:</p></p><p>-- @within Internal</p><p>-- @local</p><p>    if self.Data.DevelopingShell then</p><p>        Logic.ExecuteInLuaLocalState("AddOnQuestDebug.Local:ActivateDevelopingShell()");</p><p>    end</p><p>-- Ließt eingegebene Kommandos und führt entsprechende Funktionen aus.</p><p>-- Für die Zerlegung der Kommandizeile wird der Tokenizer benutzt.</p><p>-- Für die Nutzung im LuaDebugger des Spiels, müssen Kommandos mit</p><p>-- eval() aufgerufen werden.</p><p>-- @within Internal</p><p>-- @local</p><p>-- @see AddOnQuestDebug.Global:Tokenize</p><p>    local Results = {};</p><p>    local Commands = self:Tokenize(_Input);</p><p>    for k, v in pairs(Commands) do</p><p>        local Action = string.lower(v[1]);</p><p>        for i= 1, #AddOnQuestDebug.Global.Data.DebugCommands, 1 do</p><p>            if v[1] == AddOnQuestDebug.Global.Data.DebugCommands[i][1] then</p><p>                local SelectedCommand = AddOnQuestDebug.Global.Data.DebugCommands[i];</p><p>                for j=2, #v, 1 do</p><p>                    local Number = tonumber(v[j]);</p><p>                    if Number then</p><p>                        v[j] = Number;</p><p>                    end</p><p>                end</p><p>                local CommandResult = SelectedCommand[2](v, SelectedCommand[3]);</p><p>                if CommandResult then</p><p>                    table.insert(Results, CommandResult);</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>    return Results;</p><p>    return AddOnQuestDebug.Global:Parser(_Input);</p><p>-- Zerlegt den Eingabestring in einzelne Kommandos und gibt diese als Table</p><p>-- zurück. Unterschiedliche Kommandos werden mit && abgetrennt und entsprechend</p><p>-- als mehrere Einträge im Table angelegt. Mit dem Wiederholungszeichen &</p><p>-- wird das Komanndo für alle angegebenen Eingaben wiederholt.</p><p>-- Beispiel:</p><p>-- <pre></p><p>-- Eingabe:</p><p>-- "win QuestA & QuestB && fail QuestC && stop QuestD & Quest E"</p><p>-- Ausgabe:</p><p>-- {</p><p>-- {"win", "QuestA"}</p><p>-- {"win", "QuestB"}</p><p>-- {"fail", "QuestC"}</p><p>-- {"stop", "QuestD"}</p><p>-- {"stop", "QuestE"}</p><p>-- }</pre></p><p>-- @return Table mit Tokens</p><p>-- @within Internal</p><p>-- @local</p><p>    local Commands = {};</p><p>    local DAmberCommands = {_Input};</p><p>    local AmberCommands = {_Input};</p><p>    -- parse & delimiter</p><p>    local s, e = string.find(_Input, "s+&&s+");</p><p>    if s then</p><p>        DAmberCommands = {};</p><p>        while (s) do</p><p>            local tmp = string.sub(_Input, 1, s-1);</p><p>            table.insert(DAmberCommands, tmp);</p><p>            _Input = string.sub(_Input, e+1);</p><p>            s, e = string.find(_Input, "s+&&s+");</p><p>        end</p><p>        if string.len(_Input) > 0 then </p><p>            table.insert(DAmberCommands, _Input);</p><p>        end</p><p>    end</p><p>    -- parse & delimiter</p><p>    if #DAmberCommands > 0 then</p><p>        AmberCommands = {};</p><p>    end</p><p>    for i= 1, #DAmberCommands, 1 do</p><p>        local s, e = string.find(DAmberCommands[i], "s+&s+");</p><p>        if s then</p><p>            local LastCommand = "";</p><p>            while (s) do</p><p>                local tmp = string.sub(DAmberCommands[i], 1, s-1);</p><p>                table.insert(AmberCommands, LastCommand .. tmp);</p><p>                if string.find(tmp, " ") then</p><p>                    LastCommand = string.sub(tmp, 1, string.find(tmp, " ")-1) .. " ";</p><p>                end</p><p>                DAmberCommands[i] = string.sub(DAmberCommands[i], e+1);</p><p>                s, e = string.find(DAmberCommands[i], "s+&s+");</p><p>            end</p><p>            if string.len(DAmberCommands[i]) > 0 then </p><p>                table.insert(AmberCommands, LastCommand .. DAmberCommands[i]);</p><p>            end</p><p>        else</p><p>            table.insert(AmberCommands, DAmberCommands[i]);</p><p>        end</p><p>    end</p><p>    -- parse spaces</p><p>    for i= 1, #AmberCommands, 1 do</p><p>        local CommandLine = {};</p><p>        local s, e = string.find(AmberCommands[i], "s+");</p><p>        if s then</p><p>            while (s) do</p><p>                local tmp = string.sub(AmberCommands[i], 1, s-1);</p><p>                table.insert(CommandLine, tmp);</p><p>                AmberCommands[i] = string.sub(AmberCommands[i], e+1);</p><p>                s, e = string.find(AmberCommands[i], "s+");</p><p>            end</p><p>            table.insert(CommandLine, AmberCommands[i]);</p><p>        else</p><p>            table.insert(CommandLine, AmberCommands[i]);</p><p>        end</p><p>        table.insert(Commands, CommandLine);</p><p>    end</p><p>    return Commands;</p><p>-- Führt die Garbage Collection aus um nicht benötigten Speicher freizugeben.</p><p>-- Die Garbage Collection wird von Lua automatisch in Abständen ausgeführt.</p><p>-- Mit dieser Funktion kann man nachhelfen, sollten die Intervalle zu lang</p><p>-- sein und der Speicher vollgemüllt werden.</p><p>-- @within Internal</p><p>-- @local</p><p>    collectgarbage();</p><p>    Logic.ExecuteInLuaLocalState("AddOnQuestDebug.Local:CollectGarbage()");</p><p>-- Gibt die Speicherauslastung von Lua zurück.</p><p>-- @within Internal</p><p>-- @local</p><p>    Logic.ExecuteInLuaLocalState("AddOnQuestDebug.Local:CountLuaLoad()");</p><p>    local LuaLoad = collectgarbage("count");</p><p>    API.StaticNote("Global Lua Size: " ..LuaLoad);</p><p>-- Zeigt alle Quests nach einem Filter an.</p><p>-- @within Internal</p><p>-- @local</p><p>    local questText = ""</p><p>    local counter   = 0;</p><p>    local accept = function(_quest, _state)</p><p>        return _quest.State == _state;</p><p>    end</p><p>    if _Flags == 3 then</p><p>        return AddOnQuestDebug.PrintDetail(_Arguments);</p><p>    end</p><p>    if _Flags == 1 then</p><p>        accept = function(_quest, _arg)</p><p>            return string.find(_quest.Identifier, _arg);</p><p>        end</p><p>    elseif _Flags == 2 then</p><p>        _Arguments[2] = QuestState.Active;</p><p>    end</p><p>    for i= 1, Quests[0] do</p><p>        if Quests[i] then</p><p>            if accept(Quests[i], _Arguments[2]) then</p><p>                counter = counter +1;</p><p>                if counter <= 15 then</p><p>                    questText = questText .. ((questText:len() > 0 and "{cr}") or "");</p><p>                    questText = questText ..  Quests[i].Identifier;</p><p>                end</p><p>            end</p><p>        end</p><p>    end</p><p>    if counter >= 15 then</p><p>        questText = questText .. "{cr}{cr}(" .. (counter-15) .. " weitere Ergebnis(se) gefunden!)";</p><p>    end</p><p>    Logic.ExecuteInLuaLocalState([[</p><p>        GUI.ClearNotes()</p><p>        GUI.AddStaticNote("]]..questText..[[")</p><p>    ]]);</p><p>    questText = string.gsub(questText, "{cr}", "\n");</p><p>    return questText;</p><p>    local questText = "";</p><p>    local questID = GetQuestID(string.gsub(_Arguments[2], " ", ""));</p><p>    if Quests[questID] then</p><p>        local state        = (Quests[questID].State == QuestState.NotTriggered and "not triggered") or</p><p>                              (Quests[questID].State == QuestState.Active and "active") or</p><p>                                "over";</p><p>        local result        = (Quests[questID].Result == QuestResult.Success and "success") or</p><p>                              (Quests[questID].Result == QuestResult.Failure and "failure") or</p><p>                              (Quests[questID].Result == QuestResult.Interrupted and "interrupted") or</p><p>                                "undecided";</p><p>        questText = questText .. "Name: " .. Quests[questID].Identifier .. "{cr}";</p><p>        questText = questText .. "State: " .. state .. "{cr}";</p><p>        questText = questText .. "Result: " .. result .. "{cr}";</p><p>        questText = questText .. "Sender: " .. Quests[questID].SendingPlayer .. "{cr}";</p><p>        questText = questText .. "Receiver: " .. Quests[questID].ReceivingPlayer .. "{cr}";</p><p>        questText = questText .. "Duration: " .. Quests[questID].Duration .. "{cr}";</p><p>        questText = questText .. "Start Text: "  .. tostring(Quests[questID].QuestStartMsg) .. "{cr}";</p><p>        questText = questText .. "Failure Text: " .. tostring(Quests[questID].QuestFailureMsg) .. "{cr}";</p><p>        questText = questText .. "Success Text: " .. tostring(Quests[questID].QuestSuccessMsg) .. "{cr}";</p><p>        questText = questText .. "Description: " .. tostring(Quests[questID].QuestDescription) .. "{cr}";</p><p>        questText = questText .. "Objectives: " .. #Quests[questID].Objectives .. "{cr}";</p><p>        questText = questText .. "Reprisals: " .. #Quests[questID].Reprisals .. "{cr}";</p><p>        questText = questText .. "Rewards: " .. #Quests[questID].Rewards .. "{cr}";</p><p>        questText = questText .. "Triggers: " .. #Quests[questID].Triggers .. "{cr}";</p><p>    else</p><p>        questText = questText .. tostring(_Arguments[2]) .. " not found!";</p><p>    end</p><p>    Logic.ExecuteInLuaLocalState([[</p><p>        GUI.ClearNotes()</p><p>        GUI.AddStaticNote("]]..questText..[[")</p><p>    ]]);</p><p>    questText = string.gsub(questText, "{cr}", "\n");</p><p>    return questText;</p><p>-- Läd ein Lua-Skript in das Enviorment.</p><p>-- @within Internal</p><p>-- @local</p><p>    if _Arguments[2] then</p><p>        if _Flags == true then</p><p>            Logic.ExecuteInLuaLocalState([[Script.Load("]].._Arguments[2]..[[")]]);</p><p>        elseif _Flags == false then</p><p>            Script.Load(_Arguments[2]);</p><p>        end</p><p>        if not AddOnQuestDebug.Global.Data.SurpassMessages then</p><p>            Logic.DEBUG_AddNote("load script ".._Arguments[2]);</p><p>        end</p><p>    end</p><p>-- Führt ein Lua-Kommando im Enviorment aus.</p><p>-- @within Internal</p><p>-- @local</p><p>    if _Arguments[2] then</p><p>        local args = "";</p><p>        for i=2,#_Arguments do</p><p>            args = args .. " " .. _Arguments[i];</p><p>        end</p><p>        if _Flags == true then</p><p>            Logic.ExecuteInLuaLocalState([[]]..args..[[]]);</p><p>        elseif _Flags == false then</p><p>            Logic.ExecuteInLuaLocalState([[GUI.SendScriptCommand("]]..args..[[")]]);</p><p>        end</p><p>    end</p><p>-- Konsolenbefehl: Leert das Debug Window.</p><p>-- @within Internal</p><p>-- @local</p><p>    Logic.ExecuteInLuaLocalState("GUI.ClearNotes()");</p><p>-- Konsolenbefehl: Ändert die Diplomatie zwischen zwei Spielern.</p><p>-- @within Internal</p><p>-- @local</p><p>    SetDiplomacyState(_Arguments[2], _Arguments[3], _Arguments[4]);</p><p>--  Konsolenbefehl: Startet die Map umgehend neu.</p><p>-- @within Internal</p><p>-- @local</p><p>    Logic.ExecuteInLuaLocalState("Framework.RestartMap()");</p><p>-- Konsolenbefehl: Aktiviert/deaktiviert die geteilte Sicht zweier Spieler.</p><p>-- @within Internal</p><p>-- @local</p><p>    Logic.SetShareExplorationWithPlayerFlag(_Arguments[2], _Arguments[3], _Arguments[4]);</p><p>-- Konsolenbefehl: Setzt die Position eines Entity.</p><p>-- @within Internal</p><p>-- @local</p><p>    local entity = GetID(_Arguments[2]);</p><p>    local target = GetID(_Arguments[3]);</p><p>    local x,y,z  = Logic.EntityGetPos(target);</p><p>    if Logic.IsBuilding(target) == 1 then</p><p>        x,y = Logic.GetBuildingApproachPosition(target);</p><p>    end</p><p>    Logic.DEBUG_SetSettlerPosition(entity, x, y);</p><p>-- Konsolenbefehl: Zeigt die Version der QSB an.</p><p>-- @within Internal</p><p>-- @local</p><p>    API.Bridge("GUI.AddStaticNote(QSB.Version)");</p><p>    return QSB.Version;</p><p>-- Beendet einen Quest, oder mehrere Quests mit ähnlichen Namen, erfolgreich.</p><p>-- @within Internal</p><p>-- @local</p><p>    local FoundQuests = FindQuestsByName(_QuestName[2], _ExactName);</p><p>    if #FoundQuests == 0 then</p><p>        return;</p><p>    end</p><p>    API.WinAllQuests(unpack(FoundQuests));</p><p>-- Lässt einen Quest, oder mehrere Quests mit ähnlichen Namen, fehlschlagen.</p><p>-- @within Internal</p><p>-- @local</p><p>    local FoundQuests = FindQuestsByName(_QuestName[2], _ExactName);</p><p>    if #FoundQuests == 0 then</p><p>        return;</p><p>    end</p><p>    API.FailAllQuests(unpack(FoundQuests));</p><p>-- Stoppt einen Quest, oder mehrere Quests mit ähnlichen Namen.</p><p>-- @within Internal</p><p>-- @local</p><p>    local FoundQuests = FindQuestsByName(_QuestName[2], _ExactName);</p><p>    if #FoundQuests == 0 then</p><p>        return;</p><p>    end</p><p>    API.StopAllQuests(unpack(FoundQuests));</p><p>-- Startet einen Quest, oder mehrere Quests mit ähnlichen Namen.</p><p>-- @within Internal</p><p>-- @local</p><p>    local FoundQuests = FindQuestsByName(_QuestName[2], _ExactName);</p><p>    if #FoundQuests == 0 then</p><p>        return;</p><p>    end</p><p>    API.StartAllQuests(unpack(FoundQuests));</p><p>-- Setzt den Quest / die Quests zurück, sodass er neu gestartet werden kann.</p><p>-- @within Internal</p><p>-- @local</p><p>    local FoundQuests = FindQuestsByName(_QuestName[2], _ExactName);</p><p>    if #FoundQuests == 0 then</p><p>        return;</p><p>    end</p><p>    API.RestartAllQuests(unpack(FoundQuests));</p><p>-- Überschreibt CreateQuests, sodass Assistentenquests über das Skript erzeugt</p><p>-- werden um diese sinnvoll überprüfen zu können.</p><p>-- @within Internal</p><p>-- @local</p><p>    AddOnQuestDebug.Global.Data.CreateQuestsOriginal = CreateQuests;</p><p>    CreateQuests = function()</p><p>        local QuestNames = Logic.Quest_GetQuestNames()</p><p>        for i=1, #QuestNames, 1 do</p><p>            local QuestName = QuestNames[i]</p><p>            local QuestData = {Logic.Quest_GetQuestParamter(QuestName)};</p><p>            -- Behavior ermitteln</p><p>            local Behaviors = {};</p><p>            local Amount = Logic.Quest_GetQuestNumberOfBehaviors(QuestName);</p><p>            if Amount > 0 then</p><p>                for j=0, Amount-1, 1 do</p><p>                    local Name = Logic.Quest_GetQuestBehaviorName(QuestName, j);</p><p>                    local Template = GetBehaviorTemplateByName(Name);</p><p>                    assert(Template ~= nil);</p><p>                    local Parameters = Logic.Quest_GetQuestBehaviorParameter(QuestName, j);</p><p>                    table.insert(Behaviors, Template:new(unpack(Parameters)));</p><p>                end</p><p>                API.CreateQuest {</p><p>                    Name        = QuestName,</p><p>                    Sender      = QuestData[1],</p><p>                    Receiver    = QuestData[2],</p><p>                    Time        = QuestData[4],</p><p>                    Description = QuestData[5],</p><p>                    Suggestion  = QuestData[6],</p><p>                    Failure     = QuestData[7],</p><p>                    Success     = QuestData[8],</p><p>                    unpack(Behaviors),</p><p>                };</p><p>            end</p><p>        end</p><p>    end</p><p>-- Stellt den Debug nach dem Laden eines Spielstandes wieder her.</p><p>-- @param _Arguments Argumente der überschriebenen Funktion</p><p>-- @param _Original  Referenz auf Save-Funktion</p><p>-- @within Internal</p><p>-- @local</p><p>    AddOnQuestDebug.Global:ActivateDevelopingCheats();</p><p>    AddOnQuestDebug.Global:ActivateDevelopingShell();</p><p>    AddOnQuestDebug.Global:ActivateQuestTrace();</p><p>-- Local Script ----------------------------------------------------------------</p><p>-- Initalisiert das Bundle im lokalen Skript.</p><p>-- @within Internal</p><p>-- @local</p><p>-- Führt die Garbage Collection aus um nicht benötigten Speicher freizugeben.</p><p>-- Die Garbage Collection wird von Lua automatisch in Abständen ausgeführt.</p><p>-- Mit dieser Funktion kann man nachhelfen, sollten die Intervalle zu lang</p><p>-- sein und der Speicher vollgemüllt werden.</p><p>-- @within Internal</p><p>-- @local</p><p>    collectgarbage();</p><p>-- Gibt die Speicherauslastung von Lua zurück.</p><p>-- @within Internal</p><p>-- @local</p><p>    local LuaLoad = collectgarbage("count");</p><p>    API.StaticNote("Local Lua Size: " ..LuaLoad)</p><p>-- Aktiviert die Development Cheats des Spiels.</p><p>-- @see AddOnQuestDebug.Global:ActivateDevelopingCheats</p><p>-- @within Internal</p><p>-- @local</p><p>    KeyBindings_EnableDebugMode(1);</p><p>    KeyBindings_EnableDebugMode(2);</p><p>    KeyBindings_EnableDebugMode(3);</p><p>    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft/GameClock",1);</p><p>-- Aktiviert die Kommandokonsole.</p><p>-- @see AddOnQuestDebug.Global:ActivateDevelopingShell</p><p>-- @within Internal</p><p>-- @local</p><p>    GUI_Chat.Abort = function() end</p><p>    GUI_Chat.Confirm = function()</p><p>        Input.GameMode();</p><p>        XGUIEng.ShowWidget("/InGame/Root/Normal/ChatInput",0);</p><p>        AddOnQuestDebug.Local.Data.ChatBoxInput = XGUIEng.GetText("/InGame/Root/Normal/ChatInput/ChatInput");</p><p>        g_Chat.JustClosed = 1;</p><p>        Game.GameTimeSetFactor( GUI.GetPlayerID(), 1 );</p><p>    end</p><p>    QSB_DEBUG_InputBoxJob = function()</p><p>        if not AddOnQuestDebug.Local.Data.BoxShown then</p><p>            Input.ChatMode();</p><p>            Game.GameTimeSetFactor( GUI.GetPlayerID(), 0 );</p><p>            XGUIEng.ShowWidget("/InGame/Root/Normal/ChatInput", 1);</p><p>            XGUIEng.SetText("/InGame/Root/Normal/ChatInput/ChatInput", "");</p><p>            XGUIEng.SetFocus("/InGame/Root/Normal/ChatInput/ChatInput");</p><p>            AddOnQuestDebug.Local.Data.BoxShown = true</p><p>        elseif AddOnQuestDebug.Local.Data.ChatBoxInput then</p><p>            AddOnQuestDebug.Local.Data.ChatBoxInput = string.gsub(AddOnQuestDebug.Local.Data.ChatBoxInput,"'","\'");</p><p>            GUI.SendScriptCommand("AddOnQuestDebug.Global:Parser('"..AddOnQuestDebug.Local.Data.ChatBoxInput.."')");</p><p>            AddOnQuestDebug.Local.Data.BoxShown = nil;</p><p>            return true;</p><p>        end</p><p>    end</p><p>    Input.KeyBindDown(Keys.ModifierShift + Keys.OemPipe, "StartSimpleJob('QSB_DEBUG_InputBoxJob')", 2);</p></div>
    </div>
</div>
                </div>
                <p id="notFound">Leider wurden keine Ergebnisse gefunden!</p>
            </div>
        </div>
    </bod>
</html>