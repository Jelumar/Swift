<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8" />
        <title>Symfonia</title>
        <link rel="stylesheet" href="css/main.css" />
        <script src="js/jquery.js"></script>
        <script src="js/search.js"></script>
    </head>
    <body>
        <div id="modules">
            <div id="searchContainer">
                <h1>Symfonia</h1>
                <p>Willkommen in der Dokumentation von Symfonia!</p>
                <p>
                    Die Dokumentation soll Dir beim Erstellen von neuen Maps zur Seite stehen. Damit Du nicht von all den Modulen erschlagen wirst, 
                    wurde diese Startseite vorangestellt. Gib eindach einen Suchbegriff ein. Alle passenden Bundles von Symfonia werden anschließend 
                    in einer Liste angezeigt. Wähle das passende Bundle durch klicken aus.
                </p>
                <p>
                    Du kannst auf folgende Weise Suchbegriffe eingeben:
                    <ul>
                        <li>Einzelnes Wort: Es wird nach dem Wort gesucht</li>
                        <li>Worte mit + getrennt: Alle Wörter müssen vorkommen (Beispiel: käse+kauf)</li>
                        <li>Worte mit , getrennt: Mindestens 1 Wort muss vorkommen (Beispiel: hakim,health)</li>
                    </ul>
                </p>
                <p>
                    <b>Hinweis:</b> Es wird nicht die HTML-Datei durchsucht, sondern die LUA-Quelldatei. Es kann also sein, dass Dein Suchbegriff nicht im
                    HTML-Dokument auftaucht, weil er nur im Quellcode steht.
                </p>
                <hr/>
                <form id="searchForm">
                    <input type="text" id="pattern" />
                    <input type="button" name="search" id="search" value="Suchen" />
                    <input type="button" name="reset" id="reset" value="Zurücksetzen" />
                    <input type="submit" style="display: none" />
                </form>
            <div>
            <div id="searchResultsContainer">
                <h3>Index</h3>
                <div id="modulesContainer">
                    <div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/core.lua.html">
            <div class='doclink'>
                <div>Core</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><code>-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia Core                                                         # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Hier werden wichtige Basisfunktionen bereitgestellt. Diese Funktionen sind
-- auch in der Minimalkonfiguration der QSB vorhanden und essentiell für alle
-- anderen Bundles.
--
-- @set sort=true
--

API = API or {};
QSB = QSB or {};
QSB.Version = "2.0.0 Beta-3";
QSB.HistoryEdition = false;

QSB.RealTime_SecondsSinceGameStart = 0;

ParameterType = ParameterType or {};
g_QuestBehaviorVersion = 1;
g_QuestBehaviorTypes = {};

---
-- AddOn Versionsnummer
-- @local
--
g_GameExtraNo = 0;
if Framework then
    g_GameExtraNo = Framework.GetGameExtraNo();
elseif MapEditor then
    g_GameExtraNo = MapEditor.GetGameExtraNo();
end

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Initialisiert alle verfügbaren Bundles und führt ihre Install-Methode aus.
--
-- Bundles werden immer getrennt im globalen und im lokalen Skript gestartet.
-- Diese Funktion muss zwingend im globalen und lokalen Skript ausgeführt
-- werden, bevor die QSB verwendet werden kann.
--
-- @within Anwenderfunktionen
--
function API.Install()
    Core:InitalizeBundles();
end

-- Tables --------------------------------------------------------------------

---
-- Kopiert eine komplette Table und gibt die Kopie zurück. Tables können
-- nicht durch Zuweisungen kopiert werden. Verwende diese Funktion. Wenn ein
-- Ziel angegeben wird, ist die zurückgegebene Table eine Vereinigung der 2
-- angegebenen Tables.
-- Die Funktion arbeitet rekursiv.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; CopyTableRecursive&#x3C;/p&#x3E;
--
-- @param[type=table] _Source Quelltabelle
-- @param[type=table] _Dest   (optional) Zieltabelle
-- @return[type=table] Kopie der Tabelle
-- @within Anwenderfunktionen
-- @usage Table = {1, 2, 3, {a = true}}
-- Copy = API.InstanceTable(Table)
--
function API.InstanceTable(_Source, _Dest)
    _Dest = _Dest or {};
    assert(type(_Source) == "table")
    assert(type(_Dest) == "table")

    for k, v in pairs(_Source) do
        if type(v) == "table" then
            _Dest[k] = _Dest[k] or {};
            for kk, vv in pairs(API.InstanceTable(v)) do
                _Dest[k][kk] = _Dest[k][kk] or vv;
            end
        else
            _Dest[k] = _Dest[k] or v;
        end
    end
    return _Dest;
end
CopyTableRecursive = API.InstanceTable;

---
-- Sucht in einer eindimensionalen Table nach einem Wert. Das erste Auftreten
-- des Suchwerts wird als Erfolg gewertet.
--
-- Es können praktisch alle Lua-Werte gesucht werden, obwohl dies nur für
-- Strings und Numbers wirklich sinnvoll ist.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; Inside&#x3C;/p&#x3E;
--
-- @param             _Data Gesuchter Eintrag (multible Datentypen)
-- @param[type=table] _Table Tabelle, die durchquert wird
-- @return[type=booelan] Wert gefunden
-- @within Anwenderfunktionen
-- @usage Table = {1, 2, 3, {a = true}}
-- local Found = API.TraverseTable(3, Table)
--
function API.TraverseTable(_Data, _Table)
    for k,v in pairs(_Table) do
        if v == _Data then
            return true;
        end
    end
    return false;
end
Inside = API.TraverseTable;

---
-- Schreibt ein genaues Abbild der Table ins Log. Funktionen, Threads und
-- Metatables werden als Adresse geschrieben.
--
-- @param[type=table]  _Table Tabelle, die gedumpt wird
-- @param[type=string] _Name Optionaler Name im Log
-- @within Anwenderfunktionen
-- @local
-- @usage Table = {1, 2, 3, {a = true}}
-- API.DumpTable(Table)
--
function API.DumpTable(_Table, _Name)
    local Start = "{";
    if _Name then
        Start = _Name.. " = \n" ..Start;
    end
    Framework.WriteToLog(Start);

    for k, v in pairs(_Table) do
        if type(v) == "table" then
            Framework.WriteToLog("[" ..k.. "] = ");
            API.DumpTable(v);
        elseif type(v) == "string" then
            Framework.WriteToLog("[" ..k.. "] = \"" ..v.. "\"");
        else
            Framework.WriteToLog("[" ..k.. "] = " ..tostring(v));
        end
    end
    Framework.WriteToLog("}");
end

---
-- Konvertiert alle Strings, Booleans und Numbers einer Tabelle in
-- einen String. Die Funktion ist rekursiv, d.h. es werden auch alle
-- Untertabellen mit konvertiert. Alles was kein Number, Boolean oder
-- String ist, wird als Adresse geschrieben.
--
-- @param[type=table] _Table Table zum konvertieren
-- @return[type=string] Converted table
-- @within Anwenderfunktionen
-- @local
--
function API.ConvertTableToString(_Table)
    assert(type(_Table) == "table");
    local TableString = "{";
    for k, v in pairs(_Table) do
        local key;
        if (tonumber(k)) then
            key = ""..k;
        else
            key = "\""..k.."\"";
        end

        if type(v) == "table" then
            TableString = TableString .. "[" .. key .. "] = " .. API.ConvertTableToString(v) .. ", ";
        elseif type(v) == "number" then
            TableString = TableString .. "[" .. key .. "] = " .. v .. ", ";
        elseif type(v) == "string" then
            TableString = TableString .. "[" .. key .. "] = \"" .. v .. "\", ";
        elseif type(v) == "boolean" or type(v) == "nil" then
            TableString = TableString .. "[" .. key .. "] = " .. tostring(v) .. ", ";
        else
            TableString = TableString .. "[" .. key .. "] = \"" .. tostring(v) .. "\", ";
        end
    end
    TableString = TableString .. "}";
    return TableString
end

-- Quests ----------------------------------------------------------------------

---
-- Gibt die ID des Quests mit dem angegebenen Namen zurück. Existiert der
-- Quest nicht, wird nil zurückgegeben.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; GetQuestID&#x3C;/p&#x3E;
--
-- @param[type=string] _Name Name des Quest
-- @return[type=number] ID des Quest
-- @within Anwenderfunktionen
--
function API.GetQuestID(_Name)
    if type(_Name) == "number" then
        return _Name;
    end
    for k, v in pairs(Quests) do
        if v and k &#x3E; 0 then
            if v.Identifier == _Name then
                return k;
            end
        end
    end
end
GetQuestID = API.GetQuestID;

---
-- Prüft, ob zu der angegebenen ID ein Quest existiert. Wird ein Questname
-- angegeben wird dessen Quest-ID ermittelt und geprüft.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; IsValidQuest&#x3C;/p&#x3E;
--
-- @param[type=number] _QuestID ID oder Name des Quest
-- @return[type=boolean] Quest existiert
-- @within Anwenderfunktionen
--
function API.IsValidateQuest(_QuestID)
    return Quests[_QuestID] ~= nil or Quests[API.GetQuestID(_QuestID)] ~= nil;
end
IsValidQuest = API.IsValidateQuest;

---
-- Lässt eine Liste von Quests fehlschlagen.
--
-- Der Status wird auf Over und das Resultat auf Failure gesetzt.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; FailQuestsByName&#x3C;/p&#x3E;
--
-- @param[type=string] ... Liste mit Quests
-- @within Anwenderfunktionen
-- @local
--
function API.FailAllQuests(...)
    for i=1, #arg, 1 do
        API.FailQuest(arg[i]);
    end
end
FailQuestsByName = API.FailAllQuests;

---
-- Lässt den Quest fehlschlagen.
--
-- Der Status wird auf Over und das Resultat auf Failure gesetzt.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; FailQuestByName&#x3C;/p&#x3E;
--
-- @param[type=string]  _QuestName Name des Quest
-- @param[type=boolean] _Verbose   Meldung nicht anzeigen
-- @within Anwenderfunktionen
--
function API.FailQuest(_QuestName, _Verbose)
    local Quest = Quests[GetQuestID(_QuestName)];
    if Quest then
        if not _Verbose then
            API.Note("fail quest " .._QuestName);
        end
        Quest:RemoveQuestMarkers();
        Quest:Fail();
    end
end
FailQuestByName = API.FailQuest;

---
-- Startet eine Liste von Quests neu.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; StartQuestsByName&#x3C;/p&#x3E;
--
-- @param[type=string] ... Liste mit Quests
-- @within Anwenderfunktionen
-- @local
--
function API.RestartAllQuests(...)
    for i=1, #arg, 1 do
        API.RestartQuest(arg[i]);
    end
end
RestartQuestsByName = API.RestartAllQuests;

---
-- Startet den Quest neu.
--
-- Der Quest muss beendet sein um ihn wieder neu zu starten. Wird ein Quest
-- neu gestartet, müssen auch alle Trigger wieder neu ausgelöst werden, außer
-- der Quest wird manuell getriggert.
--
-- Alle Änderungen an Standardbehavior müssen hier berücksichtigt werden. Wird
-- ein Standardbehavior in einem Bundle verändern, muss auch diese Funktion
-- angepasst oder überschrieben werden.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; RestartQuestByName&#x3C;/p&#x3E;
--
-- @param[type=string]  _QuestName Name des Quest
-- @param[type=boolean] _Verbose   Meldung nicht anzeigen
-- @within Anwenderfunktionen
--
function API.RestartQuest(_QuestName, _Verbose)
    local QuestID = GetQuestID(_QuestName);
    local Quest = Quests[QuestID];
    if Quest then
        if not _Verbose then
            API.Note("restart quest " .._QuestName);
        end

        if Quest.Objectives then
            local questObjectives = Quest.Objectives;
            for i = 1, questObjectives[0] do
                local objective = questObjectives[i];
                objective.Completed = nil
                local objectiveType = objective.Type;

                if objectiveType == Objective.Deliver then
                    local data = objective.Data;
                    data[3] = nil;
                    data[4] = nil;
                    data[5] = nil;

                elseif g_GameExtraNo and g_GameExtraNo &#x3E;= 1 and objectiveType == Objective.Refill then
                    objective.Data[2] = nil;

                elseif objectiveType == Objective.Protect or objectiveType == Objective.Object then
                    local data = objective.Data;
                    for j=1, data[0], 1 do
                        data[-j] = nil;
                    end

                elseif objectiveType == Objective.DestroyEntities and objective.Data[1] == 2 and objective.DestroyTypeAmount then
                    objective.Data[3] = objective.DestroyTypeAmount;
                elseif objectiveType == Objective.DestroyEntities and objective.Data[1] == 3 then
                    objective.Data[4] = nil;

                elseif objectiveType == Objective.Distance then
                    if objective.Data[1] == -65565 then
                        objective.Data[4].NpcInstance = nil;
                    end

                elseif objectiveType == Objective.Custom2 and objective.Data[1].Reset then
                    objective.Data[1]:Reset(Quest, i);
                end
            end
        end

        local function resetCustom(_type, _customType)
            local Quest = Quest;
            local behaviors = Quest[_type];
            if behaviors then
                for i = 1, behaviors[0] do
                    local behavior = behaviors[i];
                    if behavior.Type == _customType then
                        local behaviorDef = behavior.Data[1];
                        if behaviorDef and behaviorDef.Reset then
                            behaviorDef:Reset(Quest, i);
                        end
                    end
                end
            end
        end

        resetCustom("Triggers", Triggers.Custom2);
        resetCustom("Rewards", Reward.Custom);
        resetCustom("Reprisals", Reprisal.Custom);

        Quest.Result = nil;
        local OldQuestState = Quest.State;
        Quest.State = QuestState.NotTriggered;
        Logic.ExecuteInLuaLocalState("LocalScriptCallback_OnQuestStatusChanged("..Quest.Index..")");
        if OldQuestState == QuestState.Over then
            Trigger.RequestTrigger(Events.LOGIC_EVENT_EVERY_SECOND, "", QuestTemplate.Loop, 1, 0, { Quest.QueueID });
        end
        return QuestID, Quest;
    end
end
RestartQuestByName = API.RestartQuest;

---
-- Startet eine Liste von Quests.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; StartQuestsByName&#x3C;/p&#x3E;
--
-- @param[type=string] ... Liste mit Quests
-- @within Anwenderfunktionen
-- @local
--
function API.StartAllQuests(...)
    for i=1, #arg, 1 do
        API.StartQuest(arg[i]);
    end
end
StartQuestsByName = API.StartAllQuests;

---
-- Startet den Quest sofort, sofern er existiert.
--
-- Dabei ist es unerheblich, ob die Bedingungen zum Start erfüllt sind.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; StartQuestByName&#x3C;/p&#x3E;
--
-- @param[type=string]  _QuestName Name des Quest
-- @param[type=boolean] _Verbose   Meldung nicht anzeigen
-- @within Anwenderfunktionen
--
function API.StartQuest(_QuestName, _Verbose)
    local Quest = Quests[GetQuestID(_QuestName)];
    if Quest then
        if not _Verbose then
            API.Note("start quest " .._QuestName);
        end
        Quest:SetMsgKeyOverride();
        Quest:SetIconOverride();
        Quest:Trigger();
    end
end
StartQuestByName = API.StartQuest;

---
-- Unterbricht eine Liste von Quests.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; StopQuestsByName&#x3C;/p&#x3E;
--
-- @param[type=string] ... Liste mit Quests
-- @within Anwenderfunktionen
-- @local
--
function API.StopAllQuests(...)
    for i=1, #arg, 1 do
        API.StopQuest(arg[i]);
    end
end
StopQuestsByName = API.StopAllQuests;

---
-- Unterbricht den Quest.
--
-- Der Status wird auf Over und das Resultat auf Interrupt gesetzt. Sind Marker
-- gesetzt, werden diese entfernt.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; StopQuestByName&#x3C;/p&#x3E;
--
-- @param[type=string]  _QuestName Name des Quest
-- @param[type=boolean] _Verbose   Meldung nicht anzeigen
-- @within Anwenderfunktionen
--
function API.StopQuest(_QuestName, _Verbose)
    local Quest = Quests[GetQuestID(_QuestName)];
    if Quest then
        if not _Verbose then
            API.Note("interrupt quest " .._QuestName);
        end
        Quest:RemoveQuestMarkers();
        Quest:Interrupt(-1);
    end
end
StopQuestByName = API.StopQuest;

---
-- Gewinnt eine Liste von Quests.
--
-- Der Status wird auf Over und das Resultat auf Success gesetzt.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; WinQuestsByName&#x3C;/p&#x3E;
--
-- @param[type=string] ... Liste mit Quests
-- @within Anwenderfunktionen
-- @local
--
function API.WinAllQuests(...)
    for i=1, #arg, 1 do
        API.WinQuest(arg[i]);
    end
end
WinQuestsByName = API.WinAllQuests;

---
-- Gewinnt den Quest.
--
-- Der Status wird auf Over und das Resultat auf Success gesetzt.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; WinQuestByName&#x3C;/p&#x3E;
--
-- @param[type=string]  _QuestName Name des Quest
-- @param[type=boolean] _Verbose   Meldung nicht anzeigen
-- @within Anwenderfunktionen
--
function API.WinQuest(_QuestName, _Verbose)
    local Quest = Quests[GetQuestID(_QuestName)];
    if Quest then
        if not _Verbose then
            API.Note("win quest " .._QuestName);
        end
        Quest:RemoveQuestMarkers();
        Quest:Success();
    end
end
WinQuestByName = API.WinQuest;

-- Messages --------------------------------------------------------------------

---
-- Schreibt eine Nachricht in das Debug Window. Der Text erscheint links am
-- Bildschirm und ist nicht statisch.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; GUI_Note&#x3C;/p&#x3E;
--
-- @param[type=string] _Message Anzeigetext
-- @within Anwenderfunktionen
-- @local
--
function API.Note(_Message)
    _Message = API.EnsureMessage(_Message);
    local MessageFunc = Logic.DEBUG_AddNote;
    if GUI then
        MessageFunc = GUI.AddNote;
    end
    MessageFunc(_Message);
end
GUI_Note = API.Note;

---
-- Schreibt eine Nachricht in das Debug Window. Der Text erscheint links am
-- Bildschirm und verbleibt dauerhaft am Bildschirm.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; GUI_StaticNote&#x3C;/p&#x3E;
--
-- @param[type=string] _Message Anzeigetext
-- @within Anwenderfunktionen
--
function API.StaticNote(_Message)
    _Message = API.EnsureMessage(_Message);
    if not GUI then
        Logic.ExecuteInLuaLocalState('GUI.AddStaticNote("' .._Message.. '")');
        return;
    end
    GUI.AddStaticNote(_Message);
end
GUI_StaticNote = API.StaticNote;

---
-- Löscht alle Nachrichten im Debug Window.
--
-- @within Anwenderfunktionen
--
function API.ClearNotes()
    if not GUI then
        Logic.ExecuteInLuaLocalState('GUI.ClearNotes()');
        return;
    end
    GUI.ClearNotes();
end

---
-- Schreibt eine Nachricht in das Nachrichtenfenster unten in der Mitte.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; GUI_NoteDown&#x3C;/p&#x3E;
--
-- @param[type=string] _Message Anzeigetext
-- @within Anwenderfunktionen
--
function API.Message(_Message)
    _Message = API.EnsureMessage(_Message);
    if not GUI then
        Logic.ExecuteInLuaLocalState('Message("' .._Message.. '")');
        return;
    end
    Message(_Message);
end
GUI_NoteDown = API.Message;

---
-- Ermittelt automatisch den Nachrichtentext, falls eine lokalisierte Table
-- übergeben wird.
--
-- @param[type=string] _Message Anzeigetext
-- @return[type=string] Message
-- @within Anwenderfunktionen
-- @local
--
function API.EnsureMessage(_Message)
    local Language = (Network.GetDesiredLanguage() == "de" and "de") or "en";
    if type(_Message) == "table" then
        _Message = _Message[Language];
    end
    return tostring(_Message);
end

---
-- Schreibt einen FATAL auf den Bildschirm und ins Log.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; API.Dbg&#x3C;/p&#x3E;
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; fatal&#x3C;/p&#x3E;
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; dbg&#x3C;/p&#x3E;
--
-- @param[type=string] _Message Anzeigetext
-- @within Anwenderfunktionen
-- @local
--
function API.Fatal(_Message)
    API.StaticNote("FATAL: " .._Message)
    Framework.WriteToLog("FATAL: " .._Message);
end
API.Dbg = API.Fatal;
fatal = API.Fatal;
dbg = API.Fatal;

---
-- Schreibt eine WARNING auf den Bildschirm und ins Log.
--
-- &#x3C;p&#x3E;&#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; warn&#x3C;/p&#x3E;&#x3C;/p&#x3E;
--
-- @param[type=string] _Message Anzeigetext
-- @within Anwenderfunktionen
-- @local
--
function API.Warn(_Message)
    API.StaticNote("WARNING: " .._Message)
    Framework.WriteToLog("WARNING: " .._Message);
end
warn = API.Warn;

-- Entities --------------------------------------------------------------------

---
-- Sendet einen Handelskarren zu dem Spieler. Startet der Karren von einem
-- Gebäude, wird immer die Position des Eingangs genommen.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; SendCart&#x3C;/p&#x3E;
--
-- @param _position                        Position (Skriptname oder Positionstable)
-- @param[type=number] _player             Zielspieler
-- @param[type=number] _good               Warentyp
-- @param[type=number] _amount             Warenmenge
-- @param[type=number] _cartOverlay        (optional) Overlay für Goldkarren
-- @param[type=boolean] _ignoreReservation (optional) Marktplatzreservation ignorieren
-- @return[type=number] Entity-ID des erzeugten Wagens
-- @within Anwenderfunktionen
-- @usage -- API-Call
-- API.SendCart(Logic.GetStoreHouse(1), 2, Goods.G_Grain, 45)
-- -- Legacy-Call mit ID-Speicherung
-- local ID = SendCart("Position_1", 5, Goods.G_Wool, 5)
--
function API.SendCart(_position, _player, _good, _amount, _cartOverlay, _ignoreReservation)
    local eID = GetID(_position);
    if not IsExisting(eID) then
        return;
    end
    local ID;
    local x,y,z = Logic.EntityGetPos(eID);
    local resCat = Logic.GetGoodCategoryForGoodType(_good);
    local orientation = 0;
    if Logic.IsBuilding(eID) == 1 then
        x,y = Logic.GetBuildingApproachPosition(eID);
        orientation = Logic.GetEntityOrientation(eID)-90;
    end

    if resCat == GoodCategories.GC_Resource then
        ID = Logic.CreateEntityOnUnblockedLand(Entities.U_ResourceMerchant, x, y,orientation,_player)
    elseif _good == Goods.G_Medicine then
        ID = Logic.CreateEntityOnUnblockedLand(Entities.U_Medicus, x, y,orientation,_player)
    elseif _good == Goods.G_Gold or _good == Goods.G_None or _good == Goods.G_Information then
        if _cartOverlay then
            ID = Logic.CreateEntityOnUnblockedLand(_cartOverlay, x, y,orientation,_player)
        else
            ID = Logic.CreateEntityOnUnblockedLand(Entities.U_GoldCart, x, y,orientation,_player)
        end
    else
        ID = Logic.CreateEntityOnUnblockedLand(Entities.U_Marketer, x, y,orientation,_player)
    end
    Logic.HireMerchant( ID, _player, _good, _amount, _player, _ignoreReservation)
    return ID
end
SendCart = API.SendCart;

---
-- Ersetzt ein Entity mit einem neuen eines anderen Typs. Skriptname,
-- Rotation, Position und Besitzer werden übernommen.
--
-- &#x3C;b&#x3E;Hinweis&#x3C;/b&#x3E;: Die Entity-ID ändert sich und beim Ersetzen von
-- Spezialgebäuden kann eine Niederlage erfolgen.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; ReplaceEntity&#x3C;/p&#x3E;
--
-- @param _Entity      Entity (Skriptname oder ID)
-- @param[type=number] _Type     Neuer Typ
-- @param[type=number] _NewOwner (optional) Neuer Besitzer
-- @return[type=number] Entity-ID des Entity
-- @within Anwenderfunktionen
-- @usage API.ReplaceEntity("Stein", Entities.XD_ScriptEntity)
--
function API.ReplaceEntity(_Entity, _Type, _NewOwner)
    local eID = GetID(_Entity);
    if eID == 0 then
        return;
    end
    local pos = GetPosition(eID);
    local player = _NewOwner or Logic.EntityGetPlayer(eID);
    local orientation = Logic.GetEntityOrientation(eID);
    local name = Logic.GetEntityName(eID);
    DestroyEntity(eID);
    if Logic.IsEntityTypeInCategory(_Type, EntityCategories.Soldier) == 1 then
        return CreateBattalion(player, _Type, pos.X, pos.Y, 1, name, orientation);
    else
        return CreateEntity(player, _Type, pos, name, orientation);
    end
end
ReplaceEntity = API.ReplaceEntity;

---
-- Rotiert ein Entity, sodass es zum Ziel schaut.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; LookAt&#x3C;/p&#x3E;
--
-- @param _entity         Entity (Skriptname oder ID)
-- @param _entityToLookAt Ziel (Skriptname oder ID)
-- @param[type=number]    _offsetEntity Winkel Offset
-- @within Anwenderfunktionen
-- @usage API.LookAt("Hakim", "Alandra")
--
function API.LookAt(_entity, _entityToLookAt, _offsetEntity)
    local entity = GetEntityId(_entity);
    local entityTLA = GetEntityId(_entityToLookAt);
    if not IsExisting(entity) or not IsExisting(entityTLA) then
        API.Warn("API.LookAt: One entity is invalid or dead!");
        return;
    end
    local eX, eY = Logic.GetEntityPosition(entity);
    local eTLAX, eTLAY = Logic.GetEntityPosition(entityTLA);
    local orientation = math.deg( math.atan2( (eTLAY - eY) , (eTLAX - eX) ) );
    if Logic.IsBuilding(entity) == 1 then
        orientation = orientation - 90;
    end
    _offsetEntity = _offsetEntity or 0;
    Logic.SetOrientation(entity, orientation + _offsetEntity);
end
LookAt = API.LookAt;

---
-- Lässt zwei Entities sich gegenseitig anschauen.
--
-- @param _entity         Entity (Skriptname oder ID)
-- @param _entityToLookAt Ziel (Skriptname oder ID)
-- @within Anwenderfunktionen
-- @usage API.Confront("Hakim", "Alandra")
--
function API.Confront(_entity, _entityToLookAt)
    API.LookAt(_entity, _entityToLookAt);
    API.LookAt(_entityToLookAt, _entity);
end

---
-- Bestimmt die Distanz zwischen zwei Punkten. Es können Entity-IDs,
-- Skriptnamen oder Positionstables angegeben werden.
--
-- Wenn die Distanz nicht bestimmt werden kann, wird -1 zurückgegeben.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; GetDistance&#x3C;/p&#x3E;
--
-- @param _pos1 Erste Vergleichsposition (Skriptname, ID oder Positions-Table)
-- @param _pos2 Zweite Vergleichsposition (Skriptname, ID oder Positions-Table)
-- @return[type=number] Entfernung zwischen den Punkten
-- @within Anwenderfunktionen
-- @usage local Distance = API.GetDistance("HQ1", Logic.GetKnightID(1))
--
function API.GetDistance( _pos1, _pos2 )
    if (type(_pos1) == "string") or (type(_pos1) == "number") then
        _pos1 = GetPosition(_pos1);
    end
    if (type(_pos2) == "string") or (type(_pos2) == "number") then
        _pos2 = GetPosition(_pos2);
    end
    if type(_pos1) ~= "table" or type(_pos2) ~= "table" then
        return -1;
    end
    local xDistance = (_pos1.X - _pos2.X);
    local yDistance = (_pos1.Y - _pos2.Y);
    return math.sqrt((xDistance^2) + (yDistance^2));
end
GetDistance = API.GetDistance;

---
-- Prüft, ob eine Positionstabelle eine gültige Position enthält.
--
-- Eine Position ist Ungültig, wenn sie sich nicht auf der Welt befindet.
-- Das ist der Fall bei negativen Werten oder Werten, welche die Größe
-- der Welt übersteigen.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; IsValidPosition&#x3C;/p&#x3E;
--
-- @param[type=table] _pos Positionstable {X= x, Y= y}
-- @return[type=boolean] Position ist valide
-- @within Anwenderfunktionen
--
function API.ValidatePosition(_pos)
    if type(_pos) == "table" then
        if (_pos.X ~= nil and type(_pos.X) == "number") and (_pos.Y ~= nil and type(_pos.Y) == "number") then
            local world = {Logic.WorldGetSize()}
            if _pos.Z and _pos.Z &#x3C; 0 then
                return false;
            end
            if _pos.X &#x3C;= world[1] and _pos.X &#x3E;= 0 and _pos.Y &#x3C;= world[2] and _pos.Y &#x3E;= 0 then
                return true;
            end
        end
    end
    return false;
end
IsValidPosition = API.ValidatePosition;

---
-- Lokalisiert ein Entity auf der Map. Es können sowohl Skriptnamen als auch
-- IDs verwendet werden. Wenn das Entity nicht gefunden wird, wird eine
-- Tabelle mit XYZ = 0 zurückgegeben.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; GetPosition&#x3C;/p&#x3E;
--
-- @param _Entity Entity (Skriptname oder ID)
-- @return[type=table] Positionstabelle {X= x, Y= y, Z= z}
-- @within Anwenderfunktionen
-- @usage local Position = API.LocateEntity("Hans")
--
function API.LocateEntity(_Entity)
    if (type(_Entity) == "table") then
        return _Entity;
    end
    if (not IsExisting(_Entity)) then
        return {X= 0, Y= 0, Z= 0};
    end
    local x, y, z = Logic.EntityGetPos(GetID(_Entity));
    return {X= x, Y= y, Z= z};
end
GetPosition = API.LocateEntity;

---
-- Aktiviert ein interaktives Objekt, sodass es benutzt werden kann.
--
-- Der State bestimmt, ob es immer aktiviert werden kann, oder ob der Spieler
-- einen Helden benutzen muss. Wird der Parameter weggelassen, muss immer ein
-- Held das Objekt aktivieren.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; InteractiveObjectActivate&#x3C;/p&#x3E;
--
-- @param[type=string] _ScriptName  Skriptname des IO
-- @param[type=number] _State       Aktivierungszustand
-- @within Anwenderfunktionen
-- @usage API.ActivateIO("Haus1", 0)
-- API.ActivateIO("Hut1")
--
function API.ActivateIO(_ScriptName, _State)
    _State = _State or 0;
    if GUI then
        GUI.SendScriptCommand('API.ActivateIO("' .._ScriptName.. '", ' .._State..')');
        return;
    end
    if not IsExisting(_ScriptName) then
        return
    end
    Logic.InteractiveObjectSetAvailability(GetID(_ScriptName), true);
    for i = 1, 8 do
        Logic.InteractiveObjectSetPlayerState(GetID(_ScriptName), i, _State);
    end
end
InteractiveObjectActivate = API.ActivateIO;

---
-- Deaktiviert ein Interaktives Objekt, sodass es nicht mehr vom Spieler
-- aktiviert werden kann.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; InteractiveObjectDeactivate&#x3C;/p&#x3E;
--
-- @param[type=string] _ScriptName Skriptname des IO
-- @within Anwenderfunktionen
-- @usage API.DeactivateIO("Hut1")
--
function API.DeactivateIO(_ScriptName)
    if GUI then
        GUI.SendScriptCommand('API.DeactivateIO("' .._ScriptName.. '")');
        return;
    end
    if not IsExisting(_ScriptName) then
        return;
    end
    Logic.InteractiveObjectSetAvailability(GetID(_ScriptName), false);
    for i = 1, 8 do
        Logic.InteractiveObjectSetPlayerState(GetID(_ScriptName), i, 2);
    end
end
InteractiveObjectDeactivate = API.DeactivateIO;

---
-- Ermittelt alle Entities in der Kategorie auf dem Territorium und gibt
-- sie als Liste zurück.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; GetEntitiesOfCategoryInTerritory&#x3C;/p&#x3E;
--
-- @param[type=number] _player    PlayerID [0-8] oder -1 für alle
-- @param[type=number] _category  Kategorie, der die Entities angehören
-- @param[type=number] _territory Zielterritorium
-- @within Anwenderfunktionen
-- @usage local Found = API.GetEntitiesOfCategoryInTerritory(1, EntityCategories.Hero, 5)
--
function API.GetEntitiesOfCategoryInTerritory(_player, _category, _territory)
    local PlayerEntities = {};
    local Units = {};
    if (_player == -1) then
        for i=0,8 do
            local NumLast = 0;
            repeat
                Units = { Logic.GetEntitiesOfCategoryInTerritory(_territory, i, _category, NumLast) };
                PlayerEntities = Array_Append(PlayerEntities, Units);
                NumLast = NumLast + #Units;
            until #Units == 0;
        end
    else
        local NumLast = 0;
        repeat
            Units = { Logic.GetEntitiesOfCategoryInTerritory(_territory, _player, _category, NumLast) };
            PlayerEntities = Array_Append(PlayerEntities, Units);
            NumLast = NumLast + #Units;
        until #Units == 0;
    end
    return PlayerEntities;
end
GetEntitiesOfCategoryInTerritory = API.GetEntitiesOfCategoryInTerritory;

---
-- Gibt dem Entity einen eindeutigen Skriptnamen und gibt ihn zurück.
-- Hat das Entity einen Namen, bleibt dieser unverändert und wird
-- zurückgegeben.
-- @param[type=number] _EntityID Entity ID
-- @return[type=string] Skriptname
-- @within Anwenderfunktionen
--
function API.EnsureScriptName(_EntityID)
    if type(_EntityID) == "string" then
        return _EntityID;
    else
        assert(type(_EntityID) == "number");
        local name = Logic.GetEntityName(_EntityID);
        if (type(name) ~= "string" or name == "" ) then
            QSB.GiveEntityNameCounter = (QSB.GiveEntityNameCounter or 0)+ 1;
            name = "EnsureScriptName_Name_"..QSB.GiveEntityNameCounter;
            Logic.SetEntityName(_EntityID, name);
        end
        return name;
    end
end
GiveEntityName = API.EnsureScriptName;

-- Overwrite -------------------------------------------------------------------

---
-- Schickt einen Skriptbefehl an die jeweils andere Skriptumgebung.
--
-- Wird diese Funktion als dem globalen Skript aufgerufen, sendet sie den
-- Befehl an das lokale Skript. Wird diese Funktion im lokalen Skript genutzt,
-- wird der Befehl an das globale Skript geschickt.
--
-- @param[type=string]  _Command Lua-Befehl als String
-- @param[type=boolean] _Flag FIXME Optional für GUI.SendScriptCommand benötigt. 
--                      Was macht das Flag?
-- @within Anwenderfunktionen
-- @local
--
function API.Bridge(_Command, _Flag)
    if not GUI then
        Logic.ExecuteInLuaLocalState(_Command)
    else
        GUI.SendScriptCommand(_Command, _Flag)
    end
end

---
-- Wandelt underschiedliche Darstellungen einer Boolean in eine echte um.
--
-- Jeder String, der mit j, t, y oder + beginnt, wird als true interpretiert.
-- Alles andere als false.
--
-- Ist die Eingabe bereits ein Boolean wird es direkt zurückgegeben.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; AcceptAlternativeBoolean&#x3C;/p&#x3E;
--
-- @param _Value Wahrheitswert
-- @return[type=boolean] Wahrheitswert
-- @within Anwenderfunktionen
-- @local
--
-- @usage local Bool = API.ToBoolean("+")  --&#x3E; Bool = true
-- local Bool = API.ToBoolean("no") --&#x3E; Bool = false
--
function API.ToBoolean(_Value)
    return Core:ToBoolean(_Value);
end
AcceptAlternativeBoolean = API.ToBoolean;

---
-- Fügt eine Beschreibung zu einem selbst gewählten Hotkey hinzu.
--
-- Ist der Hotkey bereits vorhanden, wird -1 zurückgegeben.
--
-- @param[type=string] _Key         Tastenkombination
-- @param[type=string] _Description Beschreibung des Hotkey
-- @return[type=number] Index oder Fehlercode
-- @within Anwenderfunktionen
--
function API.AddHotKey(_Key, _Description)
    if not GUI then
        API.Fatal("API.AddHotKey: Can not be used from the global script!");
        return;
    end
    g_KeyBindingsOptions.Descriptions = nil;
    table.insert(Core.Data.HotkeyDescriptions, {_Key, _Description});
    return #Core.Data.HotkeyDescriptions;
end

---
-- Entfernt eine Beschreibung eines selbst gewählten Hotkeys.
--
-- @param[type=number] _Index Index in Table
-- @within Anwenderfunktionen
--
function API.RemoveHotKey(_Index)
    if not GUI then
        API.Fatal("API.RemoveHotKey: Can not be used from the global script!");
        return;
    end
    if type(_Index) ~= "number" or _Index &#x3E; #Core.Data.HotkeyDescriptions then
        API.Fatal("API.RemoveHotKey: No candidate found or Index is nil!");
        return;
    end
    Core.Data.HotkeyDescriptions[_Index] = nil;
end

-- Simple Job Overhaul ---------------------------------------------------------

---
-- Registriert eine Funktion, die nach dem laden ausgeführt wird.
--
-- &#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: AddOnSaveGameLoadedAction
--
-- @param[type=function] _Function Funktion, die ausgeführt werden soll
-- @within Anwenderfunktionen
-- @usage SaveGame = function()
--     API.Note("foo")
-- end
-- API.AddSaveGameAction(SaveGame)
--
function API.AddSaveGameAction(_Function)
    if GUI then
        API.Fatal("API.AddSaveGameAction: Can not be used from the local script!");
        return;
    end
    return Core:AppendFunction("Mission_OnSaveGameLoaded", _Function)
end
AddOnSaveGameLoadedAction = API.AddSaveGameAction;

---
-- Fügt eine Funktion als Job hinzu, die einmal pro Sekunde ausgeführt
-- wird. Die Argumente werden an die Funktion übergeben.
--
-- &#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: StartSimpleJobEx
--
-- @param[type=number] _Function Funktion, die ausgeführt wird
-- @param              ...       Liste von Argumenten
-- @return[type=number] Job ID
-- @within Anwenderfunktionen
--
function API.StartJob(_Function, ...)
    Core.Data.Events.JobIDCounter = Core.Data.Events.JobIDCounter +1;
    local JobID = Core.Data.Events.JobIDCounter;
    Core.Data.Events.EverySecond[JobID] = {
        Function  = _Function,
        Arguments = API.InstanceTable(arg);
    };
    return JobID;
end
StartSimpleJobEx = API.StartJob;

---
-- Fügt eine Funktion als Job hinzu, die zehn Mal pro Sekunde ausgeführt
-- wird. Die Argumente werden an die Funktion übergeben.
--
-- &#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: StartSimpleHiResJobEx
--
-- @param[type=number] _Function Funktion, die ausgeführt wird
-- @param              ...       Liste von Argumenten
-- @return[type=number] Job ID
-- @within Anwenderfunktionen
--
function API.StartHiResJob(_Function, ...)
    Core.Data.Events.JobIDCounter = Core.Data.Events.JobIDCounter +1;
    local JobID = Core.Data.Events.JobIDCounter;
    Core.Data.Events.EveryTurn[JobID] = {
        Function  = _Function,
        Arguments = API.InstanceTable(arg);
    };
    return JobID;
end
StartSimpleHiResJobEx = API.StartHiResJob;

---
-- Prüft ob ein Job mit der ID existiert.
--
-- &#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: JobIsRunningEx
--
-- @param[type=number] _JobID ID des Jobs
-- @within Anwenderfunktionen
--
function API.JobIsRunning(_JobID)
    if Core.Data.Events.EveryTurn[_JobID] then
        return true;
    end
    if Core.Data.Events.EverySecond[_JobID] then
        return true;
    end
    return false;
end
JobIsRunningEx = API.JobIsRunning;

---
-- Bendet einen QSB-Job.
--
-- &#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: EndJobEx
--
-- @param[type=number] _JobID ID des Jobs
-- @within Anwenderfunktionen
--
function API.EndJob(_JobID)
    if Core.Data.Events.EveryTurn[_JobID] then
        Core.Data.Events.EveryTurn[_JobID] = nil;
    end
    if Core.Data.Events.EverySecond[_JobID] then
        Core.Data.Events.EverySecond[_JobID] = nil;
    end
end
EndJobEx = API.EndJob;

-- Echtzeit --------------------------------------------------------------------

---
-- Gibt die real vergangene Zeit seit dem Spielstart in Sekunden zurück.
-- @return[type=number] Vergangene reale Zeit
-- @within Anwenderfunktionen
--
function API.RealTimeGetSecondsPassedSinceGameStart()
    return QSB.RealTime_SecondsSinceGameStart;
end

---
-- Wartet die angebene Zeit in realen Sekunden und führt anschließend das
-- Callback aus.
--
-- Hinweis: Einmal gestartet, kann wait nicht beendet werden.
--
-- @param[type=number] _Waittime Wartezeit in realen Sekunden
-- @param[type=function] _Action Callback-Funktion
-- @param ... Liste der Argumente
-- @return[type=number] Vergangene reale Zeit
-- @within Anwenderfunktionen
--
function API.RealTimeWait(_Waittime, _Action, ...)
    StartSimpleJobEx( function(_StartTime, _Delay, _Callback, _Arguments)
        if (QSB.RealTime_SecondsSinceGameStart &#x3E;= _StartTime + _Delay) then
            if #_Arguments &#x3E; 0 then
                _Callback(unpack(_Arguments));
            else
                _Callback();
            end
            return true;
        end
    end, QSB.RealTime_SecondsSinceGameStart, _Waittime, _Action, {...});
end

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

Core = {
    Data = {
        Events = {
            EverySecond = {},
            EveryTurn = {},
            JobIDCounter = 0,
        },
        Overwrite = {
            StackedFunctions = {},
            AppendedFunctions = {},
            Fields = {},
        },
        HotkeyDescriptions = {},
        BundleInitializerList = {},
        InitalizedBundles = {},
    }
}

---
-- Initialisiert alle verfügbaren Bundles und führt ihre Install-Methode aus.
-- Bundles werden immer getrennt im globalen und im lokalen Skript gestartet.
-- @within Internal
-- @local
--
function Core:InitalizeBundles()
    if not GUI then
        self:SetupGobal_HackCreateQuest();
        self:SetupGlobal_HackQuestSystem();
        self:IdentifyHistoryEdition();
        
        StartSimpleJob("CoreEventJob_OnEveryRealTimeSecond");

        Trigger.RequestTrigger(Event.LOGIC_EVENT_ENTITY_DESTROYED, "", "CoreEventJob_OnEntityDestroyed", 1);
        Trigger.RequestTrigger(Event.LOGIC_EVENT_ENTITY_HURT_ENTITY, "", "CoreEventJob_OnEntityHurtEntity", 1);
        StartSimpleHiResJob("CoreEventJob_OnEveryTurn");
        StartSimpleJob("CoreEventJob_OnEverySecond");
    else
        self:SetupLocal_HackRegisterHotkey();

        StartSimpleJob("CoreEventJob_OnEveryRealTimeSecond");

        Trigger.RequestTrigger(Event.LOGIC_EVENT_ENTITY_DESTROYED, "", "CoreEventJob_OnEntityDestroyed", 1);
        Trigger.RequestTrigger(Event.LOGIC_EVENT_ENTITY_HURT_ENTITY, "", "CoreEventJob_OnEntityHurtEntity", 1);
        StartSimpleHiResJob("CoreEventJob_OnEveryTurn");
        StartSimpleJob("CoreEventJob_OnEverySecond");
    end

    for k,v in pairs(self.Data.BundleInitializerList) do
        local Bundle = _G[v];
        if not GUI then
            if Bundle.Global ~= nil and Bundle.Global.Install ~= nil then
                Bundle.Global:Install();
                Bundle.Local = nil;
            end
        else
            if Bundle.Local ~= nil and Bundle.Local.Install ~= nil then
                Bundle.Local:Install();
                Bundle.Global = nil;
            end
        end
        self.Data.InitalizedBundles[v] = true;
        collectgarbage();
    end
end

---
-- Überschreibt CreateQuest für die Anbindung an Symfonia.
-- @within Internal
-- @local
--
function Core:SetupGobal_HackCreateQuest()
    CreateQuest = function(_QuestName, _QuestGiver, _QuestReceiver, _QuestHidden, _QuestTime, _QuestDescription, _QuestStartMsg, _QuestSuccessMsg, _QuestFailureMsg)
        local Triggers = {};
        local Goals = {};
        local Reward = {};
        local Reprisal = {};
        local NumberOfBehavior = Logic.Quest_GetQuestNumberOfBehaviors(_QuestName);

        for i=0, NumberOfBehavior-1, 1 do
            -- Behavior ermitteln
            local BehaviorName = Logic.Quest_GetQuestBehaviorName(_QuestName, i);
            local BehaviorTemplate = GetBehaviorTemplateByName(BehaviorName);
            assert( BehaviorTemplate, "No template for name: " .. BehaviorName .. " - using an invalid QuestSystemBehavior.lua?!");
            local NewBehavior = {};
            Table_Copy(NewBehavior, BehaviorTemplate);
            local Parameter = Logic.Quest_GetQuestBehaviorParameter(_QuestName, i);
            for j=1,#Parameter do
                NewBehavior:AddParameter(j-1, Parameter[j]);
            end

            -- Füge als Goal hinzu
            if (NewBehavior.GetGoalTable ~= nil) then
                Goals[#Goals + 1] = NewBehavior:GetGoalTable();
                Goals[#Goals].Context = NewBehavior;
                Goals[#Goals].FuncOverrideIcon = NewBehavior.GetIcon;
                Goals[#Goals].FuncOverrideMsgKey = NewBehavior.GetMsgKey;
            end
            -- Füge als Trigger hinzu
            if (NewBehavior.GetTriggerTable ~= nil) then
                Triggers[#Triggers + 1] = NewBehavior:GetTriggerTable();
            end
            -- Füge als Reprisal hinzu
            if (NewBehavior.GetReprisalTable ~= nil) then
                Reprisal[#Reprisal + 1] = NewBehavior:GetReprisalTable();
            end
            -- Füge als Reward hinzu
            if (NewBehavior.GetRewardTable ~= nil) then
                Reward[#Reward + 1] = NewBehavior:GetRewardTable();
            end
        end

        -- Prüfe Mindestkonfiguration des Quest
        if (#Triggers == 0) or (#Goals == 0) then
            return;
        end

        -- Erzeuge den Quest
        if Core:CheckQuestName(_QuestName) then
            local QuestID = QuestTemplate:New(
                _QuestName,
                _QuestGiver or 1,
                _QuestReceiver or 1,
                Goals,
                Triggers,
                tonumber(_QuestTime) or 0,
                Reward,
                Reprisal,
                nil, nil,
                (not _QuestHidden or ( _QuestStartMsg and _QuestStartMsg ~= "") ),
                (not _QuestHidden or ( _QuestSuccessMsg and _QuestSuccessMsg ~= "") or ( _QuestFailureMsg and _QuestFailureMsg ~= "") ),
                _QuestDescription,
                _QuestStartMsg,
                _QuestSuccessMsg,
                _QuestFailureMsg
            );
            g_QuestNameToID[_QuestName] = QuestID;
        else
            fatal("Quest '"..tostring(questName).."': invalid questname! Contains forbidden characters!");
        end
    end
end

---
-- Implementiert die vordefinierten Texte für Custom Behavior und den Aufruf
-- der :Interrupt Methode.
-- @within Internal
-- @local
--
function Core:SetupGlobal_HackQuestSystem()
    QuestTemplate.Trigger_Orig_QSB_Core = QuestTemplate.Trigger
    QuestTemplate.Trigger = function(_quest)
        QuestTemplate.Trigger_Orig_QSB_Core(_quest);
        for i=1,_quest.Objectives[0] do
            if _quest.Objectives[i].Type == Objective.Custom2 and _quest.Objectives[i].Data[1].SetDescriptionOverwrite then
                local Desc = _quest.Objectives[i].Data[1]:SetDescriptionOverwrite(_quest);
                Core:ChangeCustomQuestCaptionText(Desc, _quest);
                break;
            end
        end
    end

    QuestTemplate.Interrupt_Orig_QSB_Core = QuestTemplate.Interrupt;
    QuestTemplate.Interrupt = function(_quest)
        QuestTemplate.Interrupt_Orig_QSB_Core(_quest);
        for i=1, _quest.Objectives[0] do
            if _quest.Objectives[i].Type == Objective.Custom2 and _quest.Objectives[i].Data[1].Interrupt then
                _quest.Objectives[i].Data[1]:Interrupt(_quest, i);
            end
        end
        for i=1, _quest.Triggers[0] do
            if _quest.Triggers[i].Type == Triggers.Custom2 and _quest.Triggers[i].Data[1].Interrupt then
                _quest.Triggers[i].Data[1]:Interrupt(_quest, i);
            end
        end
    end
end

---
-- Überschreibt das Hotkey-Register, sodass eigene Hotkeys mit im Menü
-- angezeigt werden können.
-- @within Internal
-- @local
--
function Core:SetupLocal_HackRegisterHotkey()
    function g_KeyBindingsOptions:OnShow()
        local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";
        if Game ~= nil then
            XGUIEng.ShowWidget("/InGame/KeyBindingsMain/Backdrop", 1);
        else
            XGUIEng.ShowWidget("/InGame/KeyBindingsMain/Backdrop", 0);
        end

        if g_KeyBindingsOptions.Descriptions == nil then
            g_KeyBindingsOptions.Descriptions = {};
            DescRegister("MenuInGame");
            DescRegister("MenuDiplomacy");
            DescRegister("MenuProduction");
            DescRegister("MenuPromotion");
            DescRegister("MenuWeather");
            DescRegister("ToggleOutstockInformations");
            DescRegister("JumpMarketplace");
            DescRegister("JumpMinimapEvent");
            DescRegister("BuildingUpgrade");
            DescRegister("BuildLastPlaced");
            DescRegister("BuildStreet");
            DescRegister("BuildTrail");
            DescRegister("KnockDown");
            DescRegister("MilitaryAttack");
            DescRegister("MilitaryStandGround");
            DescRegister("MilitaryGroupAdd");
            DescRegister("MilitaryGroupSelect");
            DescRegister("MilitaryGroupStore");
            DescRegister("MilitaryToggleUnits");
            DescRegister("UnitSelect");
            DescRegister("UnitSelectToggle");
            DescRegister("UnitSelectSameType");
            DescRegister("StartChat");
            DescRegister("StopChat");
            DescRegister("QuickSave");
            DescRegister("QuickLoad");
            DescRegister("TogglePause");
            DescRegister("RotateBuilding");
            DescRegister("ExitGame");
            DescRegister("Screenshot");
            DescRegister("ResetCamera");
            DescRegister("CameraMove");
            DescRegister("CameraMoveMouse");
            DescRegister("CameraZoom");
            DescRegister("CameraZoomMouse");
            DescRegister("CameraRotate");

            for k,v in pairs(Core.Data.HotkeyDescriptions) do
                if v then
                    v[1] = (type(v[1]) == "table" and v[1][lang]) or v[1];
                    v[2] = (type(v[2]) == "table" and v[2][lang]) or v[2];
                    table.insert(g_KeyBindingsOptions.Descriptions, 1, v);
                end
            end
        end
        XGUIEng.ListBoxPopAll(g_KeyBindingsOptions.Widget.ShortcutList);
        XGUIEng.ListBoxPopAll(g_KeyBindingsOptions.Widget.ActionList);
        for Index, Desc in ipairs(g_KeyBindingsOptions.Descriptions) do
            XGUIEng.ListBoxPushItem(g_KeyBindingsOptions.Widget.ShortcutList, Desc[1]);
            XGUIEng.ListBoxPushItem(g_KeyBindingsOptions.Widget.ActionList,   Desc[2]);
        end
    end
end

---
-- Prüft, ob das Bundle bereits initalisiert ist.
--
-- @param[type=string] _Bundle Name des Moduls
-- @return[type=boolean] Bundle initalisiert
-- @within Internal
-- @local
--
function Core:IsBundleRegistered(_Bundle)
    return self.Data.InitalizedBundles[Bundle] == true;
end

---
-- Registiert ein Bundle, sodass es initialisiert wird.
--
-- @param[type=string] _Bundle Name des Moduls
-- @within Internal
-- @local
--
function Core:RegisterBundle(_Bundle)
    local text = string.format("Error while initialize bundle 's': does not exist!", tostring(_Bundle));
    assert(_G[_Bundle] ~= nil, text);
    table.insert(self.Data.BundleInitializerList, _Bundle);
end

---
-- Registiert ein AddOn als Bundle, sodass es initialisiert wird.
--
-- Diese Funktion macht prinziplell das Gleiche wie Core:RegisterBundle und
-- existiert nur zur Übersichtlichkeit.
--
-- @param[type=string] _AddOn Name des Moduls
-- @within Internal
-- @local
--
function Core:RegisterAddOn(_AddOn)
    local text = string.format("Error while initialize addon 's': does not exist!", tostring(_AddOn));
    assert(_G[_AddOn] ~= nil, text);
    table.insert(self.Data.BundleInitializerList, _AddOn);
end

---
-- Bereitet ein Behavior für den Einsatz im Assistenten und im Skript vor.
-- Erzeugt zudem den Konstruktor.
--
-- @param[type=table] _Behavior Behavior-Objekt
-- @within Internal
-- @local
--
function Core:RegisterBehavior(_Behavior)
    if GUI then
        return;
    end
    if _Behavior.RequiresExtraNo and _Behavior.RequiresExtraNo &#x3E; g_GameExtraNo then
        return;
    end

    if not _G["b_" .. _Behavior.Name] then
        fatal("AddQuestBehavior: can not find ".. _Behavior.Name .."!");
    else
        if not _G["b_" .. _Behavior.Name].new then
            _G["b_" .. _Behavior.Name].new = function(self, ...)
                local behavior = API.InstanceTable(self);
                behavior.i47ya_6aghw_frxil = {};
                for i= 1, #arg, 1 do
                    if self.Parameter and self.Parameter[i] ~= nil then
                        behavior:AddParameter(i-1, arg[i]);
                    else
                        table.insert(behavior.i47ya_6aghw_frxil, arg[i]);
                    end
                end
                return behavior;
            end
        end

        for i= 1, #g_QuestBehaviorTypes, 1 do
            if g_QuestBehaviorTypes[i].Name == _Behavior.Name then
                return;
            end
        end
        table.insert(g_QuestBehaviorTypes, _Behavior);
    end
end

---
-- Prüft, ob der Questname formal korrekt ist. Questnamen dürfen i.d.R. nur
-- die Zeichen A-Z, a-7, 0-9, - und _ enthalten.
--
-- @param[type=string] _Name Name des Quest
-- @return[type=boolean] Questname ist fehlerfrei
-- @within Internal
-- @local
--
function Core:CheckQuestName(_Name)
    return string.find(_Name, "^[A-Za-z0-9_]+$") ~= nil;
end

---
-- Ändert den Text des Beschreibungsfensters eines Quests. Die Beschreibung
-- wird erst dann aktualisiert, wenn der Quest ausgeblendet wird.
--
-- @param[type=string] _Text Neuer Text
-- @param[type=table] _Quest Quest Table
-- @within Internal
-- @local
--
function Core:ChangeCustomQuestCaptionText(_Text, _Quest)
    _Quest.QuestDescription = _Text;
    Logic.ExecuteInLuaLocalState([[
        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomLeft/Message/QuestObjectives/Custom/BGDeco",0)
        local identifier = "]].._Quest.Identifier..[["
        for i=1, Quests[0] do
            if Quests[i].Identifier == identifier then
                local text = Quests[i].QuestDescription
                XGUIEng.SetText("/InGame/Root/Normal/AlignBottomLeft/Message/QuestObjectives/Custom/Text", "]].._Text..[[")
                break
            end
        end
    ]]);
end

---
-- Erweitert eine Funktion um eine andere Funktion.
--
-- Jede hinzugefügte Funktion wird vor der Originalfunktion ausgeführt. Es
-- ist möglich, eine neue Funktion an einem bestimmten Index einzufügen. Diese
-- Funktion ist nicht gedacht, um sie direkt auszuführen. Für jede Funktion
-- im Spiel sollte eine API-Funktion erstellt werden.
--
-- Wichtig: Die gestapelten Funktionen, die vor der Originalfunktion
-- ausgeführt werden, müssen etwas zurückgeben, um die Funktion an
-- gegebener Stelle zu verlassen.
--
-- @param[type=string]   _FunctionName Name der erweiterten Funktion
-- @param[type=function] _StackFunction Neuer Funktionsinhalt
-- @param[type=number]   _Index Reihenfolgeindex
-- @within Internal
-- @local
--
function Core:StackFunction(_FunctionName, _StackFunction, _Index)
    if not self.Data.Overwrite.StackedFunctions[_FunctionName] then
        self.Data.Overwrite.StackedFunctions[_FunctionName] = {
            Original = self:GetFunctionInString(_FunctionName),
            Attachments = {}
        };

        local batch = function(...)
            local ReturnValue;
            for i= 1, #self.Data.Overwrite.StackedFunctions[_FunctionName].Attachments, 1 do
                local Function = self.Data.Overwrite.StackedFunctions[_FunctionName].Attachments[i];
                ReturnValue = {Function(unpack(arg))};
                if #ReturnValue &#x3E; 0 then
                    return unpack(ReturnValue);
                end
            end
            ReturnValue = {self.Data.Overwrite.StackedFunctions[_FunctionName].Original(unpack(arg))};
            return unpack(ReturnValue);
        end
        self:ReplaceFunction(_FunctionName, batch);
    end

    _Index = _Index or #self.Data.Overwrite.StackedFunctions[_FunctionName].Attachments+1;
    table.insert(self.Data.Overwrite.StackedFunctions[_FunctionName].Attachments, _Index, _StackFunction);
end

---
-- Erweitert eine Funktion um eine andere Funktion.
--
-- Jede hinzugefügte Funktion wird nach der Originalfunktion ausgeführt. Es
-- ist möglich eine neue Funktion an einem bestimmten Index einzufügen. Diese
-- Funktion ist nicht gedacht, um sie direkt auszuführen. Für jede Funktion
-- im Spiel sollte eine API-Funktion erstellt werden.
--
-- @param[type=string]   _FunctionName Name der erweiterten Funktion
-- @param[type=function] _AppendFunction Neuer Funktionsinhalt
-- @param[type=number]   _Index Reihenfolgeindex
-- @within Internal
-- @local
--
function Core:AppendFunction(_FunctionName, _AppendFunction, _Index)
    if not self.Data.Overwrite.AppendedFunctions[_FunctionName] then
        self.Data.Overwrite.AppendedFunctions[_FunctionName] = {
            Original = self:GetFunctionInString(_FunctionName),
            Attachments = {}
        };

        local batch = function(...)
            local ReturnValue = self.Data.Overwrite.AppendedFunctions[_FunctionName].Original(unpack(arg));
            for i= 1, #self.Data.Overwrite.AppendedFunctions[_FunctionName].Attachments, 1 do
                local Function = self.Data.Overwrite.AppendedFunctions[_FunctionName].Attachments[i];
                ReturnValue = {Function(unpack(arg))};
            end
            return unpack(ReturnValue);
        end
        self:ReplaceFunction(_FunctionName, batch);
    end

    _Index = _Index or #self.Data.Overwrite.AppendedFunctions[_FunctionName].Attachments+1;
    table.insert(self.Data.Overwrite.AppendedFunctions[_FunctionName].Attachments, _Index, _AppendFunction);
end

---
-- Überschreibt eine Funktion mit einer anderen.
--
-- Funktionen in einer Tabelle werden überschrieben, indem jede Ebene des
-- Tables mit einem Punkt angetrennt wird.
--
-- @param[type=string]   _FunctionName Name der erweiterten Funktion
-- @param[type=function] _AppendFunction Neuer Funktionsinhalt
-- @local
-- @within Internal
-- @usage A = {foo = function() API.Note("bar") end}
-- B = function() API.Note("muh") end
-- Core:ReplaceFunction("A.foo", B)
-- -- A.foo() == B() =&#x3E; "muh"
--
function Core:ReplaceFunction(_FunctionName, _Function)
    assert(type(_FunctionName) == "string");
    local ref = _G;

    local s, e = _FunctionName:find(".");
    while (s ~= nil) do
        local SubName = _FunctionName:sub(1, e-1);
        SubName = (tonumber(SubName) ~= nil and tonumber(SubName)) or SubName;

        ref = ref[SubName];
        _FunctionName = _FunctionName:sub(e+1);
        s, e = _FunctionName:find(".");
    end

    local SubName = (tonumber(_FunctionName) ~= nil and tonumber(_FunctionName)) or _FunctionName;
    ref[SubName] = _Function;
end

---
-- Sucht eine Funktion mit dem angegebenen Namen.
--
-- Ist die Funktionen innerhalb einer Table, so sind alle Ebenen bis zum
-- Funktionsnamen mit anzugeben, abgetrennt durch einen Punkt.
--
-- @param[type=string] _FunctionName Name der erweiterten Funktion
-- @return[type=function] Referenz auf die Funktion
-- @within Internal
-- @local
--
function Core:GetFunctionInString(_FunctionName)
    assert(type(_FunctionName) == "string");
    local ref = _G;

    local s, e = _FunctionName:find(".");
    while (s ~= nil) do
        local SubName = _FunctionName:sub(1, e-1);
        SubName = (tonumber(SubName) ~= nil and tonumber(SubName)) or SubName;

        ref = ref[SubName];
        _FunctionName = _FunctionName:sub(e+1);
        s, e = _FunctionName:find(".");
    end

    local SubName = (tonumber(_FunctionName) ~= nil and tonumber(_FunctionName)) or _FunctionName;
    return ref[SubName];
end

---
-- Wandelt underschiedliche Darstellungen einer Boolean in eine echte um.
--
-- Jeder String, der mit j, t, y oder + beginnt, wird als true interpretiert.
-- Alles andere als false.
--
-- Ist die Eingabe bereits ein Boolean wird es direkt zurückgegeben.
--
-- @param[type=string] _Input Boolean-Darstellung
-- @return[type=boolean] Konvertierte Boolean
-- @within Internal
-- @local
--
function Core:ToBoolean(_Input)
    if type(_Input) == "boolean" then
        return _Input;
    end
    if string.find(string.lower(tostring(_Input)), "^[tjy\\+].*$") then
        return true;
    end
    return false;
end

---
-- Identifiziert anhand der um +3 Verschobenen PlayerID bei den Scripting
-- Values die infamous History Edition. Ob es sich um die History Edition
-- hält, wird in der Variable QSB.HistoryEdition gespeichert.
-- @within Internal
-- @local
--
function Core:IdentifyHistoryEdition()
    local EntityID = Logic.CreateEntity(Entities.U_NPC_Amma_NE, 100, 100, 0, 8);
    MakeInvulnerable(EntityID);
    if Logic.GetEntityScriptingValue(EntityID, -68) == 8 then
        API.Bridge("QSB.HistoryEdition = true");
        QSB.HistoryEdition = true;
    end
    DestroyEntity(EntityID);
end

-- Jobs ------------------------------------------------------------------------

-- Dieser Job ermittelt automatisch, ob eine Sekunde reale Zeit vergangen ist
-- und zählt eine Variable hoch, die die gesamt verstrichene reale Zeit hält.

function Core.EventJob_EventOnEveryRealTimeSecond()
    if not QSB.RealTime_LastTimeStamp then
        QSB.RealTime_LastTimeStamp = math.floor(Framework.TimeGetTime());
    end
    local CurrentTimeStamp = math.floor(Framework.TimeGetTime());

    -- Eine Sekunde ist vergangen
    if QSB.RealTime_LastTimeStamp ~= CurrentTimeStamp then
        QSB.RealTime_LastTimeStamp = CurrentTimeStamp;
        QSB.RealTime_SecondsSinceGameStart = QSB.RealTime_SecondsSinceGameStart +1;
    end
end
CoreEventJob_OnEveryRealTimeSecond = Core.EventJob_EventOnEveryRealTimeSecond;

-- Dieser Job führt alle registrierten Events aus, die einmal pro Sekunde
-- gestartet werden sollen.

function Core.EventJob_EventOnEverySecond()
    for k, v in pairs(Core.Data.Events.EverySecond) do
        if v and v.Function(unpack(v.Arguments)) then
            Core.Data.Events.EverySecond[k] = nil;
        end
    end
end
CoreEventJob_OnEverySecond = Core.EventJob_EventOnEverySecond;

-- Dieser Job führt alle registrierten Events aus, die zehn Mal pro Sekunde
-- gestartet werden sollen.

function Core.EventJob_EventOnEveryTurn()
    for k, v in pairs(Core.Data.Events.EveryTurn) do
        if v and v.Function(unpack(v.Arguments)) then
            Core.Data.Events.EveryTurn[k] = nil;
        end
    end
end
CoreEventJob_OnEveryTurn = Core.EventJob_EventOnEveryTurn;

</code></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundlebriefingsystem.lua.html">
            <div class='doclink'>
                <div>BundleBriefingSystem</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><code>-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundleBriefingSystem                                         # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Ermöglicht es Briefing zu verwenden.
--
-- Briefings dienen zur Darstellung von Dialogen oder zur näheren Erleuterung
-- der aktuellen Spielsituation. Mit Multiple Choice können dem Spieler mehrere
-- Auswahlmöglichkeiten gegeben, multiple Handlungsstränge gestartet
-- oder Menüstrukturen abgebildet werden. Mittels Sprüngen und Leerseiten
-- kann innerhalb des Multiple Choice Briefings navigiert werden.
--
-- &#x3C;p&#x3E;Das wichtigste auf einen Blick:
-- &#x3C;ul&#x3E;
-- &#x3C;li&#x3E;&#x3C;a href="#API.StartBriefing"&#x3E;Ein Briefing starten&#x3C;/a&#x3E;&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;&#x3C;a href="#AP"&#x3E;Ein Seite erzeugen&#x3C;/a&#x3E;&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundleBriefingSystem = {};

API = API or {};
QSB = QSB or {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Startet ein Briefing.
--
-- Für ein Briefing können verschiedene spezielle Einstellungen vorgenommen
-- werden. Jede dieser Einstellungen wird mit true aktiviert.
-- &#x3C;table border="1"&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;&#x3C;b&#x3E;Einstellung&#x3C;/b&#x3E;&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;&#x3C;b&#x3E;Beschreibung&#x3C;/b&#x3E;&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;HideBorderPins&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Die Grenzsteine werden während des Briefing ausgeblendet&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;TransparentBars&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Die Bars werden transparent dargestellt. (Opacity = 39)&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;ShowSky&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Der Himmel wird während des Briefing angezeigt&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;RestoreGameSpeed&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Die Spielgeschwindigkeit wird nach Ende des Briefing zurückgesetzt&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;RestoreCamera&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Die Kameraposition vor dem Briefing wird wiederhergestellt&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;SkippingAllowed&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Das manuelle Springen zwischen Seiten wird erlaubt.&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;ReturnForbidden&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Das Zurückspringen zur Vorherigen Seite wird verboten&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;/table&#x3E;
--
-- &#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: StartBriefing
--
-- @param[type=table] _Briefing Briefing Definition
-- @return[type=number] ID des Briefing
-- @within Anwenderfunktionen
--
function API.StartBriefing(_Briefing)
    if GUI then
        warn("API.StartBriefing: Cannot start briefing from local script!");
        return -1;
    end
    return BundleBriefingSystem.Global:StartBriefing(_Briefing);
end
StartBriefing = API.StartBriefing;

---
-- Prüft, ob ein Briefing abgeschlossen wurde.
--
-- &#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: IsBriefingFinished
--
-- @param[type=table] _Briefing Briefing Definition
-- @return[type=boolean] Briefing ist beendet
-- @within Anwenderfunktionen
--
function API.IsBriefingFinished(_BriefingID)
    if GUI then
        warn("API.IsBriefingFinished: Cannot check briefing state from local script!");
        return false;
    end
    return BundleBriefingSystem.Global.Data.FinishedBriefings[_BriefingID] == true;
end
IsBriefingFinished = API.IsBriefingFinished;

---
-- Prüft, ob ein Briefing abgeschlossen wurde.
--
-- &#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: IsBriefingActive
--
-- @param[type=table] _Briefing Briefing Definition
-- @return[type=boolean] Briefing ist beendet
-- @within Anwenderfunktionen
--
function API.IsBriefingActive(_BriefingID)
    if GUI then
        return BundleBriefingSystem.Local.Data.BriefingActive == true;
    end
    return BundleBriefingSystem.Global.Data.BriefingActive == true;
end
IsBriefingActive = API.IsBriefingActive;

---
-- Steuert, ob Quest Timer während Briefings pausiert sind oder weiterzählen.
--
-- &#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: PauseQuestsDuringBriefings
--
-- @param[type=briefing] _Flag Briefing Definition
-- @within Anwenderfunktionen
--
function API.BriefingPauseQuests(_Flag)
    BundleBriefingSystem.Global.Data.PauseQuests = _Flag == true;
end
PauseQuestsDuringBriefings = API.BriefingPauseQuests;

---
-- Erzeugt die Funktionen zur Erstellung von Seiten in einem Briefing und bindet
-- sie an das Briefing. Diese Funktion muss vor dem Start eines Briefing
-- aufgerufen werden um Seiten hinzuzufügen.
--
-- &#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: AddPages
--
-- @param[type=table] _Briefing Briefing Definition
-- @return[type=function] &#x3C;a href="#AP"&#x3E;AP&#x3C;/a&#x3E;
-- @return[type=function] &#x3C;a href="#ASP"&#x3E;ASP&#x3C;/a&#x3E;
-- @within Anwenderfunktionen
--
-- @usage local AP, ASP = API.AddPages(Briefing);
--
function API.AddPages(_Briefing)
    if GUI then
        fatal("API.AddPages: Cannot be used from local script!");
        return;
    end
    _Briefing.GetPage = function(self, _NameOrID)
        local ID = BundleBriefingSystem.Global:GetPageIDByName(_NameOrID);
        return BundleBriefingSystem.Global.Data.CurrentBriefing[ID];
    end

    local AP = function(_Page)
        _Briefing.Length = (_Briefing.Length or 0) +1;
        if type(_Page) == "table" then
            -- Sprache anpassen
            local Language = (Network.GetDesiredLanguage() == "de" and "de") or "en";
            if type(_Page.Title) == "table" then
                _Page.Title = _Page.Title[Language];
            end
            if type(_Page.Text) == "table" then
                _Page.Text = _Page.Text[Language];
            end
            -- Lookat mappen
            if type(_Page.LookAt) == "string" or type(_Page.LookAt) == "number" then
                _Page.LookAt = {_Page.LookAt, 0}
            end
            -- Position mappen
            if type(_Page.Position) == "string" or type(_Page.Position) == "number" then
                _Page.Position = {_Page.Position, 0}
            end
            -- Dialogkamera
            if _Page.DialogCamera == true then
                _Page.Angle = _Page.Angle or BundleBriefingSystem.Global.Data.DLGCAMERA_ANGLEDEFAULT;
                _Page.Zoom = _Page.Zoom or BundleBriefingSystem.Global.Data.DLGCAMERA_ZOOMDEFAULT;
                _Page.FOV = _Page.FOV or BundleBriefingSystem.Global.Data.DLGCAMERA_FOVDEFAULT;
                _Page.Rotation = _Page.Rotation or BundleBriefingSystem.Global.Data.DLGCAMERA_ROTATIONDEFAULT;
            else
                _Page.Angle = _Page.Angle or BundleBriefingSystem.Global.Data.CAMERA_ANGLEDEFAULT;
                _Page.Zoom = _Page.Zoom or BundleBriefingSystem.Global.Data.CAMERA_ZOOMDEFAULT;
                _Page.FOV = _Page.FOV or BundleBriefingSystem.Global.Data.CAMERA_FOVDEFAULT;
                _Page.Rotation = _Page.Rotation or BundleBriefingSystem.Global.Data.CAMERA_ROTATIONDEFAULT;
            end
            -- FlyTo Animation für MC entfernen
            if _Page.FlyTo and _Page.MC then
                _Page.FlyTo = nil;
            end
            -- Anzeigezeit setzen
            if not _Page.Duration then
                if _Page.FlyTo then
                    _Page.Duration = _Page.FlyTo.Duration;
                else
                    _Briefing.SkippingAllowed = true;
                    _Page.Duration = -1;
                end
            end
            -- Multiple Choice
            if _Page.MC then
                for i= 1, #_Page.MC do
                    _Page.MC[i].ID = i;
                end
                _Page.Text = "";
                _Page.text = "";
                _Page.NoSkipping = true;
                _Page.Duration = -1;
            end
            _Page.GetSelectedAnswer = function(self)
                if not self.MC or not self.MC.Selected then
                    return 0;
                end
                return self.MC.Selected;
            end

            table.insert(_Briefing, _Page);
        else
            table.insert(_Briefing, (_Page ~= nil and _Page) or -1);
        end
        return _Page;
    end

    local ASP = function(...)
        local PageName;
        if #arg &#x3E; 5 then
            PageName = table.remove(arg, 1);
        end
        local Position = {arg[1], 70};
        if Logic.IsKnight(GetID(arg[1])) then
            Position[2] = 120;
        end
        return AP {
            Name         = PageName,
            Title        = arg[2],
            Text         = arg[3],
            Position     = Position,
            Action       = arg[5],
            Angle        = (arg[4] == true and 40) or 26,
            Zoom         = (arg[4] == true and 2400) or 6250,
            DialogCamera = arg[4] == true,
        }
    end
    return AP, ASP;
end
AddPages = API.AddPages;

---
-- Erstellt eine Seite für ein Dialog-Briefing.
--
-- &#x3C;b&#x3E;Achtung&#x3C;/b&#x3E;: Diese Funktion wird von
-- &#x3C;a href="#API.AddPages"&#x3E;API.AddPages&#x3C;/a&#x3E; erzeugt und an
-- das Briefing gebunden.
--
-- &#x3C;h5&#x3E;Normale Briefings&#x3C;/h5&#x3E;
--
-- Eine einfache Seite lässt sich unter Nutzung von DialogCamera erstellen.
-- Dadurch wird entweder Nahsicht oder Fernsicht verwendet. Werte für Angle,
-- Rotation oder Zoom werden automatisch gesetzt, wenn sie fehlen.
-- &#x3C;pre&#x3E;AP {
--    Title        = "Titel",
--    Text         = "Das ist der Text der Seite.",
--    Position     = "HQ2",
--    DialogCamera = false,
--    Angle        = 30
--}&#x3C;/pre&#x3E;
-- Es gilt zu beachten, dass Seiten ohne Duration solange angezeigt werden,
-- bis der Benutzer die Seite per Button-Klick verlässt.
--
-- Es kann eine einfache Bewegung erzeugt werden. Hierzu wird FlyTo benutzt.
-- &#x3C;pre&#x3E;AP {
--    ...
--    FlyTo        = {
--        Position = {"hero", 250},
--        Zoom     = 2200,
--        Rotation = Logic.GetEntityOrientation(GetID("hero"))+90,
--        Angle    = 12,
--        Duration = 15,
--    }
--}&#x3C;/pre&#x3E;
-- Die Dauer der Animation (FlyTo.Duration) wird automatisch zur Dauer der
-- Seite, wenn diese nicht gesetzt ist oder die Animation länger ist.
--
-- &#x3C;pre&#x3E;Portrait = "Path/to/Portrait.ong",&#x3C;/pre&#x3E;
-- Jede Seite kann eine Grafik am linken oberen Rand anzeigen. Diese Grafik wird
-- als Portrait betrachtet und sollte 400x600 Pixel groß sein.
-- 
-- &#x3C;pre&#x3E;Splashscreen = "Path/to/Graphic.ong",&#x3C;/pre&#x3E;
-- Jede Seite kann ebenso eine bildschirmfüllende Grafik anzeigen. Diese Grafik
-- heißt Splashscreen. Splashscreens sollten immer das Format 16:9 haben.
--
--&#x3C;pre&#x3E;Position = {X= 12000.0, Y= 36000.0, Z= 6000.0},
--LookAt   = {X= 10000.0, Y= 35000.0, Z= 2345.0},&#x3C;/pre&#x3E;
-- AP unterstützt ebenso die Angabe von XYZ-Koordinaten. Positionen können auch
-- als Vektoren angegeben werden. Dann hat die Kamera eine Position und eine
-- Blickrichtung.
--
-- &#x3C;h5&#x3E;Multiple Choice&#x3C;/h5&#x3E;
--
-- In einem Dialog kann der Spieler auch zur Auswahl einer Option gebeten
-- werden. Dies wird als Multiple Choice bezeichnet. Schreibe die Optionen
-- in eine Subtable MC.
-- &#x3C;pre&#x3E;AP {
--    ...
--    MC = {
--        {"Antwort 1", 5},
--        {"Antwort 2", "SomePageName"},
--    },
--}&#x3C;/pre&#x3E;
-- Eine Antwort kann auch markiert werden, dass sie auch bei einem Rücksprung,
-- nicht mehrfach gewählt werden kann.
-- &#x3C;pre&#x3E;{"Antwort 3", "AnotherPage", Remove = true},&#x3C;/pre&#x3E;
-- Nachdem der Spieler eine Antwort gewählt hat, wird er auf die Seite mit
-- der angegebenen ID oder dem Namen geleitet. Um das Briefing zu beenden,
-- nachdem ein Pfad beendet ist, wird eine leere AP-Seite genutzt. Auf diese
-- Weise weiß das Briefing, das es an dieser Stelle zuende ist.
-- &#x3C;pre&#x3E;AP()&#x3C;/pre&#x3E;
-- Soll stattdessen zu einer anderen Seite gesprungen werden, kann bei AP die
-- ID der Seite angeben werden, zu der gesprungen werden soll.
-- &#x3C;pre&#x3E;AP(8)&#x3C;/pre&#x3E;
-- Pages können auch einen Namen erhalten. Der Name kann anstelle der ID für
-- Sprünge genutzt werden.
-- &#x3C;pre&#x3E;AP("SomePageName")&#x3C;/pre&#x3E;
--
-- Um später zu einem beliebigen Zeitpunkt die gewählte Antwort einer Seite zu
-- erfahren, muss der Name der Seite oder die ID genutzt werden.
-- &#x3C;pre&#x3E;Briefing.Finished(_Data)
--    local Choosen = _Data:GetPage("Choice"):GetSelectedAnswer();
--end&#x3C;/pre&#x3E;
-- Die zurückgegebene Zahl ist der Index der Antwort, angefangen von oben.
-- Wird 0 zurückgegeben, wurde noch nicht geantwortet. Wenn Anworten nicht
-- aktiv sind, verändert sich der Index anderer Antworten nicht.
--
-- Wenn man zurückblättern erlaubt, aber nicht will, dass die Entscheidung
-- erneut getroffen werden kann, kann man dies mit NoRethink unterbinden.
-- &#x3C;pre&#x3E;AP {
--    ...
--    NoRethink = true,
--}&#x3C;/pre&#x3E;
-- Auf diese Weise hat der Spieler die Möglichkeit die Texte nach der letzten
-- Entscheidung noch einmal zu lesen, ohne dass er seine Meinung ändern kann.
--
-- @param[type=table] _Page Spezifikation der Seite
-- @return[type=table] Refernez auf die angelegte Seite
-- @within Briefing
--
function AP(_Page)
    API.Fatal("AP: Please use the function provides by AddPages!");
end

---
-- Erstellt eine Seite in vereinfachter Syntax. Es wird davon
-- Ausgegangen, dass das Entity ein Siedler ist. Die Kamera
-- schaut den Siedler an.
--
-- &#x3C;b&#x3E;Achtung&#x3C;/b&#x3E;: Diese Funktion wird von
-- &#x3C;a href="#API.AddPages"&#x3E;API.AddPages&#x3C;/a&#x3E; erzeugt und an
-- das Briefing gebunden.
--
-- @param[type=string]   _pageName     (optional) Briefing-Seite Namen geben
-- @param[type=string]   _entity       Entity, das die Kamera zeigt
-- @param[type=string]   _title	       Titel der Seite
-- @param[type=string]   _text         Text der Seite
-- @param[type=boolean]  _dialogCamera Nahsicht an/aus
-- @param[type=function] _action       Callback-Funktion
-- @return[type=table] Referenz auf die Seite
-- @within Briefing
-- @usage -- Beispiel ohne Page Name
-- ASP("hans", "Hänschen-Klein", "Ich gehe in die weitel Welt hinein.", true);
-- -- Beispiel mit Page Name
-- ASP("B1P1", "hans", "Hänschen-Klein", "Ich gehe in die weitel Welt hinein.", true);
--
function ASP(...)
    fatal("ASP: Please use the function provided by AddPages!");
end

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

BundleBriefingSystem = {
    Global = {
        Data = {
            CAMERA_ANGLEDEFAULT = 43,
            CAMERA_ROTATIONDEFAULT = -45,
            CAMERA_ZOOMDEFAULT = 6250,
            CAMERA_FOVDEFAULT = 42,
            DLGCAMERA_ANGLEDEFAULT = 26,
            DLGCAMERA_ROTATIONDEFAULT = -45,
            DLGCAMERA_ZOOMDEFAULT = 3400,
            DLGCAMERA_FOVDEFAULT = 25,

            FinishedBriefings = {},
            CurrentBriefing = {},
            CurrentPage = {},
            BriefingQueue = {},
            BriefingID = 0,
            DisplayIngameCutscene = false,
            BriefingActive = false,
            PauseQuests = true,
        }
    },
    Local = {
        Data = {
            CurrentBriefing = {},
            CurrentPage = {},
            BriefingMessages = {},
            DisplayIngameCutscene = false,
            BriefingActive = false,
            LastSkipButtonPressed = 0,
        },
    },

    Text = {
        NextButton = {de = "Weiter",  en = "Forward"},
        PrevButton = {de = "Zurück",  en = "Previous"},
        EndButton  = {de = "Beenden", en = "Close"},
    },
}

-- Global Script ------------------------------------------------------------ --

---
-- Startet das Bundle im globalen Skript.
-- @within Internal
-- @local
--
function BundleBriefingSystem.Global:Install()
    BundleBriefingSystem:OverrideApiNote();
    StartSimpleHiResJobEx(self.BriefingExecutionController);
    StartSimpleJobEx(self.BriefingQuestPausedController);
end

---
-- Konvertiert eine Briefing-Table des alten Formats in das neue. Diese
-- Funktion ist auf Zeit im Skript und wird später wieder entfernt.
-- @param[type=table] _Briefing Briefing Definition
-- @return[type=number] ID des Briefing
-- @within Internal
-- @local
--
function BundleBriefingSystem.Global:ConvertBriefingTable(_Briefing)
    _Briefing.DisableGlobalInvulnerability = _Briefing.disableGlobalInvulnerability or _Briefing.DisableGlobalInvulnerability;
    _Briefing.HideBorderPins = _Briefing.hideBorderPins or _Briefing.HideBorderPins;
    _Briefing.ShowSky = _Briefing.showSky or _Briefing.ShowSky;
    _Briefing.RestoreGameSpeed = _Briefing.restoreGameSpeed or _Briefing.RestoreGameSpeed;
    _Briefing.RestoreCamera = _Briefing.restoreCamera or _Briefing.RestoreCamera;
    _Briefing.SkippingAllowed = (_Briefing.skipPerPage or _Briefing.skipAll) or _Briefing.SkippingAllowed;
    _Briefing.ReturnForbidden = _Briefing.returnForbidden or _Briefing.ReturnForbidden;
    _Briefing.Finished = _Briefing.finished or _Briefing.Finished;
    _Briefing.Starting = _Briefing.starting or _Briefing.Starting;
    
    for k, v in pairs(_Briefing) do
        if type(v) == "table" then
            -- Normale Optionen
            _Briefing[k].Title = v.title or _Briefing[k].Title;
            _Briefing[k].Text = v.text or _Briefing[k].Text;
            _Briefing[k].Position = (v.position and {v.position, 0}) or _Briefing[k].Position;
            _Briefing[k].Angle = v.angle or _Briefing[k].Angle;
            _Briefing[k].Rotation = v.rotation or _Briefing[k].Rotation;
            _Briefing[k].Zoom = v.zoom or _Briefing[k].Zoom;
            _Briefing[k].Action = v.action or _Briefing[k].Action;
            _Briefing[k].FadeIn = v.fadeIn or _Briefing[k].FadeIn;
            _Briefing[k].FadeOut = v.fadeOut or _Briefing[k].FadeOut;
            _Briefing[k].FaderAlpha = v.faderAlpha or _Briefing[k].FaderAlpha;
            _Briefing[k].DialogCamera = v.dialogCamera or _Briefing[k].DialogCamera;
            _Briefing[k].Portrait = v.portrait or _Briefing[k].Portrait;
            _Briefing[k].NoRethink = v.noRethink or _Briefing[k].NoRethink;
            _Briefing[k].NoHistory = v.noHistory or _Briefing[k].NoHistory;
            -- Splashscreen
            if v.splashscreen then
                v.Splashscreen = v.splashscreen;
                if type(v.Splashscreen) == "table" then
                    v.Splashscreen = v.Splashscreen.image;
                end
            end
            -- Multiple Choice
            if v.mc then
                _Briefing[k].Title = v.mc.title;
                _Briefing[k].Text = v.mc.title;
                _Briefing[k].MC = v.mc.answers;
            end
        end
    end
    return _Briefing;
end

---
-- Startet ein Briefing.
-- @param[type=table] _Briefing Briefing Definition
-- @return[type=number] ID des Briefing
-- @within Internal
-- @local
--
function BundleBriefingSystem.Global:StartBriefing(_Briefing)
    _Briefing = self:ConvertBriefingTable(_Briefing);
    
    if not self.Data.LoadScreenHidden or self:IsBriefingActive() then
        table.insert(self.Data.BriefingQueue, _Briefing);
        if not self.Data.BriefingQueueJobID then
            self.Data.BriefingQueueJobID = StartSimpleHiResJobEx(self.BriefingQueueController);
        end
        return;
    end

    self.Data.BriefingID = self.Data.BriefingID +1;
    self.Data.CurrentBriefing = API.InstanceTable(_Briefing);
    self.Data.CurrentBriefing.Page = 1;
    self.Data.CurrentBriefing.PageHistory = {};
    self.Data.CurrentBriefing.ID = self.Data.BriefingID;
    self:DisableMCAnswers();
    if self.Data.CurrentBriefing.DisableGlobalInvulnerability ~= false then
        Logic.SetGlobalInvulnerability(1);
    end
    local Briefing = API.ConvertTableToString(self.Data.CurrentBriefing);
    API.Bridge("BundleBriefingSystem.Local:StartBriefing(" ..Briefing.. ")");
    
    self.Data.BriefingActive = true;
    if self.Data.CurrentBriefing.Starting then
        self.Data.CurrentBriefing:Starting();
    end
    self:PageStarted();
    return self.Data.BriefingID;
end

---
-- Beendet ein Briefing.
-- @within Internal
-- @local
--
function BundleBriefingSystem.Global:FinishBriefing()
    Logic.SetGlobalInvulnerability(0);
    API.Bridge("BundleBriefingSystem.Local:FinishBriefing()");

    if self.Data.CurrentBriefing.Finished then
        self.Data.CurrentBriefing:Finished();
    end

    self.Data.FinishedBriefings[self.Data.CurrentBriefing.ID] = true;
    self.Data.CurrentBriefing = {};
    self.Data.CurrentPage = {};
    self.Data.BriefingActive = false;
end

---
-- Gibt die Page-ID zum angegebenen Page-Namen zurück.
--
-- Wenn keine Seite gefunden wird, die den angegebenen Namen hat, wird 0
-- zurückgegeben. Wenn eine Page-ID angegeben wird, wird diese zurückgegeben.
--
-- @param[type=string] _PageName Name der Seite
-- @return[type=number] ID der Seite
-- @within Internal
-- @local
--
function BundleBriefingSystem.Global:GetPageIDByName(_PageName)
    if self.Data.CurrentBriefing then
        if type(_PageName) == "number" then
            return _PageName;
        end
        for i= 1, self.Data.CurrentBriefing.Length, 1 do
            local Page = self.Data.CurrentBriefing[i];
            if Page and type(Page) == "table" and Page.Name == _PageName then
                return i;
            end
        end
    end
    return 0;
end

---
-- Startet die aktuelle Briefing-Seite.
-- @within Internal
-- @local
--
function BundleBriefingSystem.Global:PageStarted()
    local PageID = self.Data.CurrentBriefing.Page;
    if PageID then
        if type(self.Data.CurrentBriefing[PageID]) == "table" then
            if type(self.Data.CurrentBriefing[PageID]) == "table" then
                if self.Data.CurrentBriefing[PageID].Action then
                    self.Data.CurrentBriefing[PageID]:Action();
                end
                self.Data.CurrentPage = self.Data.CurrentBriefing[PageID];
                self.Data.CurrentPage.Started = Logic.GetTime();
                API.Bridge("BundleBriefingSystem.Local:PageStarted()");
            end

        elseif type(self.Data.CurrentBriefing[PageID]) == "string" then
            PageID = self:GetPageIDByName(self.Data.CurrentBriefing[PageID]);
            if PageID &#x3E; 0 then
                self.Data.CurrentBriefing.Page = PageID;
                API.Bridge("BundleBriefingSystem.Local.Data.CurrentBriefing.Page = " ..PageID);
                self:PageStarted();
            else
                self:FinishBriefing();
            end

        elseif type(self.Data.CurrentBriefing[PageID]) == "number" and self.Data.CurrentBriefing[PageID] &#x3E; 0 then
            self.Data.CurrentBriefing.Page = self.Data.CurrentBriefing[PageID];
            API.Bridge("BundleBriefingSystem.Local.Data.CurrentBriefing.Page = " ..self.Data.CurrentBriefing.Page);
            self:PageStarted();

        else
            self:FinishBriefing();
        end
    end
end

---
-- Beendet die aktuelle Briefing-Seite
-- @within Internal
-- @local
--
function BundleBriefingSystem.Global:PageFinished()
    local PageID = self.Data.CurrentBriefing.Page;
    API.Bridge("BundleBriefingSystem.Local:PageFinished()");
    self.Data.CurrentBriefing.Page = (self.Data.CurrentBriefing.Page or 0) +1;
    local PageID = self.Data.CurrentBriefing.Page;
    if not self.Data.CurrentBriefing[PageID] or PageID &#x3E; #self.Data.CurrentBriefing then
        BundleBriefingSystem.Global:FinishBriefing();
    else
        BundleBriefingSystem.Global:PageStarted();
    end
end

---
-- Prüft, ob ein Briefing aktiv ist.
-- @param[type=boolean] Briefing ist aktiv
-- @within Internal
-- @local
--
function BundleBriefingSystem.Global:IsBriefingActive()
    return self.Data.BriefingActive == true;
end

---
-- Reagiert auf die Auswahl einer Option einer Multiple-Choice-Page.
-- @within Internal
-- @local
--
function BundleBriefingSystem.Global:OnMCConfirmed(_Selected)
    if self.Data.CurrentPage.MC then
        local PageID = self.Data.CurrentBriefing.Page;
        self.Data.CurrentBriefing[PageID].MC.Selected = _Selected;
        local JumpData = self.Data.CurrentPage.MC[_Selected];
        if type(JumpData[2]) == "function" then
            self.Data.CurrentBriefing.Page = self:GetPageIDByName(JumpData[2](self.Data.CurrentPage, JumpData))-1;
        else
            self.Data.CurrentBriefing.Page = self:GetPageIDByName(JumpData[2])-1;
        end
        API.Bridge("BundleBriefingSystem.Local.Data.CurrentBriefing.Page = " ..self.Data.CurrentBriefing.Page);
        self:PageFinished();
    end
end

---
-- Aktualisiert, ob eine Option sichtbar ist oder nicht. Eine Option
-- braucht eine Update-Funktion "Display". Die Update-Funktion
-- erhält Daten der Seite und Daten der Antwort.
-- @within Internal
-- @local
--
function BundleBriefingSystem.Global:DisableMCAnswers()
    for i= 1, #self.Data.CurrentBriefing, 1 do
        if self.Data.CurrentBriefing[i].MC then
            for k, v in pairs(self.Data.CurrentBriefing[i].MC) do 
                if type(v) == "table" and type(v.Disable) == "function" then
                    local Invisible = v.Disable(self.Data.CurrentBriefing[i], v) == true;
                    self.Data.CurrentBriefing[i].MC[k].Invisible = Invisible;
                end
            end
        end
    end
end

---
-- Steuert das automatische weiter blättern und Sprünge zwischen Pages.
-- @within Internal
-- @local
--
function BundleBriefingSystem.Global.BriefingExecutionController()
    if not BundleBriefingSystem.Global.Data.DisplayIngameCutscene and BundleBriefingSystem.Global:IsBriefingActive() then
        if BundleBriefingSystem.Global.Data.CurrentPage == nil then
            BundleBriefingSystem.Global:FinishBriefing();

        elseif type(BundleBriefingSystem.Global.Data.CurrentPage) == "table" then
            local Duration = (BundleBriefingSystem.Global.Data.CurrentPage.Duration or 0);
            if Duration &#x3E; -1 and BundleBriefingSystem.Global.Data.CurrentPage.Started then
                if Logic.GetTime() &#x3E; BundleBriefingSystem.Global.Data.CurrentPage.Started + Duration then
                    local PageID = BundleBriefingSystem.Global.Data.CurrentBriefing.Page;
                    if not BundleBriefingSystem.Global.Data.CurrentPage.NoHistory then
                        API.Bridge("table.insert(BundleBriefingSystem.Local.Data.CurrentBriefing.PageHistory, " ..PageID.. ")");
                    end
                    BundleBriefingSystem.Global:PageFinished();
                end
            end
        end
    end
end

---
-- Verhindert, dass während Briefings Quest-Timer weiter laufen.
-- @within Internal
-- @local
--
function BundleBriefingSystem.Global.BriefingQuestPausedController()
    if BundleBriefingSystem.Global.Data.BriefingActive and BundleBriefingSystem.Global.Data.PauseQuests then
        for i= 1, #Quests, 1 do
            if Quests[i].State == QuestState.Active then
                Quests[i].StartTime = Quests[i].StartTime +1;
            end
        end
    end
end

---
-- Steuert die Briefing-Warteschlange.
-- @within Internal
-- @local
--
function BundleBriefingSystem.Global.BriefingQueueController()
    if #BundleBriefingSystem.Global.Data.BriefingQueue == 0 then
        BundleBriefingSystem.Global.Data.BriefingQueueJobID = nil;
        return true;
    end
    
    if BundleBriefingSystem.Global.Data.LoadScreenHidden and not BundleBriefingSystem.Global:IsBriefingActive() then
        local Next = table.remove(BundleBriefingSystem.Global.Data.BriefingQueue, 1);
        BundleBriefingSystem.Global:StartBriefing(Next);
    end
end

---
-- Fügt den Briefing Messages einen neuen Eintrag hinzu. Jede Nachricht ist
-- 120 Sekunden lang zu sehen. Sollten Nachrichten zu sehen sein, wenn ein
-- Briefing beendet ist, werden sie zu normalen Notes.
--
-- Werden 8 aktive Einträge überschritten, wird die Anzeigezeit des ersten
-- Eintrag auf 0 reduziert.
--
-- @param[type=string] _Text Text der Nachricht
-- @within Internal
-- @local
--
function BundleBriefingSystem.Global:PushBriefingNote(_Text)
    API.Bridge("BundleBriefingSystem.Local:PushBriefingNote('" .._Text.. "')");
end

-- Local Script ------------------------------------------------------------- --

---
-- Startet das Bundle im globalen Skript.
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:Install()
    if not InitializeFader then
        Script.Load("script/mainmenu/fader.lua");
    end
    self:OverrideThroneRoomFunctions();
    BundleBriefingSystem:OverrideApiNote();

    StartSimpleHiResJobEx(self.WaitForLoadScreenHidden);
end

---
-- Startet ein Briefing.
-- @param[type=table] _Briefing Briefing Definition
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:StartBriefing(_Briefing)
    self.Data.SelectedEntities = {GUI.GetSelectedEntities()};
    self.Data.CurrentBriefing.Page = 1;
    self.Data.CurrentBriefing = _Briefing;
    if self.Data.CurrentBriefing.HideBorderPins then
        Display.SetRenderBorderPins(0);
    end
    if self.Data.CurrentBriefing.ShowSky then
        Display.SetRenderSky(1);
    end
    if Game.GameTimeGetFactor() ~= 0 then
        if self.Data.CurrentBriefing.RestoreGameSpeed and not self.Data.GameSpeedBackup then
            self.Data.GameSpeedBackup = Game.GameTimeGetFactor();
        end
        Game.GameTimeSetFactor(GUI.GetPlayerID(), 1);
    end
    if self.Data.CurrentBriefing.RestoreCamera and not self.Data.CameraBackup then
        self.Data.CameraBackup = {Camera.RTS_GetLookAtPosition()};
    end
    if not self.Data.CinematicActive then
        self:ActivateCinematicMode();
    end
    self.Data.BriefingActive = true;
end

---
-- Beendet ein Briefing.
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:FinishBriefing()
    if self.Data.CurrentBriefing.CameraBackup then 
        Camera.RTS_SetLookAtPosition(unpack(self.Data.CurrentBriefing.CameraBackup));
        self.Data.CurrentBriefing.CameraBackup = nil;
    end
    for k, v in pairs(self.Data.SelectedEntities) do
        GUI.SelectEntity(v);
    end
    Display.SetRenderBorderPins(1);
    Display.SetRenderSky(0);
    local GameSpeed = (self.Data.GameSpeedBackup or 1);
    Game.GameTimeSetFactor(GUI.GetPlayerID(), GameSpeed);
    self.Data.GameSpeedBackup = nil;
    self:DeactivateCinematicMode();
    self.Data.BriefingActive = false;
    self:ConvertBriefingNotes();
    self.Data.CurrentBriefing = {};
    self.Data.CurrentPage = {};
end

---
-- Zeigt die aktuele Seite an.
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:PageStarted()
    local PageID = self.Data.CurrentBriefing.Page;
    self.Data.CurrentPage = self.Data.CurrentBriefing[PageID];
    if type(self.Data.CurrentPage) == "table" then
        self.Data.CurrentPage.Started = Logic.GetTime();

        -- Zurück und Weiter
        local BackFlag = 1;
        local SkipFlag = 1;
        if not self.Data.CurrentBriefing.SkippingAllowed or self.Data.CurrentPage.NoSkipping then
            if self.Data.CurrentPage.MC and not self.Data.CurrentPage.NoHistory then
                table.insert(self.Data.CurrentBriefing.PageHistory, PageID);
            end
            SkipFlag = 0;
            BackFlag = 0;
        end
        local LastPageID = self.Data.CurrentBriefing.PageHistory[#self.Data.CurrentBriefing.PageHistory];
        local LastPage = self.Data.CurrentBriefing[LastPageID];
        local NoRethinkMC = (type(LastPage) == "table" and LastPage.NoRethink and 0) or 1;
        if PageID == 1 or NoRethinkMC == 0 or self.Data.CurrentBriefing.ReturnForbidden == true then
            BackFlag = 0;
        end
        XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/Skip", SkipFlag);
        XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/StartButton", BackFlag);

        -- Rotation an Rotation des Ziels anpassen
        if self.Data.CurrentPage.DialogCamera and IsExisting(self.Data.CurrentPage.Position[1]) then
            self.Data.CurrentPage.Rotation = Logic.GetEntityOrientation(GetID(self.Data.CurrentPage.Position[1]));
            if Logic.IsSettler(GetID(self.Data.CurrentPage.Position[1])) == 1 then
                self.Data.CurrentPage.Rotation = self.Data.CurrentPage.Rotation + 90;
            end
        end

        -- Titel setzen
        local TitleWidget = "/InGame/ThroneRoom/Main/DialogTopChooseKnight/ChooseYourKnight";
        XGUIEng.SetText(TitleWidget, "");
        if self.Data.CurrentPage.Title then
            local Title = self.Data.CurrentPage.Title;
            if Title:sub(1, 1) ~= "{" then
                Title = "{@color:255,250,0,255}{center}" ..Title;
            end
            XGUIEng.SetText(TitleWidget, Title);
        end

        -- Text setzen
        local TextWidget = "/InGame/ThroneRoom/Main/MissionBriefing/Text";
        XGUIEng.SetText(TextWidget, "");
        if self.Data.CurrentPage.Text then
            local Text = self.Data.CurrentPage.Text;
            if Text:sub(1, 1) ~= "{" then
                Text = "{center}" ..Text;
            end
            XGUIEng.SetText(TextWidget, Text);
        end

        -- Fader
        self:SetFader();
        -- Portrait
        self:SetPortrait();
        -- Splashscreen
        self:SetSplashscreen();
        -- Multiple Choice
        self:SetOptionsDialog();
    end
end

---
-- Beendet die aktuelle Seite.
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:PageFinished()
    -- TODO: Warum ist PageHistory hier u.U. nil?
    -- self.Data.CurrentBriefing.PageHistory = self.Data.CurrentBriefing.PageHistory or {};
    self.Data.CurrentBriefing.Page = (self.Data.CurrentBriefing.Page or 0) +1;
    EndJobEx(self.Data.CurrentBriefing.FaderJob);
end

---
-- Prüft, ob ein Briefing aktiv ist.
-- @param[type=boolean] Briefing ist aktiv
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:IsBriefingActive()
    return self.Data.BriefingActive == true;
end

---
-- Reagiert auf die Auswahl einer Option einer Multiple-Choice-Page.
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:LocalOnMCConfirmed()
    local Widget = "/InGame/SoundOptionsMain/RightContainer/SoundProviderComboBoxContainer";
    local Position = self.Data.OriginalBoxPosition;
    XGUIEng.SetWidgetScreenPosition(Widget, Position[1], Position[2]);
    XGUIEng.ShowWidget(Widget, 0);
    XGUIEng.PopPage();

    if self.Data.CurrentPage.MC then
        local Selected = XGUIEng.ListBoxGetSelectedIndex(Widget .. "/ListBox")+1;
        local AnswerID = self.Data.CurrentPage.MC.Map[Selected];
        for i= #self.Data.CurrentPage.MC, 1, -1 do
            if self.Data.CurrentPage.MC[i].ID == AnswerID and self.Data.CurrentPage.MC[i].Remove then
                table.remove(self.Data.CurrentPage.MC, Selected);
            end
        end
        API.Bridge("BundleBriefingSystem.Global:OnMCConfirmed(" ..AnswerID.. ")");
    end
end

---
-- Steuert die Kamera während des Throneroom Mode.
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:ThroneRoomCameraControl()
    if self.Data.DisplayIngameCutscene then
        if AddOnCutsceneSystem then
            AddOnCutsceneSystem.Local:ThroneRoomCameraControl();
        end
    else
        if type(self.Data.CurrentPage) == "table" then
            -- Kamera
            local PX, PY, PZ = self:GetPagePosition();
            local LX, LY, LZ = self:GetPageLookAt();
            local PageFOV = self.Data.CurrentPage.FOV or 42.0;
            
            if PX and not LX then
                LX, LY, LZ, PX, PY, PZ = self:GetCameraProperties();
            end
            Camera.ThroneRoom_SetPosition(PX, PY, PZ);
            Camera.ThroneRoom_SetLookAt(LX, LY, LZ);
            Camera.ThroneRoom_SetFOV(PageFOV);

            -- Multiple Choice
            if self.Data.MCSelectionIsShown then
                local Widget = "/InGame/SoundOptionsMain/RightContainer/SoundProviderComboBoxContainer";
                if XGUIEng.IsWidgetShown(Widget) == 0 then
                    self.Data.MCSelectionIsShown = false;
                    self:LocalOnMCConfirmed();
                end
            end

            -- Button Texte
            local Language = (Network.GetDesiredLanguage() == "de" and "de") or "en";
            XGUIEng.SetText("/InGame/ThroneRoom/Main/StartButton", "{center}" ..BundleBriefingSystem.Text.PrevButton[Language]);
            local SkipText = BundleBriefingSystem.Text.NextButton[Language];
            local PageID = self.Data.CurrentBriefing.Page;
            if PageID == #self.Data.CurrentBriefing or self.Data.CurrentBriefing[PageID+1] == -1 then
                SkipText = BundleBriefingSystem.Text.EndButton[Language];
            end
            XGUIEng.SetText("/InGame/ThroneRoom/Main/Skip", "{center}" ..SkipText);

            -- Briefing Messages
            self:UpdateBriefingNotes();
        end
    end
end

---
-- Gibt die Blickrichtung der Kamera und die Position der Kamera für den
-- Kompatibelitätsmodus zurück.
-- @return[type=number] LookAt X
-- @return[type=number] LookAt Y
-- @return[type=number] LookAt Z
-- @return[type=number] Position X
-- @return[type=number] Position Y
-- @return[type=number] Position Z
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:GetCameraProperties()
    local CurrPage = self.Data.CurrentPage;
    local FlyTo = self.Data.CurrentPage.FlyTo;

    local startTime = CurrPage.Started;
    local flyTime = CurrPage.FlyTime;
    local startPosition = (FlyTo and FlyTo.Position) or CurrPage.Position;
    local endPosition = CurrPage.Position;
    local startRotation = (FlyTo and FlyTo.Rotation) or CurrPage.Rotation;
    local endRotation = CurrPage.Rotation;
    local startZoomAngle = (FlyTo and FlyTo.Angle) or CurrPage.Angle;
    local endZoomAngle = CurrPage.Angle;
    local startZoomDistance = (FlyTo and FlyTo.Zoom) or CurrPage.Zoom;
    local endZoomDistance = CurrPage.Zoom;
    local startFOV = ((FlyTo and FlyTo.FOV) or CurrPage.FOV) or 42.0;
    local endFOV = (CurrPage.FOV) or 42.0;

    local factor = self:GetLERP();
    
    local lPLX, lPLY, lPLZ = BundleBriefingSystem.Local:ConvertPosition(startPosition);
    local cPLX, cPLY, cPLZ = BundleBriefingSystem.Local:ConvertPosition(endPosition);
    local lookAtX = lPLX + (cPLX - lPLX) * factor;
    local lookAtY = lPLY + (cPLY - lPLY) * factor;
    local lookAtZ = lPLZ + (cPLZ - lPLZ) * factor;

    local zoomDistance = startZoomDistance + (endZoomDistance - startZoomDistance) * factor;
    local zoomAngle = startZoomAngle + (endZoomAngle - startZoomAngle) * factor;
    local rotation = startRotation + (endRotation - startRotation) * factor;
    local line = zoomDistance * math.cos(math.rad(zoomAngle));
    local positionX = lookAtX + math.cos(math.rad(rotation - 90)) * line;
    local positionY = lookAtY + math.sin(math.rad(rotation - 90)) * line;
    local positionZ = lookAtZ + (zoomDistance) * math.sin(math.rad(zoomAngle));

    return lookAtX, lookAtY, lookAtZ, positionX, positionY, positionZ;
end

---
-- Gibt die interpolierte Kameraposition zurück.
-- @return[type=number] X
-- @return[type=number] Y
-- @return[type=number] Z
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:GetPagePosition()
    local Position = self.Data.CurrentPage.Position;
    local x, y, z = self:ConvertPosition(Position);
    local FlyTo = self.Data.CurrentPage.FlyTo;
    if FlyTo then
        local lX, lY, lZ = self:ConvertPosition(FlyTo.Position);
        if lX then
            x = x + (lX - x) * self:GetLERP();
            y = y + (lY - y) * self:GetLERP();
            z = z + (lZ - z) * self:GetLERP();
        end
    end
    return x, y, z;
end

---
-- Gibt die interpolierte Blickrichtung der Kamera zurück.
-- @return[type=number] X
-- @return[type=number] Y
-- @return[type=number] Z
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:GetPageLookAt()
    local LookAt = self.Data.CurrentPage.LookAt;
    local x, y, z = self:ConvertPosition(LookAt);
    local FlyTo = self.Data.CurrentPage.FlyTo;
    if FlyTo and x then
        local lX, lY, lZ = self:ConvertPosition(FlyTo.LookAt);
        if lX then
            x = x + (lX - x) * self:GetLERP();
            y = y + (lY - y) * self:GetLERP();
            z = z + (lZ - z) * self:GetLERP();
        end
    end
    return x, y, z;
end

---
-- Konvertiert die angegebenen Koordinaten zu XYZ.
-- @return[type=number] X
-- @return[type=number] Y
-- @return[type=number] Z
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:ConvertPosition(_Table)
    local x, y, z;
    if _Table and _Table.X then
        x = _Table.X; y = _Table.Y; z = _Table.Z;
    elseif _Table and not _Table.X then
        x, y, z = Logic.EntityGetPos(GetID(_Table[1]));
        z = z + (_Table[2] or 0);
    end
    return x, y, z;
end

---
-- Gibt den linearen Interpolationsfaktor zurück.
-- @param[type=number] LERP
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:GetLERP()
    local Current = Logic.GetTime();
    local Started = self.Data.CurrentPage.Started;
    local FlyTime;
    if self.Data.CurrentPage.FlyTo then
        FlyTime = self.Data.CurrentPage.FlyTo.Duration;
    end

    local Factor = 1.0;
    if FlyTime then
        if Started + FlyTime &#x3E; Current then
            Factor = (Current - Started) / FlyTime;
            if Factor &#x3E; 1 then
                Factor = 1.0;
            end
        end
    end
    return Factor;
end

---
-- Reagiert auf einen beliebigen Linksklick im Throneroom.
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:ThroneRoomLeftClick()
    if self.Data.DisplayIngameCutscene then
        if AddOnCutsceneSystem then
            AddOnCutsceneSystem.Local:ThroneRoomLeftClick();
        end
    else
        -- Klick auf Entity
        local EntityID = GUI.GetMouseOverEntity();
        API.Bridge([[
            local CurrentPage = BundleBriefingSystem.Global.CurrentPage;
            if CurrentPage and CurrentPage.LeftClickOnEntity then
                BundleBriefingSystem.Global.CurrentPage:LeftClickOnEntity(]] ..tostring(EntityID).. [[)
            end
        ]]);
        -- Klick in die Spielwelt
        local x,y = GUI.Debug_GetMapPositionUnderMouse();
        API.Bridge([[
            local CurrentPage = BundleBriefingSystem.Global.CurrentPage;
            if CurrentPage and CurrentPage.LeftClickOnPosition then
                BundleBriefingSystem.Global.CurrentPage:LeftClickOnPosition(]] ..tostring(x).. [[, ]] ..tostring(y).. [[)
            end
        ]]);
        -- Klick auf den Bildschirm
        local x,y = GUI.GetMousePosition();
        API.Bridge([[
            local CurrentPage = BundleBriefingSystem.Global.CurrentPage;
            if CurrentPage and CurrentPage.LeftClickOnScreen then
                BundleBriefingSystem.Global.CurrentPage:LeftClickOnScreen(]] ..tostring(x).. [[, ]] ..tostring(y).. [[)
            end
        ]]);
    end
end

---
-- Reagiert auf Klick auf den Skip-Button während des Throneroom Mode.
--
-- Wenn eine Cutscene aktiv ist, wird die überschriebene Methode aus dem
-- Addon benutzt.
--
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:NextButtonPressed()
    if self.Data.DisplayIngameCutscene then
        if AddOnCutsceneSystem then
            AddOnCutsceneSystem.Local:NextButtonPressed();
        end
    else
        if (self.Data.LastSkipButtonPressed + 500) &#x3C; Logic.GetTimeMs() then
            self.Data.LastSkipButtonPressed = Logic.GetTimeMs();
            if not self.Data.CurrentPage.NoHistory then
                table.insert(self.Data.CurrentBriefing.PageHistory, self.Data.CurrentBriefing.Page);
            end
            if self.Data.CurrentPage.OnForward then
                API.Bridge("BundleBriefingSystem.Global.CurrentPage:OnForward()");
            end
            API.Bridge("BundleBriefingSystem.Global:PageFinished()");
        end
    end
end

---
-- Reagiert auch Klick auf den Back-Button während des Throneroom Mode.
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:PrevButtonPressed()
    if not self.Data.DisplayIngameCutscene then
        if (self.Data.LastSkipButtonPressed + 500) &#x3C; Logic.GetTimeMs() then
            self.Data.LastSkipButtonPressed = Logic.GetTimeMs();

            local LastPageID = table.remove(BundleBriefingSystem.Local.Data.CurrentBriefing.PageHistory);
            if not LastPageID then
                return;
            end
            local LastPage = BundleBriefingSystem.Local.Data.CurrentBriefing[LastPageID];
            if type(LastPage) == "number" then
                LastPageID = table.remove(BundleBriefingSystem.Local.Data.CurrentBriefing.PageHistory);
                LastPage = BundleBriefingSystem.Local.Data.CurrentBriefing[LastPageID];
            end
            if not LastPageID or LastPageID &#x3C; 1 or not LastPage then
                return;
            end

            if self.Data.CurrentPage.OnReturn then
                API.Bridge("BundleBriefingSystem.Global.CurrentPage:OnReturn()");
            end
            BundleBriefingSystem.Local.Data.CurrentBriefing.Page = LastPageID -1;
            API.Bridge([[
                BundleBriefingSystem.Global.Data.CurrentBriefing.Page = ]] ..(LastPageID -1).. [[
                BundleBriefingSystem.Global:PageFinished()
            ]]);
        end
    end
end

---
-- Setzt den Stil der Briefing-Bars.
-- @param[type=boolean] _Transparend Transparente Bars benutzen
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:SetBarStyle(_Transparend)
    local Alpha = (_Transparend and 100) or 255;

    XGUIEng.ShowWidget("/InGame/ThroneRoomBars", 1);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2", 1);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_Dodge", 1);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2_Dodge", 1);

    XGUIEng.SetMaterialAlpha("/InGame/ThroneRoomBars/BarBottom", 1, Alpha);
    XGUIEng.SetMaterialAlpha("/InGame/ThroneRoomBars/BarTop", 1, Alpha);
    XGUIEng.SetMaterialAlpha("/InGame/ThroneRoomBars_2/BarBottom", 1, Alpha);
    XGUIEng.SetMaterialAlpha("/InGame/ThroneRoomBars_2/BarTop", 1, Alpha);
end

---
-- Setzt die Fader-Optionen der aktuellen Seite.
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:SetFader()
    -- Alpha der Fader-Maske
    g_Fade.To = 0;
    SetFaderAlpha(self.Data.CurrentPage.FaderAlpha or 0);

    -- Fadein starten
    local PageFadeIn = self.Data.CurrentPage.FadeIn;
    if PageFadeIn then
        FadeIn(PageFadeIn);
    end

    -- Fadeout starten
    local PageFadeOut = self.Data.CurrentPage.FadeOut;
    if PageFadeOut then
        self.Data.CurrentBriefing.FaderJob = StartSimpleHiResJobEx(function(_Time, _FadeOut)
            if Logic.GetTimeMs() &#x3E; _Time - (_FadeOut * 1000) then
                FadeOut(_FadeOut);
                return true;
            end
        end, Logic.GetTimeMs() + ((self.Data.CurrentPage.Duration or 0) * 1000), PageFadeOut);
    end
end

---
-- Aktiviert den Auswahldialog einer Multiple-Choice-Seite.
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:SetOptionsDialog()
    if self.Data.CurrentPage.MC then
        local Screen = {GUI.GetScreenSize()};
        local Widget = "/InGame/SoundOptionsMain/RightContainer/SoundProviderComboBoxContainer";

        self.Data.OriginalBoxPosition = {
            XGUIEng.GetWidgetScreenPosition(Widget)
        };

        local listbox = XGUIEng.GetWidgetID(Widget .. "/ListBox");
        XGUIEng.ListBoxPopAll(listbox);
        self.Data.CurrentPage.MC.Map = {};
        for i=1, #self.Data.CurrentPage.MC, 1 do
            if self.Data.CurrentPage.MC[i].Invisible ~= true then
                XGUIEng.ListBoxPushItem(listbox, self.Data.CurrentPage.MC[i][1]);
                table.insert(self.Data.CurrentPage.MC.Map, self.Data.CurrentPage.MC[i].ID);
            end
        end
        XGUIEng.ListBoxSetSelectedIndex(listbox, 0);

        local wSize = {XGUIEng.GetWidgetScreenSize(Widget)};
        local xFactor = (Screen[1]/1920);
        local xFix = math.ceil((Screen[1]/2) - (wSize[1] /2));
        local yFix = math.ceil(Screen[2] - (wSize[2]-20));
        XGUIEng.SetWidgetScreenPosition(Widget, xFix, yFix);
        XGUIEng.PushPage(Widget, false);
        XGUIEng.ShowWidget(Widget, 1);

        self.Data.MCSelectionIsShown = true;
    end
end

---
-- Setzt das Portrait der aktuellen Seite.
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:SetPortrait()
    if self.Data.CurrentPage.Portrait then
        XGUIEng.SetMaterialAlpha("/InGame/ThroneRoom/KnightInfo/KnightBG", 1, 255);
        XGUIEng.SetMaterialTexture("/InGame/ThroneRoom/KnightInfo/KnightBG", 1, self.Data.CurrentPage.Portrait);
        XGUIEng.SetWidgetPositionAndSize("/InGame/ThroneRoom/KnightInfo/KnightBG", 0, 6000, 400, 600);
        XGUIEng.SetMaterialUV("/InGame/ThroneRoom/KnightInfo/KnightBG", 1, 0, 0, 1, 1);
    else
        XGUIEng.SetMaterialAlpha("/InGame/ThroneRoom/KnightInfo/KnightBG", 1, 0);
    end
end

---
-- Setzt den Splashscreen der aktuellen Seite.
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:SetSplashscreen()
    local BG = "/InGame/ThroneRoomBars_2/BarTop";
    local BB = "/InGame/ThroneRoomBars_2/BarBottom";

    if self.Data.CurrentPage.Splashscreen == nil then
        XGUIEng.SetMaterialTexture(BG, 1, "");
        XGUIEng.SetMaterialTexture(BB, 1, "");
        XGUIEng.SetMaterialColor(BG, 1, 0, 0, 0, 255);
        XGUIEng.SetMaterialColor(BB, 1, 0, 0, 0, 255);
        if self.Data.CurrentBriefing.BriefingBarSizeBackup then
            local Position = self.Data.CurrentBriefing.BriefingBarSizeBackup;
            XGUIEng.SetWidgetSize(BG, Position[1], Position[2]);
            self.Data.CurrentBriefing.BriefingBarSizeBackup = nil;
        end
        self:SetBarStyle(self.Data.CurrentBriefing.TransparentBars == true);
        return;
    end

    if self.Data.CurrentPage.Splashscreen then
        local size   = {GUI.GetScreenSize()};
        local is4To3 = math.floor((size[1]/size[2]) * 100) == 133;
        local is5To4 = math.floor((size[1]/size[2]) * 100) == 125;
        local u0, v0, u1, v1 = 0, 0, 1, 1;
        if is4To3 or is5To4 then
            u0 = u0 + (u0 * 0.125); u1 = u1 - (u1 * 0.125);
        end
        self:SetBarStyle(false);
        XGUIEng.SetMaterialColor(BG, 1, 255, 255, 255, 255);
        XGUIEng.SetMaterialTexture(BG, 1, self.Data.CurrentPage.Splashscreen);
        XGUIEng.SetMaterialUV(BG, 1, u0, v0, u1, v1);
    end
    if not self.Data.CurrentBriefing.BriefingBarSizeBackup then
        local x, y = XGUIEng.GetWidgetSize(BG);
        self.Data.CurrentBriefing.BriefingBarSizeBackup = {x, y};
    end

    local BarX    = self.Data.CurrentBriefing.BriefingBarSizeBackup[1];
    local _, BarY = XGUIEng.GetWidgetSize("/InGame/ThroneRoomBars");
    XGUIEng.SetWidgetSize(BG, BarX, BarY);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2", 1);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_Dodge", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2_Dodge", 0);
    XGUIEng.ShowWidget(BG, 1);
end

---
-- Aktiviert den Cinematic Mode.
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:ActivateCinematicMode()
    self.Data.CinematicActive = true;
    
    local LoadScreenVisible = XGUIEng.IsWidgetShownEx("/LoadScreen/LoadScreen") == 1;
    if LoadScreenVisible then
        XGUIEng.PopPage();
    end

    XGUIEng.ShowWidget("/InGame/Root/3dOnScreenDisplay", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom", 1);
    XGUIEng.PushPage("/InGame/ThroneRoomBars", false);
    XGUIEng.PushPage("/InGame/ThroneRoomBars_2", false);
    XGUIEng.PushPage("/InGame/ThroneRoom/Main", false);
    XGUIEng.PushPage("/InGame/ThroneRoomBars_Dodge", false);
    XGUIEng.PushPage("/InGame/ThroneRoomBars_2_Dodge", false);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/Skip", 1);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/StartButton", 1);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogTopChooseKnight", 1);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogTopChooseKnight/Frame", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogTopChooseKnight/DialogBG", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogTopChooseKnight/FrameEdges", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogBottomRight3pcs", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/KnightInfoButton", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/BackButton", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/Briefing", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/TitleContainer", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/MissionBriefing/Text", 1);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/MissionBriefing/Title", 1);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/MissionBriefing/Objectives", 1);

    XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Text", " ");
    XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Title", " ");
    XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Objectives", " ");

    local x,y = XGUIEng.GetWidgetScreenPosition("/InGame/ThroneRoom/Main/DialogTopChooseKnight/ChooseYourKnight");
    XGUIEng.SetWidgetScreenPosition("/InGame/ThroneRoom/Main/DialogTopChooseKnight/ChooseYourKnight", x, 65);
    local x,y = XGUIEng.GetWidgetScreenPosition("/InGame/ThroneRoom/Main/Skip");
    XGUIEng.SetWidgetScreenPosition("/InGame/ThroneRoom/Main/StartButton", 20, y);
    XGUIEng.SetWidgetPositionAndSize("/InGame/ThroneRoom/KnightInfo/Objectives", 2, 0, 2000, 20);

    XGUIEng.PushPage("/InGame/ThroneRoom/KnightInfo", false);
    XGUIEng.ShowAllSubWidgets("/InGame/ThroneRoom/KnightInfo", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/KnightInfo/Text", 1);
    XGUIEng.SetText("/InGame/ThroneRoom/KnightInfo/Text", " ");
    XGUIEng.SetWidgetPositionAndSize("/InGame/ThroneRoom/KnightInfo/Text", 200, 300, 1000, 10);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/KnightInfo/LeftFrame", 1);
    XGUIEng.ShowAllSubWidgets("/InGame/ThroneRoom/KnightInfo/LeftFrame", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/KnightInfo/KnightBG", 1);
    XGUIEng.SetWidgetPositionAndSize("/InGame/ThroneRoom/KnightInfo/KnightBG", 0, 0, 400, 600);
    XGUIEng.SetMaterialAlpha("/InGame/ThroneRoom/KnightInfo/KnightBG", 0, 0);

    BundleBriefingSystem.Local:SetBarStyle(self.Data.CurrentBriefing.TransparentBars == true);

    GUI.ClearSelection();
    GUI.ForbidContextSensitiveCommandsInSelectionState();
    GUI.ActivateCutSceneState();
    GUI.SetFeedbackSoundOutputState(0);
    GUI.EnableBattleSignals(false);
    Input.CutsceneMode();
    Display.SetRenderFogOfWar(0);
    Display.SetUserOptionOcclusionEffect(0);
    Camera.SwitchCameraBehaviour(5);

    InitializeFader();
    g_Fade.To = 0;
    SetFaderAlpha(0);

    if LoadScreenVisible then
        XGUIEng.PushPage("/LoadScreen/LoadScreen", false);
    end
end

---
-- Deaktiviert den Cinematic Mode.
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:DeactivateCinematicMode()
    self.Data.CinematicActive = false;

    g_Fade.To = 0;
    SetFaderAlpha(0);
    XGUIEng.PopPage();
    Camera.SwitchCameraBehaviour(0);
    Display.UseStandardSettings();
    Input.GameMode();
    GUI.EnableBattleSignals(true);
    GUI.SetFeedbackSoundOutputState(1);
    GUI.ActivateSelectionState();
    GUI.PermitContextSensitiveCommandsInSelectionState();
    Display.SetRenderFogOfWar(1);
    if Options.GetIntValue("Display", "Occlusion", 0) &#x3E; 0 then
        Display.SetUserOptionOcclusionEffect(1);
    end

    XGUIEng.PopPage();
    XGUIEng.PopPage();
    XGUIEng.PopPage();
    XGUIEng.PopPage();
    XGUIEng.PopPage();
    XGUIEng.PopPage();
    XGUIEng.ShowWidget("/InGame/ThroneRoom", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_Dodge", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2_Dodge", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal", 1);
    XGUIEng.ShowWidget("/InGame/Root/3dOnScreenDisplay", 1);
end

---
-- Überschreibt die Throneroom-Funktionen.
--
-- Überschriebene Funktionen:
-- &#x3C;ul&#x3E;
-- &#x3C;li&#x3E;ThroneRoomCameraControl - Steuerung der Throneroom-Kamera&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;ThroneRoomLeftClick - Es wird mit der Maus irgend wo hin geklickt&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;OnSkipButtonPressed - Überspringen wird geklickt&#x3C;/li&#x3E;
-- &#x3C;/ul&#x3E;
--
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:OverrideThroneRoomFunctions()
    ThroneRoomCameraControl = function()
        if BundleBriefingSystem then
            if BundleBriefingSystem.Local.Data.DisplayIngameCutscene then
                if AddOnCutsceneSystem then
                    AddOnCutsceneSystem.Local:ThroneRoomCameraControl();
                end
            else
                BundleBriefingSystem.Local:ThroneRoomCameraControl();
            end
        end
    end

    ThroneRoomLeftClick = function()
        if BundleBriefingSystem then
            if BundleBriefingSystem.Local.Data.DisplayIngameCutscene then
                if AddOnCutsceneSystem then
                    AddOnCutsceneSystem.Local:ThroneRoomLeftClick();
                end
            else
                BundleBriefingSystem.Local:ThroneRoomLeftClick();
            end
        end
    end

    OnSkipButtonPressed = function()
        if BundleBriefingSystem then
            if BundleBriefingSystem.Local.Data.DisplayIngameCutscene then
                if AddOnCutsceneSystem then
                    AddOnCutsceneSystem.Local:NextButtonPressed();
                end
            else
                BundleBriefingSystem.Local:NextButtonPressed();
            end
        end
    end

    OnStartButtonPressed = function()
        if BundleBriefingSystem then
            BundleBriefingSystem.Local:PrevButtonPressed();
        end
    end

    OnBackButtonPressed = function()
        if BundleBriefingSystem then
            BundleBriefingSystem.Local:PrevButtonPressed();
        end
    end

    BundleBriefingSystem.Local.GameCallback_Escape = GameCallback_Escape;
    GameCallback_Escape = function()
        if not BundleBriefingSystem.Local:IsBriefingActive() then
            BundleBriefingSystem.Local.GameCallback_Escape();
        end
    end
end

---
-- Speichert, wenn der Ladebildschirm geschlossen wird.
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local.WaitForLoadScreenHidden()
    if XGUIEng.IsWidgetShownEx("/LoadScreen/LoadScreen") == 0 then
        GUI.SendScriptCommand("BundleBriefingSystem.Global.Data.LoadScreenHidden = true");
        return true;
    end
end

---
-- Fügt den Briefing Messages einen neuen Eintrag hinzu. Jede Nachricht ist
-- 12 Sekunden lang zu sehen. Sollten Nachrichten zu sehen sein, wenn ein
-- Briefing beendet ist, werden sie zu normalen Notes.
--
-- Werden 8 aktive Einträge überschritten, wird die Anzeigezeit des ersten
-- Eintrag auf 0 reduziert.
--
-- @param[type=string] _Text Text der Nachricht
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:PushBriefingNote(_Text)
    local Size = #self.Data.BriefingMessages;
    if Size &#x3E; 8 then
        local Index = Size -8;
        self.Data.BriefingMessages[Index][2] = 0;
    end
    self.Data.BriefingMessages[Size+1] = {_Text, 12000};
end

---
-- Konvertiert alle angezeigten Briefing Notes zu normalen Notes und leert
-- die Table. Diese Funktion wird automatisch vom Briefing System aufgerufen.
--
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:ConvertBriefingNotes()
    for k, v in pairs(self.Data.BriefingMessages) do
        if v and v[2] &#x3E; 0 then
            API.Note(v[1]);
        end
    end
    self.Data.BriefingMessages = {};
end

---
-- Konvertiert alle angezeigten Briefing Notes zu normalen Notes und leert
-- die Table. Diese Funktion wird automatisch vom Briefing System aufgerufen.
--
-- @within Internal
-- @local
--
function BundleBriefingSystem.Local:UpdateBriefingNotes()
    local Color = "{@color:255,255,255,255}";
    local Text = "";
    for k, v in pairs(self.Data.BriefingMessages) do
        if v and v[2] &#x3E; 0 then
            self.Data.BriefingMessages[k][2] = v[2] -1;
            Text = Text .. Color .. v[1] .. "{cr}";
        end
    end
    XGUIEng.SetText("/InGame/ThroneRoom/KnightInfo/Text", Text);
end

-- Shared ------------------------------------------------------------------- --

---
-- Überschreibt API.Note, damit Nachrichten auch während Briefings angezeigt
-- werden können.
-- @within Internal
-- @local
--
function BundleBriefingSystem:OverrideApiNote()
    API.Note_Orig_BriefingSystem = API.Note;
    API.Note = function(_Text)
        if IsBriefingActive() then
            local Text = API.EnsureMessage(_Text);
            if not GUI then
                BundleBriefingSystem.Global:PushBriefingNote(Text);
            else
                BundleBriefingSystem.Local:PushBriefingNote(Text);
            end
            return;
        end
        API.Note_Orig_BriefingSystem(_Text);
    end
end

-- Behavior ----------------------------------------------------------------- --

---
-- Ruft die Lua-Funktion mit dem angegebenen Namen auf und spielt das Briefing
-- in ihr ab. Die Funktion muss eine Briefing-ID zurückgeben.
--
-- Das Brieifng wird an den Quest gebunden und kann mit Trigger_Briefing
-- überwacht werden. Es kann pro Quest nur ein Niederlage-Briefing 
-- gebunden werden!
--
-- @param[type=string] _Briefing Funktionsname als String
-- @within Reprisal
--
function Reprisal_Briefing(...)
    return b_Reprisal_Briefing:new(...);
end

b_Reprisal_Briefing = {
    Name = "Reprisal_Briefing",
    Description = {
        en = "Reward: Calls a function that creates a briefing and saves the returned briefing ID into the quest.",
        de = "Lohn: Ruft eine Funktion auf, die ein Briefing erzeugt und die zurueckgegebene ID in der Quest speichert.",
    },
    Parameter = {
        { ParameterType.Default, en = "Briefing function", de = "Funktion mit Briefing" },
    },
}

function b_Reprisal_Briefing:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function b_Reprisal_Briefing:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Function = _Parameter;
    end
end

function b_Reprisal_Briefing:CustomFunction(_Quest)
    local BriefingID = _G[self.Function](self, _Quest);
    local QuestID = GetQuestID(_Quest.Identifier);
    Quests[QuestID].zl97d_ukfs5_0dpm0 = BriefingID;
end

function b_Reprisal_Briefing:Debug(_Quest)
    if not type(_G[self.Function]) == "function" then
        fatal(_Quest.Identifier..": "..self.Name..": '"..self.Function.."' was not found!");
        return true;
    end
    return false;
end

function b_Reprisal_Briefing:Reset(_Quest)
    local QuestID = GetQuestID(_Quest.Identifier);
    Quests[QuestID].zl97d_ukfs5_0dpm0 = nil;
end

Core:RegisterBehavior(b_Reprisal_Briefing);

-- -------------------------------------------------------------------------- --

---
-- Ruft die Lua-Funktion mit dem angegebenen Namen auf und spielt das Briefing
-- in ihr ab. Die Funktion muss eine Briefing-ID zurückgeben.
--
-- Das Brieifng wird an den Quest gebunden und kann mit Trigger_Briefing
-- überwacht werden. Es kann pro Quest nur ein Erfolgs-Briefing gebunden werden!
--
-- @param[type=string] _Briefing Funktionsname als String
-- @within Reward
--
function Reward_Briefing(...)
    return b_Reward_Briefing:new(...);
end

b_Reward_Briefing = API.InstanceTable(b_Reprisal_Briefing);
b_Reward_Briefing.Name = "Reward_Briefing";
b_Reward_Briefing.Description.en = "Reward: Calls a function that creates a briefing and saves the returned briefing ID into the quest.";
b_Reward_Briefing.Description.de = "Lohn: Ruft eine Funktion auf, die ein Briefing erzeugt und die zurueckgegebene ID in der Quest speichert.";
b_Reward_Briefing.GetReprisalTable = nil;

b_Reward_Briefing.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} }
end

b_Reward_Briefing.CustomFunction = function(self, _Quest)
    local BriefingID = _G[self.Function](self, _Quest);
    local QuestID = GetQuestID(_Quest.Identifier);
    Quests[QuestID].w5kur_xig0q_d9k7e = BriefingID;
end

b_Reward_Briefing.Reset = function(self, _Quest)
    local QuestID = GetQuestID(_Quest.Identifier);
    Quests[QuestID].w5kur_xig0q_d9k7e = nil;
end

Core:RegisterBehavior(b_Reward_Briefing);

-- -------------------------------------------------------------------------- --

---
-- Startet einen Quest, nachdem das Briefing eines Quests gestartet und
-- durchlaufen wurde.
--
-- Der Trigger wird sowohl Erfolgs- als auch Niederlage-Briefings prüfen.
-- Über den Typ-Parameter kann auf eine spezielle Art eingeschränt werden.
--
-- @param[type=string] _QuestName Name des Quest
-- @param[type=string] _Type     (Optional) Briefing-Typ
-- @param[type=number] _Waittime (optional) Wartezeit in Sekunden
-- @within Trigger
--
function Trigger_Briefing(...)
    return b_Trigger_Briefing:new(...);
end

b_Trigger_Briefing = {
    Name = "Trigger_Briefing",
    Description = {
        en = "Trigger: After a briefing of the given quest has finished, this quest will be started. Additionally you can choose the type of briefing this trigger shall react to.",
        de = "Ausloeser: Wenn ein Briefing des angegebenen Quest beendet ist, wird dieser Quest gestartet. Optional kann gewählt werden, auf welchen Typ von Briefing reagiert werden soll.",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest name",    de = "Questname" },
        { ParameterType.Custom,    en = "Briefing type", de = "Briefing-Typ" },
        { ParameterType.Number,    en = "Wait time",     de = "Wartezeit" },
    },
}

function b_Trigger_Briefing:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function b_Trigger_Briefing:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Quest = _Parameter;
    elseif (_Index == 1) then
        _Paramater = _Parameter or "All";
        self.BriefingType = _Parameter;
    elseif (_Index == 2) then
        _Parameter = _Parameter or 0;
        self.WaitTime = _Parameter * 1;
    end
end

function b_Trigger_Briefing:GetCustomData( _Index )
    if _Index == 1 then
        return {"All", "Success", "Failure"};
    end
end

function b_Trigger_Briefing:IsConditionFulfilled(_QuestID)
    if self.BriefingType == nil or self.BriefingType == "All" then
        return IsBriefingFinished(Quests[_QuestID].zl97d_ukfs5_0dpm0) or IsBriefingFinished(Quests[_QuestID].w5kur_xig0q_d9k7e);
    elseif self.BriefingType == "Failure" then
        return IsBriefingFinished(Quests[_QuestID].zl97d_ukfs5_0dpm0);
    elseif self.BriefingType == "Success" then
        return IsBriefingFinished(Quests[_QuestID].w5kur_xig0q_d9k7e);
    end
    return false;
end

function b_Trigger_Briefing:CustomFunction(_Quest)
    local QuestID = GetQuestID(self.Quest);
    if self:IsConditionFulfilled(QuestID) then
        if self.WaitTime and self.WaitTime &#x3E; 0 then
            self.WaitTimeTimer = self.WaitTimeTimer or Logic.GetTime();
            if Logic.GetTime() &#x3E;= self.WaitTimeTimer + self.WaitTime then
                return true;
            end
        else
            return true;
        end
    end
    return false;
end

function b_Trigger_Briefing:Interrupt(_Quest)
    local QuestID = GetQuestID(self.Quest);
    Quests[QuestID].w5kur_xig0q_d9k7e = nil;
    Quests[QuestID].zl97d_ukfs5_0dpm0 = nil;
    self.WaitTimeTimer = nil
end

function b_Trigger_Briefing:Reset(_Quest)
    local QuestID = GetQuestID(self.Quest);
    Quests[QuestID].w5kur_xig0q_d9k7e = nil;
    Quests[QuestID].zl97d_ukfs5_0dpm0 = nil;
    self.WaitTimeTimer = nil
end

function b_Trigger_Briefing:Debug(__quest_)
    if self.WaitTime and self.WaitTime &#x3C; 0 then
        dbg(__quest_.Identifier.." "..self.Name..": waittime is below 0!");
        return true;
    elseif not IsValidQuest(self.Quest) then
        fatal(_Quest.Identifier.." "..self.Name..": '"..self.Quest.."' is not a valid quest!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Trigger_Briefing);

-- -------------------------------------------------------------------------- --

Core:RegisterBundle("BundleBriefingSystem");

</code></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundlebuildingbuttons.lua.html">
            <div class='doclink'>
                <div>BundleBuildingButtons</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><code>-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundleBuildingButtons                                        # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Dieses Bundle erweitert das Gebäudemenü für verschiedene Gebäude um weitere
-- Funktionen. Es ist bspw. möglich ungenutzte Schalter frei zu programmieren.
--
-- Bekannte Funktionen sind natürlich auch wieder mit dabei.
--
-- Das wichtigste auf einen Blick:
-- &#x3C;ul&#x3E;
--
-- &#x3C;li&#x3E;Viehzucht: Hernzüchten von Kühen und Schafen in Gattern
-- &#x3C;br&#x3E;Kühe züchten:&#x3C;br&#x3E;&#x3C;a href="#API.UseBreedCattle"&#x3E;Zucht aktivieren&#x3C;/a&#x3E;,
-- &#x3C;a href="#API.SetCattleNeeded"&#x3E;Mindestanzahl Kühe festlegen&#x3C;/a&#x3E;,
-- &#x3C;a href="#API.SetCattleGrainCost"&#x3E;Getreidekosten festlegen&#x3C;/a&#x3E;
-- &#x3C;br&#x3E;Schafe züchten:&#x3C;br&#x3E;&#x3C;a href="#API.UseBreedSheeps"&#x3E;Zucht aktivieren&#x3C;/a&#x3E;,
-- &#x3C;a href="#API.SetSheepNeeded"&#x3E;Mindestanzahl Schafe festlegen&#x3C;/a&#x3E;,
-- &#x3C;a href="#API.SetSheepGrainCost"&#x3E;Getreidekosten festlegen&#x3C;/a&#x3E;
-- &#x3C;/li&#x3E;
--
-- &#x3C;li&#x3E;Single Stop: Anhalten der Produktion von einzelnen Gebäuden
-- &#x3C;br&#x3E;&#x3C;a href="#API.ActivateSingleStop"&#x3E;aktivieren&#x3C;/a&#x3E;,
-- &#x3C;a href="#API.DeactivateSingleStop"&#x3E;deaktivieren&#x3C;/a&#x3E;
-- &#x3C;/li&#x3E;
--
-- &#x3C;li&#x3E;Downgrade: Rückbau von Stadt- und Rohstoffgebäuden
-- &#x3C;br&#x3E;&#x3C;a href="#API.ActivateDowngrade"&#x3E;aktivieren&#x3C;/a&#x3E;,
-- &#x3C;a href="#API.DeactivateDowngrade"&#x3E;deaktivieren&#x3C;/a&#x3E;
-- &#x3C;/li&#x3E;
--
-- &#x3C;/ul&#x3E;
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundleBuildingButtons = {};

API = API or {};
QSB = QSB or {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Aktiviert oder deaktiviert die Single Stop Buttons. Single Stop ermöglicht
-- das Anhalten eines einzelnen Betriebes, anstelle des Anhaltens aller
-- Betriebe des gleichen Typs.
--
-- Im Gegensatz zur Viehzucht und zum Rückbau, welche feste eigeständige
-- Buttons sind, handelt es sich hierbei um einen Custom Button. Single
-- Stop belegt Index 1.
--
-- @param[type=boolean] _Flag Single Stop nutzen
-- @within Anwenderfunktionen
-- @see API.AddCustomBuildingButton
--
function API.UseSingleStop(_Flag)
    if not GUI then
        API.Bridge("API.UseSingleStop(" ..tostring(_Flag).. ")");
        return;
    end

    if _Flag then
        BundleBuildingButtons.Local:AddOptionalButton(
            2,
            BundleBuildingButtons.Local.ButtonDefaultSingleStop_Action,
            BundleBuildingButtons.Local.ButtonDefaultSingleStop_Tooltip,
            BundleBuildingButtons.Local.ButtonDefaultSingleStop_Update
        );
    else
        BundleBuildingButtons.Local:DeleteOptionalButton(2);
    end
end

---
-- Aktiviere oder deaktiviere Rückbau bei Stadt- und Rohstoffgebäuden. Die
-- Rückbaufunktion erlaubt es dem Spieler bei Stadt- und Rohstoffgebäude
-- der Stufe 2 und 3 jeweils eine Stufe zu zerstören. Der überflüssige
-- Arbeiter wird entlassen.
--
-- @param[type=boolean] _Flag Downgrade nutzen
-- @within Anwenderfunktionen
--
function API.UseDowngrade(_Flag)
    if not GUI then
        API.Bridge("API.UseDowngrade(" ..tostring(_Flag).. ")");
        return;
    end
    BundleBuildingButtons.Local.Data.Downgrade = _Flag == true;
end

---
-- Erlaube oder verbiete dem Spieler Schafe zu züchten.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; UseBreedSheeps&#x3C;/p&#x3E;
--
-- @param[type=boolean] _flag Schafzucht aktiv/inaktiv
-- @within Anwenderfunktionen
--
-- @usage
-- -- Schafsaufzucht ist erlaubt
-- API.UseBreedSheeps(true);
--
function API.UseBreedSheeps(_flag)
    if not GUI then
        API.Bridge("API.UseBreedSheeps(" ..tostring(_flag).. ")");
        return;
    end

    BundleBuildingButtons.Local.Data.BreedSheeps = _flag == true;
    if _flag == true then
        local Price = MerchantSystem.BasePricesOrigBundleBuildingButtons[Goods.G_Sheep]
        MerchantSystem.BasePrices[Goods.G_Sheep] = Price;
        API.Bridge("MerchantSystem.BasePrices[Goods.G_Sheep] = " ..Price);
    else
        local Price = BundleBuildingButtons.Local.Data.SheepMoneyCost;
        MerchantSystem.BasePrices[Goods.G_Sheep] = Price;
        API.Bridge("MerchantSystem.BasePrices[Goods.G_Sheep] = " ..Price);
    end
end
UseBreedSheeps = API.UseBreedSheeps;

---
-- Erlaube oder verbiete dem Spieler Kühe zu züchten.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; UseBreedCattle&#x3C;/p&#x3E;
--
-- @param[type=boolean] _flag Kuhzucht aktiv/inaktiv
-- @within Anwenderfunktionen
--
-- @usage
-- -- Es können keine Kühe gezüchtet werden
-- API.UseBreedCattle(false);
--
function API.UseBreedCattle(_flag)
    if not GUI then
        API.Bridge("API.UseBreedCattle(" ..tostring(_flag).. ")");
        return;
    end

    BundleBuildingButtons.Local.Data.BreedCattle = _flag == true;
    if _flag == true then
        local Price = MerchantSystem.BasePricesOrigBundleBuildingButtons[Goods.G_Cow];
        MerchantSystem.BasePrices[Goods.G_Cow] = Price;
        API.Bridge("MerchantSystem.BasePrices[Goods.G_Cow] = " ..Price);
    else
        local Price = BundleBuildingButtons.Local.Data.CattleMoneyCost;
        MerchantSystem.BasePrices[Goods.G_Cow] = Price;
        API.Bridge("MerchantSystem.BasePrices[Goods.G_Cow] = " ..Price);
    end
end
UseBreedCattle = API.UseBreedCattle;

---
-- Setzt die Menge an Getreide, das zur Zucht eines Tieres benötigt wird.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; SetSheepGrainCost&#x3C;/p&#x3E;
--
-- @param[type=number] _Amount Getreidekosten
-- @within Anwenderfunktionen
--
-- @usage
-- -- Wucherpreise zum Züchten!
-- API.SetSheepGrainCost(50);
--
function API.SetSheepGrainCost(_Amount)
    if not GUI then
        API.Bridge("API.SetSheepGrainCost(" .._Amount.. ")");
        return;
    end
    BundleBuildingButtons.Local.Data.SheepCosts = _Amount;
end
SetSheepGrainCost = API.SetSheepGrainCost;

---
-- Setzt die Menge an Getreide, das zur Zucht eines Tieres benötigt wird.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; SetCattleGrainCost&#x3C;/p&#x3E;
--
-- @param[type=number] _Amount Getreidekosten
-- @within Anwenderfunktionen
--
-- @usage
-- -- Wucherpreise zum Züchten!
-- API.SetCattleGrainCost(50);
--
function API.SetCattleGrainCost(_Amount)
    if not GUI then
        API.Bridge("API.SetCattleGrainCost(" .._Amount.. ")");
        return;
    end
    BundleBuildingButtons.Local.Data.CattleCosts = _Amount;
end
SetCattleGrainCost = API.SetCattleGrainCost;

---
-- Setzt die zur Zucht benötigte Menge an Tieren in einem Gatter.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; SetSheepNeeded&#x3C;/p&#x3E;
--
-- @param[type=number] _Amount Benötigte Menge
-- @within Anwenderfunktionen
--
-- @usage
-- -- Es wird ein volles Gatter zur Zucht benötigt:
-- API.SetSheepNeeded(5);
--
function API.SetSheepNeeded(_Amount)
    if not GUI then
        API.Bridge("API.SetSheepNeeded(" .._Amount.. ")");
        return;
    end
    if type(_Amount) ~= "number" or _Amount &#x3C; 0 or _Amount &#x3E; 5 then
        API.Fatal("API.SetSheepNeeded: Needed amount is invalid!");
    end
    BundleBuildingButtons.Local.Data.SheepNeeded = _Amount;
end
SetSheepNeeded = API.SetSheepNeeded;

---
-- Setzt die zur Zucht benötigte Menge an Tieren in einem Gatter.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; SetCattleNeeded&#x3C;/p&#x3E;
--
-- @param[type=number] _Amount Benötigte Menge
-- @within Anwenderfunktionen
--
-- @usage
-- -- Es werden keine Kühe zur Zucht benötigt:
-- API.SetCattleNeeded(0);
--
function API.SetCattleNeeded(_Amount)
    if not GUI then
        API.Bridge("API.SetCattleNeeded(" .._Amount.. ")");
        return;
    end
    if type(_Amount) ~= "number" or _Amount &#x3C; 0 or _Amount &#x3E; 5 then
        API.Fatal("API.SetCattleNeeded: Needed amount is invalid!");
    end
    BundleBuildingButtons.Local.Data.CattleNeeded = _Amount;
end
SetCattleNeeded = API.SetCattleNeeded;

---
-- Fügt einen optionalen Gebäudeschalter hinzu. Der Index bestimmt, welcher
-- der beiden möglichen Buttons verwendet wird.
--
-- Mit dieser Funktion können zwei ungenutzte Buttons im Gebäudemenu mit einer
-- Funktionalität versehen werden. Es obliegt dem Mapper für welche Gebäude
-- der Button angezeigt wird und welche Funktion er hat. Es ist nicht möglich
-- Kosten im Tooltip anzuzeigen.
--
-- Jeder Button kann immer nur mit einer Aktion versehen werden. Soll die
-- Aktion für verschiedene Gebäudetypen unterschiedlich sein, muss in der
-- Aktion eine Fallunterscheidung durchgeführt werden.
--
-- Ein optionaler Button benötigt immer drei Funktionen:
-- &#x3C;ul&#x3E;
-- &#x3C;li&#x3E;Action: Steuert, was der Button tut.&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;Tooltip: Steuert, welcher Beschreibungstext angezeigt wird.&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;Update: Steuert, wann und wie der Button angezeigt wird.&#x3C;/li&#x3E;
-- &#x3C;/ul&#x3E;
-- Alle drei Funktionen erhalten die ID des Buttons und die ID des Gebäudes,
-- das gerade selektiert ist.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; AddBuildingButton&#x3C;/p&#x3E;
--
-- @param[type=number]   _Index Index des Buttons
-- @param[type=function] _Action Aktion des Buttons
-- @param[type=function] _Tooltip Tooltip Control
-- @param[type=function] _Update Button Update
-- @within Anwenderfunktionen
--
-- @usage
-- -- Aktion
-- function ExampleButtonAction(_WidgetID, _BuildingID)
--     GUI.AddNote("Hier passiert etwas!");
-- end
-- -- Tooltip
-- function ExampleButtonTooltip(_WidgetID, _BuildingID)
--     UserSetTextNormal("Beschreibung", "Das ist die Beschreibung!");
-- end
-- -- Update
-- function ExampleButtonUpdate(_WidgetID, _BuildingID)
--     SetIcon(_WidgetID, {1, 1});
-- end
--
-- -- Beispiel für einen einfachen Button, der immer angezeigt wird, das Bild
-- -- eines Apfels trägt und eine Nachricht anzeigt.
-- API.AddCustomBuildingButton(1, ExampleButtonAction, ExampleButtonTooltip, ExampleButtonUpdate);
--
function API.AddCustomBuildingButton(_Index, _Action, _Tooltip, _Update)
    if not GUI then
        API.Fatal("API.AddCustomBuildingButton: Can not be used from global script!");
        return;
    end
    if (type(_Index) ~= "number" or (_Index &#x3C; 1 or _Index &#x3E; 2)) then
        API.Fatal("API.AddCustomBuildingButton: Index must be 1 or 2!");
        return;
    end
    if (type(_Action) ~= "function" or type(_Tooltip) ~= "function" or type(_Update) ~= "function") then
        API.Fatal("API.AddCustomBuildingButton: Action, tooltip and update must be functions!");
        return;
    end
    return BundleBuildingButtons.Local:AddOptionalButton(
        _Index, _Action, _Tooltip, _Update
    );
end
AddBuildingButton = API.AddCustomBuildingButton;

---
-- Entfernt den optionalen Gebäudeschalter mit dem angegebenen Index.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; DeleteBuildingButton&#x3C;/p&#x3E;
--
-- @param[type=number] _Index Index des Buttons
-- @within Anwenderfunktionen
--
-- @usage
-- -- Entfernt die Konfiguration für Button 1
-- API.RemoveCustomBuildingButton(1);
--
function API.RemoveCustomBuildingButton(_Index)
    if not GUI then
        API.Bridge("API.RemoveCustomBuildingButton("..tostring(_Index)..")");
        return;
    end
    if (type(_Index) ~= "number" or (_Index &#x3C; 1 or _Index &#x3E; 2)) then
        API.Fatal("API.RemoveCustomBuildingButton: Index must be 1 or 2!");
        return;
    end
    return BundleBuildingButtons.Local:DeleteOptionalButton(_Index);
end
DeleteBuildingButton = API.RemoveCustomBuildingButton;

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

BundleBuildingButtons = {
    Global = {
        Data = {}
    },
    Local = {
        Data = {
            OptionalButton1 = {
                UseButton = false,
            },
            OptionalButton2 = {
                UseButton = false,
            },

            StoppedBuildings = {},
            Downgrade = true,

            BreedCattle = true,
            CattleCosts = 10,
            CattleNeeded = 3,
            CattleKnightTitle = 0,
            CattleMoneyCost = 300,

            BreedSheeps = true,
            SheepCosts = 10,
            SheepNeeded = 3,
            SheepKnightTitle = 0,
            SheepMoneyCost = 300,
        },

        Description = {
            Downgrade = {
                Title = {
                    de = "Rückbau",
                    en = "Downgrade",
                },
                Text = {
                    de = "- Reißt eine Stufe des Geb?udes ein {cr}- Der überschüssige Arbeiter wird entlassen",
                    en = "- Destroy one level of this building {cr}- The surplus worker will be dismissed",
                },
                Disabled = {
                    de = "Kann nicht zurückgebaut werden!",
                    en = "Can not be downgraded yet!",
                },
            },

            BuyCattle = {
                Title = {
                    de = "Nutztier kaufen",
                    en = "Buy Farm animal",
                },
                Text = {
                    de = "- Kauft ein Nutztier {cr}- Nutztiere produzieren Rohstoffe",
                    en = "- Buy a farm animal {cr}- Farm animals produce resources",
                },
                Disabled = {
                    de = "Kauf ist nicht möglich!",
                    en = "Buy not possible!",
                },
            },

            SingleStop = {
                Title = {
                    de = "Arbeit anhalten/aufnehmen",
                    en = "Start/Stop Work",
                },
                Text = {
                    de = "- Startet oder stoppe die Arbeit in diesem Betrieb",
                    en = "- Continue or stop work for this building",
                },
            },
        },
    },
}

-- Global Script ---------------------------------------------------------------

---
-- Initalisiert das Bundle im globalen Skript.
--
-- @within Internal
-- @local
--
function BundleBuildingButtons.Global:Install()
end



-- Local Script ----------------------------------------------------------------

---
-- Initalisiert das Bundle im lokalen Skript.
--
-- @within Internal
-- @local
--
function BundleBuildingButtons.Local:Install()
    MerchantSystem.BasePricesOrigBundleBuildingButtons                = {};

    MerchantSystem.BasePricesOrigBundleBuildingButtons[Goods.G_Sheep] = MerchantSystem.BasePrices[Goods.G_Sheep];
    MerchantSystem.BasePricesOrigBundleBuildingButtons[Goods.G_Cow]   = MerchantSystem.BasePrices[Goods.G_Cow];

    MerchantSystem.BasePrices[Goods.G_Sheep] = BundleBuildingButtons.Local.Data.SheepMoneyCost;
    MerchantSystem.BasePrices[Goods.G_Cow]   = BundleBuildingButtons.Local.Data.CattleMoneyCost;

    self:OverwriteHouseMenuButtons();
    self:OverwriteBuySiegeEngine();
    self:OverwriteToggleTrap();
    self:OverwriteGateOpenClose();
    self:OverwriteAutoToggle();

    Core:AppendFunction("GameCallback_GUI_SelectionChanged", self.OnSelectionChanged);
end

---
-- Diese Funktion erzeugt ein Nutztier und entfernt das Getreide vom Spieler.
--
-- @within Internal
-- @local
--
function BundleBuildingButtons.Local:BuyAnimal(_eID)
    Sound.FXPlay2DSound("ui\\menu_click");
    local eType = Logic.GetEntityType(_eID);

    if eType == Entities.B_CattlePasture then
        local Cost = BundleBuildingButtons.Local.Data.CattleCosts * (-1);
        GUI.SendScriptCommand([[
            local PlayerID = Logic.EntityGetPlayer(]].._eID..[[)
            local x, y = Logic.GetBuildingApproachPosition(]].._eID..[[)
            Logic.CreateEntity(Entities.A_X_Cow01, x, y, 0, PlayerID)
            AddGood(Goods.G_Grain, ]] ..Cost.. [[, PlayerID)
        ]]);
    elseif eType == Entities.B_SheepPasture then
        local Cost = BundleBuildingButtons.Local.Data.SheepCosts * (-1);
        GUI.SendScriptCommand([[
            local PlayerID = Logic.EntityGetPlayer(]].._eID..[[)
            local x, y = Logic.GetBuildingApproachPosition(]].._eID..[[)
            Logic.CreateEntity(Entities.A_X_Sheep01, x, y, 0, PlayerID)
            AddGood(Goods.G_Grain, ]] ..Cost.. [[, PlayerID)
        ]]);
    end
end

---
-- Das aktuell selektierte Gebäude wird um eine Stufe zurückgebaut.
--
-- Ein Gebäude der Stufe 1 wird zerstört. Aktuell ist dies aber inaktiv.
--
-- @within Internal
-- @local
--
function BundleBuildingButtons.Local:DowngradeBuilding()
    Sound.FXPlay2DSound("ui\\menu_click");
    local Selected = GUI.GetSelectedEntity();
    GUI.DeselectEntity(Selected);
    if Logic.GetUpgradeLevel(Selected) &#x3E; 0 then
        local AmountToHurt = math.ceil(Logic.GetEntityMaxHealth(Selected) / 2);
        if Logic.GetEntityHealth(Selected) &#x3E;= AmountToHurt then
            GUI.SendScriptCommand([[Logic.HurtEntity(]] ..Selected.. [[, ]] ..AmountToHurt.. [[)]]);
        end
    else
        local AmountToHurt = Logic.GetEntityMaxHealth(Selected);
        GUI.SendScriptCommand([[Logic.HurtEntity(]] ..Selected.. [[, ]] ..AmountToHurt.. [[)]]);
    end
end

---
-- Fügt einen Button dem Hausmenü hinzu. Es können nur 2 Buttons
-- hinzugefügt werden. Buttons brauchen immer eine Action-, eine
-- Tooltip- und eine Update-Funktion.
--
-- @param[type=number]   _idx              Indexposition des Button (1 oder 2)
-- @param[type=function] _actionFunction   Action-Funktion (String in Global)
-- @param[type=function] _tooltipFunction  Tooltip-Funktion (String in Global)
-- @param[type=function] _updateFunction   Update-Funktion (String in Global)
-- @within Internal
-- @local
-- @see API.AddCustomBuildingButton
--
function BundleBuildingButtons.Local:AddOptionalButton(_idx, _actionFunction, _tooltipFunction, _updateFunction)
    assert(_idx == 1 or _idx == 2);
    local wID = {
        XGUIEng.GetWidgetID("/InGame/Root/Normal/BuildingButtons/GateAutoToggle"),
        XGUIEng.GetWidgetID("/InGame/Root/Normal/BuildingButtons/GateOpenClose"),
    };
    BundleBuildingButtons.Local.Data["OptionalButton".._idx].WidgetID = wID[_idx];
    BundleBuildingButtons.Local.Data["OptionalButton".._idx].UseButton = true;
    BundleBuildingButtons.Local.Data["OptionalButton".._idx].ActionFunction = _actionFunction;
    BundleBuildingButtons.Local.Data["OptionalButton".._idx].TooltipFunction = _tooltipFunction;
    BundleBuildingButtons.Local.Data["OptionalButton".._idx].UpdateFunction = _updateFunction;
end

---
-- Entfernt den Zusatz-Button auf dem Index.
--
-- @param[type=number] _idx Indexposition des Button (1 oder 2)
-- @within Internal
-- @local
--
function BundleBuildingButtons.Local:DeleteOptionalButton(_idx)
    assert(_idx == 1 or _idx == 2);
    local wID = {
        XGUIEng.GetWidgetID("/InGame/Root/Normal/BuildingButtons/GateAutoToggle"),
        XGUIEng.GetWidgetID("/InGame/Root/Normal/BuildingButtons/GateOpenClose"),
    };
    BundleBuildingButtons.Local.Data["OptionalButton".._idx].WidgetID = wID[_idx];
    BundleBuildingButtons.Local.Data["OptionalButton".._idx].UseButton = false;
    BundleBuildingButtons.Local.Data["OptionalButton".._idx].ActionFunction = nil;
    BundleBuildingButtons.Local.Data["OptionalButton".._idx].TooltipFunction = nil;
    BundleBuildingButtons.Local.Data["OptionalButton".._idx].UpdateFunction = nil;
end

---
-- Überschreibt die GUI-Funktionen des inaktiven Schalters für automatisches
-- Umschalten von Torsperren.
--
-- Diese Funktion implementiert den optionalen Schalter #1.
--
-- @within Internal
-- @local
--
function BundleBuildingButtons.Local:OverwriteAutoToggle()
    GUI_BuildingButtons.GateAutoToggleClicked = function()
        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();
        local EntityID = GUI.GetSelectedEntity();
        if not BundleBuildingButtons.Local.Data.OptionalButton1.ActionFunction then
            return;
        end
        BundleBuildingButtons.Local.Data.OptionalButton1.ActionFunction(CurrentWidgetID, EntityID);
    end

    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    GUI_BuildingButtons.GateAutoToggleMouseOver = function()
        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();
        local EntityID = GUI.GetSelectedEntity();
        if not BundleBuildingButtons.Local.Data.OptionalButton1.TooltipFunction then
            return;
        end
        BundleBuildingButtons.Local.Data.OptionalButton1.TooltipFunction(CurrentWidgetID, EntityID);
    end

    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    GUI_BuildingButtons.GateAutoToggleUpdate = function()
        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();
        local EntityID = GUI.GetSelectedEntity();
        local MaxHealth = Logic.GetEntityMaxHealth(EntityID);
        local Health = Logic.GetEntityHealth(EntityID);

        SetIcon(CurrentWidgetID, {8,16});

        if EntityID == nil
        or Logic.IsBuilding(EntityID) == 0
        or not BundleBuildingButtons.Local.Data.OptionalButton1.UpdateFunction
        or not BundleBuildingButtons.Local.Data.OptionalButton1.UseButton
        or Logic.IsConstructionComplete(EntityID) == 0 then
            XGUIEng.ShowWidget(CurrentWidgetID, 0);
            return;
        end

        if Logic.BuildingDoWorkersStrike(EntityID) == true
        or Logic.IsBuildingBeingUpgraded(EntityID) == true
        or Logic.IsBuildingBeingKnockedDown(EntityID) == true
        or Logic.IsBurning(EntityID) == true
        or MaxHealth-Health &#x3E; 0 then
            XGUIEng.ShowWidget(CurrentWidgetID, 0);
            return;
        end
        BundleBuildingButtons.Local.Data.OptionalButton1.UpdateFunction(CurrentWidgetID, EntityID);
    end
end

---
-- Überschreibt den inaktiven Button zum öffnen/schließen von Toren.
--
-- Diese Funktion implementiert den optionalen Schalter #2.
--
-- @within Internal
-- @local
--
function BundleBuildingButtons.Local:OverwriteGateOpenClose()
    GUI_BuildingButtons.GateOpenCloseClicked = function()
        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();
        local EntityID = GUI.GetSelectedEntity();
        if not BundleBuildingButtons.Local.Data.OptionalButton2.ActionFunction then
            return;
        end
        BundleBuildingButtons.Local.Data.OptionalButton2.ActionFunction(CurrentWidgetID, EntityID);
    end

    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    GUI_BuildingButtons.GateOpenCloseMouseOver = function()
        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();
        local EntityID = GUI.GetSelectedEntity();
        if not BundleBuildingButtons.Local.Data.OptionalButton2.TooltipFunction then
            return;
        end
        BundleBuildingButtons.Local.Data.OptionalButton2.TooltipFunction(CurrentWidgetID, EntityID);
    end

    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    GUI_BuildingButtons.GateOpenCloseUpdate = function()
        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();
        local EntityID = GUI.GetSelectedEntity();
        local MaxHealth = Logic.GetEntityMaxHealth(EntityID);
        local Health = Logic.GetEntityHealth(EntityID);

        SetIcon(CurrentWidgetID, {8,16});

        if EntityID == nil
        or Logic.IsBuilding(EntityID) == 0
        or not BundleBuildingButtons.Local.Data.OptionalButton2.UpdateFunction
        or not BundleBuildingButtons.Local.Data.OptionalButton2.UseButton
        or Logic.IsConstructionComplete(EntityID) == 0
        or Logic.IsBuilding(EntityID) == 0 then
            XGUIEng.ShowWidget(CurrentWidgetID, 0);
            return;
        end

        if Logic.BuildingDoWorkersStrike(EntityID) == true
        or Logic.IsBuildingBeingUpgraded(EntityID) == true
        or Logic.IsBuildingBeingKnockedDown(EntityID) == true
        or Logic.IsBurning(EntityID) == true
        or MaxHealth-Health &#x3E; 0 then
            XGUIEng.ShowWidget(CurrentWidgetID, 0);
            return;
        end
        BundleBuildingButtons.Local.Data.OptionalButton2.UpdateFunction(CurrentWidgetID, EntityID);
    end
end

---
-- Überschreibt den inaktiven Button zum umschalten der Torhausfallen.
--
-- Diese Funktion implementiert den Rückbau.
--
-- @within Internal
-- @local
--
function BundleBuildingButtons.Local:OverwriteToggleTrap()
    GUI_BuildingButtons.TrapToggleClicked = function()
        BundleBuildingButtons.Local:DowngradeBuilding();
    end

    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    GUI_BuildingButtons.TrapToggleMouseOver = function()
        local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";
        BundleBuildingButtons.Local:TextNormal(
            BundleBuildingButtons.Local.Description.Downgrade.Title[lang],
            BundleBuildingButtons.Local.Description.Downgrade.Text[lang],
            BundleBuildingButtons.Local.Description.Downgrade.Disabled[lang]
        );
    end

    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    GUI_BuildingButtons.TrapToggleUpdate = function()
        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();
        local EntityID = GUI.GetSelectedEntity();
        local eName = Logic.GetEntityName(EntityID);
        local eType = Logic.GetEntityType(EntityID);
        local tID = GetTerritoryUnderEntity(EntityID);
        local MaxHealth = Logic.GetEntityMaxHealth(EntityID);
        local Health = Logic.GetEntityHealth(EntityID);
        local Level = Logic.GetUpgradeLevel(EntityID);

        local x,y = XGUIEng.GetWidgetLocalPosition("/InGame/Root/Normal/BuildingButtons/Upgrade");
        SetIcon(CurrentWidgetID, {3,15});
        XGUIEng.SetWidgetLocalPosition(CurrentWidgetID, x+64, y);

        if EntityID == nil or Logic.IsBuilding(EntityID) == 0 then
            XGUIEng.ShowWidget(CurrentWidgetID, 0);
            return;
        end

        -- Protection - Submodul
        if BundleDestructionControl then
            -- Prüfe auf Namen
            if Inside(eName, BundleDestructionControl.Local.Data.Entities) then
                XGUIEng.ShowWidget(CurrentWidgetID, 0);
                return;
            end

            -- Prüfe auf Typen
            if Inside(eType, BundleDestructionControl.Local.Data.EntityTypes) then
                XGUIEng.ShowWidget(CurrentWidgetID, 0);
                return;
            end

            -- Prüfe auf Territorien
            if Inside(tID, BundleDestructionControl.Local.Data.OnTerritory) then
                XGUIEng.ShowWidget(CurrentWidgetID, 0);
                return;
            end

            -- Prüfe auf Category
            for k,v in pairs(BundleDestructionControl.Local.Data.EntityCategories) do
                if Logic.IsEntityInCategory(_BuildingID, v) == 1 then
                    XGUIEng.ShowWidget(CurrentWidgetID, 0);
                    return;
                end
            end
        end

        if Logic.IsConstructionComplete(EntityID) == 0
        or (Logic.IsEntityInCategory(EntityID, EntityCategories.OuterRimBuilding) == 0
        and Logic.IsEntityInCategory(EntityID, EntityCategories.CityBuilding) == 0)
        or not BundleBuildingButtons.Local.Data.Downgrade
        or Level == 0 then
            XGUIEng.ShowWidget(CurrentWidgetID, 0);
            return;
        end
        if Logic.BuildingDoWorkersStrike(EntityID) == true
        or Logic.IsBuildingBeingUpgraded(EntityID) == true
        or Logic.IsBuildingBeingKnockedDown(EntityID) == true
        or Logic.IsBurning(EntityID) == true
        or MaxHealth-Health &#x3E; 0 then
            XGUIEng.DisableButton(CurrentWidgetID, 1);
        else
            XGUIEng.DisableButton(CurrentWidgetID, 0);
        end
    end
end

---
-- Diese Funktion überschreibt die Belagerungswaffenwerkstattsteuerung. Dabei
-- wird die Nutztierzucht implementiert.
--
-- @within Internal
-- @local
--
function BundleBuildingButtons.Local:OverwriteBuySiegeEngine()
    GUI_BuildingButtons.BuySiegeEngineCartMouseOver = function(_EntityType,_TechnologyType)
        local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";
        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();
        local BarrackID = GUI.GetSelectedEntity();
        local BuildingEntityType = Logic.GetEntityType(BarrackID);

        if  BuildingEntityType ~= Entities.B_SiegeEngineWorkshop
        and BuildingEntityType ~= Entities.B_CattlePasture
        and BuildingEntityType ~= Entities.B_SheepPasture then
            return;
        end

        local Costs = {Logic.GetUnitCost(BarrackID, _EntityType)}
        if BuildingEntityType == Entities.B_CattlePasture then
            BundleBuildingButtons.Local:TextCosts(
                BundleBuildingButtons.Local.Description.BuyCattle.Title[lang],
                BundleBuildingButtons.Local.Description.BuyCattle.Text[lang],
                BundleBuildingButtons.Local.Description.BuyCattle.Disabled[lang],
                {Goods.G_Grain, BundleBuildingButtons.Local.Data.CattleCosts},
                false
            );
        elseif BuildingEntityType == Entities.B_SheepPasture then
            BundleBuildingButtons.Local:TextCosts(
                BundleBuildingButtons.Local.Description.BuyCattle.Title[lang],
                BundleBuildingButtons.Local.Description.BuyCattle.Text[lang],
                BundleBuildingButtons.Local.Description.BuyCattle.Disabled[lang],
                {Goods.G_Grain, BundleBuildingButtons.Local.Data.SheepCosts},
                false
            );
        else
            GUI_Tooltip.TooltipBuy(Costs,nil,nil,_TechnologyType);
        end
    end

    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    GUI_BuildingButtons.BuySiegeEngineCartClicked_OrigTHEA_Buildings = GUI_BuildingButtons.BuySiegeEngineCartClicked
    GUI_BuildingButtons.BuySiegeEngineCartClicked = function(_EntityType)
        local BarrackID = GUI.GetSelectedEntity()
        local PlayerID = GUI.GetPlayerID()
        local eType = Logic.GetEntityType(BarrackID)
        if eType == Entities.B_CattlePasture or eType == Entities.B_SheepPasture then
            BundleBuildingButtons.Local:BuyAnimal(BarrackID);
        else
            GUI_BuildingButtons.BuySiegeEngineCartClicked_OrigTHEA_Buildings(_EntityType)
        end
    end

    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    GUI_BuildingButtons.BuySiegeEngineCartUpdate = function(_Technology)
        local PlayerID = GUI.GetPlayerID();
        local KnightTitle = Logic.GetKnightTitle(PlayerID);
        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();
        local EntityID = GUI.GetSelectedEntity();
        local EntityType = Logic.GetEntityType(EntityID);
        local grain = GetPlayerResources(Goods.G_Grain,PlayerID);
        local pos = GetPosition(EntityID);

        if EntityType == Entities.B_SiegeEngineWorkshop then
            XGUIEng.ShowWidget(CurrentWidgetID,1);
            if _Technology == Technologies.R_BatteringRam then
                SetIcon(CurrentWidgetID, {9,5});
            elseif _Technology == Technologies.R_SiegeTower then
                SetIcon(CurrentWidgetID, {9,6});
            elseif _Technology == Technologies.R_Catapult then
                SetIcon(CurrentWidgetID, {9,4});
            end
        elseif EntityType == Entities.B_CattlePasture then
            local CattlePasture = GetPlayerEntities(PlayerID,Entities.B_CattlePasture);
            local cows          = {Logic.GetPlayerEntitiesInArea(PlayerID,Entities.A_X_Cow01,pos.X,pos.Y,800,16)};
            local curAnimal     = Logic.GetNumberOfPlayerEntitiesInCategory(PlayerID,EntityCategories.CattlePasture);
            local maxAnimal     = #CattlePasture*5;

            SetIcon(CurrentWidgetID, {3,16})

            if _Technology == Technologies.R_Catapult and BundleBuildingButtons.Local.Data.BreedCattle then
                XGUIEng.ShowWidget("/InGame/Root/Normal/BuildingButtons",1);
                XGUIEng.ShowWidget("/InGame/Root/Normal/BuildingButtons/BuyCatapultCart",1);

                if curAnimal &#x3E;= maxAnimal then
                    XGUIEng.DisableButton(CurrentWidgetID, 1);
                elseif grain &#x3C; BundleBuildingButtons.Local.Data.CattleCosts then
                    XGUIEng.DisableButton(CurrentWidgetID, 1);
                elseif KnightTitle &#x3C; BundleBuildingButtons.Local.Data.CattleKnightTitle then
                    XGUIEng.DisableButton(CurrentWidgetID, 1);
                elseif cows[1] &#x3C; BundleBuildingButtons.Local.Data.CattleNeeded then
                    XGUIEng.DisableButton(CurrentWidgetID, 1);
                else
                    XGUIEng.DisableButton(CurrentWidgetID, 0);
                end
            else
                XGUIEng.ShowWidget(CurrentWidgetID,0);
            end
        elseif EntityType == Entities.B_SheepPasture then
            local SheepPasture     = GetPlayerEntities(PlayerID,Entities.B_SheepPasture);
            local sheeps        = {Logic.GetPlayerEntitiesInArea(PlayerID,Entities.A_X_Sheep01,pos.X,pos.Y,800,16)};
            table.remove(sheeps, 1);
            local sheeps2        = {Logic.GetPlayerEntitiesInArea(PlayerID,Entities.A_X_Sheep02,pos.X,pos.Y,800,16)};
            table.remove(sheeps2, 1);
            local curAnimal     = Logic.GetNumberOfPlayerEntitiesInCategory(PlayerID,EntityCategories.SheepPasture);
            local maxAnimal     = #SheepPasture*5;

            sheeps = Array_Append(sheeps,sheeps2)
            SetIcon(CurrentWidgetID, {4,1})

            if _Technology == Technologies.R_Catapult and BundleBuildingButtons.Local.Data.BreedSheeps then
                XGUIEng.ShowWidget("/InGame/Root/Normal/BuildingButtons",1);
                XGUIEng.ShowWidget("/InGame/Root/Normal/BuildingButtons/BuyCatapultCart",1);

                if curAnimal &#x3E;= maxAnimal then
                    XGUIEng.DisableButton(CurrentWidgetID, 1);
                elseif grain &#x3C; BundleBuildingButtons.Local.Data.SheepCosts then
                    XGUIEng.DisableButton(CurrentWidgetID, 1);
                elseif #sheeps &#x3C; BundleBuildingButtons.Local.Data.SheepKnightTitle then
                    XGUIEng.DisableButton(CurrentWidgetID, 1);
                elseif #sheeps &#x3C; BundleBuildingButtons.Local.Data.SheepNeeded then
                    XGUIEng.DisableButton(CurrentWidgetID, 1);
                else
                    XGUIEng.DisableButton(CurrentWidgetID, 0);
                end
            else
                XGUIEng.ShowWidget(CurrentWidgetID,0);
            end
        else
            XGUIEng.ShowWidget(CurrentWidgetID,0);
            return;
        end

        if Logic.IsConstructionComplete(GUI.GetSelectedEntity()) == 0 then
            XGUIEng.ShowWidget(CurrentWidgetID,0);
            return;
        end

        if EntityType ~= Entities.B_SheepPasture and EntityType ~= Entities.B_CattlePasture then
            local TechnologyState = Logic.TechnologyGetState(PlayerID, _Technology);
            if EnableRights == nil or EnableRights == false then
                XGUIEng.DisableButton(CurrentWidgetID,0);
                return
            end
            if TechnologyState == TechnologyStates.Researched then
                XGUIEng.DisableButton(CurrentWidgetID,0);
            else
                XGUIEng.DisableButton(CurrentWidgetID,1);
            end
        end
    end
end

---
-- Diese Funktion überschreibt das House Menu, sodass Single stop fehlerfrei
-- funktioniert.
--
-- @within Internal
-- @local
--
function BundleBuildingButtons.Local:OverwriteHouseMenuButtons()
    HouseMenuStopProductionClicked_Orig_SingleStop = HouseMenuStopProductionClicked;
    HouseMenuStopProductionClicked = function()
        HouseMenuStopProductionClicked_Orig_SingleStop();
        local WidgetName = HouseMenu.Widget.CurrentBuilding;
        local EntityType = Entities[WidgetName];
        local PlayerID = GUI.GetPlayerID();
        local Buildings = GetPlayerEntities(PlayerID, EntityType);

        for i=1, #Buildings, 1 do
            if BundleBuildingButtons.Local.Data.StoppedBuildings[Buildings[i]] ~= HouseMenu.StopProductionBool then
                BundleBuildingButtons.Local.Data.StoppedBuildings[Buildings[i]] = HouseMenu.StopProductionBool;
                GUI.SetStoppedState(Buildings[i], HouseMenu.StopProductionBool);
            end
        end
    end
end

---
-- Ändert die Textur eines Icons im House Menu.
--
-- @param[type=string] _Widget Icon Widget
-- @param[type=table]  _Icon   Icon Textur
-- @within BundleBuildingButtons
-- @local
--
function BundleBuildingButtons.Local:HouseMenuIcon(_Widget, _Icon)
    if type(_Icon) == "table" then
        if type(_Icon[3]) == "string" then
            local ButtonState = 1;
            if XGUIEng.IsButton(_Widget) == 1 then
                ButtonState = 7;
            end

            local u0, u1, v0, v1;
            u0 = (_Coordinates[1] - 1) * 64;
            v0 = (_Coordinates[2] - 1) * 64;
            u1 = (_Coordinates[1]) * 64;
            v1 = (_Coordinates[2]) * 64;
            XGUIEng.SetMaterialAlpha(_Widget, ButtonState, 255);
            XGUIEng.SetMaterialTexture(_Widget, ButtonState, _Icon[3].. "big.png");
            XGUIEng.SetMaterialUV(_Widget, ButtonState, u0, v0, u1, v1);
        else
            SetIcon(_Widget, _Icon);
        end
    else
        local screenSize = {GUI.GetScreenSize()};
        local Scale = 330;
        if screenSize[2] &#x3E;= 800 then
            Scale = 260;
        end
        if screenSize[2] &#x3E;= 1000 then
            Scale = 210;
        end
        XGUIEng.SetMaterialAlpha(_Widget, 1, 255);
        XGUIEng.SetMaterialTexture(_Widget, 1, _file);
        XGUIEng.SetMaterialUV(_Widget, 1, 0, 0, Scale, Scale);
    end
end

---
-- Setzt einen für den Tooltip des aktuellen Widget einen neuen Text.
--
-- @param[type=string] _Title        Titel des Tooltip
-- @param[type=string] _Text         Text des Tooltip
-- @param[type=string] _DisabledText (optional) Textzusatz wenn inaktiv
-- @within BundleBuildingButtons
-- @local
--
function BundleBuildingButtons.Local:TextNormal(_Title, _Text, _DisabledText)
    local TooltipContainerPath = "/InGame/Root/Normal/TooltipNormal";
    local TooltipContainer = XGUIEng.GetWidgetID(TooltipContainerPath);
    local TooltipNameWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Name");
    local TooltipDescriptionWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Text");
    local TooltipBGWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/BG");
    local TooltipFadeInContainer = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn");
    local PositionWidget = XGUIEng.GetCurrentWidgetID();
    GUI_Tooltip.ResizeBG(TooltipBGWidget, TooltipDescriptionWidget);
    local TooltipContainerSizeWidgets = {TooltipBGWidget};
    GUI_Tooltip.SetPosition(TooltipContainer, TooltipContainerSizeWidgets, PositionWidget);
    GUI_Tooltip.FadeInTooltip(TooltipFadeInContainer);

    _DisabledText = _DisabledText or "";
    local disabled = ""
    if XGUIEng.IsButtonDisabled(PositionWidget) == 1 and _DisabledText ~= "" and _Text ~= "" then
        disabled = disabled .. "{cr}{@color:255,32,32,255}" .. _DisabledText
    end

    XGUIEng.SetText(TooltipNameWidget, "{center}" .. _Title);
    XGUIEng.SetText(TooltipDescriptionWidget, _Text .. disabled);
    local Height = XGUIEng.GetTextHeight(TooltipDescriptionWidget, true);
    local W, H = XGUIEng.GetWidgetSize(TooltipDescriptionWidget);
    XGUIEng.SetWidgetSize(TooltipDescriptionWidget, W, Height);
end

---
-- Setzt den Kostentooltip des aktuellen Widgets.
--
-- @param[type=string]  _Title        Titel des Tooltip
-- @param[type=string]  _Text         Text des Tooltip
-- @param[type=string]  _DisabledText (optional) Textzusatz wenn inaktiv
-- @param[type=number]  _Costs        Kostentabelle
-- @param[type=boolean] _InSettlement Kosten in Siedlung suchen
-- @within Internal
-- @local
--
function BundleBuildingButtons.Local:TextCosts(_Title, _Text, _DisabledText, _Costs, _InSettlement)
    local TooltipContainerPath = "/InGame/Root/Normal/TooltipBuy"
    local TooltipContainer = XGUIEng.GetWidgetID(TooltipContainerPath)
    local TooltipNameWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Name")
    local TooltipDescriptionWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Text")
    local TooltipBGWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/BG")
    local TooltipFadeInContainer = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn")
    local TooltipCostsContainer = XGUIEng.GetWidgetID(TooltipContainerPath .. "/Costs")
    local PositionWidget = XGUIEng.GetCurrentWidgetID()
    GUI_Tooltip.ResizeBG(TooltipBGWidget, TooltipDescriptionWidget)
    GUI_Tooltip.SetCosts(TooltipCostsContainer, _Costs, _InSettlement)
    local TooltipContainerSizeWidgets = {TooltipContainer, TooltipCostsContainer, TooltipBGWidget}
    GUI_Tooltip.SetPosition(TooltipContainer, TooltipContainerSizeWidgets, PositionWidget, nil, true)
    GUI_Tooltip.OrderTooltip(TooltipContainerSizeWidgets, TooltipFadeInContainer, TooltipCostsContainer, PositionWidget, TooltipBGWidget)
    GUI_Tooltip.FadeInTooltip(TooltipFadeInContainer)

    _DisabledText = _DisabledText or "";
    local disabled = ""
    if XGUIEng.IsButtonDisabled(PositionWidget) == 1 and _DisabledText ~= "" and _Text ~= "" then
        disabled = disabled .. "{cr}{@color:255,32,32,255}" .. _DisabledText
    end

    XGUIEng.SetText(TooltipNameWidget, "{center}" .. _Title)
    XGUIEng.SetText(TooltipDescriptionWidget, _Text .. disabled)
    local Height = XGUIEng.GetTextHeight(TooltipDescriptionWidget, true)
    local W, H = XGUIEng.GetWidgetSize(TooltipDescriptionWidget)
    XGUIEng.SetWidgetSize(TooltipDescriptionWidget, W, Height)
end

---
-- Diese Funktion ist die Action von Single Stop.
--
-- @within Internal
-- @local
--
function BundleBuildingButtons.Local.ButtonDefaultSingleStop_Action(WidgetID, EntityID)
    local StoppedState = BundleBuildingButtons.Local.Data.StoppedBuildings[EntityID] == true;
    GUI.SetStoppedState(EntityID, not StoppedState);
    BundleBuildingButtons.Local.Data.StoppedBuildings[EntityID] = not StoppedState;
end

---
-- Diese Funktion steuert den Tooltip von Single Stop.
--
-- @within Internal
-- @local
--
function BundleBuildingButtons.Local.ButtonDefaultSingleStop_Tooltip(WidgetID, EntityID)
    local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";
    BundleBuildingButtons.Local:TextNormal(
        BundleBuildingButtons.Local.Description.SingleStop.Title[lang],
        BundleBuildingButtons.Local.Description.SingleStop.Text[lang]
    );
end

---
-- Diese Funktion ist der Update Job von Single Stop.
--
-- @within Internal
-- @local
--
function BundleBuildingButtons.Local.ButtonDefaultSingleStop_Update(_WidgetID, _EntityID)
    local IsOuterRimBuilding = Logic.IsEntityInCategory(_EntityID, EntityCategories.OuterRimBuilding) == 1;
    local IsCityBuilding = Logic.IsEntityInCategory(_EntityID, EntityCategories.CityBuilding) == 1;
    if IsOuterRimBuilding == false and IsCityBuilding == false then
        XGUIEng.ShowWidget(_WidgetID, 0);
    end

    if BundleBuildingButtons.Local.Data.StoppedBuildings[_EntityID] == true then
        SetIcon(_WidgetID, {4, 12});
    else
        SetIcon(_WidgetID, {4, 13});
    end
end

---
-- Diese Funktion wird aufgerufen, sobald sich die Selektion ändert.
--
-- Hier werden die ausgeblendeten ungenutzten Gebäudeschalter eingeblendet.
--
-- @param[type=number] _Source Quelle der Änderung
-- @within Internal
-- @local
--
function BundleBuildingButtons.Local.OnSelectionChanged(_Source)
    local eID = GUI.GetSelectedEntity();
    local eType = Logic.GetEntityType(eID);

    XGUIEng.ShowWidget("/InGame/Root/Normal/BuildingButtons/GateAutoToggle",1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/BuildingButtons/GateOpenClose",1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/BuildingButtons/TrapToggle",1);
end

-- -------------------------------------------------------------------------- --

Core:RegisterBundle("BundleBuildingButtons");

</code></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundleclassicbehaviors.lua.html">
            <div class='doclink'>
                <div>BundleClassicBehaviors</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><code>-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundleClassicBehaviors                                       # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Dieses Bundle enthält alle Behavior, die aus der QSB 3.9 PlusB bekannt sind.
--
-- Die Behavior sind weitesgehend unverändert und es dürfte keine Probleme mit
-- Inkompatibelität geben, wenn die QSB ausgetauscht wird.
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundleClassicBehaviors = {};

API = API or {};
QSB = QSB or {};

QSB.EffectNameToID    = QSB.EffectNameToID or {};
QSB.InitalizedObjekts = QSB.InitalizedObjekts or {};
QSB.DestroyedSoldiers = QSB.DestroyedSoldiers or {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Gibt das im Quest gespeicherte Resultat von Goal_InputDialog als Text zurück.
--
-- &#x3C;b&#x3E;Hinweis&#x3C;/b&#x3E;: Es wird nur die letzte Eingabe zurückgegeben.
--
-- @param[type=string] _QuestName Name des Quest
-- @return[type=string] Eingabe des Spielers
-- @within Anwenderfunktionen
--
function API.GetInputStringFromQuest(_QuestName)
    if GUI then
        API.Fatal("API.GetInputStringFromQuest: Quests can not be checked from local script!");
        return;
    end
    local Quest = Quests[GetQuestID(_QuestName)];
    if not Quest then
        API.Fatal("API.GetInputStringFromQuest: Quest '" ..tostring(_QuestName).. "' not found!");
        return;
    end
    return BundleClassicBehaviors.Global:GetInputFromQuest(_QuestName);
end

---
-- Gibt das im Quest gespeicherte Resultat von Goal_InputDialog Als Zahl zurück.
--
-- &#x3C;b&#x3E;Hinweis&#x3C;/b&#x3E;: Es wird nur die letzte Eingabe zurückgegeben.
--
-- @param[type=string] _QuestName Name des Quest
-- @return[type=number] Eingabe des Spielers
-- @within Anwenderfunktionen
--
function API.GetInputNumberFromQuest(_QuestName)
    return tonumber(API.GetInputStringFromQuest(_QuestName));
end

-- -------------------------------------------------------------------------- --
-- Goals                                                                      --
-- -------------------------------------------------------------------------- --

---
-- Ein Interaktives Objekt muss benutzt werden.
--
-- @param _ScriptName Skriptname des interaktiven Objektes
--
-- @within Goal
--
function Goal_ActivateObject(...)
    return b_Goal_ActivateObject:new(...);
end

b_Goal_ActivateObject = {
    Name = "Goal_ActivateObject",
    Description = {
        en = "Goal: Activate an interactive object",
        de = "Ziel: Aktiviere ein interaktives Objekt",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Object name", de = "Skriptname" },
    },
}

function b_Goal_ActivateObject:GetGoalTable()
    return {Objective.Object, { self.ScriptName } }
end

function b_Goal_ActivateObject:AddParameter(_Index, _Parameter)
   if _Index == 0 then
        self.ScriptName = _Parameter
   end
end

function b_Goal_ActivateObject:GetMsgKey()
    return "Quest_Object_Activate"
end

Core:RegisterBehavior(b_Goal_ActivateObject);

-- -------------------------------------------------------------------------- --

---
-- Einem Spieler müssen Rohstoffe oder Waren gesendet werden.
--
-- In der Regel wird zum Auftraggeber gesendet. Es ist aber möglich auch zu
-- einem anderen Zielspieler schicken zu lassen. Wird ein Wagen gefangen
-- genommen, dann muss erneut geschickt werden. Optional kann dem Spieler
-- auch erlaubt werden, den Karren zurückzuerobern.
--
-- @param _GoodType      Typ der Ware
-- @param _GoodAmount    Menga der Ware
-- @param _OtherTarget   Anderes Ziel als Auftraggeber
-- @param _IgnoreCapture Wagen kann zurückerobert werden
--
-- @within Goal
--
function Goal_Deliver(...)
    return b_Goal_Deliver:new(...)
end

b_Goal_Deliver = {
    Name = "Goal_Deliver",
    Description = {
        en = "Goal: Deliver goods to quest giver or to another player.",
        de = "Ziel: Liefere Waren zum Auftraggeber oder zu einem anderen Spieler.",
    },
    Parameter = {
        { ParameterType.Custom, en = "Type of good", de = "Ressourcentyp" },
        { ParameterType.Number, en = "Amount of good", de = "Ressourcenmenge" },
        { ParameterType.Custom, en = "To different player", de = "Anderer Empfänger" },
        { ParameterType.Custom, en = "Ignore capture", de = "Abfangen ignorieren" },
    },
}


function b_Goal_Deliver:GetGoalTable()
    local GoodType = Logic.GetGoodTypeID(self.GoodTypeName)
    return { Objective.Deliver, GoodType, self.GoodAmount, self.OverrideTarget, self.IgnoreCapture }
end

function b_Goal_Deliver:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.GoodTypeName = _Parameter
    elseif (_Index == 1) then
        self.GoodAmount = _Parameter * 1
    elseif (_Index == 2) then
        self.OverrideTarget = tonumber(_Parameter)
    elseif (_Index == 3) then
        self.IgnoreCapture = AcceptAlternativeBoolean(_Parameter)
    end
end

function b_Goal_Deliver:GetCustomData( _Index )
    local Data = {}
    if _Index == 0 then
        for k, v in pairs( Goods ) do
            if string.find( k, "^G_" ) then
                table.insert( Data, k )
            end
        end
        table.sort( Data )
    elseif _Index == 2 then
        table.insert( Data, "-" )
        for i = 1, 8 do
            table.insert( Data, i )
        end
    elseif _Index == 3 then
        table.insert( Data, "true" )
        table.insert( Data, "false" )
    else
        assert( false )
    end
    return Data
end

function b_Goal_Deliver:GetMsgKey()
    local GoodType = Logic.GetGoodTypeID(self.GoodTypeName)
    local GC = Logic.GetGoodCategoryForGoodType( GoodType )

    local tMapping = {
        [GoodCategories.GC_Clothes] = "Quest_Deliver_GC_Clothes",
        [GoodCategories.GC_Entertainment] = "Quest_Deliver_GC_Entertainment",
        [GoodCategories.GC_Food] = "Quest_Deliver_GC_Food",
        [GoodCategories.GC_Gold] = "Quest_Deliver_GC_Gold",
        [GoodCategories.GC_Hygiene] = "Quest_Deliver_GC_Hygiene",
        [GoodCategories.GC_Medicine] = "Quest_Deliver_GC_Medicine",
        [GoodCategories.GC_Water] = "Quest_Deliver_GC_Water",
        [GoodCategories.GC_Weapon] = "Quest_Deliver_GC_Weapon",
        [GoodCategories.GC_Resource] = "Quest_Deliver_Resources",
    }

    if GC then
        local Key = tMapping[GC]
        if Key then
            return Key
        end
    end
    return "Quest_Deliver_Goods"
end

Core:RegisterBehavior(b_Goal_Deliver);

-- -------------------------------------------------------------------------- --

---
-- Es muss ein bestimmter Diplomatiestatus zu einer anderen Patei erreicht
-- werden. Der Status kann eine Verbesserung oder eine Verschlechterung zum
-- aktuellen Status sein.
--
-- @param _PlayerID Partei, die Entdeckt werden muss
-- @param _State    Diplomatiestatus
--
-- @within Goal
--
function Goal_Diplomacy(...)
    return b_Goal_Diplomacy:new(...);
end

b_Goal_Diplomacy = {
    Name = "Goal_Diplomacy",
    Description = {
        en = "Goal: A diplomatic state must b reached. Can be lower than current state or higher.",
        de = "Ziel: Die Beziehungen zu einem Spieler müssen entweder verbessert oder verschlechtert werden.",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Party", de = "Partei" },
        { ParameterType.Custom,   en = "Diplomacy state", de = "Diplomatische Beziehung" },
        { ParameterType.Custom,   en = "Relation", de = "Relation" },
    },
    DiploNameMap = {
        [DiplomacyStates.Allied]             = {de = "Verbündeter",    en = "Allied"},
        [DiplomacyStates.TradeContact]       = {de = "Handelspartner", en = "Trade Contact"},
        [DiplomacyStates.EstablishedContact] = {de = "Bekannt",        en = "Established Contact"},
        [DiplomacyStates.Undecided]          = {de = "Unbekannt",      en = "Undecided"},
        [DiplomacyStates.Enemy]              = {de = "Feind",          en = "Enemy"},
    },
    TextPattern = {
        de = "DIPLOMATIESTATUS ERREICHEN {cr}{cr}Status: s{cr}Zur Partei: s",
        en = "DIPLOMATIC STATE {cr}{cr}State: s{cr}To player: s",
    },
}

function b_Goal_Diplomacy:GetGoalTable()
    return { Objective.Custom2, {self, self.CustomFunction}};
end

function b_Goal_Diplomacy:ChangeCaption(_Quest)
    local PlayerName = GetPlayerName(self.PlayerID) or "";
    local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";
    local Text = string.format(self.TextPattern[lang], self.DiploNameMap[self.DiplState][lang], PlayerName);
    Core:ChangeCustomQuestCaptionText(Text, _Quest);
end

function b_Goal_Diplomacy:CustomFunction(_Quest)
    self:ChangeCaption(_Quest);
    if self.BeSmallerThan then
        if GetDiplomacyState(_Quest.ReceivingPlayer, self.PlayerID) &#x3C; self.DiplState then
            return true;
        end
    else
        if GetDiplomacyState(_Quest.ReceivingPlayer, self.PlayerID) &#x3E;= self.DiplState then
            return true;
        end
    end
end

function b_Goal_Diplomacy:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.DiplState = DiplomacyStates[_Parameter];
    elseif (_Index == 2) then
        self.BeSmallerThan = _Parameter == "&#x3C;";
    end
end

function b_Goal_Diplomacy:GetIcon()
    return {6, 3};
end

function b_Goal_Diplomacy:GetCustomData(_Index)
    if _Index == 1 then
        return {"Allied", "TradeContact", "EstablishedContact", "Undecided", "Enemy"};
    elseif _Index == 2 then
        return {"&#x3E;=", "&#x3C;"};
    end
end

Core:RegisterBehavior(b_Goal_Diplomacy);

-- -------------------------------------------------------------------------- --

---
-- Das Heimatterritorium des Spielers muss entdeckt werden.
--
-- Das Heimatterritorium ist immer das, wo sich Burg oder Lagerhaus der
-- zu entdeckenden Partei befinden.
--
-- @param _PlayerID ID der zu entdeckenden Partei
--
-- @within Goal
--
function Goal_DiscoverPlayer(...)
    return b_Goal_DiscoverPlayer:new(...);
end

b_Goal_DiscoverPlayer = {
    Name = "Goal_DiscoverPlayer",
    Description = {
        en = "Goal: Discover the home territory of another player.",
        de = "Ziel: Entdecke das Heimatterritorium eines Spielers.",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Player", de = "Spieler" },
    },
}

function b_Goal_DiscoverPlayer:GetGoalTable()
    return {Objective.Discover, 2, { self.PlayerID } }
end

function b_Goal_DiscoverPlayer:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    end
end

function b_Goal_DiscoverPlayer:GetMsgKey()
    local tMapping = {
        [PlayerCategories.BanditsCamp] = "Quest_Discover",
        [PlayerCategories.City] = "Quest_Discover_City",
        [PlayerCategories.Cloister] = "Quest_Discover_Cloister",
        [PlayerCategories.Harbour] = "Quest_Discover",
        [PlayerCategories.Village] = "Quest_Discover_Village",
    }
    local PlayerCategory = GetPlayerCategoryType(self.PlayerID)
    if PlayerCategory then
        local Key = tMapping[PlayerCategory]
        if Key then
            return Key
        end
    end
    return "Quest_Discover"
end

Core:RegisterBehavior(b_Goal_DiscoverPlayer);

-- -------------------------------------------------------------------------- --

---
-- Ein Territorium muss erstmalig vom Auftragnehmer betreten werden.
--
-- Wenn ein Spieler zuvor mit seinen Einheiten auf dem Territorium war, ist
-- es bereits entdeckt und das Ziel sofort erfüllt.
--
-- @param _Territory Name oder ID des Territorium
--
-- @within Goal
--
function Goal_DiscoverTerritory(...)
    return b_Goal_DiscoverTerritory:new(...);
end

b_Goal_DiscoverTerritory = {
    Name = "Goal_DiscoverTerritory",
    Description = {
        en = "Goal: Discover a territory",
        de = "Ziel: Entdecke ein Territorium",
    },
    Parameter = {
        { ParameterType.TerritoryName, en = "Territory", de = "Territorium" },
    },
}

function b_Goal_DiscoverTerritory:GetGoalTable()
    return { Objective.Discover, 1, { self.TerritoryID  } }
end

function b_Goal_DiscoverTerritory:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.TerritoryID = tonumber(_Parameter)
        if not self.TerritoryID then
            self.TerritoryID = GetTerritoryIDByName(_Parameter)
        end
        assert( self.TerritoryID &#x3E; 0 )
    end
end

function b_Goal_DiscoverTerritory:GetMsgKey()
    return "Quest_Discover_Territory"
end

Core:RegisterBehavior(b_Goal_DiscoverTerritory);

-- -------------------------------------------------------------------------- --

---
-- Eine andere Partei muss besiegt werden.
--
-- Die Partei gilt als besiegt, wenn ein Hauptgebäude (Burg, Kirche, Lager)
-- zerstört wurde.
-- 
-- &#x3C;b&#x3E;Achtung:&#x3C;/b&#x3E; Bei Banditen ist dieses Behavior wenig sinnvoll, da sie
-- nicht durch zerstörung ihres Hauptzeltes vernichtet werden. Hier bietet
-- sich Goal_DestroyAllPlayerUnits an.
--
-- @param _PlayerID ID des Spielers
--
-- @within Goal
--
function Goal_DestroyPlayer(...)
    return b_Goal_DestroyPlayer:new(...);
end

b_Goal_DestroyPlayer = {
    Name = "Goal_DestroyPlayer",
    Description = {
        en = "Goal: Destroy a player (destroy a main building)",
        de = "Ziel: Zerstöre einen Spieler (ein Hauptgebäude muss zerstört werden).",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Player", de = "Spieler" },
    },
}

function b_Goal_DestroyPlayer:GetGoalTable()
    assert( self.PlayerID &#x3C;= 8 and self.PlayerID &#x3E;= 1, "Error in " .. self.Name .. ": GetGoalTable: PlayerID is invalid")
    return { Objective.DestroyPlayers, self.PlayerID }
end

function b_Goal_DestroyPlayer:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    end
end

function b_Goal_DestroyPlayer:GetMsgKey()
    local tMapping = {
        [PlayerCategories.BanditsCamp] = "Quest_DestroyPlayers_Bandits",
        [PlayerCategories.City] = "Quest_DestroyPlayers_City",
        [PlayerCategories.Cloister] = "Quest_DestroyPlayers_Cloister",
        [PlayerCategories.Harbour] = "Quest_DestroyEntities_Building",
        [PlayerCategories.Village] = "Quest_DestroyPlayers_Village",
    }

    local PlayerCategory = GetPlayerCategoryType(self.PlayerID)
    if PlayerCategory then
        local Key = tMapping[PlayerCategory]
        if Key then
            return Key
        end
    end
    return "Quest_DestroyEntities_Building"
end

Core:RegisterBehavior(b_Goal_DestroyPlayer)

-- -------------------------------------------------------------------------- --

---
-- Es sollen Informationen aus der Burg gestohlen werden.
--
-- Der Spieler muss einen Dieb entsenden um Informationen aus der Burg zu
-- stehlen. 
--
-- &#x3C;b&#x3E;Achtung:&#x3C;/b&#x3E; Das ist nur bei Feinden möglich!
--
-- @param _PlayerID ID der Partei
--
-- @within Goal
--
function Goal_StealInformation(...)
    return b_Goal_StealInformation:new(...);
end

b_Goal_StealInformation = {
    Name = "Goal_StealInformation",
    Description = {
        en = "Goal: Steal information from another players castle",
        de = "Ziel: Stehle Informationen aus der Burg eines Spielers",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Player", de = "Spieler" },
    },
}

function b_Goal_StealInformation:GetGoalTable()

    local Target = Logic.GetHeadquarters(self.PlayerID)
    if not Target or Target == 0 then
        Target = Logic.GetStoreHouse(self.PlayerID)
    end
    assert( Target and Target ~= 0 )
    return {Objective.Steal, 1, { Target } }

end

function b_Goal_StealInformation:AddParameter(_Index, _Parameter)

    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    end

end

function b_Goal_StealInformation:GetMsgKey()
    return "Quest_Steal_Info"

end

Core:RegisterBehavior(b_Goal_StealInformation);

-- -------------------------------------------------------------------------- --

---
-- Alle Einheiten des Spielers müssen zerstört werden.
--
-- &#x3C;b&#x3E;Achtung&#x3C;/b&#x3E;: Bei normalen Parteien, welche ein Dorf oder eine Stadt
-- besitzen, ist Goal_DestroyPlayer besser geeignet!
--
-- @param _PlayerID ID des Spielers
--
-- @within Goal
--
function Goal_DestroyAllPlayerUnits(...)
    return b_Goal_DestroyAllPlayerUnits:new(...);
end

b_Goal_DestroyAllPlayerUnits = {
    Name = "Goal_DestroyAllPlayerUnits",
    Description = {
        en = "Goal: Destroy all units owned by player (be careful with script entities)",
        de = "Ziel: Zerstöre alle Einheiten eines Spielers (vorsicht mit Script-Entities)",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Player", de = "Spieler" },
    },
}

function b_Goal_DestroyAllPlayerUnits:GetGoalTable()
    return { Objective.DestroyAllPlayerUnits, self.PlayerID }
end

function b_Goal_DestroyAllPlayerUnits:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    end
end

function b_Goal_DestroyAllPlayerUnits:GetMsgKey()
    local tMapping = {
        [PlayerCategories.BanditsCamp] = "Quest_DestroyPlayers_Bandits",
        [PlayerCategories.City] = "Quest_DestroyPlayers_City",
        [PlayerCategories.Cloister] = "Quest_DestroyPlayers_Cloister",
        [PlayerCategories.Harbour] = "Quest_DestroyEntities_Building",
        [PlayerCategories.Village] = "Quest_DestroyPlayers_Village",
    }

    local PlayerCategory = GetPlayerCategoryType(self.PlayerID)
    if PlayerCategory then
        local Key = tMapping[PlayerCategory]
        if Key then
            return Key
        end
    end
    return "Quest_DestroyEntities"
end

Core:RegisterBehavior(b_Goal_DestroyAllPlayerUnits);

-- -------------------------------------------------------------------------- --

---
-- Ein benanntes Entity muss zerstört werden.
--
-- Ein Entity gilt als zerstört, wenn es nicht mehr existiert oder während
-- der Laufzeit des Quests seine Entity-ID oder den Besitzer verändert.
--
-- &#x3C;b&#x3E;Achtung&#x3C;/b&#x3E;: Helden können nicht direkt zerstört werden. Bei ihnen
-- genügt es, wenn sie sich "in die Burg zurückziehen".
--
-- @param _ScriptName Skriptname des Ziels
--
-- @within Goal
--
function Goal_DestroyScriptEntity(...)
    return b_Goal_DestroyScriptEntity:new(...);
end

b_Goal_DestroyScriptEntity = {
    Name = "Goal_DestroyScriptEntity",
    Description = {
        en = "Goal: Destroy an entity",
        de = "Ziel: Zerstöre eine Entität",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script name", de = "Skriptname" },
    },
}

function b_Goal_DestroyScriptEntity:GetGoalTable()
    return {Objective.DestroyEntities, 1, { self.ScriptName } }
end

function b_Goal_DestroyScriptEntity:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptName = _Parameter
    end
end

function b_Goal_DestroyScriptEntity:GetMsgKey()
    if Logic.IsEntityAlive(self.ScriptName) then
        local ID = GetID(self.ScriptName)
        if ID and ID ~= 0 then
            ID = Logic.GetEntityType( ID )
            if ID and ID ~= 0 then
                if Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableBuilding ) == 1 then
                    return "Quest_DestroyEntities_Building"

                elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableAnimal ) == 1 then
                    return "Quest_DestroyEntities_Predators"

                elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.Hero ) == 1 then
                    return "Quest_Destroy_Leader"

                elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.Military ) == 1
                    or Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableSettler ) == 1
                    or Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableMerchant ) == 1  then

                    return "Quest_DestroyEntities_Unit"
                end
            end
        end
    end
    return "Quest_DestroyEntities"
end

Core:RegisterBehavior(b_Goal_DestroyScriptEntity);

-- -------------------------------------------------------------------------- --

---
-- Eine Menge an Entities eines Typs müssen zerstört werden.
--
-- &#x3C;b&#x3E;Achtung&#x3C;/b&#x3E;: Wenn Raubtiere zerstört werden sollen, muss Spieler 0
-- als Besitzer angegeben werden.
--
-- @param _EntityType Typ des Entity
-- @param _Amount     Menge an Entities des Typs
-- @param _PlayerID   Besitzer des Entity
--
-- @within Goal
--
function Goal_DestroyType(...)
    return b_Goal_DestroyType:new(...);
end

b_Goal_DestroyType = {
    Name = "Goal_DestroyType",
    Description = {
        en = "Goal: Destroy entity types",
        de = "Ziel: Zerstöre Entitätstypen",
    },
    Parameter = {
        { ParameterType.Custom, en = "Type name", de = "Typbezeichnung" },
        { ParameterType.Number, en = "Amount", de = "Anzahl" },
        { ParameterType.Custom, en = "Player", de = "Spieler" },
    },
}

function b_Goal_DestroyType:GetGoalTable()
    return {Objective.DestroyEntities, 2, Entities[self.EntityName], self.Amount, self.PlayerID }
end

function b_Goal_DestroyType:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.EntityName = _Parameter
    elseif (_Index == 1) then
        self.Amount = _Parameter * 1
        self.DestroyTypeAmount = self.Amount
    elseif (_Index == 2) then
        self.PlayerID = _Parameter * 1
    end
end

function b_Goal_DestroyType:GetCustomData( _Index )
    local Data = {}
    if _Index == 0 then
        for k, v in pairs( Entities ) do
            if string.find( k, "^[ABU]_" ) then
                table.insert( Data, k )
            end
        end
        table.sort( Data )
    elseif _Index == 2 then
        for i = 0, 8 do
            table.insert( Data, i )
        end
    else
        assert( false )
    end
    return Data
end

function b_Goal_DestroyType:GetMsgKey()
    local ID = self.EntityName
    if Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableBuilding ) == 1 then
        return "Quest_DestroyEntities_Building"

    elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableAnimal ) == 1 then
        return "Quest_DestroyEntities_Predators"

    elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.Hero ) == 1 then
        return "Quest_Destroy_Leader"

    elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.Military ) == 1
        or Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableSettler ) == 1
        or Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableMerchant ) == 1  then

        return "Quest_DestroyEntities_Unit"
    end
    return "Quest_DestroyEntities"
end

Core:RegisterBehavior(b_Goal_DestroyType);

-- -------------------------------------------------------------------------- --

do
    GameCallback_EntityKilled_Orig_QSB_Goal_DestroySoldiers = GameCallback_EntityKilled;
    GameCallback_EntityKilled = function(_AttackedEntityID, _AttackedPlayerID, _AttackingEntityID, _AttackingPlayerID, _AttackedEntityType, _AttackingEntityType)
        if _AttackedPlayerID ~= 0 and _AttackingPlayerID ~= 0 then
            QSB.DestroyedSoldiers[_AttackingPlayerID] = QSB.DestroyedSoldiers[_AttackingPlayerID] or {}
            QSB.DestroyedSoldiers[_AttackingPlayerID][_AttackedPlayerID] = QSB.DestroyedSoldiers[_AttackingPlayerID][_AttackedPlayerID] or 0
            if Logic.IsEntityTypeInCategory( _AttackedEntityType, EntityCategories.Military ) == 1
            and Logic.IsEntityInCategory( _AttackedEntityID, EntityCategories.HeavyWeapon) == 0 then
                QSB.DestroyedSoldiers[_AttackingPlayerID][_AttackedPlayerID] = QSB.DestroyedSoldiers[_AttackingPlayerID][_AttackedPlayerID] +1
            end
        end
        GameCallback_EntityKilled_Orig_QSB_Goal_DestroySoldiers(_AttackedEntityID, _AttackedPlayerID, _AttackingEntityID, _AttackingPlayerID, _AttackedEntityType, _AttackingEntityType)
    end
end

---
-- Ein beliebiger Spieler muss Soldaten eines anderen Spielers zerstören.
--
-- Dieses Behavior kann auch in versteckten Quests bentutzt werden, wenn die
-- Menge an zerstörten Soldaten durch einen Feind des Spielers gefragt ist.
--
-- @param _PlayerA Angreifende Partei
-- @param _PlayerB Zielpartei
-- @param _Amount Menga an Soldaten
--
-- @within Goal
--
function Goal_DestroySoldiers(...)
    return b_Goal_DestroySoldiers:new(...);
end

b_Goal_DestroySoldiers = {
    Name = "Goal_DestroySoldiers",
    Description = {
        en = "Goal: Destroy a given amount of enemy soldiers",
        de = "Ziel: Zerstöre eine Anzahl gegnerischer Soldaten",
                },
    Parameter = {
        {ParameterType.PlayerID, en = "Attacking Player", de = "Angreifer", },
        {ParameterType.PlayerID, en = "Defending Player", de = "Verteidiger", },
        {ParameterType.Number, en = "Amount", de = "Anzahl", },
    },
}

function b_Goal_DestroySoldiers:GetGoalTable()
    return {Objective.Custom2, {self, self.CustomFunction} }
end

function b_Goal_DestroySoldiers:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.AttackingPlayer = _Parameter * 1
    elseif (_Index == 1) then
        self.AttackedPlayer = _Parameter * 1
    elseif (_Index == 2) then
        self.KillsNeeded = _Parameter * 1
    end
end

function b_Goal_DestroySoldiers:CustomFunction(_Quest)
    if not _Quest.QuestDescription or _Quest.QuestDescription == "" then
        local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en"
        local caption = (lang == "de" and "SOLDATEN ZERSTÖREN {cr}{cr}von der Partei: ") or
                         "DESTROY SOLDIERS {cr}{cr}from faction: "
        local amount  = (lang == "de" and "Anzahl: ") or "Amount: "
        local party = GetPlayerName(self.AttackedPlayer) or "";
        local text = "{center}" .. caption .. party .. "{cr}{cr}" .. amount .. " "..self.KillsNeeded;
        Core:ChangeCustomQuestCaptionText(text, _Quest);
    end

    local currentKills = 0;
    if QSB.DestroyedSoldiers[self.AttackingPlayer] and QSB.DestroyedSoldiers[self.AttackingPlayer][self.AttackedPlayer] then
        currentKills = QSB.DestroyedSoldiers[self.AttackingPlayer][self.AttackedPlayer]
    end
    self.SaveAmount = self.SaveAmount or currentKills
    return self.KillsNeeded &#x3C;= currentKills - self.SaveAmount or nil
end

function b_Goal_DestroySoldiers:Debug(_Quest)
    if Logic.GetStoreHouse(self.AttackingPlayer) == 0 then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": Player " .. self.AttackinPlayer .. " is dead :-(")
        return true
    elseif Logic.GetStoreHouse(self.AttackedPlayer) == 0 then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": Player " .. self.AttackedPlayer .. " is dead :-(")
        return true
    elseif self.KillsNeeded &#x3C; 0 then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": Amount negative")
        return true
    end
end

function b_Goal_DestroySoldiers:GetIcon()
    return {7,12}
end

function b_Goal_DestroySoldiers:Reset()
    self.SaveAmount = nil
end

Core:RegisterBehavior(b_Goal_DestroySoldiers)

---
-- Eine Entfernung zwischen zwei Entities muss erreicht werden.
--
-- Je nach angegebener Relation muss die Entfernung unter- oder überschritten
-- werden, um den Quest zu gewinnen.
--
-- @param _ScriptName1  Erstes Entity
-- @param _ScriptName2  Zweites Entity
-- @param _Relation     Relation
-- @param _Distance     Entfernung
--
-- @within Goal
--
function Goal_EntityDistance(...)
    return b_Goal_EntityDistance:new(...);
end

b_Goal_EntityDistance = {
    Name = "Goal_EntityDistance",
    Description = {
        en = "Goal: Distance between two entities",
        de = "Ziel: Zwei Entities sollen zueinander eine Entfernung über- oder unterschreiten.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Entity 1", de = "Entity 1" },
        { ParameterType.ScriptName, en = "Entity 2", de = "Entity 2" },
        { ParameterType.Custom, en = "Relation", de = "Relation" },
        { ParameterType.Number, en = "Distance", de = "Entfernung" },
    },
}

function b_Goal_EntityDistance:GetGoalTable()
    return { Objective.Custom2, {self, self.CustomFunction} }
end

function b_Goal_EntityDistance:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Entity1 = _Parameter
    elseif (_Index == 1) then
        self.Entity2 = _Parameter
    elseif (_Index == 2) then
        self.bRelSmallerThan = _Parameter == "&#x3C;"
    elseif (_Index == 3) then
        self.Distance = _Parameter * 1
    end
end

function b_Goal_EntityDistance:CustomFunction(_Quest)
    if Logic.IsEntityDestroyed( self.Entity1 ) or Logic.IsEntityDestroyed( self.Entity2 ) then
        return false
    end
    local ID1 = GetID( self.Entity1 )
    local ID2 = GetID( self.Entity2 )
    local InRange = Logic.CheckEntitiesDistance( ID1, ID2, self.Distance )
    if ( self.bRelSmallerThan and InRange ) or ( not self.bRelSmallerThan and not InRange ) then
        return true
    end
end

function b_Goal_EntityDistance:GetCustomData( _Index )
    local Data = {}
    if _Index == 2 then
        table.insert( Data, "&#x3E;" )
        table.insert( Data, "&#x3C;" )
    else
        assert( false )
    end
    return Data
end

function b_Goal_EntityDistance:Debug(_Quest)
    if not IsExisting(self.Entity1) or not IsExisting(self.Entity2) then
        fatal("".._Quest.Identifier.." "..self.Name..": At least 1 of the entities for distance check don't exist!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Goal_EntityDistance);

-- -------------------------------------------------------------------------- --

---
-- Der Primary Knight des angegebenen Spielers muss sich dem Ziel nähern.
--
-- Die Distanz ist auf 2500 festgelegt. Es wird immer ein Marker genutzt.
--
-- @param _PlayerID   PlayerID des Helden
-- @param _ScriptName Skriptname des Ziels
--
-- @within Goal
--
function Goal_KnightDistance(...)
    return b_Goal_KnightDistance:new(...);
end

b_Goal_KnightDistance = {
    Name = "Goal_KnightDistance",
    Description = {
        en = "Goal: Bring the knight close to a given entity",
        de = "Ziel: Bringe den Ritter nah an eine bestimmte Entität",
    },
    Parameter = {
        { ParameterType.PlayerID,     en = "Player", de = "Spieler" },
        { ParameterType.ScriptName, en = "Target", de = "Ziel" },
    },
}

function b_Goal_KnightDistance:GetGoalTable()
    return {Objective.Distance, Logic.GetKnightID(self.PlayerID), self.Target, 2500, true}
end

function b_Goal_KnightDistance:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.Target = _Parameter
    end
end

Core:RegisterBehavior(b_Goal_KnightDistance);

---
-- Eine bestimmte Anzahl an Einheiten einer Kategorie muss sich auf dem
-- Territorium befinden.
--
-- Es kann entweder gefordert werden, weniger als die angegebene Menge auf
-- dem Territorium zu haben (z.B. "&#x3C;"" 1 für 0) oder mindestens so
-- viele Entities (z.B. "&#x3E;=" 5 für mindestens 5).
--
-- @param _Territory  TerritoryID oder TerritoryName
-- @param _PlayerID   PlayerID der Einheiten
-- @param _Category   Kategorie der Einheiten
-- @param _Relation   Mengenrelation (&#x3C; oder &#x3E;=)
-- @param _Amount     Menge an Einheiten
--
-- @within Goal
--
function Goal_UnitsOnTerritory(...)
    return b_Goal_UnitsOnTerritory:new(...);
end

b_Goal_UnitsOnTerritory = {
    Name = "Goal_UnitsOnTerritory",
    Description = {
        en = "Goal: Place a certain amount of units on a territory",
        de = "Ziel: Platziere eine bestimmte Anzahl Einheiten auf einem Gebiet",
    },
    Parameter = {
        { ParameterType.TerritoryNameWithUnknown, en = "Territory", de = "Territorium" },
        { ParameterType.Custom,  en = "Player", de = "Spieler" },
        { ParameterType.Custom,  en = "Category", de = "Kategorie" },
        { ParameterType.Custom,  en = "Relation", de = "Relation" },
        { ParameterType.Number,  en = "Number of units", de = "Anzahl Einheiten" },
    },
}

function b_Goal_UnitsOnTerritory:GetGoalTable()
    return { Objective.Custom2, {self, self.CustomFunction} }
end

function b_Goal_UnitsOnTerritory:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.TerritoryID = tonumber(_Parameter)
        if self.TerritoryID == nil then
            self.TerritoryID = GetTerritoryIDByName(_Parameter)
        end
    elseif (_Index == 1) then
        self.PlayerID = tonumber(_Parameter) * 1
    elseif (_Index == 2) then
        self.Category = _Parameter
    elseif (_Index == 3) then
        self.bRelSmallerThan = (tostring(_Parameter) == "true" or tostring(_Parameter) == "&#x3C;")
    elseif (_Index == 4) then
        self.NumberOfUnits = _Parameter * 1
    end
end

function b_Goal_UnitsOnTerritory:CustomFunction(_Quest)
    local Units = GetEntitiesOfCategoryInTerritory(self.PlayerID, EntityCategories[self.Category], self.TerritoryID);
    if self.bRelSmallerThan == false and #Units &#x3E;= self.NumberOfUnits then
        return true;
    elseif self.bRelSmallerThan == true and #Units &#x3C; self.NumberOfUnits then
        return true;
    end
end

function b_Goal_UnitsOnTerritory:GetCustomData( _Index )
    local Data = {}
    if _Index == 1 then
        table.insert( Data, -1 )
        for i = 1, 8 do
            table.insert( Data, i )
        end
    elseif _Index == 2 then
        for k, v in pairs( EntityCategories ) do
            if not string.find( k, "^G_" ) and k ~= "SheepPasture" then
                table.insert( Data, k )
            end
        end
        table.sort( Data );
    elseif _Index == 3 then
        table.insert( Data, "&#x3E;=" )
        table.insert( Data, "&#x3C;" )
    else
        assert( false )
    end
    return Data
end

function b_Goal_UnitsOnTerritory:Debug(_Quest)
    local territories = {Logic.GetTerritories()}
    if tonumber(self.TerritoryID) == nil or self.TerritoryID &#x3C; 0 or not Inside(self.TerritoryID,territories) then
        fatal("".._Quest.Identifier.." "..self.Name..": got an invalid territoryID!");
        return true;
    elseif tonumber(self.PlayerID) == nil or self.PlayerID &#x3C; 0 or self.PlayerID &#x3E; 8 then
        fatal("".._Quest.Identifier.." "..self.Name..": got an invalid playerID!");
        return true;
    elseif not EntityCategories[self.Category] then
        fatal("".._Quest.Identifier.." "..self.Name..": got an invalid entity category!");
        return true;
    elseif tonumber(self.NumberOfUnits) == nil or self.NumberOfUnits &#x3C; 0 then
        fatal("".._Quest.Identifier.." "..self.Name..": amount is negative or nil!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Goal_UnitsOnTerritory);

-- -------------------------------------------------------------------------- --

---
-- Der angegebene Spieler muss einen Buff aktivieren.
--
-- &#x3C;u&#x3E;Buffs "Aufstieg eines Königreich"&#x3C;/u&#x3E;
-- &#x3C;li&#x3E;Buff_Spice: Salz&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;Buff_Colour: Farben&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;Buff_Entertainers: Entertainer anheuern&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;Buff_FoodDiversity: Vielfältige Nahrung&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;Buff_ClothesDiversity: Vielfältige Kleidung&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;Buff_HygieneDiversity: Vielfältige Hygiene&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;Buff_EntertainmentDiversity: Vielfältige Unterhaltung&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;Buff_Sermon: Predigt halten&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;Buff_Festival: Fest veranstalten&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;Buff_ExtraPayment: Bonussold auszahlen&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;Buff_HighTaxes: Hohe Steuern verlangen&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;Buff_NoPayment: Sold streichen&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;Buff_NoTaxes: Keine Steuern verlangen&#x3C;/li&#x3E;
-- &#x3C;br/&#x3E;
-- &#x3C;u&#x3E;Buffs "Reich des Ostens"&#x3C;/u&#x3E;
-- &#x3C;li&#x3E;Buff_Gems: Edelsteine&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;Buff_MusicalInstrument: Musikinstrumente&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;Buff_Olibanum: Weihrauch&#x3C;/li&#x3E;
--
-- @param _PlayerID Spieler, der den Buff aktivieren muss
-- @param _Buff     Buff, der aktiviert werden soll
--
-- @within Goal
--
function Goal_ActivateBuff(...)
    return b_Goal_ActivateBuff:new(...);
end

b_Goal_ActivateBuff = {
    Name = "Goal_ActivateBuff",
    Description = {
        en = "Goal: Activate a buff",
        de = "Ziel: Aktiviere einen Buff",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Player", de = "Spieler" },
        { ParameterType.Custom, en = "Buff", de = "Buff" },
    },
}

function b_Goal_ActivateBuff:GetGoalTable()
    return { Objective.Custom2, {self, self.CustomFunction} }
end

function b_Goal_ActivateBuff:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.BuffName = _Parameter
        self.Buff = Buffs[_Parameter]
    end
end

function b_Goal_ActivateBuff:CustomFunction(_Quest)
   if not _Quest.QuestDescription or _Quest.QuestDescription == "" then
        local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en"
        local caption = (lang == "de" and "BONUS AKTIVIEREN{cr}{cr}") or "ACTIVATE BUFF{cr}{cr}"

        local tMapping = {
            ["Buff_Spice"]                        = {de = "Salz", en = "Salt"},
            ["Buff_Colour"]                        = {de = "Farben", en = "Color"},
            ["Buff_Entertainers"]                = {de = "Entertainer", en = "Entertainer"},
            ["Buff_FoodDiversity"]                = {de = "Vielfältige Nahrung", en = "Food diversity"},
            ["Buff_ClothesDiversity"]            = {de = "Vielfältige Kleidung", en = "Clothes diversity"},
            ["Buff_HygieneDiversity"]            = {de = "Vielfältige Reinigung", en = "Hygiene diversity"},
            ["Buff_EntertainmentDiversity"]        = {de = "Vielfältige Unterhaltung", en = "Entertainment diversity"},
            ["Buff_Sermon"]                        = {de = "Predigt", en = "Sermon"},
            ["Buff_Festival"]                    = {de = "Fest", en = "Festival"},
            ["Buff_ExtraPayment"]                = {de = "Sonderzahlung", en = "Extra payment"},
            ["Buff_HighTaxes"]                    = {de = "Hohe Steuern", en = "High taxes"},
            ["Buff_NoPayment"]                    = {de = "Kein Sold", en = "No payment"},
            ["Buff_NoTaxes"]                    = {de = "Keine Steuern", en = "No taxes"},
        }

        if g_GameExtraNo &#x3E;= 1 then
            tMapping["Buff_Gems"]                = {de = "Edelsteine", en = "Gems"}
            tMapping["Buff_MusicalInstrument"]  = {de = "Musikinstrumente", en = "Musical instruments"}
            tMapping["Buff_Olibanum"]            = {de = "Weihrauch", en = "Olibanum"}
        end

        local text = "{center}" .. caption .. tMapping[self.BuffName][lang]
        Core:ChangeCustomQuestCaptionText(text, _Quest)
    end

    local Buff = Logic.GetBuff( self.PlayerID, self.Buff )
    if Buff and Buff ~= 0 then
        return true
    end
end

function b_Goal_ActivateBuff:GetCustomData( _Index )
    local Data = {}
    if _Index == 1 then
        Data = {
            "Buff_Spice",
            "Buff_Colour",
            "Buff_Entertainers",
            "Buff_FoodDiversity",
            "Buff_ClothesDiversity",
            "Buff_HygieneDiversity",
            "Buff_EntertainmentDiversity",
            "Buff_Sermon",
            "Buff_Festival",
            "Buff_ExtraPayment",
            "Buff_HighTaxes",
            "Buff_NoPayment",
            "Buff_NoTaxes"
        }

        if g_GameExtraNo &#x3E;= 1 then
            table.insert(Data, "Buff_Gems")
            table.insert(Data, "Buff_MusicalInstrument")
            table.insert(Data, "Buff_Olibanum")
        end

        table.sort( Data )
    else
        assert( false )
    end
    return Data
end

function b_Goal_ActivateBuff:GetIcon()
    local tMapping = {
        [Buffs.Buff_Spice] = "Goods.G_Salt",
        [Buffs.Buff_Colour] = "Goods.G_Dye",
        [Buffs.Buff_Entertainers] = "Entities.U_Entertainer_NA_FireEater", --{5, 12},
        [Buffs.Buff_FoodDiversity] = "Needs.Nutrition", --{1, 1},
        [Buffs.Buff_ClothesDiversity] = "Needs.Clothes", --{1, 2},
        [Buffs.Buff_HygieneDiversity] = "Needs.Hygiene", --{16, 1},
        [Buffs.Buff_EntertainmentDiversity] = "Needs.Entertainment", --{1, 4},
        [Buffs.Buff_Sermon] = "Technologies.R_Sermon", --{4, 14},
        [Buffs.Buff_Festival] = "Technologies.R_Festival", --{4, 15},
        [Buffs.Buff_ExtraPayment]    = {1,8},
        [Buffs.Buff_HighTaxes] = {1,6},
        [Buffs.Buff_NoPayment] = {1,8},
        [Buffs.Buff_NoTaxes]    = {1,6},
    }
    if g_GameExtraNo and g_GameExtraNo &#x3E;= 1 then
        tMapping[Buffs.Buff_Gems] = "Goods.G_Gems"
        tMapping[Buffs.Buff_MusicalInstrument] = "Goods.G_MusicalInstrument"
        tMapping[Buffs.Buff_Olibanum] = "Goods.G_Olibanum"
    end
    return tMapping[self.Buff]
end

function b_Goal_ActivateBuff:Debug(_Quest)
    if not self.Buff then
        fatal("".._Quest.Identifier.." "..self.Name..": buff '" ..self.BuffName.. "' does not exist!");
        return true;
    elseif not tonumber(self.PlayerID) or self.PlayerID &#x3C; 1 or self.PlayerID &#x3E; 8 then
        fatal("".._Quest.Identifier.." "..self.Name..": got an invalid playerID!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Goal_ActivateBuff);

-- -------------------------------------------------------------------------- --

---
-- Zwei Punkte auf der Spielwelt müssen mit einer Straße verbunden werden.
--
-- @param _Position1 Erster Endpunkt der Straße
-- @param _Position2 Zweiter Endpunkt der Straße
-- @param _OnlyRoads Keine Wege akzeptieren
--
-- @within Goal
--
function Goal_BuildRoad(...)
    return b_Goal_BuildRoad:new(...)
end

b_Goal_BuildRoad = {
    Name = "Goal_BuildRoad",
    Description = {
        en = "Goal: Connect two points with a street or a road",
        de = "Ziel: Verbinde zwei Punkte mit einer Strasse oder einem Weg.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Entity 1",     de = "Entity 1" },
        { ParameterType.ScriptName, en = "Entity 2",     de = "Entity 2" },
        { ParameterType.Custom,     en = "Only roads",     de = "Nur Strassen" },
    },
}

function b_Goal_BuildRoad:GetGoalTable()
    -- {BehaviorType, {EntityID1, EntityID2, BeSmalerThan, Length, RoadsOnly}}
    -- -&#x3E; Length wird nicht mehr benutzt. Sorgte für Promleme im Spiel
    return { Objective.BuildRoad, { GetID( self.Entity1 ), GetID( self.Entity2 ), false, 0, self.bRoadsOnly } }
end

function b_Goal_BuildRoad:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Entity1 = _Parameter
    elseif (_Index == 1) then
        self.Entity2 = _Parameter
    elseif (_Index == 2) then
        self.bRoadsOnly = AcceptAlternativeBoolean(_Parameter)
    end
end

function b_Goal_BuildRoad:GetCustomData( _Index )
    local Data
    if _Index == 2 then
        Data = {"true","false"}
    end
    return Data
end

function b_Goal_BuildRoad:Debug(_Quest)
    if not IsExisting(self.Entity1) or not IsExisting(self.Entity2) then
        fatal("".._Quest.Identifier.." "..self.Name..": first or second entity does not exist!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Goal_BuildRoad);

-- -------------------------------------------------------------------------- --


---
-- Eine Mauer muss gebaut werden um die Bewegung eines Spielers einzuschränken.
-- 
-- Einschränken bedeutet, dass sich der angegebene Spieler nicht von Punkt A
-- nach Punkt B bewegen kann, weil eine Mauer im Weg ist. Die Punkte sind
-- frei wählbar. In den meisten Fällen reicht es, Marktplätze anzugeben.
--
-- Beispiel: Spieler 3 ist der Feind von Spieler 1, aber Bekannt mit Spieler 2.
-- Wenn er sich nicht mehr zwischen den Marktplätzen von Spieler 1 und 2
-- bewegen kann, weil eine Mauer dazwischen ist, ist das Ziel erreicht.
--
-- &#x3C;b&#x3E;Achtung:&#x3C;/b&#x3E; Bei Monsun kann dieses Ziel fälschlicher Weise als erfüllt
-- gewertet werden, wenn der Weg durch Wasser blockiert wird!
--
-- @param _PlayerID  PlayerID, die blockiert wird
-- @param _Position1 Erste Position
-- @param _Position2 Zweite Position
--
-- @within Goal
--
function Goal_BuildWall(...)
    return b_Goal_BuildWall:new(...)
end

b_Goal_BuildWall = {
    Name = "Goal_BuildWall",
    Description = {
        en = "Goal: Build a wall between 2 positions bo stop the movement of an (hostile) player.",
        de = "Ziel: Baue eine Mauer zwischen 2 Punkten, die die Bewegung eines (feindlichen) Spielers zwischen den Punkten verhindert.",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Enemy", de = "Feind" },
        { ParameterType.ScriptName, en = "Entity 1", de = "Entity 1" },
        { ParameterType.ScriptName, en = "Entity 2", de = "Entity 2" },
    },
}

function b_Goal_BuildWall:GetGoalTable()
    return { Objective.Custom2, {self, self.CustomFunction} }
end

function b_Goal_BuildWall:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.EntityName1 = _Parameter
    elseif (_Index == 2) then
        self.EntityName2 = _Parameter
    end
end

function b_Goal_BuildWall:CustomFunction(_Quest)
    local eID1 = GetID(self.EntityName1)
    local eID2 = GetID(self.EntityName2)

    if not IsExisting(eID1) then
        return false
    end
    if not IsExisting(eID2) then
        return false
    end
    local x,y,z = Logic.EntityGetPos(eID1)
    if Logic.IsBuilding(eID1) == 1 then
        x,y = Logic.GetBuildingApproachPosition(eID1)
    end
    local Sector1 = Logic.GetPlayerSectorAtPosition(self.PlayerID, x, y)
    local x,y,z = Logic.EntityGetPos(eID2)
    if Logic.IsBuilding(eID2) == 1 then
        x,y = Logic.GetBuildingApproachPosition(eID2)
    end
    local Sector2 = Logic.GetPlayerSectorAtPosition(self.PlayerID, x, y)
    if Sector1 ~= Sector2 then
        return true
    end
    return nil
end

function b_Goal_BuildWall:GetMsgKey()
    return "Quest_Create_Wall"
end

function b_Goal_BuildWall:GetIcon()
    return {3,9}
end

function b_Goal_BuildWall:Debug(_Quest)
    if not IsExisting(self.EntityName1) or not IsExisting(self.EntityName2) then
        fatal("".._Quest.Identifier.." "..self.Name..": first or second entity does not exist!");
        return true;
    elseif not tonumber(self.PlayerID) or self.PlayerID &#x3C; 1 or self.PlayerID &#x3E; 8 then
        fatal("".._Quest.Identifier.." "..self.Name..": got an invalid playerID!");
        return true;
    end

    if GetDiplomacyState(_Quest.ReceivingPlayer, self.PlayerID) &#x3E; -1 and not self.WarningPrinted then
        warn("".._Quest.Identifier.." "..self.Name..": player d is neighter enemy or unknown to quest receiver!");
        self.WarningPrinted = true;
    end
    return false;
end

Core:RegisterBehavior(b_Goal_BuildWall);

-- -------------------------------------------------------------------------- --

---
-- Ein bestimmtes Territorium muss vom Auftragnehmer eingenommen werden.
--
-- @param _Territory Territorium-ID oder Territoriumname
--
-- @within Goal
--
function Goal_Claim(...)
    return b_Goal_Claim:new(...)
end

b_Goal_Claim = {
    Name = "Goal_Claim",
    Description = {
        en = "Goal: Claim a territory",
        de = "Ziel: Erobere ein Territorium",
    },
    Parameter = {
        { ParameterType.TerritoryName, en = "Territory", de = "Territorium" },
    },
}

function b_Goal_Claim:GetGoalTable()
    return { Objective.Claim, 1, self.TerritoryID }
end

function b_Goal_Claim:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.TerritoryID = tonumber(_Parameter)
        if not self.TerritoryID then
            self.TerritoryID = GetTerritoryIDByName(_Parameter)
        end
    end
end

function b_Goal_Claim:GetMsgKey()
    return "Quest_Claim_Territory"
end

Core:RegisterBehavior(b_Goal_Claim);

-- -------------------------------------------------------------------------- --

---
-- Der Auftragnehmer muss eine Menge an Territorien besitzen.
-- Das Heimatterritorium des Spielers wird mitgezählt!
--
-- @param _Amount Anzahl Territorien
--
-- @within Goal
--
function Goal_ClaimXTerritories(...)
    return b_Goal_ClaimXTerritories:new(...)
end

b_Goal_ClaimXTerritories = {
    Name = "Goal_ClaimXTerritories",
    Description = {
        en = "Goal: Claim the given number of territories, all player territories are counted",
        de = "Ziel: Erobere die angegebene Anzahl Territorien, alle spielereigenen Territorien werden gezählt",
    },
    Parameter = {
        { ParameterType.Number, en = "Territories" , de = "Territorien" }
    },
}

function b_Goal_ClaimXTerritories:GetGoalTable()
    return { Objective.Claim, 2, self.TerritoriesToClaim }
end

function b_Goal_ClaimXTerritories:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.TerritoriesToClaim = _Parameter * 1
    end
end

function b_Goal_ClaimXTerritories:GetMsgKey()
    return "Quest_Claim_Territory"
end

Core:RegisterBehavior(b_Goal_ClaimXTerritories);

-- -------------------------------------------------------------------------- --

---
-- Der Auftragnehmer muss auf dem Territorium einen Entitytyp erstellen.
--
-- Dieses Behavior eignet sich für Aufgaben vom Schlag "Baue X Getreidefarmen
-- Auf Territorium &#x3E;".
--
-- @param _Type      Typ des Entity
-- @param _Amount    Menge an Entities
-- @param _Territory Territorium
--
-- @within Goal
--
function Goal_Create(...)
    return b_Goal_Create:new(...);
end

b_Goal_Create = {
    Name = "Goal_Create",
    Description = {
        en = "Goal: Create Buildings/Units on a specified territory",
        de = "Ziel: Erstelle Einheiten/Gebäude auf einem bestimmten Territorium.",
    },
    Parameter = {
        { ParameterType.Entity, en = "Type name", de = "Typbezeichnung" },
        { ParameterType.Number, en = "Amount", de = "Anzahl" },
        { ParameterType.TerritoryNameWithUnknown, en = "Territory", de = "Territorium" },
    },
}

function b_Goal_Create:GetGoalTable()
    return { Objective.Create, assert( Entities[self.EntityName] ), self.Amount, self.TerritoryID  }
end

function b_Goal_Create:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.EntityName = _Parameter
    elseif (_Index == 1) then
        self.Amount = _Parameter * 1
    elseif (_Index == 2) then
        self.TerritoryID = tonumber(_Parameter)
        if not self.TerritoryID then
            self.TerritoryID = GetTerritoryIDByName(_Parameter)
        end
    end
end

function b_Goal_Create:GetMsgKey()
    return Logic.IsEntityTypeInCategory( Entities[self.EntityName], EntityCategories.AttackableBuilding ) == 1 and "Quest_Create_Building" or "Quest_Create_Unit"
end

Core:RegisterBehavior(b_Goal_Create);

-- -------------------------------------------------------------------------- --

---
-- Der Auftragnehmer muss eine Menge von Rohstoffen produzieren.
--
-- @param _Type   Typ des Rohstoffs
-- @param _Amount Menge an Rohstoffen
--
-- @within Goal
--
function Goal_Produce(...)
    return b_Goal_Produce:new(...);
end

b_Goal_Produce = {
    Name = "Goal_Produce",
    Description = {
        en = "Goal: Produce an amount of goods",
        de = "Ziel: Produziere eine Anzahl einer bestimmten Ware.",
    },
    Parameter = {
        { ParameterType.RawGoods, en = "Type of good", de = "Ressourcentyp" },
        { ParameterType.Number, en = "Amount of good", de = "Anzahl der Ressource" },
    },
}

function b_Goal_Produce:GetGoalTable()
    local GoodType = Logic.GetGoodTypeID(self.GoodTypeName)
    return { Objective.Produce, GoodType, self.GoodAmount }
end

function b_Goal_Produce:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.GoodTypeName = _Parameter
    elseif (_Index == 1) then
        self.GoodAmount = _Parameter * 1
    end
end

function b_Goal_Produce:GetMsgKey()
    return "Quest_Produce"
end

Core:RegisterBehavior(b_Goal_Produce);

-- -------------------------------------------------------------------------- --

---
-- Der Spieler muss eine bestimmte Menge einer Ware erreichen.
--
-- @param _Type     Typ der Ware
-- @param _Amount   Menge an Waren
-- @param _Relation Mengenrelation
--
-- @within Goal
--
function Goal_GoodAmount(...)
    return b_Goal_GoodAmount:new(...);
end

b_Goal_GoodAmount = {
    Name = "Goal_GoodAmount",
    Description = {
        en = "Goal: Obtain an amount of goods - either by trading or producing them",
        de = "Ziel: Beschaffe eine Anzahl Waren - entweder durch Handel oder durch eigene Produktion.",
    },
    Parameter = {
        { ParameterType.Custom, en = "Type of good", de = "Warentyp" },
        { ParameterType.Number, en = "Amount", de = "Anzahl" },
        { ParameterType.Custom, en = "Relation", de = "Relation" },
    },
}

function b_Goal_GoodAmount:GetGoalTable()
    local GoodType = Logic.GetGoodTypeID(self.GoodTypeName)
    return { Objective.Produce, GoodType, self.GoodAmount, self.bRelSmallerThan }
end

function b_Goal_GoodAmount:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.GoodTypeName = _Parameter
    elseif (_Index == 1) then
        self.GoodAmount = _Parameter * 1
    elseif  (_Index == 2) then
        self.bRelSmallerThan = _Parameter == "&#x3C;" or tostring(_Parameter) == "true"
    end
end

function b_Goal_GoodAmount:GetCustomData( _Index )
    local Data = {}
    if _Index == 0 then
        for k, v in pairs( Goods ) do
            if string.find( k, "^G_" ) then
                table.insert( Data, k )
            end
        end
        table.sort( Data )
    elseif _Index == 2 then
        table.insert( Data, "&#x3E;=" )
        table.insert( Data, "&#x3C;" )
    else
        assert( false )
    end
    return Data
end

Core:RegisterBehavior(b_Goal_GoodAmount);

-- -------------------------------------------------------------------------- --

---
-- Die Siedler des Spielers dürfen nicht aufgrund des Bedürfnisses streiken.
--
-- &#x3C;u&#x3E;Bedürfnisse&#x3C;/u&#x3E;
-- &#x3C;ul&#x3E;
-- &#x3C;li&#x3E;Clothes: Kleidung&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;Entertainment: Unterhaltung&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;Nutrition: Nahrung&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;Hygiene: Hygiene&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;Medicine: Medizin&#x3C;/li&#x3E;
-- &#x3C;/ul&#x3E;
--
-- @param _PlayerID ID des Spielers
-- @param _Need     Bedürfnis
--
-- @within Goal
--
function Goal_SatisfyNeed(...)
    return b_Goal_SatisfyNeed:new(...);
end

b_Goal_SatisfyNeed = {
    Name = "Goal_SatisfyNeed",
    Description = {
        en = "Goal: Satisfy a need",
        de = "Ziel: Erfuelle ein Beduerfnis",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Player", de = "Spieler" },
        { ParameterType.Need, en = "Need", de = "Beduerfnis" },
    },
}

function b_Goal_SatisfyNeed:GetGoalTable()
    return { Objective.SatisfyNeed, Needs[self.Need], self.PlayerID }

end

function b_Goal_SatisfyNeed:AddParameter(_Index, _Parameter)

    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.Need = _Parameter
    end

end

function b_Goal_SatisfyNeed:GetMsgKey()
    local tMapping = {
        [Needs.Clothes] = "Quest_SatisfyNeed_Clothes",
        [Needs.Entertainment] = "Quest_SatisfyNeed_Entertainment",
        [Needs.Nutrition] = "Quest_SatisfyNeed_Food",
        [Needs.Hygiene] = "Quest_SatisfyNeed_Hygiene",
        [Needs.Medicine] = "Quest_SatisfyNeed_Medicine",
    }

    local Key = tMapping[Needs[self.Need]]
    if Key then
        return Key
    end

    -- No default message
end

Core:RegisterBehavior(b_Goal_SatisfyNeed);

-- -------------------------------------------------------------------------- --

---
-- Der angegebene Spieler muss eine Menge an Siedlern in der Stadt haben.
--
-- @param _Amount   Menge an Siedlern
-- @param _PlayerID ID des Spielers
--
-- @within Goal
--
function Goal_SettlersNumber(...)
    return b_Goal_SettlersNumber:new(...);
end

b_Goal_SettlersNumber = {
    Name = "Goal_SettlersNumber",
    Description = {
        en = "Goal: Get a given amount of settlers",
        de = "Ziel: Erreiche eine bestimmte Anzahl Siedler.",
    },
    Parameter = {
        { ParameterType.Number,   en = "Amount", de = "Anzahl" },
        { ParameterType.PlayerID, en = "Player", de = "Spieler" },
    },
}

function b_Goal_SettlersNumber:GetGoalTable()
    return {Objective.SettlersNumber, self.PlayerID, self.SettlersAmount };
end

function b_Goal_SettlersNumber:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.SettlersAmount = _Parameter * 1;
    elseif (_Index == 1) then
        self.PlayerID = (_Parameter or 1) * 1;
    end
end

function b_Goal_SettlersNumber:GetMsgKey()
    return "Quest_NumberSettlers";
end

Core:RegisterBehavior(b_Goal_SettlersNumber);

-- -------------------------------------------------------------------------- --

---
-- Der Auftragnehmer muss eine Menge von Ehefrauen in der Stadt haben.
--
-- @param _Amount Menge an Ehefrauen
--
-- @within Goal
--
function Goal_Spouses(...)
    return b_Goal_Spouses:new(...);
end

b_Goal_Spouses = {
    Name = "Goal_Spouses",
    Description = {
        en = "Goal: Get a given amount of spouses",
        de = "Ziel: Erreiche eine bestimmte Ehefrauenanzahl",
    },
    Parameter = {
        { ParameterType.Number, en = "Amount", de = "Anzahl" },
    },
}

function b_Goal_Spouses:GetGoalTable()
    return {Objective.Spouses, self.SpousesAmount }
end

function b_Goal_Spouses:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.SpousesAmount = _Parameter * 1
    end
end

function b_Goal_Spouses:GetMsgKey()
    return "Quest_NumberSpouses"
end

Core:RegisterBehavior(b_Goal_Spouses);

-- -------------------------------------------------------------------------- --

---
-- Ein Spieler muss eine Menge an Soldaten haben.
--
-- &#x3C;u&#x3E;Relationen&#x3C;/u&#x3E;
-- &#x3C;ul&#x3E;
-- &#x3C;li&#x3E;&#x3E;= - Anzahl als Mindestmenge&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;&#x3C; - Weniger als Anzahl&#x3C;/li&#x3E;
-- &#x3C;/ul&#x3E;
--
-- Dieses Behavior kann verwendet werden um die Menge an feindlichen
-- Soldaten zu zählen oder die Menge an Soldaten des Spielers.
--
-- @param _PlayerID ID des Spielers
-- @param _Relation Mengenrelation
-- @param _Amount   Menge an Soldaten
--
-- @within Goal
--
function Goal_SoldierCount(...)
    return b_Goal_SoldierCount:new(...);
end

b_Goal_SoldierCount = {
    Name = "Goal_SoldierCount",
    Description = {
        en = "Goal: Create a specified number of soldiers",
        de = "Ziel: Erreiche eine Anzahl grösser oder kleiner der angegebenen Menge Soldaten.",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Player", de = "Spieler" },
        { ParameterType.Custom, en = "Relation", de = "Relation" },
        { ParameterType.Number, en = "Number of soldiers", de = "Anzahl Soldaten" },
    },
}

function b_Goal_SoldierCount:GetGoalTable()
    return { Objective.Custom2, {self, self.CustomFunction} }
end

function b_Goal_SoldierCount:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.bRelSmallerThan = tostring(_Parameter) == "true" or tostring(_Parameter) == "&#x3C;"
    elseif (_Index == 2) then
        self.NumberOfUnits = _Parameter * 1
    end
end

function b_Goal_SoldierCount:CustomFunction(_Quest)
    if not _Quest.QuestDescription or _Quest.QuestDescription == "" then
        local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en"
        local caption = (lang == "de" and "SOLDATENANZAHL {cr}Partei: ") or
                            "SOLDIERS {cr}faction: "
        local relation = tostring(self.bRelSmallerThan);
        local relationText = {
            ["true"]  = {de = "Weniger als", en = "Less than"},
            ["false"] = {de = "Mindestens", en = "At least"},
        };
        local party = GetPlayerName(self.PlayerID) or "";
        local text = "{center}" .. caption .. party .. "{cr}{cr}" .. relationText[relation][lang] .. " "..self.NumberOfUnits;
        Core:ChangeCustomQuestCaptionText(text, _Quest);
    end

    local NumSoldiers = Logic.GetCurrentSoldierCount( self.PlayerID )
    if ( self.bRelSmallerThan and NumSoldiers &#x3C; self.NumberOfUnits ) then
        return true
    elseif ( not self.bRelSmallerThan and NumSoldiers &#x3E;= self.NumberOfUnits ) then
        return true
    end
    return nil
end

function b_Goal_SoldierCount:GetCustomData( _Index )
    local Data = {}
    if _Index == 1 then

        table.insert( Data, "&#x3E;=" )
        table.insert( Data, "&#x3C;" )

    else
        assert( false )
    end
    return Data
end

function b_Goal_SoldierCount:GetIcon()
    return {7,11}
end

function b_Goal_SoldierCount:GetMsgKey()
    return "Quest_Create_Unit"
end

function b_Goal_SoldierCount:Debug(_Quest)
    if tonumber(self.NumberOfUnits) == nil or self.NumberOfUnits &#x3C; 0 then
        fatal("".._Quest.Identifier.." "..self.Name..": amount can not be below 0!");
        return true;
    elseif tonumber(self.PlayerID) == nil or self.PlayerID &#x3C; 1 or self.PlayerID &#x3E; 8 then
        fatal("".._Quest.Identifier.." "..self.Name..": got an invalid playerID!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Goal_SoldierCount);

-- -------------------------------------------------------------------------- --

---
-- Der Auftragnehmer muss wenigstens einen bestimmten Titel erreichen.
--
-- Folgende Titel können verwendet werden:
-- &#x3C;table border="1"&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;&#x3C;b&#x3E;Titel&#x3C;/b&#x3E;&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;&#x3C;b&#x3E;Übersetzung&#x3C;/b&#x3E;&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;Knight&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Ritter&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;Mayor&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Landvogt&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;Baron&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Baron&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;Earl&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Graf&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;Marquees&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Marktgraf&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;Duke&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Herzog&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;Archduke&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Erzherzog&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;table&#x3E;
--
-- @param _Title Titel, der erreicht werden muss
--
-- @within Goal
--
function Goal_KnightTitle(...)
    return b_Goal_KnightTitle:new(...);
end

b_Goal_KnightTitle = {
    Name = "Goal_KnightTitle",
    Description = {
        en = "Goal: Reach a specified knight title",
        de = "Ziel: Erreiche einen vorgegebenen Titel",
    },
    Parameter = {
        { ParameterType.Custom, en = "Knight title", de = "Titel" },
    },
}

function b_Goal_KnightTitle:GetGoalTable()
    return {Objective.KnightTitle, assert( KnightTitles[self.KnightTitle] ) }
end

function b_Goal_KnightTitle:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.KnightTitle = _Parameter
    end
end

function b_Goal_KnightTitle:GetMsgKey()
    return "Quest_KnightTitle"
end

function b_Goal_KnightTitle:GetCustomData( _Index )
    return {"Knight", "Mayor", "Baron", "Earl", "Marquees", "Duke", "Archduke"}
end

Core:RegisterBehavior(b_Goal_KnightTitle);

-- -------------------------------------------------------------------------- --

---
-- Der angegebene Spieler muss mindestens die Menge an Festen feiern.
--
-- Ein Fest wird gewertet, sobald die Metfässer auf dem Markt erscheinen. Diese
-- Metfässer erscheinen im normalen Spielverlauf nur durch ein Fest!
--
-- &#x3C;b&#x3E;Achtung&#x3C;/b&#x3E;: Wenn ein Spieler aus einem anderen Grund Metfässer besitzt,
-- wird dieses Behavior nicht mehr richtig funktionieren!
--
-- @param _PlayerID ID des Spielers
-- @param _Amount   Menge an Festen
--
-- @within Goal
--
function Goal_Festivals(...)
    return b_Goal_Festivals:new(...);
end

b_Goal_Festivals = {
    Name = "Goal_Festivals",
    Description = {
        en = "Goal: The player has to start the given number of festivals.",
        de = "Ziel: Der Spieler muss eine gewisse Anzahl Feste gestartet haben.",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Player", de = "Spieler" },
        { ParameterType.Number, en = "Number of festivals", de = "Anzahl Feste" }
    }
};

function b_Goal_Festivals:GetGoalTable()
    return { Objective.Custom2, {self, self.CustomFunction} };
end

function b_Goal_Festivals:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        self.PlayerID = tonumber(_Parameter);
    else
        assert(_Index == 1, "Error in " .. self.Name .. ": AddParameter: Index is invalid.");
        self.NeededFestivals = tonumber(_Parameter);
    end
end

function b_Goal_Festivals:CustomFunction(_Quest)
    if not _Quest.QuestDescription or _Quest.QuestDescription == "" then
        local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en"
        local caption = (lang == "de" and "FESTE FEIERN {cr}{cr}Partei: ") or
                            "HOLD PARTIES {cr}{cr}faction: "
        local amount  = (lang == "de" and "Anzahl: ") or "Amount: "
        local party = GetPlayerName(self.PlayerID) or "";
        local text = "{center}" .. caption .. party .. "{cr}{cr}" .. amount .. " "..self.NeededFestivals;
        Core:ChangeCustomQuestCaptionText(text, _Quest);
    end

    if Logic.GetStoreHouse( self.PlayerID ) == 0  then
        return false
    end
    local tablesOnFestival = {Logic.GetPlayerEntities(self.PlayerID, Entities.B_TableBeer, 5,0)}
    local amount = 0
    for k=2, #tablesOnFestival do
        local tableID = tablesOnFestival[k]
        if Logic.GetIndexOnOutStockByGoodType(tableID, Goods.G_Beer) ~= -1 then
            local goodAmountOnMarketplace = Logic.GetAmountOnOutStockByGoodType(tableID, Goods.G_Beer)
            amount = amount + goodAmountOnMarketplace
        end
    end
    if not self.FestivalStarted and amount &#x3E; 0 then
        self.FestivalStarted = true
        self.FestivalCounter = (self.FestivalCounter and self.FestivalCounter + 1) or 1
        if self.FestivalCounter &#x3E;= self.NeededFestivals then
            self.FestivalCounter = nil
            return true
        end
    elseif amount == 0 then
        self.FestivalStarted = false
    end
end

function b_Goal_Festivals:Debug(_Quest)
    if Logic.GetStoreHouse( self.PlayerID ) == 0 then
        fatal(_Quest.Identifier .. ": Error in " .. self.Name .. ": Player " .. self.PlayerID .. " is dead :-(")
        return true
    elseif GetPlayerCategoryType(self.PlayerID) ~= PlayerCategories.City then
        fatal(_Quest.Identifier .. ": Error in " .. self.Name .. ":  Player "..  self.PlayerID .. " is no city")
        return true
    elseif self.NeededFestivals &#x3C; 0 then
        fatal(_Quest.Identifier .. ": Error in " .. self.Name .. ": Number of Festivals is negative")
        return true
    end
    return false
end

function b_Goal_Festivals:Reset()
    self.FestivalCounter = nil
    self.FestivalStarted = nil
end

function b_Goal_Festivals:GetIcon()
    return {4,15}
end

Core:RegisterBehavior(b_Goal_Festivals)

-- -------------------------------------------------------------------------- --

---
-- Der Auftragnehmer muss eine Einheit gefangen nehmen.
--
-- @param _ScriptName Ziel
--
-- @within Goal
--
function Goal_Capture(...)
    return b_Goal_Capture:new(...)
end

b_Goal_Capture = {
    Name = "Goal_Capture",
    Description = {
        en = "Goal: Capture a cart.",
        de = "Ziel: Ein Karren muss erobert werden.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script name", de = "Skriptname" },
    },
}

function b_Goal_Capture:GetGoalTable()
    return { Objective.Capture, 1, { self.ScriptName } }
end

function b_Goal_Capture:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptName = _Parameter
    end
end

function b_Goal_Capture:GetMsgKey()
   local ID = GetID(self.ScriptName)
   if Logic.IsEntityAlive(ID) then
        ID = Logic.GetEntityType( ID )
        if ID and ID ~= 0 then
            if Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableMerchant ) == 1 then
                return "Quest_Capture_Cart"

            elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.SiegeEngine ) == 1 then
                return "Quest_Capture_SiegeEngine"

            elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.Worker ) == 1
                or Logic.IsEntityTypeInCategory( ID, EntityCategories.Spouse ) == 1
                or Logic.IsEntityTypeInCategory( ID, EntityCategories.Hero ) == 1 then

                return "Quest_Capture_VIPOfPlayer"

            end
        end
    end
end

Core:RegisterBehavior(b_Goal_Capture);

-- -------------------------------------------------------------------------- --

---
-- Der Auftragnehmer muss eine Menge von Einheiten eines Typs von einem
-- Spieler gefangen nehmen.
--
-- @param _Typ      Typ, der gefangen werden soll
-- @param _Amount   Menge an Einheiten
-- @param _PlayerID Besitzer der Einheiten
--
-- @within Goal
--
function Goal_CaptureType(...)
    return b_Goal_CaptureType:new(...)
end

b_Goal_CaptureType = {
    Name = "Goal_CaptureType",
    Description = {
        en = "Goal: Capture specified entity types",
        de = "Ziel: Nimm bestimmte Entitätstypen gefangen",
    },
    Parameter = {
        { ParameterType.Custom,     en = "Type name", de = "Typbezeichnung" },
        { ParameterType.Number,     en = "Amount", de = "Anzahl" },
        { ParameterType.PlayerID,     en = "Player", de = "Spieler" },
    },
}

function b_Goal_CaptureType:GetGoalTable()
    return { Objective.Capture, 2, Entities[self.EntityName], self.Amount, self.PlayerID }
end

function b_Goal_CaptureType:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.EntityName = _Parameter
    elseif (_Index == 1) then
        self.Amount = _Parameter * 1
    elseif (_Index == 2) then
        self.PlayerID = _Parameter * 1
    end
end

function b_Goal_CaptureType:GetCustomData( _Index )
    local Data = {}
    if _Index == 0 then
        for k, v in pairs( Entities ) do
            if string.find( k, "^U_.+Cart" ) or Logic.IsEntityTypeInCategory( v, EntityCategories.AttackableMerchant ) == 1 then
                table.insert( Data, k )
            end
        end
        table.sort( Data )
    elseif _Index == 2 then
        for i = 0, 8 do
            table.insert( Data, i )
        end
    else
        assert( false )
    end
    return Data
end

function b_Goal_CaptureType:GetMsgKey()

    local ID = self.EntityName
    if Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableMerchant ) == 1 then
        return "Quest_Capture_Cart"

    elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.SiegeEngine ) == 1 then
        return "Quest_Capture_SiegeEngine"

    elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.Worker ) == 1
        or Logic.IsEntityTypeInCategory( ID, EntityCategories.Spouse ) == 1
        or Logic.IsEntityTypeInCategory( ID, EntityCategories.Hero ) == 1 then

        return "Quest_Capture_VIPOfPlayer"
    end
end

Core:RegisterBehavior(b_Goal_CaptureType);

-- -------------------------------------------------------------------------- --

---
-- Der Auftragnehmer muss das angegebene Entity beschützen.
--
-- Wird ein Wagen zerstört oder in das Lagerhaus / die Burg eines Feindes
-- gebracht, schlägt das Ziel fehl.
--
-- @param _ScriptName Zu beschützendes Entity
--
-- @within Goal
--
function Goal_Protect(...)
    return b_Goal_Protect:new(...)
end

b_Goal_Protect = {
    Name = "Goal_Protect",
    Description = {
        en = "Goal: Protect an entity (entity needs a script name",
        de = "Ziel: Beschütze eine Entität (Entität benötigt einen Skriptnamen)",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script name", de = "Skriptname" },
    },
}

function b_Goal_Protect:GetGoalTable()
    return {Objective.Protect, { self.ScriptName }}
end

function b_Goal_Protect:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptName = _Parameter
    end
end

function b_Goal_Protect:GetMsgKey()
    if Logic.IsEntityAlive(self.ScriptName) then
        local ID = GetID(self.ScriptName)
        if ID and ID ~= 0 then
            ID = Logic.GetEntityType( ID )
            if ID and ID ~= 0 then
                if Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableBuilding ) == 1 then
                    return "Quest_Protect_Building"

                elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.SpecialBuilding ) == 1 then
                    local tMapping = {
                        [PlayerCategories.City]        = "Quest_Protect_City",
                        [PlayerCategories.Cloister]    = "Quest_Protect_Cloister",
                        [PlayerCategories.Village]    = "Quest_Protect_Village",
                    }
                    local PlayerCategory = GetPlayerCategoryType( Logic.EntityGetPlayer(GetID(self.ScriptName)) )
                    if PlayerCategory then
                        local Key = tMapping[PlayerCategory]
                        if Key then
                            return Key
                        end
                    end
                    return "Quest_Protect_Building"

                elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.Hero ) == 1 then
                    return "Quest_Protect_Knight"

                elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableMerchant ) == 1 then
                    return "Quest_Protect_Cart"
                end
            end
        end
    end
    return "Quest_Protect"
end

Core:RegisterBehavior(b_Goal_Protect);

-- -------------------------------------------------------------------------- --

---
-- Der Auftragnehmer muss eine Mine mit einem Geologen wieder auffüllen.
--
-- &#x3C;b&#x3E;Achtung&#x3C;/b&#x3E;: Dieses Behavior ist nur in "Reich des Ostens" verfügbar.
--
-- @param _ScriptName Skriptname der Mine
--
-- @within Goal
--
function Goal_Refill(...)
    return b_Goal_Refill:new(...)
end

b_Goal_Refill = {
    Name = "Goal_Refill",
    Description = {
        en = "Goal: Refill an object using a geologist",
        de = "Ziel: Eine Mine soll durch einen Geologen wieder aufgefuellt werden.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script name", de = "Skriptname" },
    },
   RequiresExtraNo = 1,
}

function b_Goal_Refill:GetGoalTable()
    return { Objective.Refill, { GetID(self.ScriptName) } }
end

function b_Goal_Refill:GetIcon()
    return {8,1,1}
end

function b_Goal_Refill:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptName = _Parameter
    end
end

if g_GameExtraNo &#x3E; 0 then
    Core:RegisterBehavior(b_Goal_Refill);
end

-- -------------------------------------------------------------------------- --

---
-- Eine bestimmte Menge an Rohstoffen in einer Mine muss erreicht werden.
--
-- Dieses Behavior eignet sich besonders für den Einsatz als versteckter
-- Quest um eine Reaktion auszulösen, wenn z.B. eine Mine leer ist.
--
-- &#x3C;u&#x3E;Relationen&#x3C;/u&#x3E;
-- &#x3C;ul&#x3E;
-- &#x3C;li&#x3E;&#x3E; - Mehr als Anzahl&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;&#x3C; - Weniger als Anzahl&#x3C;/li&#x3E;
-- &#x3C;/ul&#x3E;
--
-- @param _ScriptName Skriptname der Mine
-- @param _Relation   Mengenrelation
-- @param _Amount     Menge an Rohstoffen
--
-- @within Goal
--
function Goal_ResourceAmount(...)
    return b_Goal_ResourceAmount:new(...)
end

b_Goal_ResourceAmount = {
    Name = "Goal_ResourceAmount",
    Description = {
        en = "Goal: Reach a specified amount of resources in a doodad",
        de = "Ziel: In einer Mine soll weniger oder mehr als eine angegebene Anzahl an Rohstoffen sein.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script name", de = "Skriptname" },
        { ParameterType.Custom, en = "Relation", de = "Relation" },
        { ParameterType.Number, en = "Amount", de = "Menge" },
    },
}

function b_Goal_ResourceAmount:GetGoalTable()
    return { Objective.Custom2, {self, self.CustomFunction} }
end

function b_Goal_ResourceAmount:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptName = _Parameter
    elseif (_Index == 1) then
        self.bRelSmallerThan = _Parameter == "&#x3C;"
    elseif (_Index == 2) then
        self.Amount = _Parameter * 1
    end
end

function b_Goal_ResourceAmount:CustomFunction(_Quest)
    local ID = GetID(self.ScriptName)
    if ID and ID ~= 0 and Logic.GetResourceDoodadGoodType(ID) ~= 0 then
        local HaveAmount = Logic.GetResourceDoodadGoodAmount(ID)
        if ( self.bRelSmallerThan and HaveAmount &#x3C; self.Amount ) or ( not self.bRelSmallerThan and HaveAmount &#x3E;= self.Amount ) then
            return true
        end
    end
    return nil
end

function b_Goal_ResourceAmount:GetCustomData( _Index )
    local Data = {}
    if _Index == 1 then
        table.insert( Data, "&#x3E;=" )
        table.insert( Data, "&#x3C;" )
    else
        assert( false )
    end
    return Data
end

function b_Goal_ResourceAmount:Debug(_Quest)
    if not IsExisting(self.ScriptName) then
        fatal("".._Quest.Identifier.." "..self.Name..": entity '" ..self.ScriptName.. "' does not exist!");
        return true;
    elseif tonumber(self.Amount) == nil or self.Amount &#x3C; 0 then
        fatal("".._Quest.Identifier.." "..self.Name..": error at amount! (nil or below 0)");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Goal_ResourceAmount);

-- -------------------------------------------------------------------------- --

---
-- Der Quest schlägt sofort fehl.
--
-- @within Goal
--
function Goal_InstantFailure()
    return b_Goal_InstantFailure:new()
end

b_Goal_InstantFailure = {
    Name = "Goal_InstantFailure",
    Description = {
        en = "Instant failure, the goal returns false.",
        de = "Direkter Misserfolg, das Goal sendet false.",
    },
}

function b_Goal_InstantFailure:GetGoalTable()
    return {Objective.DummyFail};
end

Core:RegisterBehavior(b_Goal_InstantFailure);

-- -------------------------------------------------------------------------- --

---
-- Der Quest wird sofort erfüllt.
--
-- @within Goal
--
function Goal_InstantSuccess()
    return b_Goal_InstantSuccess:new()
end

b_Goal_InstantSuccess = {
    Name = "Goal_InstantSuccess",
    Description = {
        en = "Instant success, the goal returns true.",
        de = "Direkter Erfolg, das Goal sendet true.",
    },
}

function b_Goal_InstantSuccess:GetGoalTable()
    return {Objective.Dummy};
end

Core:RegisterBehavior(b_Goal_InstantSuccess);

-- -------------------------------------------------------------------------- --

---
-- Der Zustand des Quests ändert sich niemals
--
-- Wenn ein Zeitlimit auf dem Quest liegt, wird dieses Behavior nicht
-- fehlschlagen sondern automatisch erfüllt.
--
-- @within Goal
--
function Goal_NoChange()
    return b_Goal_NoChange:new()
end

b_Goal_NoChange = {
    Name = "Goal_NoChange",
    Description = {
        en = "The quest state doesn't change. Use reward functions of other quests to change the state of this quest.",
        de = "Der Questzustand wird nicht verändert. Ein Reward einer anderen Quest sollte den Zustand dieser Quest verändern.",
    },
}

function b_Goal_NoChange:GetGoalTable()
    return { Objective.NoChange }
end

Core:RegisterBehavior(b_Goal_NoChange);

-- -------------------------------------------------------------------------- --

---
-- Führt eine Funktion im Skript als Goal aus.
--
-- Die Funktion muss entweder true, false oder nichts zurückgeben.
-- &#x3C;ul&#x3E;
-- &#x3C;li&#x3E;true: Erfolgreich abgeschlossen&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;false: Fehlschlag&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;nichts: Zustand unbestimmt&#x3C;/li&#x3E;
-- &#x3C;/ul&#x3E;
--
-- Anstelle eines Strings kann beim Einsatz im Skript eine Funktionsreferenz
-- übergeben werden. In diesem Fall werden alle weiteren Parameter direkt an
-- die Funktion weitergereicht.
--
-- @param _FunctionName Name der Funktion
--
-- @within Goal
--
function Goal_MapScriptFunction(...)
    return b_Goal_MapScriptFunction:new(...);
end

b_Goal_MapScriptFunction = {
    Name = "Goal_MapScriptFunction",
    Description = {
        en = "Goal: Calls a function within the global map script. Return 'true' means success, 'false' means failure and 'nil' doesn't change anything.",
        de = "Ziel: Ruft eine Funktion im globalen Skript auf, die einen Wahrheitswert zurueckgibt. Rueckgabe 'true' gilt als erfuellt, 'false' als gescheitert und 'nil' ändert nichts.",
    },
    Parameter = {
        { ParameterType.Default, en = "Function name", de = "Funktionsname" },
    },
}

function b_Goal_MapScriptFunction:GetGoalTable()
    return {Objective.Custom2, {self, self.CustomFunction}};
end

function b_Goal_MapScriptFunction:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.FuncName = _Parameter
    end
end

function b_Goal_MapScriptFunction:CustomFunction(_Quest)
    if type(self.FuncName) == "function" then
        return self.Function(unpack(self.i47ya_6aghw_frxil));
    end
    return _G[self.FuncName](self, _Quest);
end

function b_Goal_MapScriptFunction:Debug(_Quest)
    if not self.FuncName then
        fatal(_Quest.Identifier.." "..self.Name..": function reference is invalid!");
        return true;
    end
    if type(self.FuncName) == "string" and not _G[self.FuncName] then
        fatal(_Quest.Identifier.." "..self.Name..": function does not exist!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Goal_MapScriptFunction);

-- -------------------------------------------------------------------------- --

---
-- Eine benutzerdefinierte Variable muss einen bestimmten Wert haben.
--
-- Custom Variables können ausschließlich Zahlen enthalten. Bevor eine
-- Variable in einem Goal abgefragt werden kann, muss sie zuvor mit
-- Reprisal_CustomVariables oder Reward_CutsomVariables initialisiert
-- worden sein.
--
-- &#x3C;p&#x3E;Vergleichsoperatoren&#x3C;/p&#x3E;
-- &#x3C;ul&#x3E;
-- &#x3C;li&#x3E;== - Werte müssen gleich sein&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;~= - Werte müssen ungleich sein&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;&#x3E; - Variablenwert größer Vergleichswert&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;&#x3E;= - Variablenwert größer oder gleich Vergleichswert&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;&#x3C; - Variablenwert kleiner Vergleichswert&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;&#x3C;= - Variablenwert kleiner oder gleich Vergleichswert&#x3C;/li&#x3E;
-- &#x3C;/ul&#x3E;
--
-- @param _Name     Name der Variable
-- @param _Relation Vergleichsoperator
-- @param _Value    Wert oder andere Custom Variable mit wert.
--
-- @within Goal
--
function Goal_CustomVariables(...)
    return b_Goal_CustomVariables:new(...);
end

b_Goal_CustomVariables = {
    Name = "Goal_CustomVariables",
    Description = {
        en = "Goal: A customised variable has to assume a certain value.",
        de = "Ziel: Eine benutzerdefinierte Variable muss einen bestimmten Wert annehmen.",
    },
    Parameter = {
        { ParameterType.Default, en = "Name of Variable", de = "Variablenname" },
        { ParameterType.Custom,  en = "Relation", de = "Relation" },
        { ParameterType.Default, en = "Value or variable", de = "Wert oder Variable" }
    }
};

function b_Goal_CustomVariables:GetGoalTable()
    return { Objective.Custom2, {self, self.CustomFunction} };
end

function b_Goal_CustomVariables:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        self.VariableName = _Parameter
    elseif _Index == 1 then
        self.Relation = _Parameter
    elseif _Index == 2 then
        local value = tonumber(_Parameter);
        value = (value ~= nil and value) or tostring(_Parameter);
        self.Value = value
    end
end

function b_Goal_CustomVariables:CustomFunction()
    _G["QSB_CustomVariables_"..self.VariableName] = _G["QSB_CustomVariables_"..self.VariableName] or 0;

    local Value = (type(self.Value) ~= "string" and self.Value) or _G["QSB_CustomVariables_"..self.Value];
    if self.Relation == "==" then
        if _G["QSB_CustomVariables_"..self.VariableName] == Value then
            return true;
        end
    elseif self.Relation == "~=" then
        if _G["QSB_CustomVariables_"..self.VariableName] == Value then
            return true;
        end
    elseif self.Relation == "&#x3C;" then
        if _G["QSB_CustomVariables_"..self.VariableName] &#x3C; Value then
            return true;
        end
    elseif self.Relation == "&#x3C;=" then
        if _G["QSB_CustomVariables_"..self.VariableName] &#x3C;= Value then
            return true;
        end
    elseif self.Relation == "&#x3E;=" then
        if _G["QSB_CustomVariables_"..self.VariableName] &#x3E;= Value then
            return true;
        end
    else
        if _G["QSB_CustomVariables_"..self.VariableName] &#x3E; Value then
            return true;
        end
    end
    return nil;
end

function b_Goal_CustomVariables:GetCustomData( _Index )
    return {"==", "~=", "&#x3C;=", "&#x3C;", "&#x3E;", "&#x3E;="};
end

function b_Goal_CustomVariables:Debug(_Quest)
    local relations = {"==", "~=", "&#x3C;=", "&#x3C;", "&#x3E;", "&#x3E;="}
    local results    = {true, false, nil}

    if not _G["QSB_CustomVariables_"..self.VariableName] then
        warn(_Quest.Identifier.." "..self.Name..": variable '"..self.VariableName.."' do not exist!");
    end
    if not Inside(self.Relation, relations) then
        fatal(_Quest.Identifier.." "..self.Name..": '"..self.Relation.."' is an invalid relation!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Goal_CustomVariables)

-- -------------------------------------------------------------------------- --

---
-- Lässt den Spieler zwischen zwei Antworten wählen.
--
-- Dabei kann zwischen den Labels Ja/Nein und Ok/Abbrechen gewählt werden.
--
-- &#x3C;b&#x3E;Hinweis:&#x3C;/b&#x3E; Es können nur geschlossene Fragen gestellt werden. Dialoge
-- müssen also immer mit Ja oder Nein beantwortbar sein oder auf Okay und
-- Abbrechen passen.
--
-- @param _Title  Fenstertitel
-- @param _Text   Fenstertext
-- @param _Labels Label der Buttons
--
-- @within Goal
--
function Goal_Decide(...)
    return b_Goal_Decide:new(...);
end

b_Goal_Decide = {
    Name = "Goal_Decide",
    Description = {
        en = "Opens a Yes/No Dialog. Decision = Quest Result",
        de = "Oeffnet einen Ja/Nein-Dialog. Die Entscheidung bestimmt das Quest-Ergebnis (ja=true, nein=false).",
    },
    Parameter = {
        { ParameterType.Default, en = "Text", de = "Text", },
        { ParameterType.Default, en = "Title", de = "Titel", },
        { ParameterType.Custom, en = "Button labels", de = "Button Beschriftung", },
    },
}

function b_Goal_Decide:GetGoalTable()
    return { Objective.Custom2, { self, self.CustomFunction } }
end

function b_Goal_Decide:AddParameter( _Index, _Parameter )
    if (_Index == 0) then
        self.Text = _Parameter
    elseif (_Index == 1) then
        self.Title = _Parameter
    elseif (_Index == 2) then
        self.Buttons = (_Parameter == "Ok/Cancel")
    end
end

function b_Goal_Decide:CustomFunction(_Quest)
    if not IsBriefingActive or (IsBriefingActive and IsBriefingActive() == false) then
        if not self.LocalExecuted then
            if QSB.DialogActive then
                return;
            end
            QSB.DialogActive = true
            local buttons = (self.Buttons and "true") or "nil"
            self.LocalExecuted = true

            local commandString = [[
                Game.GameTimeSetFactor( GUI.GetPlayerID(), 0 )
                OpenRequesterDialog(q,
                                    q,
                                    "Game.GameTimeSetFactor( GUI.GetPlayerID(), 1 ); GUI.SendScriptCommand( 'QSB.DecisionWindowResult = true ')",
                                    s ,
                                    "Game.GameTimeSetFactor( GUI.GetPlayerID(), 1 ); GUI.SendScriptCommand( 'QSB.DecisionWindowResult = false ')")
            ]];
            local commandString = string.format(commandString, self.Text, "{center} " .. self.Title, buttons)
            Logic.ExecuteInLuaLocalState(commandString);

        end
        local result = QSB.DecisionWindowResult
        if result ~= nil then
            QSB.DecisionWindowResult = nil
            QSB.DialogActive = false;
            return result
        end
    end
end

function b_Goal_Decide:Reset()
    self.LocalExecuted = nil;
end

function b_Goal_Decide:GetIcon()
    return {4,12}
end

function b_Goal_Decide:GetCustomData(_Index)
    if _Index == 2 then
        return { "Yes/No", "Ok/Cancel" }
    end
end

Core:RegisterBehavior(b_Goal_Decide);

-- -------------------------------------------------------------------------- --

---
-- Der Spieler kann durch regelmäßiges Begleichen eines Tributes bessere
-- Diplomatie zu einen Spieler erreichen.
--
-- Die Zeit zum Bezahlen des Tributes muss immer kleiner sein als die
-- Wiederholungsperiode.
--
-- &#x3C;b&#x3E;Hinweis&#x3C;/b&#x3E;: Je mehr Zeit sich der Spieler lässt um den Tribut zu
-- begleichen, desto mehr wird sich der Start der nächsten Periode verzögern.
--
-- @param _GoldAmount Menge an Gold
-- @param _Periode    Zahlungsperiode in Sekunden
-- @param _Time       Zeitbegrenzung in Sekunden
-- @param _StartMsg   Vorschlagnachricht
-- @param _SuccessMsg Erfolgsnachricht
-- @param _FailureMsg Fehlschlagnachricht
-- @param _Restart    Nach nichtbezahlen neu starten
--
-- @within Goal
--
function Goal_TributeDiplomacy(...)
    return b_Goal_TributeDiplomacy:new(...);
end

b_Goal_TributeDiplomacy = {
    Name = "Goal_TributeDiplomacy",
    Description = {
        en = "Goal: AI requests periodical tribute for better Diplomacy",
        de = "Ziel: Die KI fordert einen regelmässigen Tribut fuer bessere Diplomatie. Der Questgeber ist der fordernde Spieler.",
    },
    Parameter = {
        { ParameterType.Number, en = "Amount", de = "Menge", },
        { ParameterType.Number, en = "Time till next peyment in seconds", de = "Zeit bis zur Forderung in Sekunden", },
        { ParameterType.Number, en = "Time to pay tribute in seconds", de = "Zeit bis zur Zahlung in Sekunden", },
        { ParameterType.Default, en = "Start Message for TributQuest", de = "Startnachricht der Tributquest", },
        { ParameterType.Default, en = "Success Message for TributQuest", de = "Erfolgsnachricht der Tributquest", },
        { ParameterType.Default, en = "Failure Message for TributQuest", de = "Niederlagenachricht der Tributquest", },
        { ParameterType.Custom, en = "Restart if failed to pay", de = "Nicht-bezahlen beendet die Quest", },
    },
}

function b_Goal_TributeDiplomacy:GetGoalTable()
    return {Objective.Custom2, {self, self.CustomFunction} };
end

function b_Goal_TributeDiplomacy:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Amount = _Parameter * 1;
    elseif (_Index == 1) then
        self.PeriodLength = _Parameter * 1;
    elseif (_Index == 2) then
        self.TributTime = _Parameter * 1;
    elseif (_Index == 3) then
        self.StartMsg = _Parameter;
    elseif (_Index == 4) then
        self.SuccessMsg = _Parameter;
    elseif (_Index == 5) then
        self.FailureMsg = _Parameter;
    elseif (_Index == 6) then
        self.RestartAtFailure = AcceptAlternativeBoolean(_Parameter);
    end
end

function b_Goal_TributeDiplomacy:GetTributeQuest(_Quest)
    if not self.InternTributeQuest then
        local Language = (Network.GetDesiredLanguage() == "de" and "de") or "en";
        local StartMsg = self.StartMsg;
        if type(StartMsg) == "table" then
            StartMsg = StartMsg[Language];
        end
        local SuccessMsg = self.SuccessMsg;
        if type(SuccessMsg) == "table" then
            SuccessMsg = SuccessMsg[Language];
        end
        local FailureMsg = self.FailureMsg;
        if type(FailureMsg) == "table" then
            FailureMsg = FailureMsg[Language];
        end

        local QuestID, Quest = QuestTemplate:New (
            _Quest.Identifier.."_TributeDiplomacyQuest" , _Quest.SendingPlayer, _Quest.ReceivingPlayer,
            {{ Objective.Deliver, {Goods.G_Gold, self.Amount}}},
            {{ Triggers.Time, 0 }},
            self.TributTime, nil, nil, nil, nil, true, true, nil,
            StartMsg,
            SuccessMsg,
            FailureMsg
        );
        self.InternTributeQuest = Quest;
    end
end

function b_Goal_TributeDiplomacy:CheckTributeQuest(_Quest)
    if self.InternTributeQuest and self.InternTributeQuest.State == QuestState.Over and not self.RestartQuest then
        if self.InternTributeQuest.Result ~= QuestResult.Success then
            SetDiplomacyState( _Quest.ReceivingPlayer, _Quest.SendingPlayer, DiplomacyStates.Enemy);
            if not self.RestartAtFailure then
                return false;
            end
        else
            SetDiplomacyState(_Quest.ReceivingPlayer, _Quest.SendingPlayer, DiplomacyStates.TradeContact);
        end
        self.RestartQuest = true;
        self.Time = Logic.GetTime();
    end
end

function b_Goal_TributeDiplomacy:CheckTributePlayer(_Quest)
    local storeHouse = Logic.GetStoreHouse(_Quest.SendingPlayer);
    if (storeHouse == 0 or Logic.IsEntityDestroyed(storeHouse)) then
        if self.InternTributeQuest and self.InternTributeQuest.State == QuestState.Active then
            self.InternTributeQuest:Interrupt();
        end
        return true;
    end
end

function b_Goal_TributeDiplomacy:TributQuestRestarter(_Quest)
    if self.InternTributeQuest and self.Time and self.RestartQuest and ((Logic.GetTime() - self.Time) &#x3E;= self.PeriodLength) then
        self.InternTributeQuest.Objectives[1].Completed = nil;
        self.InternTributeQuest.Objectives[1].Data[3] = nil;
        self.InternTributeQuest.Objectives[1].Data[4] = nil;
        self.InternTributeQuest.Objectives[1].Data[5] = nil;
        self.InternTributeQuest.Result = nil;
        self.InternTributeQuest.State = QuestState.NotTriggered;
        Logic.ExecuteInLuaLocalState("LocalScriptCallback_OnQuestStatusChanged("..self.InternTributeQuest.Index..")");
        Trigger.RequestTrigger(Events.LOGIC_EVENT_EVERY_SECOND, "", QuestTemplate.Loop, 1, 0, { self.InternTributeQuest.QueueID });
        self.RestartQuest = nil;
    end
end

function b_Goal_TributeDiplomacy:CustomFunction(_Quest)
    -- Tribut Quest erzeugen
    self:GetTributeQuest(_Quest);
    -- Status des Tributes prüfen.
    if self:CheckTributeQuest(_Quest) == false then
        return false;
    end
    -- Status des fordernden Spielers prüfen.
    if self:CheckTributePlayer(_Quest) == true then
        return true;
    end
    -- Quest neu starten, falls nötig.
    self:TributQuestRestarter(_Quest);
end

function b_Goal_TributeDiplomacy:Debug(_Quest)
    if self.Amount &#x3C; 0 then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": Amount is negative!");
        return true;
    end
    if self.PeriodLength &#x3C; self.TributTime then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": TributTime too long!");
        return true;
    end
end

function b_Goal_TributeDiplomacy:Reset()
    self.Time = nil;
    self.InternTributeQuest = nil;
    self.RestartQuest = nil;
end

function b_Goal_TributeDiplomacy:Interrupt(_Quest)
    if self.InternTributeQuest ~= nil then
        if self.InternTributeQuest.State == QuestState.Active then
            self.InternTributeQuest:Interrupt()
        end
    end
end

function b_Goal_TributeDiplomacy:GetCustomData(_Index)
    if (_Index == 6) then
        return {"true", "false"};
    end
end

Core:RegisterBehavior(b_Goal_TributeDiplomacy);

-- -------------------------------------------------------------------------- --

---
-- Erlaubt es dem Spieler ein Territorium zu "mieten".
--
-- Zerstört der Spieler den Außenposten, schlägt der Quest fehl und das
-- Territorium wird an den Vermieter übergeben. Wenn der Spieler die Pacht
-- nicht bezahlt, geht der Besitz an den Vermieter über.
--
-- Die Zeit zum Bezahlen des Tributes muss immer kleiner sein als die
-- Wiederholungsperiode.
--
-- &#x3C;b&#x3E;Hinweis&#x3C;/b&#x3E;: Je mehr Zeit sich der Spieler lässt um den Tribut zu
-- begleichen, desto mehr wird sich der Start der nächsten Periode verzögern.
--
-- @param _Territory  Name des Territorium
-- @param _PlayerID   PlayerID des Zahlungsanforderer
-- @param _Cost       Menge an Gold
-- @param _Periode    Zahlungsperiode in Sekunden
-- @param _Time       Zeitbegrenzung in Sekunden
-- @param _StartMsg   Vorschlagnachricht
-- @param _SuccessMsg Erfolgsnachricht
-- @param _FailMsg    Fehlschlagnachricht
-- @param _HowOften   Anzahl an Zahlungen (0 = endlos)
-- @param _OtherOwner Eroberung durch Dritte beendet Quest
-- @param _Abort      Nach nichtbezahlen abbrechen
--
-- @within Goal
--
function Goal_TributeClaim(...)
    return b_Goal_TributeClaim:new(...);
end

b_Goal_TributeClaim = {
    Name = "Goal_TributeClaim",
    Description = {
        en = "Goal: AI requests periodical tribute for a specified territory. The quest sender is the demanding player.",
        de = "Ziel: Die KI fordert einen regelmässigen Tribut fuer ein Territorium. Der Questgeber ist der fordernde Spieler.",
                },
    Parameter = {
        { ParameterType.TerritoryName, en = "Territory", de = "Territorium", },
        { ParameterType.PlayerID, en = "PlayerID", de = "PlayerID", },
        { ParameterType.Number, en = "Amount", de = "Menge", },
        { ParameterType.Number, en = "Length of Period in seconds", de = "Sekunden bis zur nächsten Forderung", },
        { ParameterType.Number, en = "Time to pay Tribut in seconds", de = "Zeit bis zur Zahlung in Sekunden", },
        { ParameterType.Default, en = "Start Message for TributQuest", de = "Startnachricht der Tributquest", },
        { ParameterType.Default, en = "Success Message for TributQuest", de = "Erfolgsnachricht der Tributquest", },
        { ParameterType.Default, en = "Failure Message for TributQuest", de = "Niederlagenachricht der Tributquest", },
        { ParameterType.Number, en = "How often to pay (0 = forerver)", de = "Anzahl der Tributquests (0 = unendlich)", },
        { ParameterType.Custom, en = "Other Owner cancels the Quest", de = "Anderer Spieler kann Quest beenden", },
        { ParameterType.Custom, en = "About if a rate is not payed", de = "Nicht-bezahlen beendet die Quest", },
    },
}

function b_Goal_TributeClaim:GetGoalTable()
    return {Objective.Custom2, {self, self.CustomFunction} };
end

function b_Goal_TributeClaim:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        if type(_Parameter) == "string" then
            _Parameter = GetTerritoryIDByName(_Parameter);
        end
        self.TerritoryID = _Parameter;
    elseif (_Index == 1) then
        self.PlayerID = _Parameter * 1;
    elseif (_Index == 2) then
        self.Amount = _Parameter * 1;
    elseif (_Index == 3) then
        self.PeriodLength = _Parameter * 1;
    elseif (_Index == 4) then
        self.TributTime = _Parameter * 1;
    elseif (_Index == 5) then
        self.StartMsg = _Parameter;
    elseif (_Index == 6) then
        self.SuccessMsg = _Parameter;
    elseif (_Index == 7) then
        self.FailureMsg = _Parameter;
    elseif (_Index == 8) then
        self.HowOften = _Parameter * 1;
    elseif (_Index == 9) then
        self.OtherOwnerCancels = AcceptAlternativeBoolean(_Parameter);
    elseif (_Index == 10) then
        self.DontPayCancels = AcceptAlternativeBoolean(_Parameter);
    end
end

function b_Goal_TributeClaim:CureOutpost(_Quest)
    local Outpost = Logic.GetTerritoryAcquiringBuildingID(self.TerritoryID);
    if IsExisting(Outpost) and GetHealth(Outpost) &#x3C; 25 and Logic.IsBuildingBeingKnockedDown(Outpost) == false then
        while (Logic.GetEntityHealth(Outpost) &#x3C; Logic.GetEntityMaxHealth(Outpost) * 0.6) do
            Logic.HealEntity(Outpost, 1);
        end
    end
end

function b_Goal_TributeClaim:RestartTributeQuest(_Quest)
    if self.InternTributeQuest then
        self.InternTributeQuest.Objectives[1].Completed = nil;
        self.InternTributeQuest.Objectives[1].Data[3] = nil;
        self.InternTributeQuest.Objectives[1].Data[4] = nil;
        self.InternTributeQuest.Objectives[1].Data[5] = nil;
        self.InternTributeQuest.Result = nil;
        self.InternTributeQuest.State = QuestState.NotTriggered;
        Logic.ExecuteInLuaLocalState("LocalScriptCallback_OnQuestStatusChanged("..self.InternTributeQuest.Index..")");
        Trigger.RequestTrigger(Events.LOGIC_EVENT_EVERY_SECOND, "", QuestTemplate.Loop, 1, 0, { self.InternTributeQuest.QueueID });
    end
end

function b_Goal_TributeClaim:CreateTributeQuest(_Quest)
    if not self.InternTributeQuest then
        local Language = (Network.GetDesiredLanguage() == "de" and "de") or "en";
        local StartMsg = self.StartMsg;
        if type(StartMsg) == "table" then
            StartMsg = StartMsg[Language];
        end
        local SuccessMsg = self.SuccessMsg;
        if type(SuccessMsg) == "table" then
            SuccessMsg = SuccessMsg[Language];
        end
        local FailureMsg = self.FailureMsg;
        if type(FailureMsg) == "table" then
            FailureMsg = FailureMsg[Language];
        end

        local OnFinished = function()
            self.Time = Logic.GetTime();
        end
        local QuestID, Quest = QuestTemplate:New(
            _Quest.Identifier.."_TributeClaimQuest", self.PlayerID, _Quest.ReceivingPlayer,
            {{ Objective.Deliver, {Goods.G_Gold, self.Amount}}},
            {{ Triggers.Time, 0 }},
            self.TributTime, nil, nil, OnFinished, nil, true, true, nil,
            StartMsg,
            SuccessMsg,
            FailureMsg
        );
        self.InternTributeQuest = Quest;
    end
end

function b_Goal_TributeClaim:OnTributeFailed(_Quest)
    local Outpost = Logic.GetTerritoryAcquiringBuildingID(self.TerritoryID);
    if IsExisting(Outpost) then
        Logic.ChangeEntityPlayerID(Outpost, self.PlayerID);
    end
    Logic.SetTerritoryPlayerID(self.TerritoryID, self.PlayerID);
    self.InternTributeQuest.State = false;
    self.Time = nil;

    if self.DontPayCancels then
        _Quest:Interrupt();
    end
end

function b_Goal_TributeClaim:OnTributePaid(_Quest)
    local Outpost = Logic.GetTerritoryAcquiringBuildingID(self.TerritoryID);
    if self.InternTributeQuest.Result == QuestResult.Success then
        if Logic.GetTerritoryPlayerID(self.TerritoryID) == self.PlayerID then
            if IsExisting(Outpost) then
                Logic.ChangeEntityPlayerID(Outpost, _Quest.ReceivingPlayer);
            end
            Logic.SetTerritoryPlayerID(self.TerritoryID, _Quest.ReceivingPlayer);
        end
    end
    if self.Time and Logic.GetTime() &#x3E;= self.Time + self.PeriodLength then
        if self.HowOften and self.HowOften ~= 0 then
            self.TributeCounter = (self.TributeCounter or 0) +1;
            if self.TributeCounter &#x3E;= self.HowOften then
                return false;
            end
        end
        self:RestartTributeQuest();
        self.Time = nil;
    end
end

function b_Goal_TributeClaim:CustomFunction(_Quest)
    self:CreateTributeQuest(_Quest);
    self:CureOutpost(_Quest);

    if Logic.GetTerritoryPlayerID(self.TerritoryID) == _Quest.ReceivingPlayer
    or Logic.GetTerritoryPlayerID(self.TerritoryID) == self.PlayerID then
        if self.OtherOwner then
            self:RestartTributeQuest();
            self.OtherOwner = nil;
        end

        -- Quest abgeschlossen
        if self.InternTributeQuest.State == QuestState.Over then
            if self.InternTributeQuest.Result == QuestResult.Failure then
                self:OnTributeFailed(_Quest);
            else
                self:OnTributePaid(_Quest);
            end

        elseif self.InternTributeQuest.State == false then
            if self.Time and Logic.GetTime() &#x3E;= self.Time + self.PeriodLength then
                self:RestartTributeQuest(_Quest);
            end
        end

    -- Keiner besitzt das Territorium -&#x3E; Abbruch
    elseif Logic.GetTerritoryPlayerID(self.TerritoryID) == 0 and self.InternTributeQuest then
        if self.InternTributeQuest.State == QuestState.Active then
            self.InternTributeQuest:Interrupt();
        end

    -- Anderer Besitzer -&#x3E; Abbruch
    elseif Logic.GetTerritoryPlayerID(self.TerritoryID) ~= self.PlayerID then
        if self.InternTributeQuest.State == QuestState.Active then
            self.InternTributeQuest:Interrupt();
        end
        if self.OtherOwnerCancels then
            _Quest:Interrupt();
        end
        self.OtherOwner = true;
    end

    --Fordernder Spieler existiert nicht -&#x3E; Abbruch
    local storeHouse = Logic.GetStoreHouse(self.PlayerID);
    if (storeHouse == 0 or Logic.IsEntityDestroyed(storeHouse)) then
        if self.InternTributeQuest and self.InternTributeQuest.State == QuestState.Active then
            self.InternTributeQuest:Interrupt();
        end
        return true;
    end
end

function b_Goal_TributeClaim:Debug(_Quest)
    if self.TerritoryID == 0 then
        fatal(_Quest.Identifier .. ": " .. self.Name .. ": Unknown Territory");
        return true;
    end
    if not self.Quest and Logic.GetStoreHouse(self.PlayerID) == 0 then
        fatal(_Quest.Identifier .. ": " .. self.Name .. ": Player " .. self.PlayerID .. " is dead. :-(");
        return true;
    end
    if self.Amount &#x3C; 0 then
        fatal(_Quest.Identifier .. ": " .. self.Name .. ": Amount is negative");
        return true;
    end
    if self.PeriodLength &#x3C; self.TributTime or self.PeriodLength &#x3C; 1 then
        fatal(_Quest.Identifier .. ": " .. self.Name .. ": Period Length is wrong");
        return true;
    end
    if self.HowOften &#x3C; 0 then
        fatal(_Quest.Identifier .. ": " .. self.Name .. ": HowOften is negative");
        return true;
    end
end

function b_Goal_TributeClaim:Reset()
    self.InternTributeQuest = nil;
    self.Time = nil;
    self.OtherOwner = nil;
end

function b_Goal_TributeClaim:Interrupt(_Quest)
    if type(self.InternTributeQuest) == "table" then
        if self.InternTributeQuest.State == QuestState.Active then
            self.InternTributeQuest:Interrupt();
        end
    end
end

function b_Goal_TributeClaim:GetCustomData(_Index)
    if (_Index == 9) or (_Index == 10) then
        return {"false", "true"};
    end
end

Core:RegisterBehavior(b_Goal_TributeClaim);

-- -------------------------------------------------------------------------- --
-- Reprisal                                                                   --
-- -------------------------------------------------------------------------- --

---
-- Deaktiviert ein interaktives Objekt.
--
-- @param _ScriptName Skriptname des interaktiven Objektes
--
-- @within Reprisal
--
function Reprisal_ObjectDeactivate(...)
    return b_Reprisal_ObjectDeactivate:new(...);
end

b_Reprisal_ObjectDeactivate = {
    Name = "Reprisal_ObjectDeactivate",
    Description = {
        en = "Reprisal: Deactivates an interactive object",
        de = "Vergeltung: Deaktiviert ein interaktives Objekt",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Interactive object", de = "Interaktives Objekt" },
    },
}

function b_Reprisal_ObjectDeactivate:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function b_Reprisal_ObjectDeactivate:AddParameter(_Index, _Parameter)

    if (_Index == 0) then
        self.ScriptName = _Parameter
    end

end

function b_Reprisal_ObjectDeactivate:CustomFunction(_Quest)
    InteractiveObjectDeactivate(self.ScriptName);
end

function b_Reprisal_ObjectDeactivate:Debug(_Quest)
    if not Logic.IsInteractiveObject(GetID(self.ScriptName)) then
        warn("".._Quest.Identifier.." "..self.Name..": '" ..self.ScriptName.. "' is not a interactive object!");
        self.WarningPrinted = true;
    end
    local eID = GetID(self.ScriptName);
    if QSB.InitalizedObjekts[eID] and QSB.InitalizedObjekts[eID] == _Quest.Identifier then
        fatal("".._Quest.Identifier.." "..self.Name..": you can not deactivate in the same quest the object is initalized!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Reprisal_ObjectDeactivate);

-- -------------------------------------------------------------------------- --

---
-- Aktiviert ein interaktives Objekt.
--
-- Der Status bestimmt, wie das Objekt aktiviert wird.
-- &#x3C;ul&#x3E;
-- &#x3C;li&#x3E;0: Kann nur mit Helden aktiviert werden&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;1: Kann immer aktiviert werden&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;2: Kann niemals aktiviert werden&#x3C;/li&#x3E;
-- &#x3C;/ul&#x3E;
--
-- @param _ScriptName Skriptname des interaktiven Objektes
-- @param _State      Status des Objektes
--
-- @within Reprisal
--
function Reprisal_ObjectActivate(...)
    return b_Reprisal_ObjectActivate:new(...);
end

b_Reprisal_ObjectActivate = {
    Name = "Reprisal_ObjectActivate",
    Description = {
        en = "Reprisal: Activates an interactive object",
        de = "Vergeltung: Aktiviert ein interaktives Objekt",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Interactive object",  de = "Interaktives Objekt" },
        { ParameterType.Custom,     en = "Availability",         de = "Nutzbarkeit" },
    },
}

function b_Reprisal_ObjectActivate:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function b_Reprisal_ObjectActivate:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptName = _Parameter
    elseif (_Index == 1) then
        local parameter = 0
        if _Parameter == "Always" or 1 then
            parameter = 1
        end
        self.UsingState = parameter * 1
    end
end

function b_Reprisal_ObjectActivate:CustomFunction(_Quest)
    InteractiveObjectActivate(self.ScriptName, self.UsingState);
end

function b_Reprisal_ObjectActivate:GetCustomData( _Index )
    if _Index == 1 then
        return {"Knight only", "Always"}
    end
end

function b_Reprisal_ObjectActivate:Debug(_Quest)
    if not Logic.IsInteractiveObject(GetID(self.ScriptName)) then
        warn("".._Quest.Identifier.." "..self.Name..": '" ..self.ScriptName.. "' is not a interactive object!");
        self.WarningPrinted = true;
    end
    local eID = GetID(self.ScriptName);
    if QSB.InitalizedObjekts[eID] and QSB.InitalizedObjekts[eID] == _Quest.Identifier then
        fatal("".._Quest.Identifier.." "..self.Name..": you can not activate in the same quest the object is initalized!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Reprisal_ObjectActivate);

-- -------------------------------------------------------------------------- --

---
-- Der diplomatische Status zwischen Sender und Empfänger verschlechtert sich
-- um eine Stufe.
--
-- @within Reprisal
--
function Reprisal_DiplomacyDecrease()
    return b_Reprisal_DiplomacyDecrease:new();
end

b_Reprisal_DiplomacyDecrease = {
    Name = "Reprisal_DiplomacyDecrease",
    Description = {
        en = "Reprisal: Diplomacy decreases slightly to another player.",
        de = "Vergeltung: Der Diplomatiestatus zum Auftraggeber wird um eine Stufe verringert.",
    },
}

function b_Reprisal_DiplomacyDecrease:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function b_Reprisal_DiplomacyDecrease:CustomFunction(_Quest)
    local Sender = _Quest.SendingPlayer;
    local Receiver = _Quest.ReceivingPlayer;
    local State = GetDiplomacyState(Receiver, Sender);
    if State &#x3E; -2 then
        SetDiplomacyState(Receiver, Sender, State-1);
    end
end

function b_Reprisal_DiplomacyDecrease:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    end
end

Core:RegisterBehavior(b_Reprisal_DiplomacyDecrease);

-- -------------------------------------------------------------------------- --

---
-- Änder den Diplomatiestatus zwischen zwei Spielern.
--
-- @param _Party1   ID der ersten Partei
-- @param _Party2   ID der zweiten Partei
-- @param _State    Neuer Diplomatiestatus
--
-- @within Reprisal
--
function Reprisal_Diplomacy(...)
    return b_Reprisal_Diplomacy:new(...);
end

b_Reprisal_Diplomacy = {
    Name = "Reprisal_Diplomacy",
    Description = {
        en = "Reprisal: Sets Diplomacy state of two Players to a stated value.",
        de = "Vergeltung: Setzt den Diplomatiestatus zweier Spieler auf den angegebenen Wert.",
    },
    Parameter = {
        { ParameterType.PlayerID,         en = "PlayerID 1", de = "Spieler 1" },
        { ParameterType.PlayerID,         en = "PlayerID 2", de = "Spieler 2" },
        { ParameterType.DiplomacyState,   en = "Relation",   de = "Beziehung" },
    },
}

function b_Reprisal_Diplomacy:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function b_Reprisal_Diplomacy:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID1 = _Parameter * 1
    elseif (_Index == 1) then
        self.PlayerID2 = _Parameter * 1
    elseif (_Index == 2) then
        self.Relation = DiplomacyStates[_Parameter]
    end
end

function b_Reprisal_Diplomacy:CustomFunction(_Quest)
    SetDiplomacyState(self.PlayerID1, self.PlayerID2, self.Relation);
end

function b_Reprisal_Diplomacy:Debug(_Quest)
    if not tonumber(self.PlayerID1) or self.PlayerID1 &#x3C; 1 or self.PlayerID1 &#x3E; 8 then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": PlayerID 1 is invalid!");
        return true;
    elseif not tonumber(self.PlayerID2) or self.PlayerID2 &#x3C; 1 or self.PlayerID2 &#x3E; 8 then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": PlayerID 2 is invalid!");
        return true;
    elseif not tonumber(self.Relation) or self.Relation &#x3C; -2 or self.Relation &#x3E; 2 then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": '"..self.Relation.."' is a invalid diplomacy state!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Reprisal_Diplomacy);

-- -------------------------------------------------------------------------- --

---
-- Ein benanntes Entity wird entfernt.
--
-- &#x3C;b&#x3E;Hinweis&#x3C;/b&#x3E;: Das Entity wird durch ein XD_ScriptEntity ersetzt. Es
-- behält Name, Besitzer und Ausrichtung.
--
-- @param _ScriptName Skriptname des Entity
--
-- @within Reprisal
--
function Reprisal_DestroyEntity(...)
    return b_Reprisal_DestroyEntity:new(...);
end

b_Reprisal_DestroyEntity = {
    Name = "Reprisal_DestroyEntity",
    Description = {
        en = "Reprisal: Replaces an entity with an invisible script entity, which retains the entities name.",
        de = "Vergeltung: Ersetzt eine Entity mit einer unsichtbaren Script-Entity, die den Namen übernimmt.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Entity", de = "Entity" },
    },
}

function b_Reprisal_DestroyEntity:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function b_Reprisal_DestroyEntity:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptName = _Parameter
    end
end

function b_Reprisal_DestroyEntity:CustomFunction(_Quest)
    ReplaceEntity(self.ScriptName, Entities.XD_ScriptEntity);
end

function b_Reprisal_DestroyEntity:Debug(_Quest)
    if not IsExisting(self.ScriptName) then
        warn(_Quest.Identifier.." " ..self.Name..": '" ..self.ScriptName.. "' is already destroyed!");
        self.WarningPrinted = true;
    end
    return false;
end

Core:RegisterBehavior(b_Reprisal_DestroyEntity);

-- -------------------------------------------------------------------------- --

---
-- Zerstört einen über ein Behavior erzeugten Effekt.
--
-- @param _EffectName Name des Effekts
--
-- @within Reprisal
--
function Reprisal_DestroyEffect(...)
    return b_Reprisal_DestroyEffect:new(...);
end

b_Reprisal_DestroyEffect = {
    Name = "Reprisal_DestroyEffect",
    Description = {
        en = "Reprisal: Destroys an effect",
        de = "Vergeltung: Zerstört einen Effekt",
    },
    Parameter = {
        { ParameterType.Default, en = "Effect name", de = "Effektname" },
    }
}

function b_Reprisal_DestroyEffect:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        self.EffectName = _Parameter;
    end
end

function b_Reprisal_DestroyEffect:GetReprisalTable()
    return { Reprisal.Custom, { self, self.CustomFunction } };
end

function b_Reprisal_DestroyEffect:CustomFunction(_Quest)
    if not QSB.EffectNameToID[self.EffectName] or not Logic.IsEffectRegistered(QSB.EffectNameToID[self.EffectName]) then
        return;
    end
    Logic.DestroyEffect(QSB.EffectNameToID[self.EffectName]);
end

function b_Reprisal_DestroyEffect:Debug(_Quest)
    if not QSB.EffectNameToID[self.EffectName] then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": Effect " .. self.EffectName .. " never created")
    end
    return false;
end

Core:RegisterBehavior(b_Reprisal_DestroyEffect);

-- -------------------------------------------------------------------------- --

---
-- Der Spieler verliert das Spiel.
--
-- @within Reprisal
--
function Reprisal_Defeat()
    return b_Reprisal_Defeat:new()
end

b_Reprisal_Defeat = {
    Name = "Reprisal_Defeat",
    Description = {
        en = "Reprisal: The player loses the game.",
        de = "Vergeltung: Der Spieler verliert das Spiel.",
    },
}

function b_Reprisal_Defeat:GetReprisalTable()
    return {Reprisal.Defeat};
end

Core:RegisterBehavior(b_Reprisal_Defeat);

-- -------------------------------------------------------------------------- --

---
-- Zeigt die Niederlagedekoration am Quest an.
--
-- Es handelt sich dabei um reine Optik! Der Spieler wird nicht verlieren.
--
-- @within Reprisal
--
function Reprisal_FakeDefeat()
    return b_Reprisal_FakeDefeat:new();
end

b_Reprisal_FakeDefeat = {
    Name = "Reprisal_FakeDefeat",
    Description = {
        en = "Reprisal: Displays a defeat icon for a quest",
        de = "Vergeltung: Zeigt ein Niederlage Icon fuer eine Quest an",
    },
}

function b_Reprisal_FakeDefeat:GetReprisalTable()
    return { Reprisal.FakeDefeat }
end

Core:RegisterBehavior(b_Reprisal_FakeDefeat);

-- -------------------------------------------------------------------------- --

---
-- Ein Entity wird durch ein neues anderen Typs ersetzt.
--
-- Das neue Entity übernimmt Skriptname, Besitzer  und Ausrichtung des 
-- alten Entity.
--
-- @param _Entity Skriptname oder ID des Entity
-- @param _Type   Neuer Typ des Entity
-- @param _Owner  Besitzer des Entity
--
-- @within Reprisal
--
function Reprisal_ReplaceEntity(...)
    return b_Reprisal_ReplaceEntity:new(...);
end

b_Reprisal_ReplaceEntity = {
    Name = "Reprisal_ReplaceEntity",
    Description = {
        en = "Reprisal: Replaces an entity with a new one of a different type. The playerID can be changed too.",
        de = "Vergeltung: Ersetzt eine Entity durch eine neue anderen Typs. Es kann auch die Spielerzugehörigkeit geändert werden.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Target", de = "Ziel" },
        { ParameterType.Custom, en = "New Type", de = "Neuer Typ" },
        { ParameterType.Custom, en = "New playerID", de = "Neue Spieler ID" },
    },
}

function b_Reprisal_ReplaceEntity:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function b_Reprisal_ReplaceEntity:AddParameter(_Index, _Parameter)
   if (_Index == 0) then
        self.ScriptName = _Parameter
    elseif (_Index == 1) then
        self.NewType = _Parameter
    elseif (_Index == 2) then
        self.PlayerID = tonumber(_Parameter);
    end
end

function b_Reprisal_ReplaceEntity:CustomFunction(_Quest)
    local eID = GetID(self.ScriptName);
    local pID = self.PlayerID;
    if pID == Logic.EntityGetPlayer(eID) then
        pID = nil;
    end
    ReplaceEntity(self.ScriptName, Entities[self.NewType], pID);
end

function b_Reprisal_ReplaceEntity:GetCustomData(_Index)
    local Data = {}
    if _Index == 1 then
        for k, v in pairs( Entities ) do
            local name = {"^M_","^XS_","^X_","^XT_","^Z_", "^XB_"}
            local found = false;
            for i=1,#name do
                if k:find(name[i]) then
                    found = true;
                    break;
                end
            end
            if not found then
                table.insert( Data, k );
            end
        end
        table.sort( Data )
    elseif _Index == 2 then
        Data = {"-","0","1","2","3","4","5","6","7","8",}
    end
    return Data
end

function b_Reprisal_ReplaceEntity:Debug(_Quest)
    if not Entities[self.NewType] then
        fatal(_Quest.Identifier.." "..self.Name..": got an invalid entity type!");
        return true;
    elseif self.PlayerID ~= nil and (self.PlayerID &#x3C; 1 or self.PlayerID &#x3E; 8) then
        fatal(_Quest.Identifier.." "..self.Name..": got an invalid playerID!");
        return true;
    end

    if not IsExisting(self.ScriptName) then
        self.WarningPrinted = true;
        warn(_Quest.Identifier.." "..self.Name..": '" ..self.ScriptName.. "' does not exist!");
    end
    return false;
end

Core:RegisterBehavior(b_Reprisal_ReplaceEntity);

-- -------------------------------------------------------------------------- --

---
-- Startet einen Quest neu.
--
-- @param _QuestName Name des Quest
--
-- @within Reprisal
--
function Reprisal_QuestRestart(...)
    return b_Reprisal_QuestRestart(...)
end

b_Reprisal_QuestRestart = {
    Name = "Reprisal_QuestRestart",
    Description = {
        en = "Reprisal: Restarts a (completed) quest so it can be triggered and completed again",
        de = "Vergeltung: Startet eine (beendete) Quest neu, damit diese neu ausgelöst und beendet werden kann",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest name", de = "Questname" },
    },
}

function b_Reprisal_QuestRestart:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function b_Reprisal_QuestRestart:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter
    end
end

function b_Reprisal_QuestRestart:CustomFunction(_Quest)
    RestartQuestByName(self.QuestName, true);
end

function b_Reprisal_QuestRestart:Debug(_Quest)
    if not Quests[GetQuestID(self.QuestName)] then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": quest "..  self.QuestName .. " does not exist!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Reprisal_QuestRestart);

-- -------------------------------------------------------------------------- --

---
-- Lässt einen Quest fehlschlagen.
--
-- @param _QuestName Name des Quest
--
-- @within Reprisal
--
function Reprisal_QuestFailure(...)
    return b_Reprisal_QuestFailure(...)
end

b_Reprisal_QuestFailure = {
    Name = "Reprisal_QuestFailure",
    Description = {
        en = "Reprisal: Lets another active quest fail",
        de = "Vergeltung: Lässt eine andere aktive Quest fehlschlagen",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest name", de = "Questname" },
    },
}

function b_Reprisal_QuestFailure:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function b_Reprisal_QuestFailure:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter
    end
end

function b_Reprisal_QuestFailure:CustomFunction(_Quest)
    FailQuestByName(self.QuestName, true);
end

function b_Reprisal_QuestFailure:Debug(_Quest)
    if not Quests[GetQuestID(self.QuestName)] then
        fatal("".._Quest.Identifier.." "..self.Name..": got an invalid quest!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Reprisal_QuestFailure);

-- -------------------------------------------------------------------------- --

---
-- Wertet einen Quest als erfolgreich.
--
-- @param _QuestName Name des Quest
--
-- @within Reprisal
--
function Reprisal_QuestSuccess(...)
    return b_Reprisal_QuestSuccess(...)
end

b_Reprisal_QuestSuccess = {
    Name = "Reprisal_QuestSuccess",
    Description = {
        en = "Reprisal: Completes another active quest successfully",
        de = "Vergeltung: Beendet eine andere aktive Quest erfolgreich",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest name", de = "Questname" },
    },
}

function b_Reprisal_QuestSuccess:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function b_Reprisal_QuestSuccess:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter
    end
end

function b_Reprisal_QuestSuccess:CustomFunction(_Quest)
    WinQuestByName(self.QuestName, true);
end

function b_Reprisal_QuestSuccess:Debug(_Quest)
    if not Quests[GetQuestID(self.QuestName)] then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": quest "..  self.QuestName .. " does not exist!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Reprisal_QuestSuccess);

-- -------------------------------------------------------------------------- --

---
-- Triggert einen Quest.
--
-- @param _QuestName Name des Quest
--
-- @within Reprisal
--
function Reprisal_QuestActivate(...)
    return b_Reprisal_QuestActivate(...)
end

b_Reprisal_QuestActivate = {
    Name = "Reprisal_QuestActivate",
    Description = {
        en = "Reprisal: Activates another quest that is not triggered yet.",
        de = "Vergeltung: Aktiviert eine andere Quest die noch nicht ausgelöst wurde.",
                },
    Parameter = {
        {ParameterType.QuestName, en = "Quest name", de = "Questname", },
    },
}

function b_Reprisal_QuestActivate:GetReprisalTable()
    return {Reprisal.Custom, {self, self.CustomFunction} }
end

function b_Reprisal_QuestActivate:AddParameter(_Index, _Parameter)
    if (_Index==0) then
        self.QuestName = _Parameter
    else
        assert(false, "Error in " .. self.Name .. ": AddParameter: Index is invalid")
    end
end

function b_Reprisal_QuestActivate:CustomFunction(_Quest)
    StartQuestByName(self.QuestName, true);
end

function b_Reprisal_QuestActivate:Debug(_Quest)
    if not IsValidQuest(self.QuestName) then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": Quest: "..  self.QuestName .. " does not exist");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Reprisal_QuestActivate)

-- -------------------------------------------------------------------------- --

---
-- Unterbricht einen Quest.
--
-- @param _QuestName Name des Quest
--
-- @within Reprisal
--
function Reprisal_QuestInterrupt(...)
    return b_Reprisal_QuestInterrupt(...)
end

b_Reprisal_QuestInterrupt = {
    Name = "Reprisal_QuestInterrupt",
    Description = {
        en = "Reprisal: Interrupts another active quest without success or failure",
        de = "Vergeltung: Beendet eine andere aktive Quest ohne Erfolg oder Misserfolg",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest name", de = "Questname" },
    },
}

function b_Reprisal_QuestInterrupt:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function b_Reprisal_QuestInterrupt:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter
    end
end

function b_Reprisal_QuestInterrupt:CustomFunction(_Quest)
    if (GetQuestID(self.QuestName) ~= nil) then

        local QuestID = GetQuestID(self.QuestName)
        local Quest = Quests[QuestID]
        if Quest.State == QuestState.Active then
            StopQuestByName(self.QuestName, true);
        end
    end
end

function b_Reprisal_QuestInterrupt:Debug(_Quest)
    if not Quests[GetQuestID(self.QuestName)] then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": quest "..  self.QuestName .. " does not exist!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Reprisal_QuestInterrupt);

-- -------------------------------------------------------------------------- --

---
-- Unterbricht einen Quest, selbst wenn dieser noch nicht ausgelöst wurde.
--
-- @param _QuestName   Name des Quest
-- @param _EndetQuests Bereits beendete unterbrechen
--
-- @within Reprisal
--
function Reprisal_QuestForceInterrupt(...)
    return b_Reprisal_QuestForceInterrupt(...)
end

b_Reprisal_QuestForceInterrupt = {
    Name = "Reprisal_QuestForceInterrupt",
    Description = {
        en = "Reprisal: Interrupts another quest (even when it isn't active yet) without success or failure",
        de = "Vergeltung: Beendet eine andere Quest, auch wenn diese noch nicht aktiv ist ohne Erfolg oder Misserfolg",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest name", de = "Questname" },
        { ParameterType.Custom, en = "Ended quests", de = "Beendete Quests" },
    },
}

function b_Reprisal_QuestForceInterrupt:GetReprisalTable()

    return { Reprisal.Custom,{self, self.CustomFunction} }

end

function b_Reprisal_QuestForceInterrupt:AddParameter(_Index, _Parameter)

    if (_Index == 0) then
        self.QuestName = _Parameter
    elseif (_Index == 1) then
        self.InterruptEnded = AcceptAlternativeBoolean(_Parameter)
    end

end

function b_Reprisal_QuestForceInterrupt:GetCustomData( _Index )
    local Data = {}
    if _Index == 1 then
        table.insert( Data, "false" )
        table.insert( Data, "true" )
    else
        assert( false )
    end
    return Data
end
function b_Reprisal_QuestForceInterrupt:CustomFunction(_Quest)
    if (GetQuestID(self.QuestName) ~= nil) then

        local QuestID = GetQuestID(self.QuestName)
        local Quest = Quests[QuestID]
        if self.InterruptEnded or Quest.State ~= QuestState.Over then
            Quest:Interrupt()
        end
    end
end

function b_Reprisal_QuestForceInterrupt:Debug(_Quest)
    if not Quests[GetQuestID(self.QuestName)] then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": quest "..  self.QuestName .. " does not exist!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Reprisal_QuestForceInterrupt);

-- -------------------------------------------------------------------------- --

---
-- Ändert den Wert einer benutzerdefinierten Variable.
--
-- Benutzerdefinierte Variablen können ausschließlich Zahlen sein. Nutze
-- dieses Behavior bevor die Variable in einem Goal oder Trigger abgefragt
-- wird, um sie zu initialisieren!
--
---- &#x3C;p&#x3E;Operatoren&#x3C;/p&#x3E;
-- &#x3C;ul&#x3E;
-- &#x3C;li&#x3E;= - Variablenwert wird auf den Wert gesetzt&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;- - Variablenwert mit Wert Subtrahieren&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;+ - Variablenwert mit Wert addieren&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;* - Variablenwert mit Wert multiplizieren&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;/ - Variablenwert mit Wert dividieren&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;^ - Variablenwert mit Wert potenzieren&#x3C;/li&#x3E;
-- &#x3C;/ul&#x3E;
--
-- @param _Name     Name der Variable
-- @param _Operator Rechen- oder Zuweisungsoperator
-- @param _Value    Wert oder andere Custom Variable
--
-- @within Reprisal
--
function Reprisal_CustomVariables(...)
    return b_Reprisal_CustomVariables:new(...);
end

b_Reprisal_CustomVariables = {
    Name = "Reprisal_CustomVariables",
    Description = {
        en = "Reprisal: Executes a mathematical operation with this variable. The other operand can be a number or another custom variable.",
        de = "Vergeltung: Fuehrt eine mathematische Operation mit der Variable aus. Der andere Operand kann eine Zahl oder eine Custom-Varible sein.",
    },
    Parameter = {
        { ParameterType.Default, en = "Name of variable", de = "Variablenname" },
        { ParameterType.Custom,  en = "Operator", de = "Operator" },
        { ParameterType.Default,  en = "Value or variable", de = "Wert oder Variable" }
    }
};

function b_Reprisal_CustomVariables:GetReprisalTable()
    return { Reprisal.Custom, {self, self.CustomFunction} };
end

function b_Reprisal_CustomVariables:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        self.VariableName = _Parameter
    elseif _Index == 1 then
        self.Operator = _Parameter
    elseif _Index == 2 then
        local value = tonumber(_Parameter);
        value = (value ~= nil and value) or tostring(_Parameter);
        self.Value = value
    end
end

function b_Reprisal_CustomVariables:CustomFunction()
    _G["QSB_CustomVariables_"..self.VariableName] = _G["QSB_CustomVariables_"..self.VariableName] or 0;
    local oldValue = _G["QSB_CustomVariables_"..self.VariableName];

    if self.Operator == "=" then
        _G["QSB_CustomVariables_"..self.VariableName] = (type(self.Value) ~= "string" and self.Value) or _G["QSB_CustomVariables_"..self.Value];
    elseif self.Operator == "+" then
        _G["QSB_CustomVariables_"..self.VariableName] = oldValue + (type(self.Value) ~= "string" and self.Value) or _G["QSB_CustomVariables_"..self.Value];
    elseif self.Operator == "-" then
        _G["QSB_CustomVariables_"..self.VariableName] = oldValue - (type(self.Value) ~= "string" and self.Value) or _G["QSB_CustomVariables_"..self.Value];
    elseif self.Operator == "*" then
        _G["QSB_CustomVariables_"..self.VariableName] = oldValue * (type(self.Value) ~= "string" and self.Value) or _G["QSB_CustomVariables_"..self.Value];
    elseif self.Operator == "/" then
        _G["QSB_CustomVariables_"..self.VariableName] = oldValue / (type(self.Value) ~= "string" and self.Value) or _G["QSB_CustomVariables_"..self.Value];
    elseif self.Operator == "^" then
        _G["QSB_CustomVariables_"..self.VariableName] = oldValue ^ (type(self.Value) ~= "string" and self.Value) or _G["QSB_CustomVariables_"..self.Value];

    end
end

function b_Reprisal_CustomVariables:GetCustomData( _Index )
    return {"=", "+", "-", "*", "/", "^"};
end

function b_Reprisal_CustomVariables:Debug(_Quest)
    local operators = {"=", "+", "-", "*", "/", "^"};
    if not Inside(self.Operator,operators) then
        fatal(_Quest.Identifier.." "..self.Name..": got an invalid operator!");
        return true;
    elseif self.VariableName == "" then
        fatal(_Quest.Identifier.." "..self.Name..": missing name for variable!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Reprisal_CustomVariables)

-- -------------------------------------------------------------------------- --

---
-- Führt eine Funktion im Skript als Reprisal aus.
--
-- Wird ein Funktionsname als String übergeben, wird die Funktion mit den
-- Daten des Behavors und des zugehörigen Quest aufgerufen (Standard).
--
-- Wird eine Funktionsreferenz angegeben, wird die Funktion zusammen mit allen
-- optionalen Parametern aufgerufen, als sei es ein gewöhnlicher Aufruf im
-- Skript.
-- &#x3C;pre&#x3E; Reprisal_MapScriptFunction(ReplaceEntity, "block", Entities.XD_ScriptEntity);
-- -- entspricht: ReplaceEntity("block", Entities.XD_ScriptEntity);&#x3C;/pre&#x3E;
-- &#x3C;b&#x3E;Achtung:&#x3C;/b&#x3E; Nicht über den Assistenten verfügbar!
--
-- @param _Function Name der Funktion oder Funktionsreferenz
--
-- @within Reprisal
--
function Reprisal_MapScriptFunction(...)
    return b_Reprisal_MapScriptFunction:new(...);
end

b_Reprisal_MapScriptFunction = {
    Name = "Reprisal_MapScriptFunction",
    Description = {
        en = "Reprisal: Calls a function within the global map script if the quest has failed.",
        de = "Vergeltung: Ruft eine Funktion im globalen Kartenskript auf, wenn die Quest fehlschlägt.",
    },
    Parameter = {
        { ParameterType.Default, en = "Function name", de = "Funktionsname" },
    },
}

function b_Reprisal_MapScriptFunction:GetReprisalTable()
    return {Reprisal.Custom, {self, self.CustomFunction}};
end

function b_Reprisal_MapScriptFunction:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        self.FuncName = _Parameter;
    end
end

function b_Reprisal_MapScriptFunction:CustomFunction(_Quest)
    if type(self.FuncName) == "function" then
        self.Function(unpack(self.i47ya_6aghw_frxil));
        return;
    end
    _G[self.FuncName](self, _Quest);
end

function b_Reprisal_MapScriptFunction:Debug(_Quest)
    if not self.FuncName then
        fatal(_Quest.Identifier.." "..self.Name..": function reference is invalid!");
        return true;
    end
    if type(self.FuncName) == "string" and not _G[self.FuncName] then
        fatal(_Quest.Identifier.." "..self.Name..": function does not exist!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Reprisal_MapScriptFunction);

-- -------------------------------------------------------------------------- --

---
-- Erlaubt oder verbietet einem Spieler ein Recht.
--
-- @param _PlayerID   ID des Spielers
-- @param _Lock       Sperren/Entsperren
-- @param _Technology Name des Rechts
--
-- @within Reprisal
--
function Reprisal_Technology(...)
    return b_Reprisal_Technology:new(...);
end

b_Reprisal_Technology = {
    Name = "Reprisal_Technology",
    Description = {
        en = "Reprisal: Locks or unlocks a technology for the given player",
        de = "Vergeltung: Sperrt oder erlaubt eine Technolgie fuer den angegebenen Player",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "PlayerID", de = "SpielerID" },
        { ParameterType.Custom,   en = "Un / Lock", de = "Sperren/Erlauben" },
        { ParameterType.Custom,   en = "Technology", de = "Technologie" },
    },
}

function b_Reprisal_Technology:GetReprisalTable()
    return { Reprisal.Custom, {self, self.CustomFunction} }
end

function b_Reprisal_Technology:AddParameter(_Index, _Parameter)
    if (_Index ==0) then
        self.PlayerID = _Parameter*1
    elseif (_Index == 1) then
        self.LockType = _Parameter == "Lock"
    elseif (_Index == 2) then
        self.Technology = _Parameter
    end
end

function b_Reprisal_Technology:CustomFunction(_Quest)
    if self.PlayerID
    and Logic.GetStoreHouse(self.PlayerID) ~= 0
    and Technologies[self.Technology]
    then
        if self.LockType  then
            LockFeaturesForPlayer(self.PlayerID, Technologies[self.Technology])
        else
            UnLockFeaturesForPlayer(self.PlayerID, Technologies[self.Technology])
        end
    else
        return false
    end
end

function b_Reprisal_Technology:GetCustomData(_Index)
    local Data = {}
    if (_Index == 1) then
        Data[1] = "Lock"
        Data[2] = "UnLock"
    elseif (_Index == 2) then
        for k, v in pairs( Technologies ) do
            table.insert( Data, k )
        end
    end
    return Data
end

function b_Reprisal_Technology:Debug(_Quest)
    if not Technologies[self.Technology] then
        fatal("".._Quest.Identifier.." "..self.Name..": got an invalid technology type!");
        return true;
    elseif tonumber(self.PlayerID) == nil or self.PlayerID &#x3C; 1 or self.PlayerID &#x3E; 8 then
        fatal("".._Quest.Identifier.." "..self.Name..": got an invalid playerID!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Reprisal_Technology);

-- -------------------------------------------------------------------------- --
-- Rewards                                                                    --
-- -------------------------------------------------------------------------- --

---
-- Deaktiviert ein interaktives Objekt
--
-- @param _ScriptName Skriptname des interaktiven Objektes
--
-- @within Reward
--
function Reward_ObjectDeactivate(...)
    return b_Reward_ObjectDeactivate:new(...);
end

b_Reward_ObjectDeactivate = API.InstanceTable(b_Reprisal_ObjectDeactivate);
b_Reward_ObjectDeactivate.Name             = "Reward_ObjectDeactivate";
b_Reward_ObjectDeactivate.Description.de   = "Reward: Deactivates an interactive object";
b_Reward_ObjectDeactivate.Description.en   = "Lohn: Deaktiviert ein interaktives Objekt";
b_Reward_ObjectDeactivate.GetReprisalTable = nil;

b_Reward_ObjectDeactivate.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} }
end

Core:RegisterBehavior(b_Reward_ObjectDeactivate);

-- -------------------------------------------------------------------------- --

---
-- Aktiviert ein interaktives Objekt.
--
-- Der Status bestimmt, wie das objekt aktiviert wird.
-- &#x3C;ul&#x3E;
-- &#x3C;li&#x3E;0: Kann nur mit Helden aktiviert werden&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;1: Kann immer aktiviert werden&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;2: Kann niemals aktiviert werden&#x3C;/li&#x3E;
-- &#x3C;/ul&#x3E;
--
-- @param _ScriptName Skriptname des interaktiven Objektes
-- @param _State Status des Objektes
--
-- @within Reward
--
function Reward_ObjectActivate(...)
    return b_Reward_ObjectActivate:new(...);
end

b_Reward_ObjectActivate = API.InstanceTable(b_Reprisal_ObjectActivate);
b_Reward_ObjectActivate.Name             = "Reward_ObjectActivate";
b_Reward_ObjectActivate.Description.de   = "Reward: Activates an interactive object";
b_Reward_ObjectActivate.Description.en   = "Lohn: Aktiviert ein interaktives Objekt";
b_Reward_ObjectActivate.GetReprisalTable = nil;

b_Reward_ObjectActivate.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} };
end

Core:RegisterBehavior(b_Reward_ObjectActivate);

-- -------------------------------------------------------------------------- --

---
-- Initialisiert ein interaktives Objekt.
--
-- Interaktive Objekte können Kosten und Belohnungen enthalten, müssen sie
-- jedoch nicht. Ist eine Wartezeit angegeben, kann das Objekt erst nach
-- Ablauf eines Cooldowns benutzt werden.
--
-- @param _ScriptName Skriptname des interaktiven Objektes
-- @param _Distance   Entfernung zur Aktivierung
-- @param _Time       Wartezeit bis zur Aktivierung
-- @param _RType1     Warentyp der Belohnung
-- @param _RAmount    Menge der Belohnung
-- @param _CType1     Typ der 1. Ware
-- @param _CAmount1   Menge der 1. Ware
-- @param _CType2     Typ der 2. Ware
-- @param _CAmount2   Menge der 2. Ware
-- @param _Status     Aktivierung (0: Held, 1: immer, 2: niemals)
--
-- @within Reward
--
function Reward_ObjectInit(...)
    return b_Reward_ObjectInit:new(...);
end

b_Reward_ObjectInit = {
    Name = "Reward_ObjectInit",
    Description = {
        en = "Reward: Setup an interactive object with costs and rewards.",
        de = "Lohn: Initialisiert ein interaktives Objekt mit seinen Kosten und Schätzen.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Interactive object",     de = "Interaktives Objekt" },
        { ParameterType.Number,     en = "Distance to use",     de = "Nutzungsentfernung" },
        { ParameterType.Number,     en = "Waittime",             de = "Wartezeit" },
        { ParameterType.Custom,     en = "Reward good",         de = "Belohnungsware" },
        { ParameterType.Number,     en = "Reward amount",         de = "Anzahl" },
        { ParameterType.Custom,     en = "Cost good 1",         de = "Kostenware 1" },
        { ParameterType.Number,     en = "Cost amount 1",         de = "Anzahl 1" },
        { ParameterType.Custom,     en = "Cost good 2",         de = "Kostenware 2" },
        { ParameterType.Number,     en = "Cost amount 2",         de = "Anzahl 2" },
        { ParameterType.Custom,     en = "Availability",         de = "Verfï¿½gbarkeit" },
    },
}

function b_Reward_ObjectInit:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function b_Reward_ObjectInit:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptName = _Parameter
    elseif (_Index == 1) then
        self.Distance = _Parameter * 1
    elseif (_Index == 2) then
        self.Waittime = _Parameter * 1
    elseif (_Index == 3) then
        self.RewardType = _Parameter
    elseif (_Index == 4) then
        self.RewardAmount = _Parameter * 1
    elseif (_Index == 5) then
        self.FirstCostType = _Parameter
    elseif (_Index == 6) then
        self.FirstCostAmount = _Parameter * 1
    elseif (_Index == 7) then
        self.SecondCostType = _Parameter
    elseif (_Index == 8) then
        self.SecondCostAmount = _Parameter * 1
    elseif (_Index == 9) then
        local parameter = nil
        if _Parameter == "Always" or _Parameter == 1 then
            parameter = 1
        elseif _Parameter == "Never" or _Parameter == 2 then
            parameter = 2
        elseif _Parameter == "Knight only" or _Parameter == 0 then
            parameter = 0
        end
        self.UsingState = parameter
    end
end

function b_Reward_ObjectInit:CustomFunction(_Quest)
    local eID = GetID(self.ScriptName);
    if eID == 0 then
        return;
    end
    QSB.InitalizedObjekts[eID] = _Quest.Identifier;

    Logic.InteractiveObjectClearCosts(eID);
    Logic.InteractiveObjectClearRewards(eID);

    Logic.InteractiveObjectSetInteractionDistance(eID, self.Distance);
    Logic.InteractiveObjectSetTimeToOpen(eID, self.Waittime);

    if self.RewardType and self.RewardType ~= "-" then
        Logic.InteractiveObjectAddRewards(eID, Goods[self.RewardType], self.RewardAmount);
    end
    if self.FirstCostType and self.FirstCostType ~= "-" then
        Logic.InteractiveObjectAddCosts(eID, Goods[self.FirstCostType], self.FirstCostAmount);
    end
    if self.SecondCostType and self.SecondCostType ~= "-" then
        Logic.InteractiveObjectAddCosts(eID, Goods[self.SecondCostType], self.SecondCostAmount);
    end

    Logic.InteractiveObjectSetAvailability(eID,true);
    if self.UsingState then
        for i=1, 8 do
            Logic.InteractiveObjectSetPlayerState(eID,i, self.UsingState);
        end
    end

    Logic.InteractiveObjectSetRewardResourceCartType(eID,Entities.U_ResourceMerchant);
    Logic.InteractiveObjectSetRewardGoldCartType(eID,Entities.U_GoldCart);
    Logic.InteractiveObjectSetCostResourceCartType(eID,Entities.U_ResourceMerchant);
    Logic.InteractiveObjectSetCostGoldCartType(eID, Entities.U_GoldCart);
    RemoveInteractiveObjectFromOpenedList(eID);
    table.insert(HiddenTreasures,eID);
end

function b_Reward_ObjectInit:GetCustomData( _Index )
    if _Index == 3 or _Index == 5 or _Index == 7 then
        local Data = {
            "-",
            "G_Beer",
            "G_Bread",
            "G_Broom",
            "G_Carcass",
            "G_Cheese",
            "G_Clothes",
            "G_Dye",
            "G_Gold",
            "G_Grain",
            "G_Herb",
            "G_Honeycomb",
            "G_Iron",
            "G_Leather",
            "G_Medicine",
            "G_Milk",
            "G_RawFish",
            "G_Salt",
            "G_Sausage",
            "G_SmokedFish",
            "G_Soap",
            "G_Stone",
            "G_Water",
            "G_Wood",
            "G_Wool",
        }

        if g_GameExtraNo &#x3E;= 1 then
            Data[#Data+1] = "G_Gems"
            Data[#Data+1] = "G_MusicalInstrument"
            Data[#Data+1] = "G_Olibanum"
        end
        return Data
    elseif _Index == 9 then
        return {"-", "Knight only", "Always", "Never",}
    end
end

function b_Reward_ObjectInit:Debug(_Quest)
    if Logic.IsInteractiveObject(GetID(self.ScriptName)) == false then
        fatal("".._Quest.Identifier.." "..self.Name..": '"..self.ScriptName.."' is not a interactive object!");
        return true;
    end
    if self.UsingState ~= 1 and self.Distance &#x3C; 50 then
        warn("".._Quest.Identifier.." "..self.Name..": distance is maybe too short!");
    end
    if self.Waittime &#x3C; 0 then
        fatal("".._Quest.Identifier.." "..self.Name..": waittime must be equal or greater than 0!");
        return true;
    end
    if self.RewardType and self.RewardType ~= "-" then
        if not Goods[self.RewardType] then
            fatal("".._Quest.Identifier.." "..self.Name..": '"..self.RewardType.."' is invalid good type!");
            return true;
        elseif self.RewardAmount &#x3C; 1 then
            fatal("".._Quest.Identifier.." "..self.Name..": amount can not be 0 or negative!");
            return true;
        end
    end
    if self.FirstCostType and self.FirstCostType ~= "-" then
        if not Goods[self.FirstCostType] then
            fatal("".._Quest.Identifier.." "..self.Name..": '"..self.FirstCostType.."' is invalid good type!");
            return true;
        elseif self.FirstCostAmount &#x3C; 1 then
            fatal("".._Quest.Identifier.." "..self.Name..": amount can not be 0 or negative!");
            return true;
        end
    end
    if self.SecondCostType and self.SecondCostType ~= "-" then
        if not Goods[self.SecondCostType] then
            fatal("".._Quest.Identifier.." "..self.Name..": '"..self.SecondCostType.."' is invalid good type!");
            return true;
        elseif self.SecondCostAmount &#x3C; 1 then
            fatal("".._Quest.Identifier.." "..self.Name..": amount can not be 0 or negative!");
            return true;
        end
    end
    return false;
end

Core:RegisterBehavior(b_Reward_ObjectInit);

-- -------------------------------------------------------------------------- --

---
-- Änder den Diplomatiestatus zwischen zwei Spielern.
--
-- @param _Party1   ID der ersten Partei
-- @param _Party2   ID der zweiten Partei
-- @param _State    Neuer Diplomatiestatus
--
-- @within Reward
--
function Reward_Diplomacy(...)
    return b_Reward_Diplomacy:new(...);
end

b_Reward_Diplomacy = API.InstanceTable(b_Reprisal_Diplomacy);
b_Reward_Diplomacy.Name             = "Reward_Diplomacy";
b_Reward_Diplomacy.Description.de   = "Reward: Sets Diplomacy state of two Players to a stated value.";
b_Reward_Diplomacy.Description.en   = "Lohn: Setzt den Diplomatiestatus zweier Spieler auf den angegebenen Wert.";
b_Reward_Diplomacy.GetReprisalTable = nil;

b_Reward_Diplomacy.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} }
end

Core:RegisterBehavior(b_Reward_Diplomacy);

-- -------------------------------------------------------------------------- --

---
-- Verbessert die diplomatischen Beziehungen zwischen Sender und Empfänger
-- um einen Grad.
--
-- @within Reward
--
function Reward_DiplomacyIncrease()
    return b_Reward_DiplomacyIncrease:new();
end

b_Reward_DiplomacyIncrease = {
    Name = "Reward_DiplomacyIncrease",
    Description = {
        en = "Reward: Diplomacy increases slightly to another player",
        de = "Lohn: Verbesserug des Diplomatiestatus zu einem anderen Spieler",
    },
}

function b_Reward_DiplomacyIncrease:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function b_Reward_DiplomacyIncrease:CustomFunction(_Quest)
    local Sender = _Quest.SendingPlayer;
    local Receiver = _Quest.ReceivingPlayer;
    local State = GetDiplomacyState(Receiver, Sender);
    if State &#x3C; 2 then
        SetDiplomacyState(Receiver, Sender, State+1);
    end
end

function b_Reward_DiplomacyIncrease:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    end
end

Core:RegisterBehavior(b_Reward_DiplomacyIncrease);

-- -------------------------------------------------------------------------- --

---
-- Erzeugt Handelsangebote im Lagerhaus des angegebenen Spielers.
--
-- Sollen Angebote gelöscht werden, muss "-" als Ware ausgewählt werden.
--
-- &#x3C;b&#x3E;Achtung:&#x3C;/b&#x3E; Stadtlagerhäuser können keine Söldner anbieten!
--
-- @param _PlayerID Partei, die Anbietet
-- @param _Amount1  Menge des 1. Angebot
-- @param _Type1    Ware oder Typ des 1. Angebot
-- @param _Amount2  Menge des 2. Angebot
-- @param _Type2    Ware oder Typ des 2. Angebot
-- @param _Amount3  Menge des 3. Angebot
-- @param _Type3    Ware oder Typ des 3. Angebot
-- @param _Amount4  Menge des 4. Angebot
-- @param _Type4    Ware oder Typ des 4. Angebot
--
-- @within Reward
--
function Reward_TradeOffers(...)
    return b_Reward_TradeOffers:new(...);
end

b_Reward_TradeOffers = {
    Name = "Reward_TradeOffers",
    Description = {
        en = "Reward: Deletes all existing offers for a merchant and sets new offers, if given",
        de = "Lohn: Löscht alle Angebote eines Händlers und setzt neue, wenn angegeben",
    },
    Parameter = {
        { ParameterType.Custom, en = "PlayerID", de = "PlayerID" },
        { ParameterType.Custom, en = "Amount 1", de = "Menge 1" },
        { ParameterType.Custom, en = "Offer 1", de = "Angebot 1" },
        { ParameterType.Custom, en = "Amount 2", de = "Menge 2" },
        { ParameterType.Custom, en = "Offer 2", de = "Angebot 2" },
        { ParameterType.Custom, en = "Amount 3", de = "Menge 3" },
        { ParameterType.Custom, en = "Offer 3", de = "Angebot 3" },
        { ParameterType.Custom, en = "Amount 4", de = "Menge 4" },
        { ParameterType.Custom, en = "Offer 4", de = "Angebot 4" },
    },
}

function b_Reward_TradeOffers:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function b_Reward_TradeOffers:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter
    elseif (_Index == 1) then
        _Parameter = _Parameter or 0;
        self.AmountOffer1 = _Parameter * 1;
    elseif (_Index == 2) then
        self.Offer1 = _Parameter
    elseif (_Index == 3) then
        _Parameter = _Parameter or 0;
        self.AmountOffer2 = _Parameter * 1;
    elseif (_Index == 4) then
        self.Offer2 = _Parameter
    elseif (_Index == 5) then
        _Parameter = _Parameter or 0;
        self.AmountOffer3 = _Parameter * 1;
    elseif (_Index == 6) then
        self.Offer3 = _Parameter
    elseif (_Index == 7) then
        _Parameter = _Parameter or 0;
        self.AmountOffer4 = _Parameter * 1;
    elseif (_Index == 8) then
        self.Offer4 = _Parameter
    end
end

function b_Reward_TradeOffers:CustomFunction()
    if (self.PlayerID &#x3E; 1) and (self.PlayerID &#x3C; 9) then
        local Storehouse = Logic.GetStoreHouse(self.PlayerID)
        Logic.RemoveAllOffers(Storehouse)
        for i =  1,4 do
            if self["Offer"..i] and self["Offer"..i] ~= "-" then
                if Goods[self["Offer"..i]] then
                    AddOffer(Storehouse, self["AmountOffer"..i], Goods[self["Offer"..i]])
                elseif Logic.IsEntityTypeInCategory(Entities[self["Offer"..i]], EntityCategories.Military) == 1 then
                    AddMercenaryOffer(Storehouse, self["AmountOffer"..i], Entities[self["Offer"..i]])
                else
                    AddEntertainerOffer (Storehouse , Entities[self["Offer"..i]])
                end
            end
        end
    end
end

function b_Reward_TradeOffers:Debug(_Quest)
    if Logic.GetStoreHouse(self.PlayerID ) == 0 then
        fatal(_Quest.Identifier .. ": Error in " .. self.Name .. ": Player " .. self.PlayerID .. " is dead. :-(")
        return true
    end
end

function b_Reward_TradeOffers:GetCustomData(_Index)
    local Players = { "2", "3", "4", "5", "6", "7", "8" }
    local Amount = { "1", "2", "3", "4", "5", "6", "7", "8", "9" }
    local Offers = {"-",
                    "G_Beer",
                    "G_Bow",
                    "G_Bread",
                    "G_Broom",
                    "G_Candle",
                    "G_Carcass",
                    "G_Cheese",
                    "G_Clothes",
                    "G_Cow",
                    "G_Grain",
                    "G_Herb",
                    "G_Honeycomb",
                    "G_Iron",
                    "G_Leather",
                    "G_Medicine",
                    "G_Milk",
                    "G_RawFish",
                    "G_Sausage",
                    "G_Sheep",
                    "G_SmokedFish",
                    "G_Soap",
                    "G_Stone",
                    "G_Sword",
                    "G_Wood",
                    "G_Wool",
                    "G_Salt",
                    "G_Dye",
                    "U_AmmunitionCart",
                    "U_BatteringRamCart",
                    "U_CatapultCart",
                    "U_SiegeTowerCart",
                    "U_MilitaryBandit_Melee_ME",
                    "U_MilitaryBandit_Melee_SE",
                    "U_MilitaryBandit_Melee_NA",
                    "U_MilitaryBandit_Melee_NE",
                    "U_MilitaryBandit_Ranged_ME",
                    "U_MilitaryBandit_Ranged_NA",
                    "U_MilitaryBandit_Ranged_NE",
                    "U_MilitaryBandit_Ranged_SE",
                    "U_MilitaryBow_RedPrince",
                    "U_MilitaryBow",
                    "U_MilitarySword_RedPrince",
                    "U_MilitarySword",
                    "U_Entertainer_NA_FireEater",
                    "U_Entertainer_NA_StiltWalker",
                    "U_Entertainer_NE_StrongestMan_Barrel",
                    "U_Entertainer_NE_StrongestMan_Stone",
                    }
    if g_GameExtraNo and g_GameExtraNo &#x3E;= 1 then
        table.insert(Offers, "G_Gems")
        table.insert(Offers, "G_Olibanum")
        table.insert(Offers, "G_MusicalInstrument")
        table.insert(Offers, "G_MilitaryBandit_Ranged_AS")
        table.insert(Offers, "G_MilitaryBandit_Melee_AS")
        table.insert(Offers, "U_MilitarySword_Khana")
        table.insert(Offers, "U_MilitaryBow_Khana")
    end
    if (_Index == 0) then
        return Players
    elseif (_Index == 1) or (_Index == 3) or (_Index == 5) or (_Index == 7) then
        return Amount
    elseif (_Index == 2) or (_Index == 4) or (_Index == 6) or (_Index == 8) then
        return Offers
    end
end

Core:RegisterBehavior(b_Reward_TradeOffers)

-- -------------------------------------------------------------------------- --

---
-- Ein benanntes Entity wird entfernt.
--
-- &#x3C;b&#x3E;Hinweis&#x3C;/b&#x3E;: Das Entity wird durch ein XD_ScriptEntity ersetzt. Es
-- behält Name, Besitzer und Ausrichtung.
--
-- @param _ScriptName Skriptname des Entity
--
-- @within Reward
--
function Reward_DestroyEntity(...)
    return b_Reward_DestroyEntity:new(...);
end

b_Reward_DestroyEntity = API.InstanceTable(b_Reprisal_DestroyEntity);
b_Reward_DestroyEntity.Name = "Reward_DestroyEntity";
b_Reward_DestroyEntity.Description.en = "Reward: Replaces an entity with an invisible script entity, which retains the entities name.";
b_Reward_DestroyEntity.Description.de = "Lohn: Ersetzt eine Entity mit einer unsichtbaren Script-Entity, die den Namen übernimmt.";
b_Reward_DestroyEntity.GetReprisalTable = nil;

b_Reward_DestroyEntity.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} }
end

Core:RegisterBehavior(b_Reward_DestroyEntity);

-- -------------------------------------------------------------------------- --

---
-- Zerstört einen über ein Behavior erzeugten Effekt.
--
-- @param _EffectName Name des Effekts
--
-- @within Reward
--
function Reward_DestroyEffect(...)
    return b_Reward_DestroyEffect:new(...);
end

b_Reward_DestroyEffect = API.InstanceTable(b_Reprisal_DestroyEffect);
b_Reward_DestroyEffect.Name = "Reward_DestroyEffect";
b_Reward_DestroyEffect.Description.en = "Reward: Destroys an effect.";
b_Reward_DestroyEffect.Description.de = "Lohn: Zerstört einen Effekt.";
b_Reward_DestroyEffect.GetReprisalTable = nil;

b_Reward_DestroyEffect.GetRewardTable = function(self, _Quest)
    return { Reward.Custom, { self, self.CustomFunction } };
end

Core:RegisterBehavior(b_Reward_DestroyEffect);

-- -------------------------------------------------------------------------- --

---
-- Ersetzt ein Entity mit einem Batallion.
--
-- Ist die Position ein Gebäude, werden die Battalione am Eingang erzeugt und
-- Das Entity wird nicht ersetzt.
--
-- Das erzeugte Battalion kann vor der KI des Besitzers versteckt werden.
--
-- @param _Position    Skriptname des Entity
-- @param _PlayerID    PlayerID des Battalion
-- @param _UnitType    Einheitentyp der Soldaten
-- @param _Orientation Ausrichtung in °
-- @param _Soldiers    Anzahl an Soldaten
-- @param _HideFromAI  Vor KI verstecken
--
-- @within Reward
--
function Reward_CreateBattalion(...)
    return b_Reward_CreateBattalion:new(...);
end

b_Reward_CreateBattalion = {
    Name = "Reward_CreateBattalion",
    Description = {
        en = "Reward: Replaces a script entity with a battalion, which retains the entities name",
        de = "Lohn: Ersetzt eine Script-Entity durch ein Bataillon, welches den Namen der Script-Entity übernimmt",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script entity", de = "Script Entity" },
        { ParameterType.PlayerID, en = "Player", de = "Spieler" },
        { ParameterType.Custom, en = "Type name", de = "Typbezeichnung" },
        { ParameterType.Number, en = "Orientation (in degrees)", de = "Ausrichtung (in Grad)" },
        { ParameterType.Number, en = "Number of soldiers", de = "Anzahl Soldaten" },
        { ParameterType.Custom, en = "Hide from AI", de = "Vor KI verstecken" },
    },
}

function b_Reward_CreateBattalion:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function b_Reward_CreateBattalion:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptNameEntity = _Parameter
    elseif (_Index == 1) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 2) then
        self.UnitKey = _Parameter
    elseif (_Index == 3) then
        self.Orientation = _Parameter * 1
    elseif (_Index == 4) then
        self.SoldierCount = _Parameter * 1
    elseif (_Index == 5) then
        self.HideFromAI = AcceptAlternativeBoolean(_Parameter)
    end
end

function b_Reward_CreateBattalion:CustomFunction(_Quest)
    if not IsExisting( self.ScriptNameEntity ) then
        return false
    end
    local pos = GetPosition(self.ScriptNameEntity)
    local NewID = Logic.CreateBattalionOnUnblockedLand( Entities[self.UnitKey], pos.X, pos.Y, self.Orientation, self.PlayerID, self.SoldierCount )
    local posID = GetID(self.ScriptNameEntity)
    if Logic.IsBuilding(posID) == 0 then
        DestroyEntity(self.ScriptNameEntity)
        Logic.SetEntityName( NewID, self.ScriptNameEntity )
    end
    if self.HideFromAI then
        AICore.HideEntityFromAI( self.PlayerID, NewID, true )
    end
end

function b_Reward_CreateBattalion:GetCustomData( _Index )
    local Data = {}
    if _Index == 2 then
        for k, v in pairs( Entities ) do
            if Logic.IsEntityTypeInCategory( v, EntityCategories.Soldier ) == 1 then
                table.insert( Data, k )
            end
        end
        table.sort( Data )
    elseif _Index == 5 then
        table.insert( Data, "false" )
        table.insert( Data, "true" )
    else
        assert( false )
    end
    return Data
end

function b_Reward_CreateBattalion:Debug(_Quest)
    if not Entities[self.UnitKey] then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": got an invalid entity type!");
        return true;
    elseif not IsExisting(self.ScriptNameEntity) then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": spawnpoint does not exist!");
        return true;
    elseif tonumber(self.PlayerID) == nil or self.PlayerID &#x3C; 1 or self.PlayerID &#x3E; 8 then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": playerID is wrong!");
        return true;
    elseif tonumber(self.Orientation) == nil then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": orientation must be a number!");
        return true;
    elseif tonumber(self.SoldierCount) == nil or self.SoldierCount &#x3C; 1 then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": you can not create a empty batallion!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Reward_CreateBattalion);

-- -------------------------------------------------------------------------- --

---
-- Erzeugt eine Menga von Battalionen an der Position.
--
-- Die erzeugten Battalione können vor der KI ihres Besitzers versteckt werden.
--
-- @param _Amount      Anzahl erzeugter Battalione
-- @param _Position    Skriptname des Entity
-- @param _PlayerID    PlayerID des Battalion
-- @param _UnitType    Einheitentyp der Soldaten
-- @param _Orientation Ausrichtung in °
-- @param _Soldiers    Anzahl an Soldaten
-- @param _HideFromAI  Vor KI verstecken
--
-- @within Reward
--
function Reward_CreateSeveralBattalions(...)
    return b_Reward_CreateSeveralBattalions:new(...);
end

b_Reward_CreateSeveralBattalions = {
    Name = "Reward_CreateSeveralBattalions",
    Description = {
        en = "Reward: Creates a given amount of battalions",
        de = "Lohn: Erstellt eine gegebene Anzahl Bataillone",
    },
    Parameter = {
        { ParameterType.Number, en = "Amount", de = "Anzahl" },
        { ParameterType.ScriptName, en = "Script entity", de = "Script Entity" },
        { ParameterType.PlayerID, en = "Player", de = "Spieler" },
        { ParameterType.Custom, en = "Type name", de = "Typbezeichnung" },
        { ParameterType.Number, en = "Orientation (in degrees)", de = "Ausrichtung (in Grad)" },
        { ParameterType.Number, en = "Number of soldiers", de = "Anzahl Soldaten" },
        { ParameterType.Custom, en = "Hide from AI", de = "Vor KI verstecken" },
    },
}

function b_Reward_CreateSeveralBattalions:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function b_Reward_CreateSeveralBattalions:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Amount = _Parameter * 1
    elseif (_Index == 1) then
        self.ScriptNameEntity = _Parameter
    elseif (_Index == 2) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 3) then
        self.UnitKey = _Parameter
    elseif (_Index == 4) then
        self.Orientation = _Parameter * 1
    elseif (_Index == 5) then
        self.SoldierCount = _Parameter * 1
    elseif (_Index == 6) then
        self.HideFromAI = AcceptAlternativeBoolean(_Parameter)
    end
end

function b_Reward_CreateSeveralBattalions:CustomFunction(_Quest)
    if not IsExisting( self.ScriptNameEntity ) then
        return false
    end
    local tID = GetID(self.ScriptNameEntity)
    local x,y,z = Logic.EntityGetPos(tID);
    if Logic.IsBuilding(tID) == 1 then
        x,y = Logic.GetBuildingApproachPosition(tID)
    end

    for i=1, self.Amount do
        local NewID = Logic.CreateBattalionOnUnblockedLand( Entities[self.UnitKey], x, y, self.Orientation, self.PlayerID, self.SoldierCount )
        Logic.SetEntityName( NewID, self.ScriptNameEntity .. "_" .. i )
        if self.HideFromAI then
            AICore.HideEntityFromAI( self.PlayerID, NewID, true )
        end
    end
end

function b_Reward_CreateSeveralBattalions:GetCustomData( _Index )
    local Data = {}
    if _Index == 3 then
        for k, v in pairs( Entities ) do
            if Logic.IsEntityTypeInCategory( v, EntityCategories.Soldier ) == 1 then
                table.insert( Data, k )
            end
        end
        table.sort( Data )
    elseif _Index == 6 then
        table.insert( Data, "false" )
        table.insert( Data, "true" )
    else
        assert( false )
    end
    return Data
end

function b_Reward_CreateSeveralBattalions:Debug(_Quest)
    if not Entities[self.UnitKey] then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": got an invalid entity type!");
        return true;
    elseif not IsExisting(self.ScriptNameEntity) then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": spawnpoint does not exist!");
        return true;
    elseif tonumber(self.PlayerID) == nil or self.PlayerID &#x3C; 1 or self.PlayerID &#x3E; 8 then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": playerDI is wrong!");
        return true;
    elseif tonumber(self.Orientation) == nil then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": orientation must be a number!");
        return true;
    elseif tonumber(self.SoldierCount) == nil or self.SoldierCount &#x3C; 1 then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": you can not create a empty batallion!");
        return true;
    elseif tonumber(self.Amount) == nil or self.Amount &#x3C; 0 then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": amount can not be negative!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Reward_CreateSeveralBattalions);

-- -------------------------------------------------------------------------- --

---
-- Erzeugt einen Effekt an der angegebenen Position.
--
-- Der Effekt kann über seinen Namen jeder Zeit gelöscht werden.
--
-- &#x3C;b&#x3E;Achtung&#x3C;/b&#x3E;: Feuereffekte sind bekannt dafür Abstürzue zu verursachen.
-- Vermeide sie entweder ganz oder unterbinde das Speichern, solange ein
-- solcher Effekt aktiv ist!
--
-- @param _EffectName  Einzigartiger Effektname
-- @param _TypeName    Typ des Effekt
-- @param _PlayerID    PlayerID des Effekt
-- @param _Location    Position des Effekt
-- @param _Orientation Ausrichtung in °
--
-- @within Reward
--
function Reward_CreateEffect(...)
    return b_Reward_CreateEffect:new(...);
end

b_Reward_CreateEffect = {
    Name = "Reward_CreateEffect",
    Description = {
        en = "Reward: Creates an effect at a specified position",
        de = "Lohn: Erstellt einen Effekt an der angegebenen Position",
    },
    Parameter = {
        { ParameterType.Default,    en = "Effect name", de = "Effektname" },
        { ParameterType.Custom,     en = "Type name", de = "Typbezeichnung" },
        { ParameterType.PlayerID,   en = "Player", de = "Spieler" },
        { ParameterType.ScriptName, en = "Location", de = "Ort" },
        { ParameterType.Number,     en = "Orientation (in degrees)(-1: from locating entity)", de = "Ausrichtung (in Grad)(-1: von Positionseinheit)" },
    }
}

function b_Reward_CreateEffect:AddParameter(_Index, _Parameter)

    if _Index == 0 then
        self.EffectName = _Parameter;
    elseif _Index == 1 then
        self.Type = EGL_Effects[_Parameter];
    elseif _Index == 2 then
        self.PlayerID = _Parameter * 1;
    elseif _Index == 3 then
        self.Location = _Parameter;
    elseif _Index == 4 then
        self.Orientation = _Parameter * 1;
    end

end

function b_Reward_CreateEffect:GetRewardTable()
    return { Reward.Custom, { self, self.CustomFunction } };
end

function b_Reward_CreateEffect:CustomFunction(_Quest)
    if Logic.IsEntityDestroyed(self.Location) then
        return;
    end
    local entity = assert(GetID(self.Location), _Quest.Identifier .. "Error in " .. self.Name .. ": CustomFunction: Entity is invalid");
    if QSB.EffectNameToID[self.EffectName] and Logic.IsEffectRegistered(QSB.EffectNameToID[self.EffectName]) then
        return;
    end

    local posX, posY = Logic.GetEntityPosition(entity);
    local orientation = tonumber(self.Orientation);
    local effect = Logic.CreateEffectWithOrientation(self.Type, posX, posY, orientation, self.PlayerID);
    if self.EffectName ~= "" then
        QSB.EffectNameToID[self.EffectName] = effect;
    end
end

function b_Reward_CreateEffect:Debug(_Quest)
    if QSB.EffectNameToID[self.EffectName] and Logic.IsEffectRegistered(QSB.EffectNameToID[self.EffectName]) then
        fatal("".._Quest.Identifier.." "..self.Name..": effect already exists!");
        return true;
    elseif not IsExisting(self.Location) then
        fatal("".._Quest.Identifier.." "..self.Name..": location '" ..self.Location.. "' is missing!");
        return true;
    elseif self.PlayerID and (self.PlayerID &#x3C; 0 or self.PlayerID &#x3E; 8) then
        fatal("".._Quest.Identifier.." "..self.Name..": invalid playerID!");
        return true;
    elseif tonumber(self.Orientation) == nil then
        fatal("".._Quest.Identifier.." "..self.Name..": invalid orientation!");
        return true;
    end
end

function b_Reward_CreateEffect:GetCustomData(_Index)
    assert(_Index == 1, "Error in " .. self.Name .. ": GetCustomData: Index is invalid.");
    local types = {};
    for k, v in pairs(EGL_Effects) do
        table.insert(types, k);
    end
    table.sort(types);
    return types;
end

Core:RegisterBehavior(b_Reward_CreateEffect);

-- -------------------------------------------------------------------------- --

---
-- Ersetzt ein Entity mit dem Skriptnamen durch ein neues Entity.
--
-- Ist die Position ein Gebäude, werden die Entities am Eingang erzeugt und
-- die Position wird nicht ersetzt.
--
-- Das erzeugte Entity kann vor der KI des Besitzers versteckt werden.
--
-- @param _ScriptName  Skriptname des Entity
-- @param _PlayerID    PlayerID des Effekt
-- @param _TypeName    Typname des Entity
-- @param _Orientation Ausrichtung in °
-- @param _HideFromAI  Vor KI verstecken
--
-- @within Reward
--
function Reward_CreateEntity(...)
    return b_Reward_CreateEntity:new(...);
end

b_Reward_CreateEntity = {
    Name = "Reward_CreateEntity",
    Description = {
        en = "Reward: Replaces an entity by a new one of a given type",
        de = "Lohn: Ersetzt eine Entity durch eine neue gegebenen Typs",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script entity", de = "Script Entity" },
        { ParameterType.PlayerID, en = "Player", de = "Spieler" },
        { ParameterType.Custom, en = "Type name", de = "Typbezeichnung" },
        { ParameterType.Number, en = "Orientation (in degrees)", de = "Ausrichtung (in Grad)" },
        { ParameterType.Custom, en = "Hide from AI", de = "Vor KI verstecken" },
    },
}

function b_Reward_CreateEntity:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function b_Reward_CreateEntity:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptNameEntity = _Parameter
    elseif (_Index == 1) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 2) then
        self.UnitKey = _Parameter
    elseif (_Index == 3) then
        self.Orientation = _Parameter * 1
    elseif (_Index == 4) then
        self.HideFromAI = AcceptAlternativeBoolean(_Parameter)
    end
end

function b_Reward_CreateEntity:CustomFunction(_Quest)
    if not IsExisting( self.ScriptNameEntity ) then
        return false
    end
    local pos = GetPosition(self.ScriptNameEntity)
    local NewID;
    if Logic.IsEntityTypeInCategory( self.UnitKey, EntityCategories.Soldier ) == 1 then
        NewID       = Logic.CreateBattalionOnUnblockedLand( Entities[self.UnitKey], pos.X, pos.Y, self.Orientation, self.PlayerID, 1 )
        local l,s = {Logic.GetSoldiersAttachedToLeader(NewID)}
        Logic.SetOrientation(s,self.Orientation)
    else
        NewID = Logic.CreateEntityOnUnblockedLand( Entities[self.UnitKey], pos.X, pos.Y, self.Orientation, self.PlayerID )
    end
    local posID = GetID(self.ScriptNameEntity)
    if Logic.IsBuilding(posID) == 0 then
        DestroyEntity(self.ScriptNameEntity)
        Logic.SetEntityName( NewID, self.ScriptNameEntity )
    end
    if self.HideFromAI then
        AICore.HideEntityFromAI( self.PlayerID, NewID, true )
    end
end

function b_Reward_CreateEntity:GetCustomData( _Index )
    local Data = {}
    if _Index == 2 then
        for k, v in pairs( Entities ) do
            local name = {"^M_*","^XS_*","^X_*","^XT_*","^Z_*"}
            local found = false;
            for i=1,#name do
                if k:find(name[i]) then
                    found = true;
                    break;
                end
            end
            if not found then
                table.insert( Data, k );
            end
        end
        table.sort( Data )

    elseif _Index == 4 or _Index == 5 then
        table.insert( Data, "false" )
        table.insert( Data, "true" )
    else
        assert( false )
    end
    return Data
end

function b_Reward_CreateEntity:Debug(_Quest)
    if not Entities[self.UnitKey] then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": got an invalid entity type!");
        return true;
    elseif not IsExisting(self.ScriptNameEntity) then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": spawnpoint does not exist!");
        return true;
    elseif tonumber(self.PlayerID) == nil or self.PlayerID &#x3C; 0 or self.PlayerID &#x3E; 8 then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": playerID is not valid!");
        return true;
    elseif tonumber(self.Orientation) == nil then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": orientation must be a number!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Reward_CreateEntity);

-- -------------------------------------------------------------------------- --

---
-- Erzeugt mehrere Entities an der angegebenen Position.
--
-- Die erzeugten Entities können vor der KI ihres Besitzers versteckt werden.
--
-- @param _Amount      Anzahl an Entities
-- @param _ScriptName  Skriptname des Entity
-- @param _PlayerID    PlayerID des Effekt
-- @param _TypeName    Einzigartiger Effektname
-- @param _Orientation Ausrichtung in °
-- @param _HideFromAI  Vor KI verstecken
--
-- @within Reward
--
function Reward_CreateSeveralEntities(...)
    return b_Reward_CreateSeveralEntities:new(...);
end

b_Reward_CreateSeveralEntities = {
    Name = "Reward_CreateSeveralEntities",
    Description = {
        en = "Reward: Creating serveral battalions at the position of a entity. They retains the entities name and a _[index] suffix",
        de = "Lohn: Erzeugt mehrere Entities an der Position der Entity. Sie übernimmt den Namen der Script Entity und den Suffix _[index]",
    },
    Parameter = {
        { ParameterType.Number, en = "Amount", de = "Anzahl" },
        { ParameterType.ScriptName, en = "Script entity", de = "Script Entity" },
        { ParameterType.PlayerID, en = "Player", de = "Spieler" },
        { ParameterType.Custom, en = "Type name", de = "Typbezeichnung" },
        { ParameterType.Number, en = "Orientation (in degrees)", de = "Ausrichtung (in Grad)" },
        { ParameterType.Custom, en = "Hide from AI", de = "Vor KI verstecken" },
    },
}

function b_Reward_CreateSeveralEntities:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function b_Reward_CreateSeveralEntities:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Amount = _Parameter * 1
    elseif (_Index == 1) then
        self.ScriptNameEntity = _Parameter
    elseif (_Index == 2) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 3) then
        self.UnitKey = _Parameter
    elseif (_Index == 4) then
        self.Orientation = _Parameter * 1
    elseif (_Index == 5) then
        self.HideFromAI = AcceptAlternativeBoolean(_Parameter)
    end
end

function b_Reward_CreateSeveralEntities:CustomFunction(_Quest)
    if not IsExisting( self.ScriptNameEntity ) then
        return false
    end
    local pos = GetPosition(self.ScriptNameEntity)
    local NewID;
    for i=1, self.Amount do
        if Logic.IsEntityTypeInCategory( self.UnitKey, EntityCategories.Soldier ) == 1 then
            NewID       = Logic.CreateBattalionOnUnblockedLand( Entities[self.UnitKey], pos.X, pos.Y, self.Orientation, self.PlayerID, 1 )
            local l,s = {Logic.GetSoldiersAttachedToLeader(NewID)}
            Logic.SetOrientation(s,self.Orientation)
        else
            NewID = Logic.CreateEntityOnUnblockedLand( Entities[self.UnitKey], pos.X, pos.Y, self.Orientation, self.PlayerID )
        end
        Logic.SetEntityName( NewID, self.ScriptNameEntity .. "_" .. i )
        if self.HideFromAI then
            AICore.HideEntityFromAI( self.PlayerID, NewID, true )
        end
    end
end

function b_Reward_CreateSeveralEntities:GetCustomData( _Index )
    local Data = {}
    if _Index == 3 then
        for k, v in pairs( Entities ) do
            local name = {"^M_*","^XS_*","^X_*","^XT_*","^Z_*"}
            local found = false;
            for i=1,#name do
                if k:find(name[i]) then
                    found = true;
                    break;
                end
            end
            if not found then
                table.insert( Data, k );
            end
        end
        table.sort( Data )

    elseif _Index == 5 or _Index == 6 then
        table.insert( Data, "false" )
        table.insert( Data, "true" )
    else
        assert( false )
    end
    return Data

end

function b_Reward_CreateSeveralEntities:Debug(_Quest)
    if not Entities[self.UnitKey] then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": got an invalid entity type!");
        return true;
    elseif not IsExisting(self.ScriptNameEntity) then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": spawnpoint does not exist!");
        return true;
    elseif tonumber(self.PlayerID) == nil or self.PlayerID &#x3C; 1 or self.PlayerID &#x3E; 8 then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": spawnpoint does not exist!");
        return true;
    elseif tonumber(self.Orientation) == nil then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": orientation must be a number!");
        return true;
    elseif tonumber(self.Amount) == nil or self.Amount &#x3C; 0 then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": amount can not be negative!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Reward_CreateSeveralEntities);

-- -------------------------------------------------------------------------- --

---
-- Bewegt einen Siedler, einen Helden oder ein Battalion zum angegebenen 
-- Zielort.
--
-- @param _Settler     Einheit, die bewegt wird
-- @param _Destination Bewegungsziel
--
-- @within Reward
--
function Reward_MoveSettler(...)
    return b_Reward_MoveSettler:new(...);
end

b_Reward_MoveSettler = {
    Name = "Reward_MoveSettler",
    Description = {
        en = "Reward: Moves a (NPC) settler to a destination. Must not be AI controlled, or it won't move",
        de = "Lohn: Bewegt einen (NPC) Siedler zu einem Zielort. Darf keinem KI Spieler gehören, ansonsten wird sich der Siedler nicht bewegen",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Settler", de = "Siedler" },
        { ParameterType.ScriptName, en = "Destination", de = "Ziel" },
    },
}

function b_Reward_MoveSettler:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function b_Reward_MoveSettler:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptNameUnit = _Parameter
    elseif (_Index == 1) then
        self.ScriptNameDest = _Parameter
    end
end

function b_Reward_MoveSettler:CustomFunction(_Quest)
    if Logic.IsEntityDestroyed( self.ScriptNameUnit ) or Logic.IsEntityDestroyed( self.ScriptNameDest ) then
        return false
    end
    local DestID = GetID( self.ScriptNameDest )
    local DestX, DestY = Logic.GetEntityPosition( DestID )
    if Logic.IsBuilding( DestID ) == 1 then
        DestX, DestY = Logic.GetBuildingApproachPosition( DestID )
    end
    Logic.MoveSettler( GetID( self.ScriptNameUnit ), DestX, DestY )
end

function b_Reward_MoveSettler:Debug(_Quest)
    if not IsExisting(self.ScriptNameUnit) then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": mover entity does not exist!");
        return true;
    elseif not IsExisting(self.ScriptNameDest) then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": destination does not exist!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Reward_MoveSettler);

-- -------------------------------------------------------------------------- --

---
-- Der Spieler gewinnt das Spiel.
--
-- @within Reward
--
function Reward_Victory()
    return b_Reward_Victory:new()
end

b_Reward_Victory = {
    Name = "Reward_Victory",
    Description = {
        en = "Reward: The player wins the game.",
        de = "Lohn: Der Spieler gewinnt das Spiel.",
    },
}

function b_Reward_Victory:GetRewardTable()
    return {Reward.Victory};
end

Core:RegisterBehavior(b_Reward_Victory);

-- -------------------------------------------------------------------------- --

---
-- Der Spieler verliert das Spiel.
--
--
-- @within Reward
--
function Reward_Defeat()
    return b_Reward_Defeat:new()
end

b_Reward_Defeat = {
    Name = "Reward_Defeat",
    Description = {
        en = "Reward: The player loses the game.",
        de = "Lohn: Der Spieler verliert das Spiel.",
    },
}

function b_Reward_Defeat:GetRewardTable()
    return { Reward.Custom, {self, self.CustomFunction} }
end

function b_Reward_Defeat:CustomFunction(_Quest)
    _Quest:TerminateEventsAndStuff()
    Logic.ExecuteInLuaLocalState("GUI_Window.MissionEndScreenSetVictoryReasonText(".. g_VictoryAndDefeatType.DefeatMissionFailed ..")")
    Defeated(_Quest.ReceivingPlayer)
end

Core:RegisterBehavior(b_Reward_Defeat);

-- -------------------------------------------------------------------------- --

---
-- Zeigt die Siegdekoration an dem Quest an.
--
-- Dies ist reine Optik! Der Spieler wird dadurch nicht das Spiel gewinnen.
--
-- @within Reward
--
function Reward_FakeVictory()
    return b_Reward_FakeVictory:new();
end

b_Reward_FakeVictory = {
    Name = "Reward_FakeVictory",
    Description = {
        en = "Reward: Display a victory icon for a quest",
        de = "Lohn: Zeigt ein Siegesicon fuer diese Quest",
    },
}

function b_Reward_FakeVictory:GetRewardTable()
    return { Reward.FakeVictory }
end

Core:RegisterBehavior(b_Reward_FakeVictory);

-- -------------------------------------------------------------------------- --

---
-- Erzeugt eine Armee, die das angegebene Territorium angreift.
--
-- Die Armee wird versuchen Gebäude auf dem Territrium zu zerstören.
-- &#x3C;ul&#x3E;
-- &#x3C;li&#x3E;Außenposten: Die Armee versucht den Außenposten zu zerstören&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;Stadt: Die Armee versucht das Lagerhaus zu zerstören&#x3C;/li&#x3E;
-- &#x3C;/ul&#x3E;
--
-- @param _PlayerID   PlayerID der Angreifer
-- @param _SpawnPoint Skriptname des Entstehungspunkt
-- @param _Territory  Zielterritorium
-- @param _Sword      Anzahl Schwertkämpfer (Battalion)
-- @param _Bow        Anzahl Bogenschützen (Battalion)
-- @param _Cata       Anzahl Katapulte
-- @param _Towers     Anzahl Belagerungstürme
-- @param _Rams       Anzahl Rammen
-- @param _Ammo       Anzahl Munitionswagen
-- @param _Type       Typ der Soldaten
-- @param _Reuse      Freie Truppen wiederverwenden
--
-- @within Reward
--
function Reward_AI_SpawnAndAttackTerritory(...)
    return b_Reward_AI_SpawnAndAttackTerritory:new(...);
end

b_Reward_AI_SpawnAndAttackTerritory = {
    Name = "Reward_AI_SpawnAndAttackTerritory",
    Description = {
        en = "Reward: Spawns AI troops and attacks a territory (Hint: Use for hidden quests as a surprise)",
        de = "Lohn: Erstellt KI Truppen und greift ein Territorium an (Tipp: Fuer eine versteckte Quest als Ueberraschung verwenden)",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "AI Player", de = "KI Spieler" },
        { ParameterType.ScriptName, en = "Spawn point", de = "Erstellungsort" },
        { ParameterType.TerritoryName, en = "Territory", de = "Territorium" },
        { ParameterType.Number, en = "Sword", de = "Schwert" },
        { ParameterType.Number, en = "Bow", de = "Bogen" },
        { ParameterType.Number, en = "Catapults", de = "Katapulte" },
        { ParameterType.Number, en = "Siege towers", de = "Belagerungstuerme" },
        { ParameterType.Number, en = "Rams", de = "Rammen" },
        { ParameterType.Number, en = "Ammo carts", de = "Munitionswagen" },
        { ParameterType.Custom, en = "Soldier type", de = "Soldatentyp" },
        { ParameterType.Custom, en = "Reuse troops", de = "Verwende bestehende Truppen" },
    },
}

function b_Reward_AI_SpawnAndAttackTerritory:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function b_Reward_AI_SpawnAndAttackTerritory:AddParameter(_Index, _Parameter)

    if (_Index == 0) then
        self.AIPlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.Spawnpoint = _Parameter
    elseif (_Index == 2) then
        self.TerritoryID = tonumber(_Parameter)
        if not self.TerritoryID then
            self.TerritoryID = GetTerritoryIDByName(_Parameter)
        end
    elseif (_Index == 3) then
        self.NumSword = _Parameter * 1
    elseif (_Index == 4) then
        self.NumBow = _Parameter * 1
    elseif (_Index == 5) then
        self.NumCatapults = _Parameter * 1
    elseif (_Index == 6) then
        self.NumSiegeTowers = _Parameter * 1
    elseif (_Index == 7) then
        self.NumRams = _Parameter * 1
    elseif (_Index == 8) then
        self.NumAmmoCarts = _Parameter * 1
    elseif (_Index == 9) then
        if _Parameter == "Normal" or _Parameter == false then
            self.TroopType = false
        elseif _Parameter == "RedPrince" or _Parameter == true then
            self.TroopType = true
        elseif _Parameter == "Bandit" or _Parameter == 2 then
            self.TroopType = 2
        elseif _Parameter == "Cultist" or _Parameter == 3 then
            self.TroopType = 3
        else
            assert(false)
        end
    elseif (_Index == 10) then
        self.ReuseTroops = AcceptAlternativeBoolean(_Parameter)
    end

end

function b_Reward_AI_SpawnAndAttackTerritory:GetCustomData( _Index )

    local Data = {}
    if _Index == 9 then
        table.insert( Data, "Normal" )
        table.insert( Data, "RedPrince" )
        table.insert( Data, "Bandit" )
        if g_GameExtraNo &#x3E;= 1 then
            table.insert( Data, "Cultist" )
        end

    elseif _Index == 10 then
        table.insert( Data, "false" )
        table.insert( Data, "true" )

    else
        assert( false )
    end

    return Data

end

function b_Reward_AI_SpawnAndAttackTerritory:CustomFunction(_Quest)

    local TargetID = Logic.GetTerritoryAcquiringBuildingID( self.TerritoryID )
    if TargetID ~= 0 then
        AIScript_SpawnAndAttackCity( self.AIPlayerID, TargetID, self.Spawnpoint, self.NumSword, self.NumBow, self.NumCatapults, self.NumSiegeTowers, self.NumRams, self.NumAmmoCarts, self.TroopType, self.ReuseTroops)
    end

end

function b_Reward_AI_SpawnAndAttackTerritory:Debug(_Quest)
    if self.AIPlayerID &#x3C; 2 then
        fatal(_Quest.Identifier .. ": Error in " .. self.Name .. ": Player " .. self.AIPlayerID .. " is wrong")
        return true
    elseif Logic.IsEntityDestroyed(self.Spawnpoint) then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": Entity " .. self.SpawnPoint .. " is missing")
        return true
    elseif self.TerritoryID == 0 then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": Territory unknown")
        return true
    elseif self.NumSword &#x3C; 0 then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": Number of Swords is negative")
        return true
    elseif self.NumBow &#x3C; 0 then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": Number of Bows is negative")
        return true
    elseif self.NumBow + self.NumSword &#x3C; 1 then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": No Soldiers?")
        return true
    elseif self.NumCatapults &#x3C; 0 then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": Catapults is negative")
        return true
    elseif self.NumSiegeTowers &#x3C; 0 then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": SiegeTowers is negative")
        return true
    elseif self.NumRams &#x3C; 0 then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": Rams is negative")
        return true
    elseif self.NumAmmoCarts &#x3C; 0 then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": AmmoCarts is negative")
        return true
    end
    return false;
end

Core:RegisterBehavior(b_Reward_AI_SpawnAndAttackTerritory);

-- -------------------------------------------------------------------------- --

---
-- Erzeugt eine Armee, die sich zum Zielpunkt bewegt und das Gebiet angreift.
--
-- Dabei werden die Soldaten alle erreichbaren Gebäude in Brand stecken. Ist
-- Das Zielgebiet eingemauert, können die Soldaten nicht angreifen und werden
-- sich zurückziehen.
--
-- @param _PlayerID   PlayerID des Angreifers
-- @param _SpawnPoint Skriptname des Entstehungspunktes
-- @param _Target     Skriptname des Ziels
-- @param _Radius     Aktionsradius um das Ziel
-- @param _Sword      Anzahl Schwertkämpfer (Battalione)
-- @param _Bow        Anzahl Bogenschützen (Battalione)
-- @param _Soldier    Typ der Soldaten
-- @param _Reuse      Freie Truppen wiederverwenden
--
-- @within Reward
--
function Reward_AI_SpawnAndAttackArea(...)
    return b_Reward_AI_SpawnAndAttackArea:new(...);
end

b_Reward_AI_SpawnAndAttackArea = {
    Name = "Reward_AI_SpawnAndAttackArea",
    Description = {
        en = "Reward: Spawns AI troops and attacks everything within the specified area, except the players main buildings",
        de = "Lohn: Erstellt KI Truppen und greift ein angegebenes Gebiet an, aber nicht die Hauptgebauede eines Spielers",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "AI Player", de = "KI Spieler" },
        { ParameterType.ScriptName, en = "Spawn point", de = "Erstellungsort" },
        { ParameterType.ScriptName, en = "Target", de = "Ziel" },
        { ParameterType.Number, en = "Radius", de = "Radius" },
        { ParameterType.Number, en = "Sword", de = "Schwert" },
        { ParameterType.Number, en = "Bow", de = "Bogen" },
        { ParameterType.Custom, en = "Soldier type", de = "Soldatentyp" },
        { ParameterType.Custom, en = "Reuse troops", de = "Verwende bestehende Truppen" },
    },
}

function b_Reward_AI_SpawnAndAttackArea:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function b_Reward_AI_SpawnAndAttackArea:AddParameter(_Index, _Parameter)

    if (_Index == 0) then
        self.AIPlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.Spawnpoint = _Parameter
    elseif (_Index == 2) then
        self.TargetName = _Parameter
    elseif (_Index == 3) then
        self.Radius = _Parameter * 1
    elseif (_Index == 4) then
        self.NumSword = _Parameter * 1
    elseif (_Index == 5) then
        self.NumBow = _Parameter * 1
    elseif (_Index == 6) then
        if _Parameter == "Normal" or _Parameter == false then
            self.TroopType = false
        elseif _Parameter == "RedPrince" or _Parameter == true then
            self.TroopType = true
        elseif _Parameter == "Bandit" or _Parameter == 2 then
            self.TroopType = 2
        elseif _Parameter == "Cultist" or _Parameter == 3 then
            self.TroopType = 3
        else
            assert(false)
        end
    elseif (_Index == 7) then
        self.ReuseTroops = AcceptAlternativeBoolean(_Parameter)
    end
end

function b_Reward_AI_SpawnAndAttackArea:GetCustomData( _Index )
    local Data = {}
    if _Index == 6 then
        table.insert( Data, "Normal" )
        table.insert( Data, "RedPrince" )
        table.insert( Data, "Bandit" )
        if g_GameExtraNo &#x3E;= 1 then
            table.insert( Data, "Cultist" )
        end
    elseif _Index == 7 then
        table.insert( Data, "false" )
        table.insert( Data, "true" )
    else
        assert( false )
    end
    return Data
end

function b_Reward_AI_SpawnAndAttackArea:CustomFunction(_Quest)
    if Logic.IsEntityAlive( self.TargetName ) and Logic.IsEntityAlive( self.Spawnpoint ) then
        local TargetID = GetID( self.TargetName )
        AIScript_SpawnAndRaidSettlement( self.AIPlayerID, TargetID, self.Spawnpoint, self.Radius, self.NumSword, self.NumBow, self.TroopType, self.ReuseTroops )
    end
end

function b_Reward_AI_SpawnAndAttackArea:Debug(_Quest)
    if self.AIPlayerID &#x3C; 2 then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": Player " .. self.AIPlayerID .. " is wrong")
        return true
    elseif Logic.IsEntityDestroyed(self.Spawnpoint) then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": Entity " .. self.SpawnPoint .. " is missing")
        return true
    elseif Logic.IsEntityDestroyed(self.TargetName) then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": Entity " .. self.TargetName .. " is missing")
        return true
    elseif self.Radius &#x3C; 1 then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": Radius is to small or negative")
        return true
    elseif self.NumSword &#x3C; 0 then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": Number of Swords is negative")
        return true
    elseif self.NumBow &#x3C; 0 then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": Number of Bows is negative")
        return true
    elseif self.NumBow + self.NumSword &#x3C; 1 then
        fatal(_Quest.Identifier .. ": Error in " .. self.Name .. ": No Soldiers?")
        return true
    end
    return false;
end

Core:RegisterBehavior(b_Reward_AI_SpawnAndAttackArea);

-- -------------------------------------------------------------------------- --

---
-- Erstellt eine Armee, die das Zielgebiet verteidigt.
--
-- @param _PlayerID     PlayerID des Angreifers
-- @param _SpawnPoint   Skriptname des Entstehungspunktes
-- @param _Target       Skriptname des Ziels
-- @param _Radius       Bewachtes Gebiet
-- @param _Time         Dauer der Bewachung (-1 für unendlich)
-- @param _Sword        Anzahl Schwertkämpfer (Battalione)
-- @param _Bow          Anzahl Bogenschützen (Battalione)
-- @param _CaptureCarts Soldaten greifen Karren an
-- @param _Type         Typ der Soldaten
-- @param _Reuse        Freie Truppen wiederverwenden
--
-- @within Reward
--
function Reward_AI_SpawnAndProtectArea(...)
    return b_Reward_AI_SpawnAndProtectArea:new(...);
end

b_Reward_AI_SpawnAndProtectArea = {
    Name = "Reward_AI_SpawnAndProtectArea",
    Description = {
        en = "Reward: Spawns AI troops and defends a specified area",
        de = "Lohn: Erstellt KI Truppen und verteidigt ein angegebenes Gebiet",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "AI Player", de = "KI Spieler" },
        { ParameterType.ScriptName, en = "Spawn point", de = "Erstellungsort" },
        { ParameterType.ScriptName, en = "Target", de = "Ziel" },
        { ParameterType.Number, en = "Radius", de = "Radius" },
        { ParameterType.Number, en = "Time (-1 for infinite)", de = "Zeit (-1 fuer unendlich)" },
        { ParameterType.Number, en = "Sword", de = "Schwert" },
        { ParameterType.Number, en = "Bow", de = "Bogen" },
        { ParameterType.Custom, en = "Capture tradecarts", de = "Handelskarren angreifen" },
        { ParameterType.Custom, en = "Soldier type", de = "Soldatentyp" },
        { ParameterType.Custom, en = "Reuse troops", de = "Verwende bestehende Truppen" },
    },
}

function b_Reward_AI_SpawnAndProtectArea:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function b_Reward_AI_SpawnAndProtectArea:AddParameter(_Index, _Parameter)

    if (_Index == 0) then
        self.AIPlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.Spawnpoint = _Parameter
    elseif (_Index == 2) then
        self.TargetName = _Parameter
    elseif (_Index == 3) then
        self.Radius = _Parameter * 1
    elseif (_Index == 4) then
        self.Time = _Parameter * 1
    elseif (_Index == 5) then
        self.NumSword = _Parameter * 1
    elseif (_Index == 6) then
        self.NumBow = _Parameter * 1
    elseif (_Index == 7) then
        self.CaptureTradeCarts = AcceptAlternativeBoolean(_Parameter)
    elseif (_Index == 8) then
        if _Parameter == "Normal" or _Parameter == true then
            self.TroopType = false
        elseif _Parameter == "RedPrince" or _Parameter == false then
            self.TroopType = true
        elseif _Parameter == "Bandit" or _Parameter == 2 then
            self.TroopType = 2
        elseif _Parameter == "Cultist" or _Parameter == 3 then
            self.TroopType = 3
        else
            assert(false)
        end
    elseif (_Index == 9) then
        self.ReuseTroops = AcceptAlternativeBoolean(_Parameter)
    end

end

function b_Reward_AI_SpawnAndProtectArea:GetCustomData( _Index )

    local Data = {}
    if _Index == 7 then
        table.insert( Data, "false" )
        table.insert( Data, "true" )
    elseif _Index == 8 then
        table.insert( Data, "Normal" )
        table.insert( Data, "RedPrince" )
        table.insert( Data, "Bandit" )
        if g_GameExtraNo &#x3E;= 1 then
            table.insert( Data, "Cultist" )
        end

    elseif _Index == 9 then
        table.insert( Data, "false" )
        table.insert( Data, "true" )

    else
        assert( false )
    end

    return Data

end

function b_Reward_AI_SpawnAndProtectArea:CustomFunction(_Quest)

    if Logic.IsEntityAlive( self.TargetName ) and Logic.IsEntityAlive( self.Spawnpoint ) then
        local TargetID = GetID( self.TargetName )
        AIScript_SpawnAndProtectArea( self.AIPlayerID, TargetID, self.Spawnpoint, self.Radius, self.NumSword, self.NumBow, self.Time, self.TroopType, self.ReuseTroops, self.CaptureTradeCarts )
    end

end

function b_Reward_AI_SpawnAndProtectArea:Debug(_Quest)
    if self.AIPlayerID &#x3C; 2 then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": Player " .. self.AIPlayerID .. " is wrong")
        return true
    elseif Logic.IsEntityDestroyed(self.Spawnpoint) then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": Entity " .. self.SpawnPoint .. " is missing")
        return true
    elseif Logic.IsEntityDestroyed(self.TargetName) then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": Entity " .. self.TargetName .. " is missing")
        return true
    elseif self.Radius &#x3C; 1 then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": Radius is to small or negative")
        return true
    elseif self.Time &#x3C; -1 then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": Time is smaller than -1")
        return true
    elseif self.NumSword &#x3C; 0 then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": Number of Swords is negative")
        return true
    elseif self.NumBow &#x3C; 0 then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": Number of Bows is negative")
        return true
    elseif self.NumBow + self.NumSword &#x3C; 1 then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": No Soldiers?")
        return true
    end
    return false;
end

Core:RegisterBehavior(b_Reward_AI_SpawnAndProtectArea);

-- -------------------------------------------------------------------------- --

---
-- Ändert die Konfiguration eines KI-Spielers.
--
-- Optionen:
-- &#x3C;ul&#x3E;
-- &#x3C;li&#x3E;Courage/FEAR: Angstfaktor (0 bis ?)&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;Reconstruction/BARB: Wiederaufbau von Gebäuden (0 oder 1)&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;Build Order/BPMX: Buildorder ausführen (Nummer der Build Order)&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;Conquer Outposts/FCOP: Außenposten einnehmen (0 oder 1)&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;Mount Outposts/FMOP: Eigene Außenposten bemannen (0 oder 1)&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;max. Bowmen/FMBM: Maximale Anzahl an Bogenschützen (min. 1)&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;max. Swordmen/FMSM: Maximale Anzahl an Schwerkkämpfer (min. 1) &#x3C;/li&#x3E;
-- &#x3C;li&#x3E;max. Rams/FMRA: Maximale Anzahl an Rammen (min. 1)&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;max. Catapults/FMCA: Maximale Anzahl an Katapulten (min. 1)&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;max. Ammunition Carts/FMAC: Maximale Anzahl an Minitionswagen (min. 1)&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;max. Siege Towers/FMST: Maximale Anzahl an Belagerungstürmen (min. 1)&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;max. Wall Catapults/FMBA: Maximale Anzahl an Mauerkatapulten (min. 1)&#x3C;/li&#x3E;
-- &#x3C;/ul&#x3E;
--
-- @param _PlayerID PlayerID des KI
-- @param _Fact     Konfigurationseintrag
-- @param _Value    Neuer Wert
--
-- @within Reward
--
function Reward_AI_SetNumericalFact(...)
    return b_Reward_AI_SetNumericalFact:new(...);
end

b_Reward_AI_SetNumericalFact = {
    Name = "Reward_AI_SetNumericalFact",
    Description = {
        en = "Reward: Sets a numerical fact for the AI player",
        de = "Lohn: Setzt eine Verhaltensregel fuer den KI-Spieler. ",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "AI Player",      de = "KI Spieler" },
        { ParameterType.Custom,   en = "Numerical Fact", de = "Verhaltensregel" },
        { ParameterType.Number,   en = "Value",          de = "Wert" },
    },
}

function b_Reward_AI_SetNumericalFact:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function b_Reward_AI_SetNumericalFact:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.AIPlayerID = _Parameter * 1
    elseif (_Index == 1) then
        -- mapping of numerical facts
        local fact = {
            ["Courage"]               = "FEAR",
            ["Reconstruction"]        = "BARB",
            ["Build Order"]           = "BPMX",
            ["Conquer Outposts"]      = "FCOP",
            ["Mount Outposts"]        = "FMOP",
            ["max. Bowmen"]           = "FMBM",
            ["max. Swordmen"]         = "FMSM",
            ["max. Rams"]             = "FMRA",
            ["max. Catapults"]        = "FMCA",
            ["max. Ammunition Carts"] = "FMAC",
            ["max. Siege Towers"]     = "FMST",
            ["max. Wall Catapults"]   = "FMBA",
            ["FEAR"]                  = "FEAR", -- &#x3E; 0
            ["BARB"]                  = "BARB", -- 1 or 0
            ["BPMX"]                  = "BPMX", -- &#x3E;= 0
            ["FCOP"]                  = "FCOP", -- 1 or 0
            ["FMOP"]                  = "FMOP", -- 1 or 0
            ["FMBM"]                  = "FMBM", -- &#x3E;= 0
            ["FMSM"]                  = "FMSM", -- &#x3E;= 0
            ["FMRA"]                  = "FMRA", -- &#x3E;= 0
            ["FMCA"]                  = "FMCA", -- &#x3E;= 0
            ["FMAC"]                  = "FMAC", -- &#x3E;= 0
            ["FMST"]                  = "FMST", -- &#x3E;= 0
            ["FMBA"]                  = "FMBA", -- &#x3E;= 0
        }
        self.NumericalFact = fact[_Parameter]
    elseif (_Index == 2) then
        self.Value = _Parameter * 1
    end
end

function b_Reward_AI_SetNumericalFact:CustomFunction(_Quest)
    AICore.SetNumericalFact( self.AIPlayerID, self.NumericalFact, self.Value )
end

function b_Reward_AI_SetNumericalFact:GetCustomData(_Index)
    if (_Index == 1) then
        return {
            "Courage",
            "Reconstruction",
            "Build Order",
            "Conquer Outposts",
            "Mount Outposts",
            "max. Bowmen",
            "max. Swordmen",
            "max. Rams",
            "max. Catapults",
            "max. Ammunition Carts",
            "max. Siege Towers",
            "max. Wall Catapults",
        };
    end
end

function b_Reward_AI_SetNumericalFact:Debug(_Quest)
    if Logic.GetStoreHouse(self.AIPlayerID) == 0 then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": Player " .. self.AIPlayerID .. " is wrong or dead!");
        return true;
    elseif not self.NumericalFact then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": invalid numerical fact choosen!");
        return true;
    else
        if self.NumericalFact == "BARB" or self.NumericalFact == "FCOP" or self.NumericalFact == "FMOP" then
            if self.Value ~= 0 and self.Value ~= 1 then
                fatal(_Quest.Identifier .. " " .. self.Name .. ": BARB, FCOP, FMOP: value must be 1 or 0!");
                return true;
            end
        elseif self.NumericalFact == "FEAR" then
            if self.Value &#x3C;= 0 then
                fatal(_Quest.Identifier .. " " .. self.Name .. ": FEAR: value must greater than 0!");
                return true;
            end
        else
            if self.Value &#x3C; 0 then
                fatal(_Quest.Identifier .. " " .. self.Name .. ": value must always greater than or equal 0!");
                return true;
            end
        end
    end
    return false
end

Core:RegisterBehavior(b_Reward_AI_SetNumericalFact);

-- -------------------------------------------------------------------------- --

---
-- Stellt den Aggressivitätswert des KI-Spielers nachträglich ein.
--
-- @param _PlayerID         PlayerID des KI-Spielers
-- @param _Aggressiveness   Aggressivitätswert (1 bis 3)
--
-- @within Reward
--
function Reward_AI_Aggressiveness(...)
    return b_Reward_AI_Aggressiveness:new(...);
end

b_Reward_AI_Aggressiveness = {
    Name = "Reward_AI_Aggressiveness",
    Description = {
        en = "Reward: Sets the AI player's aggressiveness.",
        de = "Lohn: Setzt die Aggressivität des KI-Spielers fest.",
    },
    Parameter =
    {
        { ParameterType.PlayerID, en = "AI player", de = "KI-Spieler" },
        { ParameterType.Custom, en = "Aggressiveness (1-3)", de = "Aggressivität (1-3)" }
    }
};

function b_Reward_AI_Aggressiveness:GetRewardTable()
    return {Reward.Custom, {self, self.CustomFunction} };
end

function b_Reward_AI_Aggressiveness:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        self.AIPlayer = _Parameter * 1;
    elseif _Index == 1 then
        self.Aggressiveness = tonumber(_Parameter);
    end
end

function b_Reward_AI_Aggressiveness:CustomFunction()
    local player = (PlayerAIs[self.AIPlayer]
        or AIPlayerTable[self.AIPlayer]
        or AIPlayer:new(self.AIPlayer, AIPlayerProfile_City));
    PlayerAIs[self.AIPlayer] = player;
    if self.Aggressiveness &#x3E;= 2 then
        player.m_ProfileLoop = AIProfile_Skirmish;
        player.Skirmish = player.Skirmish or {};
        player.Skirmish.Claim_MinTime = SkirmishDefault.Claim_MinTime + (self.Aggressiveness - 2) * 390;
        player.Skirmish.Claim_MaxTime = player.Skirmish.Claim_MinTime * 2;
    else
        player.m_ProfileLoop = AIPlayerProfile_City;
    end
end

function b_Reward_AI_Aggressiveness:Debug(_Quest)
    if self.AIPlayer &#x3C; 2 or Logic.GetStoreHouse(self.AIPlayer) == 0 then
        fatal(_Quest.Identifier .. ": Error in " .. self.Name .. ": Player " .. self.PlayerID .. " is wrong")
        return true
    end
end

function b_Reward_AI_Aggressiveness:GetCustomData(_Index)
    assert(_Index == 1, "Error in " .. self.Name .. ": GetCustomData: Index is invalid.");
    return { "1", "2", "3" };
end

Core:RegisterBehavior(b_Reward_AI_Aggressiveness)

-- -------------------------------------------------------------------------- --

---
-- Stellt den Feind des Skirmish-KI ein.
--
-- Der Skirmish-KI (maximale Aggressivität) kann nur einen Spieler als Feind
-- behandeln. Für gewöhnlich ist dies der menschliche Spieler.
--
-- @param _PlayerID      PlayerID des KI
-- @param _EnemyPlayerID PlayerID des Feindes
--
-- @within Reward
--
function Reward_AI_SetEnemy(...)
    return b_Reward_AI_SetEnemy:new(...);
end

b_Reward_AI_SetEnemy = {
    Name = "Reward_AI_SetEnemy",
    Description = {
        en = "Reward:Sets the enemy of an AI player (the AI only handles one enemy properly).",
        de = "Lohn: Legt den Feind eines KI-Spielers fest (die KI behandelt nur einen Feind korrekt).",
    },
    Parameter =
    {
        { ParameterType.PlayerID, en = "AI player", de = "KI-Spieler" },
        { ParameterType.PlayerID, en = "Enemy", de = "Feind" }
    }
};

function b_Reward_AI_SetEnemy:GetRewardTable()

    return {Reward.Custom, {self, self.CustomFunction} };

end

function b_Reward_AI_SetEnemy:AddParameter(_Index, _Parameter)

    if _Index == 0 then
        self.AIPlayer = _Parameter * 1;
    elseif _Index == 1 then
        self.Enemy = _Parameter * 1;
    end

end

function b_Reward_AI_SetEnemy:CustomFunction()

    local player = PlayerAIs[self.AIPlayer];
    if player and player.Skirmish then
        player.Skirmish.Enemy = self.Enemy;
    end

end

function b_Reward_AI_SetEnemy:Debug(_Quest)
    if self.AIPlayer &#x3C;= 1 or self.AIPlayer &#x3E;= 8 or Logic.PlayerGetIsHumanFlag(self.AIPlayer) then
        fatal(_Quest.Identifier .. ": Error in " .. self.Name .. ": Player " .. self.AIPlayer .. " is wrong")
        return true;
    end
    return false;
end
Core:RegisterBehavior(b_Reward_AI_SetEnemy)

-- -------------------------------------------------------------------------- --

---
-- Ein Entity wird durch ein neues anderen Typs ersetzt.
--
-- Das neue Entity übernimmt Skriptname, Besitzer und Ausrichtung des
-- alten Entity.
--
-- @param _Entity Skriptname oder ID des Entity
-- @param _Type   Neuer Typ des Entity
-- @param _Owner  Besitzer des Entity
--
-- @within Reward
--
function Reward_ReplaceEntity(...)
    return b_Reward_ReplaceEntity:new(...);
end

b_Reward_ReplaceEntity = API.InstanceTable(b_Reprisal_ReplaceEntity);
b_Reward_ReplaceEntity.Name = "Reward_ReplaceEntity";
b_Reward_ReplaceEntity.Description.en = "Reward: Replaces an entity with a new one of a different type. The playerID can be changed too.";
b_Reward_ReplaceEntity.Description.de = "Lohn: Ersetzt eine Entity durch eine neue anderen Typs. Es kann auch die Spielerzugehörigkeit geändert werden.";
b_Reward_ReplaceEntity.GetReprisalTable = nil;

b_Reward_ReplaceEntity.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} }
end

Core:RegisterBehavior(b_Reward_ReplaceEntity);

-- -------------------------------------------------------------------------- --

---
-- Setzt die Menge von Rohstoffen in einer Mine.
--
-- &#x3C;b&#x3E;Achtung:&#x3C;/b&#x3E; Im Reich des Ostens darf die Mine nicht eingestürzt sein!
-- Außerdem bringt dieses Behavior die Nachfüllmechanik durcheinander.
--
-- @param _ScriptName Skriptname der Mine
-- @param _Amount     Menge an Rohstoffen
--
-- @within Reward
--
function Reward_SetResourceAmount(...)
    return b_Reward_SetResourceAmount:new(...);
end

b_Reward_SetResourceAmount = {
    Name = "Reward_SetResourceAmount",
    Description = {
        en = "Reward: Set the current and maximum amount of a resource doodad (the amount can also set to 0)",
        de = "Lohn: Setzt die aktuellen sowie maximalen Resourcen in einem Doodad (auch 0 ist möglich)",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Ressource", de = "Resource" },
        { ParameterType.Number, en = "Amount", de = "Menge" },
    },
}

function b_Reward_SetResourceAmount:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function b_Reward_SetResourceAmount:AddParameter(_Index, _Parameter)

    if (_Index == 0) then
        self.ScriptName = _Parameter
    elseif (_Index == 1) then
        self.Amount = _Parameter * 1
    end

end

function b_Reward_SetResourceAmount:CustomFunction(_Quest)
    if Logic.IsEntityDestroyed( self.ScriptName ) then
        return false
    end
    local EntityID = GetID( self.ScriptName )
    if Logic.GetResourceDoodadGoodType( EntityID ) == 0 then
        return false
    end
    Logic.SetResourceDoodadGoodAmount( EntityID, self.Amount )
end

function b_Reward_SetResourceAmount:Debug(_Quest)
    if not IsExisting(self.ScriptName) then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": resource entity does not exist!")
        return true
    elseif not type(self.Amount) == "number" or self.Amount &#x3C; 0 then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": resource amount can not be negative!")
        return true
    end
    return false;
end

Core:RegisterBehavior(b_Reward_SetResourceAmount);

-- -------------------------------------------------------------------------- --

---
-- Fügt dem Lagerhaus des Auftragnehmers eine Menge an Rohstoffen hinzu. Die
-- Rohstoffe werden direkt ins Lagerhaus bzw. die Schatzkammer gelegt.
--
-- @param _Type   Rohstofftyp
-- @param _Amount Menge an Rohstoffen
--
-- @within Reward
--
function Reward_Resources(...)
    return b_Reward_Resources:new(...);
end

b_Reward_Resources = {
    Name = "Reward_Resources",
    Description = {
        en = "Reward: The player receives a given amount of Goods in his store.",
        de = "Lohn: Legt der Partei die angegebenen Rohstoffe ins Lagerhaus.",
    },
    Parameter = {
        { ParameterType.RawGoods, en = "Type of good", de = "Resourcentyp" },
        { ParameterType.Number, en = "Amount of good", de = "Anzahl der Resource" },
    },
}

function b_Reward_Resources:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.GoodTypeName = _Parameter
    elseif (_Index == 1) then
        self.GoodAmount = _Parameter * 1
    end
end

function b_Reward_Resources:GetRewardTable()
    local GoodType = Logic.GetGoodTypeID(self.GoodTypeName)
    return { Reward.Resources, GoodType, self.GoodAmount }
end

Core:RegisterBehavior(b_Reward_Resources);

-- -------------------------------------------------------------------------- --

---
-- Entsendet einen Karren zum angegebenen Spieler.
--
-- Wenn der Spawnpoint ein Gebäude ist, wird der Wagen am Eingang erstellt.
-- Andernfalls kann der Spawnpoint gelöscht werden und der Wagen übernimmt
-- dann den Skriptnamen.
--
-- @param _ScriptName    Skriptname des Spawnpoint
-- @param _Owner         Empfänger der Lieferung
-- @param _Type          Typ des Wagens
-- @param _Good          Typ der Ware
-- @param _Amount        Menge an Waren
-- @param _OtherPlayer   Anderer Empfänger als Auftraggeber
-- @param _NoReservation Platzreservation auf dem Markt ignorieren (Sinnvoll?)
-- @param _Replace       Spawnpoint ersetzen
--
-- @within Reward
--
function Reward_SendCart(...)
    return b_Reward_SendCart:new(...);
end

b_Reward_SendCart = {
    Name = "Reward_SendCart",
    Description = {
        en = "Reward: Sends a cart to a player. It spawns at a building or by replacing an entity. The cart can replace the entity if it's not a building.",
        de = "Lohn: Sendet einen Karren zu einem Spieler. Der Karren wird an einem Gebäude oder einer Entity erstellt. Er ersetzt die Entity, wenn diese kein Gebäude ist.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script entity", de = "Script Entity" },
        { ParameterType.PlayerID, en = "Owning player", de = "Besitzer" },
        { ParameterType.Custom, en = "Type name", de = "Typbezeichnung" },
        { ParameterType.Custom, en = "Good type", de = "Warentyp" },
        { ParameterType.Number, en = "Amount", de = "Anzahl" },
        { ParameterType.Custom, en = "Override target player", de = "Anderer Zielspieler" },
        { ParameterType.Custom, en = "Ignore reservations", de = "Ignoriere Reservierungen" },
        { ParameterType.Custom, en = "Replace entity", de = "Entity ersetzen" },
    },
}

function b_Reward_SendCart:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function b_Reward_SendCart:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptNameEntity = _Parameter
    elseif (_Index == 1) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 2) then
        self.UnitKey = _Parameter
    elseif (_Index == 3) then
        self.GoodType = _Parameter
    elseif (_Index == 4) then
        self.GoodAmount = _Parameter * 1
    elseif (_Index == 5) then
        self.OverrideTargetPlayer = tonumber(_Parameter)
    elseif (_Index == 6) then
        self.IgnoreReservation = AcceptAlternativeBoolean(_Parameter)
    elseif (_Index == 7) then
        self.ReplaceEntity = AcceptAlternativeBoolean(_Parameter)
    end
end

function b_Reward_SendCart:CustomFunction(_Quest)

    if not IsExisting( self.ScriptNameEntity ) then
        return false;
    end

    local ID = SendCart(self.ScriptNameEntity, self.PlayerID, Goods[self.GoodType], self.GoodAmount, Entities[self.UnitKey], self.IgnoreReservation);

    if self.ReplaceEntity and Logic.IsBuilding(GetID(self.ScriptNameEntity)) == 0 then
        DestroyEntity(self.ScriptNameEntity);
        Logic.SetEntityName(ID, self.ScriptNameEntity);
    end
    if self.OverrideTargetPlayer then
        Logic.ResourceMerchant_OverrideTargetPlayerID(ID,self.OverrideTargetPlayer);
    end
end

function b_Reward_SendCart:GetCustomData( _Index )
    local Data = {};
    if _Index == 2 then
        Data = { "U_ResourceMerchant", "U_Medicus", "U_Marketer", "U_ThiefCart", "U_GoldCart", "U_Noblemen_Cart", "U_RegaliaCart" };
    elseif _Index == 3 then
        for k, v in pairs( Goods ) do
            if string.find( k, "^G_" ) then
                table.insert( Data, k );
            end
        end
        table.sort( Data );
    elseif _Index == 5 then
        table.insert( Data, "-" );
        for i = 1, 8 do
            table.insert( Data, i );
        end
    elseif _Index == 6 then
        table.insert( Data, "false" );
        table.insert( Data, "true" );
    elseif _Index == 7 then
        table.insert( Data, "false" );
        table.insert( Data, "true" );
    end
    return Data;
end

function b_Reward_SendCart:Debug(_Quest)
    if not IsExisting(self.ScriptNameEntity) then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": spawnpoint does not exist!");
        return true;
    elseif not tonumber(self.PlayerID) or self.PlayerID &#x3C; 1 or self.PlayerID &#x3E; 8 then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": got a invalid playerID!");
        return true;
    elseif not Entities[self.UnitKey] then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": entity type '"..self.UnitKey.."' is invalid!");
        return true;
    elseif not Goods[self.GoodType] then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": good type '"..self.GoodType.."' is invalid!");
        return true;
    elseif not tonumber(self.GoodAmount) or self.GoodAmount &#x3C; 1 then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": good amount can not be below 1!");
        return true;
    elseif tonumber(self.OverrideTargetPlayer) and (self.OverrideTargetPlayer &#x3C; 1 or self.OverrideTargetPlayer &#x3E; 8) then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": overwrite target player with invalid playerID!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Reward_SendCart);

-- -------------------------------------------------------------------------- --

---
-- Gibt dem Auftragnehmer eine Menge an Einheiten.
--
-- Die Einheiten erscheinen an der Burg. Hat der Spieler keine Burg, dann
-- erscheinen sie vorm Lagerhaus.
--
-- @param _Type   Typ der Einheit
-- @param _Amount Menge an Einheiten
--
-- @within Reward
--
function Reward_Units(...)
    return b_Reward_Units:new(...)
end

b_Reward_Units = {
    Name = "Reward_Units",
    Description = {
        en = "Reward: Units",
        de = "Lohn: Einheiten",
    },
    Parameter = {
        { ParameterType.Entity, en = "Type name", de = "Typbezeichnung" },
        { ParameterType.Number, en = "Amount", de = "Anzahl" },
    },
}

function b_Reward_Units:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.EntityName = _Parameter
    elseif (_Index == 1) then
        self.Amount = _Parameter * 1
    end
end

function b_Reward_Units:GetRewardTable()
    return { Reward.Units, assert( Entities[self.EntityName] ), self.Amount }
end

Core:RegisterBehavior(b_Reward_Units);

-- -------------------------------------------------------------------------- --

---
-- Startet einen Quest neu.
--
-- @param _QuestName Name des Quest
--
-- @within Reward
--
function Reward_QuestRestart(...)
    return b_Reward_QuestRestart:new(...)
end

b_Reward_QuestRestart = API.InstanceTable(b_Reprisal_QuestRestart);
b_Reward_QuestRestart.Name = "Reward_QuestRestart";
b_Reward_QuestRestart.Description.en = "Reward: Restarts a (completed) quest so it can be triggered and completed again.";
b_Reward_QuestRestart.Description.de = "Lohn: Startet eine (beendete) Quest neu, damit diese neu ausgelöst und beendet werden kann.";
b_Reward_QuestRestart.GetReprisalTable = nil;

b_Reward_QuestRestart.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} }
end

Core:RegisterBehavior(b_Reward_QuestRestart);

-- -------------------------------------------------------------------------- --

---
-- Lässt einen Quest fehlschlagen.
--
-- @param _QuestName Name des Quest
--
-- @within Reward
--
function Reward_QuestFailure(...)
    return b_Reward_QuestFailure:new(...)
end

b_Reward_QuestFailure = API.InstanceTable(b_Reprisal_QuestFailure);
b_Reward_QuestFailure.Name = "Reward_QuestFailure";
b_Reward_QuestFailure.Description.en = "Reward: Lets another active quest fail.";
b_Reward_QuestFailure.Description.de = "Lohn: Lässt eine andere aktive Quest fehlschlagen.";
b_Reward_QuestFailure.GetReprisalTable = nil;

b_Reward_QuestFailure.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} }
end

Core:RegisterBehavior(b_Reward_QuestFailure);

-- -------------------------------------------------------------------------- --

---
-- Wertet einen Quest als erfolgreich.
--
-- @param _QuestName Name des Quest
--
-- @within Reward
--
function Reward_QuestSuccess(...)
    return b_Reward_QuestSuccess:new(...)
end

b_Reward_QuestSuccess = API.InstanceTable(b_Reprisal_QuestSuccess);
b_Reward_QuestSuccess.Name = "Reward_QuestSuccess";
b_Reward_QuestSuccess.Description.en = "Reward: Completes another active quest successfully.";
b_Reward_QuestSuccess.Description.de = "Lohn: Beendet eine andere aktive Quest erfolgreich.";
b_Reward_QuestSuccess.GetReprisalTable = nil;

b_Reward_QuestSuccess.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} }
end

Core:RegisterBehavior(b_Reward_QuestSuccess);

-- -------------------------------------------------------------------------- --

---
-- Triggert einen Quest.
--
-- @param _QuestName Name des Quest
--
-- @within Reward
--
function Reward_QuestActivate(...)
    return b_Reward_QuestActivate:new(...)
end

b_Reward_QuestActivate = API.InstanceTable(b_Reprisal_QuestActivate);
b_Reward_QuestActivate.Name = "Reward_QuestActivate";
b_Reward_QuestActivate.Description.en = "Reward: Activates another quest that is not triggered yet.";
b_Reward_QuestActivate.Description.de = "Lohn: Aktiviert eine andere Quest die noch nicht ausgelöst wurde.";
b_Reward_QuestActivate.GetReprisalTable = nil;

b_Reward_QuestActivate.GetRewardTable = function(self, _Quest)
    return {Reward.Custom, {self, self.CustomFunction} }
end

Core:RegisterBehavior(b_Reward_QuestActivate)

-- -------------------------------------------------------------------------- --

---
-- Unterbricht einen Quest.
--
-- @param _QuestName Name des Quest
--
-- @within Reward
--
function Reward_QuestInterrupt(...)
    return b_Reward_QuestInterrupt:new(...)
end

b_Reward_QuestInterrupt = API.InstanceTable(b_Reprisal_QuestInterrupt);
b_Reward_QuestInterrupt.Name = "Reward_QuestInterrupt";
b_Reward_QuestInterrupt.Description.en = "Reward: Interrupts another active quest without success or failure.";
b_Reward_QuestInterrupt.Description.de = "Lohn: Beendet eine andere aktive Quest ohne Erfolg oder Misserfolg.";
b_Reward_QuestInterrupt.GetReprisalTable = nil;

b_Reward_QuestInterrupt.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} }
end

Core:RegisterBehavior(b_Reward_QuestInterrupt);

-- -------------------------------------------------------------------------- --

---
-- Unterbricht einen Quest, selbst wenn dieser noch nicht ausgelöst wurde.
--
-- @param _QuestName   Name des Quest
-- @param _EndetQuests Bereits beendete unterbrechen
--
-- @within Reward
--
function Reward_QuestForceInterrupt(...)
    return b_Reward_QuestForceInterrupt:new(...)
end

b_Reward_QuestForceInterrupt = API.InstanceTable(b_Reprisal_QuestForceInterrupt);
b_Reward_QuestForceInterrupt.Name = "Reward_QuestForceInterrupt";
b_Reward_QuestForceInterrupt.Description.en = "Reward: Interrupts another quest (even when it isn't active yet) without success or failure.";
b_Reward_QuestForceInterrupt.Description.de = "Lohn: Beendet eine andere Quest, auch wenn diese noch nicht aktiv ist ohne Erfolg oder Misserfolg.";
b_Reward_QuestForceInterrupt.GetReprisalTable = nil;

b_Reward_QuestForceInterrupt.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} }
end

Core:RegisterBehavior(b_Reward_QuestForceInterrupt);

-- -------------------------------------------------------------------------- --

---
-- Ändert den Wert einer benutzerdefinierten Variable.
--
-- Benutzerdefinierte Variablen können ausschließlich Zahlen sein. Nutze
-- dieses Behavior bevor die Variable in einem Goal oder Trigger abgefragt
-- wird, um sie zu initialisieren!
--
---- &#x3C;p&#x3E;Operatoren&#x3C;/p&#x3E;
-- &#x3C;ul&#x3E;
-- &#x3C;li&#x3E;= - Variablenwert wird auf den Wert gesetzt&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;- - Variablenwert mit Wert Subtrahieren&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;+ - Variablenwert mit Wert addieren&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;* - Variablenwert mit Wert multiplizieren&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;/ - Variablenwert mit Wert dividieren&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;^ - Variablenwert mit Wert potenzieren&#x3C;/li&#x3E;
-- &#x3C;/ul&#x3E;
--
-- @param _Name     Name der Variable
-- @param _Operator Rechen- oder Zuweisungsoperator
-- @param _Value    Wert oder andere Custom Variable
--
-- @within Reward
--
function Reward_CustomVariables(...)
    return b_Reward_CustomVariables:new(...);
end

b_Reward_CustomVariables = API.InstanceTable(b_Reprisal_CustomVariables);
b_Reward_CustomVariables.Name = "Reward_CustomVariables";
b_Reward_CustomVariables.Description.en = "Reward: Executes a mathematical operation with this variable. The other operand can be a number or another custom variable.";
b_Reward_CustomVariables.Description.de = "Lohn: Fuehrt eine mathematische Operation mit der Variable aus. Der andere Operand kann eine Zahl oder eine Custom-Varible sein.";
b_Reward_CustomVariables.GetReprisalTable = nil;

b_Reward_CustomVariables.GetRewardTable = function(self, _Quest)
    return { Reward.Custom, {self, self.CustomFunction} };
end

Core:RegisterBehavior(b_Reward_CustomVariables)

-- -------------------------------------------------------------------------- --

---
-- Führt eine Funktion im Skript als Reward aus.
--
-- Wird ein Funktionsname als String übergeben, wird die Funktion mit den
-- Daten des Behavors und des zugehörigen Quest aufgerufen (Standard).
--
-- Wird eine Funktionsreferenz angegeben, wird die Funktion zusammen mit allen
-- optionalen Parametern aufgerufen, als sei es ein gewöhnlicher Aufruf im
-- Skript.
-- &#x3C;pre&#x3E;Reward_MapScriptFunction(ReplaceEntity, "block", Entities.XD_ScriptEntity);
-- -- entspricht: ReplaceEntity("block", Entities.XD_ScriptEntity);&#x3C;/pre&#x3E;
-- &#x3C;b&#x3E;Achtung:&#x3C;/b&#x3E; Nicht über den Assistenten verfügbar!
--
-- @param _FunctionName Name der Funktion oder Funktionsreferenz
--
-- @within Reward
--
function Reward_MapScriptFunction(...)
    return b_Reward_MapScriptFunction:new(...);
end

b_Reward_MapScriptFunction = API.InstanceTable(b_Reprisal_MapScriptFunction);
b_Reward_MapScriptFunction.Name = "Reward_MapScriptFunction";
b_Reward_MapScriptFunction.Description.en = "Reward: Calls a function within the global map script if the quest has failed.";
b_Reward_MapScriptFunction.Description.de = "Lohn: Ruft eine Funktion im globalen Kartenskript auf, wenn die Quest fehlschlägt.";
b_Reward_MapScriptFunction.GetReprisalTable = nil;

b_Reward_MapScriptFunction.GetRewardTable = function(self, _Quest)
    return {Reward.Custom, {self, self.CustomFunction}};
end

Core:RegisterBehavior(b_Reward_MapScriptFunction);

-- -------------------------------------------------------------------------- --

---
-- Erlaubt oder verbietet einem Spieler ein Recht.
--
-- @param _PlayerID   ID des Spielers
-- @param _Lock       Sperren/Entsperren
-- @param _Technology Name des Rechts
--
-- @within Reward
--
function Reward_Technology(...)
    return b_Reward_Technology:new(...);
end

b_Reward_Technology = API.InstanceTable(b_Reprisal_Technology);
b_Reward_Technology.Name = "Reward_Technology";
b_Reward_Technology.Description.en = "Reward: Locks or unlocks a technology for the given player.";
b_Reward_Technology.Description.de = "Lohn: Sperrt oder erlaubt eine Technolgie fuer den angegebenen Player.";
b_Reward_Technology.GetReprisalTable = nil;

b_Reward_Technology.GetRewardTable = function(self, _Quest)
    return { Reward.Custom, {self, self.CustomFunction} }
end

Core:RegisterBehavior(b_Reward_Technology);

---
-- Gibt dem Auftragnehmer eine Anzahl an Prestigepunkten.
--
-- Prestige hat i.d.R. keine Funktion und wird nur als Zusatzpunkte in der
-- Statistik angezeigt.
--
-- @param _Amount Menge an Prestige
--
-- @within Reward
--
function Reward_PrestigePoints(...)
    return b_Reward_PrestigePoints:mew(...);
end

b_Reward_PrestigePoints  = {
    Name = "Reward_PrestigePoints",
    Description = {
        en = "Reward: Prestige",
        de = "Lohn: Prestige",
    },
    Parameter = {
        { ParameterType.Number, en = "Points", de = "Punkte" },
    },
}

function b_Reward_PrestigePoints :AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Points = _Parameter
    end
end

function b_Reward_PrestigePoints :GetRewardTable()
    return { Reward.PrestigePoints, self.Points }
end

Core:RegisterBehavior(b_Reward_PrestigePoints);

-- -------------------------------------------------------------------------- --

---
-- Besetzt einen Außenposten mit Soldaten.
--
-- @param _ScriptName Skriptname des Außenposten
-- @param _Type       Soldatentyp
--
-- @within Reward
--
function Reward_AI_MountOutpost(...)
    return b_Reward_AI_MountOutpost:new(...);
end

b_Reward_AI_MountOutpost = {
    Name = "Reward_AI_MountOutpost",
    Description = {
        en = "Reward: Places a troop of soldiers on a named outpost.",
        de = "Lohn: Platziert einen Trupp Soldaten auf einem Aussenposten der KI.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script name", de = "Skriptname" },
        { ParameterType.Custom,      en = "Soldiers type", de = "Soldatentyp" },
    },
}

function b_Reward_AI_MountOutpost:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function b_Reward_AI_MountOutpost:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        self.Scriptname = _Parameter
    else
        self.SoldiersType = _Parameter
    end
end

function b_Reward_AI_MountOutpost:CustomFunction(_Quest)
    local outpostID = assert(
        not Logic.IsEntityDestroyed(self.Scriptname) and GetID(self.Scriptname),
       _Quest.Identifier .. ": Error in " .. self.Name .. ": CustomFunction: Outpost is invalid"
    )
    local AIPlayerID = Logic.EntityGetPlayer(outpostID)
    local ax, ay = Logic.GetBuildingApproachPosition(outpostID)
    local TroopID = Logic.CreateBattalionOnUnblockedLand(Entities[self.SoldiersType], ax, ay, 0, AIPlayerID, 0)
    AICore.HideEntityFromAI(AIPlayerID, TroopID, true)
    Logic.CommandEntityToMountBuilding(TroopID, outpostID)
end

function b_Reward_AI_MountOutpost:GetCustomData(_Index)
    if _Index == 1 then
        local Data = {}
        for k,v in pairs(Entities) do
            if string.find(k, "U_MilitaryBandit") or string.find(k, "U_MilitarySword") or string.find(k, "U_MilitaryBow") then
                Data[#Data+1] = k
            end
        end
        return Data
    end
end

function b_Reward_AI_MountOutpost:Debug(_Quest)
    if Logic.IsEntityDestroyed(self.Scriptname) then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": Outpost " .. self.Scriptname .. " is missing")
        return true
    end
end

Core:RegisterBehavior(b_Reward_AI_MountOutpost)

-- -------------------------------------------------------------------------- --

---
-- Startet einen Quest neu und lößt ihn sofort aus.
--
-- @param _QuestName Name des Quest
--
-- @within Reward
--
function Reward_QuestRestartForceActive(...)
    return b_Reward_QuestRestartForceActive:new(...);
end

b_Reward_QuestRestartForceActive = {
    Name = "Reward_QuestRestartForceActive",
    Description = {
        en = "Reward: Restarts a (completed) quest and triggers it immediately.",
        de = "Lohn: Startet eine (beendete) Quest neu und triggert sie sofort.",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest name", de = "Questname" },
    },
}

function b_Reward_QuestRestartForceActive:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function b_Reward_QuestRestartForceActive:AddParameter(_Index, _Parameter)
    assert(_Index == 0, "Error in " .. self.Name .. ": AddParameter: Index is invalid.")
    self.QuestName = _Parameter
end

function b_Reward_QuestRestartForceActive:CustomFunction(_Quest)
    local QuestID, Quest = self:ResetQuest(_Quest);
    if QuestID then
        Quest:SetMsgKeyOverride()
        Quest:SetIconOverride()
        Quest:Trigger()
    end
end

b_Reward_QuestRestartForceActive.ResetQuest = b_Reward_QuestRestart.CustomFunction;
function b_Reward_QuestRestartForceActive:Debug(_Quest)
    if not Quests[GetQuestID(self.QuestName)] then
        fatal(_Quest.Identifier .. ": Error in " .. self.Name .. ": Quest: "..  self.QuestName .. " does not exist");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Reward_QuestRestartForceActive)

-- -------------------------------------------------------------------------- --

---
-- Baut das angegebene Gabäude um eine Stufe aus. Das Gebäude wird durch einen
-- Arbeiter um eine Stufe erweitert. Der Arbeiter muss zuerst aus dem Lagerhaus
-- kommen und sich zum Gebäude bewegen.
--
-- &#x3C;b&#x3E;Achtung:&#x3C;/b&#x3E; Ein Gebäude muss erst fertig ausgebaut sein, bevor ein
-- weiterer Ausbau begonnen werden kann!
--
-- @param _ScriptName Skriptname des Gebäudes
--
-- @within Reward
--
function Reward_UpgradeBuilding(...)
    return b_Reward_UpgradeBuilding:new(...);
end

b_Reward_UpgradeBuilding = {
    Name = "Reward_UpgradeBuilding",
    Description = {
        en = "Reward: Upgrades a building",
        de = "Lohn: Baut ein Gebäude aus"
    },
    Parameter =    {
        { ParameterType.ScriptName, en = "Building", de = "Gebäude" }
    }
};

function b_Reward_UpgradeBuilding:GetRewardTable()

    return {Reward.Custom, {self, self.CustomFunction}};

end

function b_Reward_UpgradeBuilding:AddParameter(_Index, _Parameter)

    if _Index == 0 then
        self.Building = _Parameter;
    end

end

function b_Reward_UpgradeBuilding:CustomFunction(_Quest)

    local building = GetID(self.Building);
    if building ~= 0
    and Logic.IsBuilding(building) == 1
    and Logic.IsBuildingUpgradable(building, true)
    and Logic.IsBuildingUpgradable(building, false)
    then
        Logic.UpgradeBuilding(building);
    end

end

function b_Reward_UpgradeBuilding:Debug(_Quest)

    local building = GetID(self.Building);
    if not (building ~= 0
            and Logic.IsBuilding(building) == 1
            and Logic.IsBuildingUpgradable(building, true)
            and Logic.IsBuildingUpgradable(building, false) )
    then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": Building is wrong")
        return true
    end

end

Core:RegisterBehavior(b_Reward_UpgradeBuilding)

-- -------------------------------------------------------------------------- --
-- Trigger                                                                    --
-- -------------------------------------------------------------------------- --

---
-- Starte den Quest, wenn ein anderer Spieler entdeckt wurde.
--
-- Ein Spieler ist dann entdeckt, wenn sein Heimatterritorium aufgedeckt wird.
--
-- @param _PlayerID Zu entdeckender Spieler
--
-- @within Trigger
--
function Trigger_PlayerDiscovered(...)
    return b_Trigger_PlayerDiscovered:new(...);
end

b_Trigger_PlayerDiscovered = {
    Name = "Trigger_PlayerDiscovered",
    Description = {
        en = "Trigger: if a given player has been discovered",
        de = "Auslöser: wenn ein angegebener Spieler entdeckt wurde",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Player", de = "Spieler" },
    },
}

function b_Trigger_PlayerDiscovered:GetTriggerTable()
    return {Triggers.PlayerDiscovered, self.PlayerID}
end

function b_Trigger_PlayerDiscovered:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1;
    end
end

Core:RegisterBehavior(b_Trigger_PlayerDiscovered);

-- -------------------------------------------------------------------------- --

---
-- Starte den Quest, wenn zwischen dem Empfänger und der angegebenen Partei
-- der geforderte Diplomatiestatus herrscht.
--
-- @param _PlayerID ID der Partei
-- @param _State    Diplomatie-Status
--
-- @within Trigger
--
function Trigger_OnDiplomacy(...)
    return b_Trigger_OnDiplomacy:new(...);
end

b_Trigger_OnDiplomacy = {
    Name = "Trigger_OnDiplomacy",
    Description = {
        en = "Trigger: if diplomatic relations have been established with a player",
        de = "Auslöser: wenn ein angegebener Diplomatie-Status mit einem Spieler erreicht wurde.",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Player", de = "Spieler" },
        { ParameterType.DiplomacyState, en = "Relation", de = "Beziehung" },
    },
}

function b_Trigger_OnDiplomacy:GetTriggerTable()
    return {Triggers.Diplomacy, self.PlayerID, assert( DiplomacyStates[self.DiplState] ) }
end

function b_Trigger_OnDiplomacy:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.DiplState = _Parameter
    end
end

Core:RegisterBehavior(b_Trigger_OnDiplomacy);

-- -------------------------------------------------------------------------- --

---
-- Starte den Quest, sobald ein Bedürfnis nicht erfüllt wird.
--
-- @param _PlayerID ID des Spielers
-- @param _Need     Bedürfnis
-- @param _Amount   Menge an skreikenden Siedlern
--
-- @within Trigger
--
function Trigger_OnNeedUnsatisfied(...)
    return b_Trigger_OnNeedUnsatisfied:new(...);
end

b_Trigger_OnNeedUnsatisfied = {
    Name = "Trigger_OnNeedUnsatisfied",
    Description = {
        en = "Trigger: if a specified need is unsatisfied",
        de = "Auslöser: wenn ein bestimmtes Beduerfnis nicht befriedigt ist.",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Player", de = "Spieler" },
        { ParameterType.Need, en = "Need", de = "Beduerfnis" },
        { ParameterType.Number, en = "Workers on strike", de = "Streikende Arbeiter" },
    },
}

function b_Trigger_OnNeedUnsatisfied:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function b_Trigger_OnNeedUnsatisfied:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.Need = _Parameter
    elseif (_Index == 2) then
        self.WorkersOnStrike = _Parameter * 1
    end
end

function b_Trigger_OnNeedUnsatisfied:CustomFunction(_Quest)
    return Logic.GetNumberOfStrikingWorkersPerNeed( self.PlayerID, Needs[self.Need] ) &#x3E;= self.WorkersOnStrike
end

function b_Trigger_OnNeedUnsatisfied:Debug(_Quest)
    if Logic.GetStoreHouse(self.PlayerID) == 0 then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": " .. self.PlayerID .. " does not exist.")
        return true
    elseif not Needs[self.Need] then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": " .. self.Need .. " does not exist.")
        return true
    elseif self.WorkersOnStrike &#x3C; 0 then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": WorkersOnStrike value negative")
        return true
    end
    return false;
end

Core:RegisterBehavior(b_Trigger_OnNeedUnsatisfied);

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest, wenn die angegebene Mine erschöpft ist.
--
-- @param _ScriptName Skriptname der Mine
--
-- @within Trigger
--
function Trigger_OnResourceDepleted(...)
    return b_Trigger_OnResourceDepleted:new(...);
end

b_Trigger_OnResourceDepleted = {
    Name = "Trigger_OnResourceDepleted",
    Description = {
        en = "Trigger: if a resource is (temporarily) depleted",
        de = "Auslöser: wenn eine Ressource (zeitweilig) verbraucht ist",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script name", de = "Skriptname" },
    },
}

function b_Trigger_OnResourceDepleted:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function b_Trigger_OnResourceDepleted:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptName = _Parameter
    end
end

function b_Trigger_OnResourceDepleted:CustomFunction(_Quest)
    local ID = GetID(self.ScriptName)
    return not ID or ID == 0 or Logic.GetResourceDoodadGoodType(ID) == 0 or Logic.GetResourceDoodadGoodAmount(ID) == 0
end

Core:RegisterBehavior(b_Trigger_OnResourceDepleted);

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest, sobald der angegebene Spieler eine Menge an Rohstoffen
-- im Lagerhaus hat.
--
-- @param  _PlayerID ID des Spielers
-- @param  _Type     Typ des Rohstoffes
-- @param _Amount    Menge an Rohstoffen
--
-- @within Trigger
--
function Trigger_OnAmountOfGoods(...)
    return b_Trigger_OnAmountOfGoods:new(...);
end

b_Trigger_OnAmountOfGoods = {
    Name = "Trigger_OnAmountOfGoods",
    Description = {
        en = "Trigger: if the player has gathered a given amount of resources in his storehouse",
        de = "Auslöser: wenn der Spieler eine bestimmte Menge einer Ressource in seinem Lagerhaus hat",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Player", de = "Spieler" },
        { ParameterType.RawGoods, en = "Type of good", de = "Resourcentyp" },
        { ParameterType.Number, en = "Amount of good", de = "Anzahl der Resource" },
    },
}

function b_Trigger_OnAmountOfGoods:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function b_Trigger_OnAmountOfGoods:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.GoodTypeName = _Parameter
    elseif (_Index == 2) then
        self.GoodAmount = _Parameter * 1
    end
end

function b_Trigger_OnAmountOfGoods:CustomFunction(_Quest)
    local StoreHouseID = Logic.GetStoreHouse(self.PlayerID)
    if (StoreHouseID == 0) then
        return false
    end
    local GoodType = Logic.GetGoodTypeID(self.GoodTypeName)
    local GoodAmount = Logic.GetAmountOnOutStockByGoodType(StoreHouseID, GoodType)
    if (GoodAmount &#x3E;= self.GoodAmount)then
        return true
    end
    return false
end

function b_Trigger_OnAmountOfGoods:Debug(_Quest)
    if Logic.GetStoreHouse(self.PlayerID) == 0 then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": " .. self.PlayerID .. " does not exist.")
        return true
    elseif not Goods[self.GoodTypeName] then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": Good type is wrong.")
        return true
    elseif self.GoodAmount &#x3C; 0 then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": Good amount is negative.")
        return true
    end
    return false;
end

Core:RegisterBehavior(b_Trigger_OnAmountOfGoods);

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest, sobald ein anderer aktiv ist.
--
-- @param _QuestName Name des Quest
-- @param _Time      Wartezeit
-- return Table mit Behavior
-- @within Trigger
--
function Trigger_OnQuestActive(...)
    return b_Trigger_OnQuestActive:new(...);
end

b_Trigger_OnQuestActive = {
    Name = "Trigger_OnQuestActive",
    Description = {
        en = "Trigger: if a given quest has been activated. Waiting time optional",
        de = "Auslöser: wenn eine angegebene Quest aktiviert wurde. Optional mit Wartezeit",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest name", de = "Questname" },
        { ParameterType.Number,     en = "Waiting time", de = "Wartezeit"},
    },
}

function b_Trigger_OnQuestActive:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function b_Trigger_OnQuestActive:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter
    elseif (_Index == 1) then
        self.WaitTime = (_Parameter ~= nil and tonumber(_Parameter)) or 0
    end
end

function b_Trigger_OnQuestActive:CustomFunction(_Quest)
    local QuestID = GetQuestID(self.QuestName)
    if QuestID ~= nil then
        assert(type(QuestID) == "number");

        if (Quests[QuestID].State == QuestState.Active) then
            self.WasActivated = self.WasActivated or true;
        end
        if self.WasActivated then
            if self.WaitTime and self.WaitTime &#x3E; 0 then
                self.WaitTimeTimer = self.WaitTimeTimer or Logic.GetTime();
                if Logic.GetTime() &#x3E;= self.WaitTimeTimer + self.WaitTime then
                    return true;
                end
            else
                return true;
            end
        end
    end
    return false;
end

function b_Trigger_OnQuestActive:Debug(_Quest)
    if type(self.QuestName) ~= "string" then
        fatal("".._Quest.Identifier.." "..self.Name..": invalid quest name!");
        return true;
    elseif self.WaitTime and (type(self.WaitTime) ~= "number" or self.WaitTime &#x3C; 0) then
        dbg("".._Quest.Identifier.." "..self.Name..": waitTime must be a number!");
        return true;
    end
    return false;
end

function b_Trigger_OnQuestActive:Interrupt()
    -- does this realy matter after interrupt?
    -- self.WaitTimeTimer = nil;
    -- self.WasActivated = nil;
end

function b_Trigger_OnQuestActive:Reset()
    self.WaitTimeTimer = nil;
    self.WasActivated = nil;
end

Core:RegisterBehavior(b_Trigger_OnQuestActive);

-- -------------------------------------------------------------------------- --

---
-- Startet einen Quest, sobald ein anderer fehlschlägt.
--
-- @param _QuestName Name des Quest
-- @param _Time      Wartezeit
-- return Table mit Behavior
-- @within Trigger
--
function Trigger_OnQuestFailure(...)
    return b_Trigger_OnQuestFailure:new(...);
end

b_Trigger_OnQuestFailure = {
    Name = "Trigger_OnQuestFailure",
    Description = {
        en = "Trigger: if a given quest has failed. Waiting time optional",
        de = "Auslöser: wenn eine angegebene Quest fehlgeschlagen ist. Optional mit Wartezeit",
    },
    Parameter = {
        { ParameterType.QuestName,     en = "Quest name", de = "Questname" },
        { ParameterType.Number,     en = "Waiting time", de = "Wartezeit"},
    },
}

function b_Trigger_OnQuestFailure:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function b_Trigger_OnQuestFailure:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter
    elseif (_Index == 1) then
        self.WaitTime = (_Parameter ~= nil and tonumber(_Parameter)) or 0
    end
end

function b_Trigger_OnQuestFailure:CustomFunction(_Quest)
    if (GetQuestID(self.QuestName) ~= nil) then
        local QuestID = GetQuestID(self.QuestName)
        if (Quests[QuestID].Result == QuestResult.Failure) then
            if self.WaitTime and self.WaitTime &#x3E; 0 then
                self.WaitTimeTimer = self.WaitTimeTimer or Logic.GetTime();
                if Logic.GetTime() &#x3E;= self.WaitTimeTimer + self.WaitTime then
                    return true;
                end
            else
                return true;
            end
        end
    end
    return false;
end

function b_Trigger_OnQuestFailure:Debug(_Quest)
    if type(self.QuestName) ~= "string" then
        fatal("".._Quest.Identifier.." "..self.Name..": invalid quest name!");
        return true;
    elseif self.WaitTime and (type(self.WaitTime) ~= "number" or self.WaitTime &#x3C; 0) then
        dbg("".._Quest.Identifier.." "..self.Name..": waitTime must be a number!");
        return true;
    end
    return false;
end

function b_Trigger_OnQuestFailure:Interrupt()
    self.WaitTimeTimer = nil;
end

function b_Trigger_OnQuestFailure:Reset()
    self.WaitTimeTimer = nil;
end

Core:RegisterBehavior(b_Trigger_OnQuestFailure);

-- -------------------------------------------------------------------------- --

---
-- Startet einen Quest, wenn ein anderer noch nicht ausgelöst wurde.
--
-- @param _QuestName Name des Quest
-- @param _Time      Wartezeit
-- return Table mit Behavior
-- @within Trigger
--
function Trigger_OnQuestNotTriggered(...)
    return b_Trigger_OnQuestNotTriggered:new(...);
end

b_Trigger_OnQuestNotTriggered = {
    Name = "Trigger_OnQuestNotTriggered",
    Description = {
        en = "Trigger: if a given quest is not yet active. Should be used in combination with other triggers.",
        de = "Auslöser: wenn eine angegebene Quest noch inaktiv ist. Sollte mit weiteren Triggern kombiniert werden.",
    },
    Parameter = {
        { ParameterType.QuestName,     en = "Quest name", de = "Questname" },
    },
}

function b_Trigger_OnQuestNotTriggered:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function b_Trigger_OnQuestNotTriggered:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter
    end
end

function b_Trigger_OnQuestNotTriggered:CustomFunction(_Quest)
    if (GetQuestID(self.QuestName) ~= nil) then
        local QuestID = GetQuestID(self.QuestName)
        if (Quests[QuestID].State == QuestState.NotTriggered) then
            return true;
        end
    end
    return false;
end

function b_Trigger_OnQuestNotTriggered:Debug(_Quest)
    if type(self.QuestName) ~= "string" then
        fatal("".._Quest.Identifier.." "..self.Name..": invalid quest name!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Trigger_OnQuestNotTriggered);

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest, sobald ein anderer unterbrochen wurde.
--
-- @param _QuestName Name des Quest
-- @param _Time      Wartezeit
-- return Table mit Behavior
-- @within Trigger
--
function Trigger_OnQuestInterrupted(...)
    return b_Trigger_OnQuestInterrupted:new(...);
end

b_Trigger_OnQuestInterrupted = {
    Name = "Trigger_OnQuestInterrupted",
    Description = {
        en = "Trigger: if a given quest has been interrupted. Should be used in combination with other triggers.",
        de = "Auslöser: wenn eine angegebene Quest abgebrochen wurde. Sollte mit weiteren Triggern kombiniert werden.",
    },
    Parameter = {
        { ParameterType.QuestName,     en = "Quest name", de = "Questname" },
        { ParameterType.Number,     en = "Waiting time", de = "Wartezeit"},
    },
}

function b_Trigger_OnQuestInterrupted:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function b_Trigger_OnQuestInterrupted:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter
    elseif (_Index == 1) then
        self.WaitTime = (_Parameter ~= nil and tonumber(_Parameter)) or 0
    end
end

function b_Trigger_OnQuestInterrupted:CustomFunction(_Quest)
    if (GetQuestID(self.QuestName) ~= nil) then
        local QuestID = GetQuestID(self.QuestName)
        if (Quests[QuestID].State == QuestState.Over and Quests[QuestID].Result == QuestResult.Interrupted) then
            if self.WaitTime and self.WaitTime &#x3E; 0 then
                self.WaitTimeTimer = self.WaitTimeTimer or Logic.GetTime();
                if Logic.GetTime() &#x3E;= self.WaitTimeTimer + self.WaitTime then
                    return true;
                end
            else
                return true;
            end
        end
    end
    return false;
end

function b_Trigger_OnQuestInterrupted:Debug(_Quest)
    if type(self.QuestName) ~= "string" then
        fatal("".._Quest.Identifier.." "..self.Name..": invalid quest name!");
        return true;
    elseif self.WaitTime and (type(self.WaitTime) ~= "number" or self.WaitTime &#x3C; 0) then
        dbg("".._Quest.Identifier.." "..self.Name..": waitTime must be a number!");
        return true;
    end
    return false;
end

function b_Trigger_OnQuestInterrupted:Interrupt()
    self.WaitTimeTimer = nil;
end

function b_Trigger_OnQuestInterrupted:Reset()
    self.WaitTimeTimer = nil;
end

Core:RegisterBehavior(b_Trigger_OnQuestInterrupted);

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest, sobald ein anderer bendet wurde.
--
-- Dabei ist das Resultat egal. Der Quest kann entweder erfolgreich beendet
-- wurden oder fehlgeschlagen sein.
--
-- @param _QuestName Name des Quest
-- @param _Time      Wartezeit
-- return Table mit Behavior
-- @within Trigger
--
function Trigger_OnQuestOver(...)
    return b_Trigger_OnQuestOver:new(...);
end

b_Trigger_OnQuestOver = {
    Name = "Trigger_OnQuestOver",
    Description = {
        en = "Trigger: if a given quest has been finished, regardless of its result. Waiting time optional",
        de = "Auslöser: wenn eine angegebene Quest beendet wurde, unabhängig von deren Ergebnis. Wartezeit optional",
    },
    Parameter = {
        { ParameterType.QuestName,     en = "Quest name", de = "Questname" },
        { ParameterType.Number,     en = "Waiting time", de = "Wartezeit"},
    },
}

function b_Trigger_OnQuestOver:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function b_Trigger_OnQuestOver:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter
    elseif (_Index == 1) then
        self.WaitTime = (_Parameter ~= nil and tonumber(_Parameter)) or 0
    end
end

function b_Trigger_OnQuestOver:CustomFunction(_Quest)
    if (GetQuestID(self.QuestName) ~= nil) then
        local QuestID = GetQuestID(self.QuestName)
        if (Quests[QuestID].State == QuestState.Over and Quests[QuestID].Result ~= QuestResult.Interrupted) then
            if self.WaitTime and self.WaitTime &#x3E; 0 then
                self.WaitTimeTimer = self.WaitTimeTimer or Logic.GetTime();
                if Logic.GetTime() &#x3E;= self.WaitTimeTimer + self.WaitTime then
                    return true;
                end
            else
                return true;
            end
        end
    end
    return false;
end

function b_Trigger_OnQuestOver:Debug(_Quest)
    if type(self.QuestName) ~= "string" then
        fatal("".._Quest.Identifier.." "..self.Name..": invalid quest name!");
        return true;
    elseif self.WaitTime and (type(self.WaitTime) ~= "number" or self.WaitTime &#x3C; 0) then
        dbg("".._Quest.Identifier.." "..self.Name..": waitTime must be a number!");
        return true;
    end
    return false;
end

function b_Trigger_OnQuestOver:Interrupt()
    self.WaitTimeTimer = nil;
end

function b_Trigger_OnQuestOver:Reset()
    self.WaitTimeTimer = nil;
end

Core:RegisterBehavior(b_Trigger_OnQuestOver);

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest, sobald ein anderer Quest erfolgreich abgeschlossen wurde.
--
-- @param _QuestName Name des Quest
-- @param _Time      Wartezeit
-- return Table mit Behavior
-- @within Trigger
--
function Trigger_OnQuestSuccess(...)
    return b_Trigger_OnQuestSuccess:new(...);
end

b_Trigger_OnQuestSuccess = {
    Name = "Trigger_OnQuestSuccess",
    Description = {
        en = "Trigger: if a given quest has been finished successfully. Waiting time optional",
        de = "Auslöser: wenn eine angegebene Quest erfolgreich abgeschlossen wurde. Wartezeit optional",
    },
    Parameter = {
        { ParameterType.QuestName,     en = "Quest name", de = "Questname" },
        { ParameterType.Number,     en = "Waiting time", de = "Wartezeit"},
    },
}

function b_Trigger_OnQuestSuccess:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function b_Trigger_OnQuestSuccess:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter
    elseif (_Index == 1) then
        self.WaitTime = (_Parameter ~= nil and tonumber(_Parameter)) or 0
    end
end

function b_Trigger_OnQuestSuccess:CustomFunction()
    if (GetQuestID(self.QuestName) ~= nil) then
        local QuestID = GetQuestID(self.QuestName)
        if (Quests[QuestID].Result == QuestResult.Success) then
            if self.WaitTime and self.WaitTime &#x3E; 0 then
                self.WaitTimeTimer = self.WaitTimeTimer or Logic.GetTime();
                if Logic.GetTime() &#x3E;= self.WaitTimeTimer + self.WaitTime then
                    return true;
                end
            else
                return true;
            end
        end
    end
    return false;
end

function b_Trigger_OnQuestSuccess:Debug(_Quest)
    if type(self.QuestName) ~= "string" then
        fatal("".._Quest.Identifier.." "..self.Name..": invalid quest name!");
        return true;
    elseif self.WaitTime and (type(self.WaitTime) ~= "number" or self.WaitTime &#x3C; 0) then
        dbg("".._Quest.Identifier.." "..self.Name..": waittime must be a number!");
        return true;
    end
    return false;
end

function b_Trigger_OnQuestSuccess:Interrupt()
    self.WaitTimeTimer = nil;
end

function b_Trigger_OnQuestSuccess:Reset()
    self.WaitTimeTimer = nil;
end

Core:RegisterBehavior(b_Trigger_OnQuestSuccess);

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest, wenn eine benutzerdefinierte Variable einen bestimmten
-- Wert angenommen hat.
--
-- Benutzerdefinierte Variablen müssen Zahlen sein. Bevor eine
-- Variable in einem Goal abgefragt werden kann, muss sie zuvor mit
-- Reprisal_CustomVariables oder Reward_CutsomVariables initialisiert
-- worden sein.
--
-- @param _Name     Name der Variable
-- @param _Relation Vergleichsoperator
-- @param _Value    Wert oder Custom Variable
--
-- @within Trigger
--
function Trigger_CustomVariables(...)
    return b_Trigger_CustomVariables:new(...);
end

b_Trigger_CustomVariables = {
    Name = "Trigger_CustomVariables",
    Description = {
        en = "Trigger: if the variable has a certain value.",
        de = "Auslöser: wenn die Variable einen bestimmen Wert eingenommen hat.",
    },
    Parameter = {
        { ParameterType.Default, en = "Name of Variable", de = "Variablennamen" },
        { ParameterType.Custom,  en = "Relation", de = "Relation" },
        { ParameterType.Default, en = "Value", de = "Wert" }
    }
};

function b_Trigger_CustomVariables:GetTriggerTable()
    return { Triggers.Custom2, {self, self.CustomFunction} };
end

function b_Trigger_CustomVariables:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        self.VariableName = _Parameter
    elseif _Index == 1 then
        self.Relation = _Parameter
    elseif _Index == 2 then
        local value = tonumber(_Parameter);
        value = (value ~= nil and value) or _Parameter;
        self.Value = value
    end
end

function b_Trigger_CustomVariables:CustomFunction()
    _G["QSB_CustomVariables_"..self.VariableName] = _G["QSB_CustomVariables_"..self.VariableName] or 0;

    if self.Relation == "==" then
        return _G["QSB_CustomVariables_"..self.VariableName] == ((type(self.Value) ~= "string" and self.Value) or _G["QSB_CustomVariables_"..self.Value]);
    elseif self.Relation ~= "~=" then
        return _G["QSB_CustomVariables_"..self.VariableName] ~= ((type(self.Value) ~= "string" and self.Value) or _G["QSB_CustomVariables_"..self.Value]);
    elseif self.Relation == "&#x3E;" then
        return _G["QSB_CustomVariables_"..self.VariableName] &#x3E; ((type(self.Value) ~= "string" and self.Value) or _G["QSB_CustomVariables_"..self.Value]);
    elseif self.Relation == "&#x3E;=" then
        return _G["QSB_CustomVariables_"..self.VariableName] &#x3E;= ((type(self.Value) ~= "string" and self.Value) or _G["QSB_CustomVariables_"..self.Value]);
    elseif self.Relation == "&#x3C;=" then
        return _G["QSB_CustomVariables_"..self.VariableName] &#x3C;= ((type(self.Value) ~= "string" and self.Value) or _G["QSB_CustomVariables_"..self.Value]);
    else
        return _G["QSB_CustomVariables_"..self.VariableName] &#x3C; ((type(self.Value) ~= "string" and self.Value) or _G["QSB_CustomVariables_"..self.Value]);
    end
    return false;
end

function b_Trigger_CustomVariables:GetCustomData( _Index )
    if _Index == 1 then
        return {"==", "~=", "&#x3C;=", "&#x3C;", "&#x3E;", "&#x3E;="};
    end
end

function b_Trigger_CustomVariables:Debug(_Quest)
    local relations = {"==", "~=", "&#x3C;=", "&#x3C;", "&#x3E;", "&#x3E;="}
    local results    = {true, false, nil}

    if not _G["QSB_CustomVariables_"..self.VariableName] then
        warn(_Quest.Identifier.." "..self.Name..": variable '"..self.VariableName.."' do not exist!");
    end
    if not Inside(self.Relation,relations) then
        fatal(_Quest.Identifier.." "..self.Name..": '"..self.Relation.."' is an invalid relation!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Trigger_CustomVariables)

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest sofort.
--
-- @within Trigger
--
function Trigger_AlwaysActive()
    return b_Trigger_AlwaysActive:new()
end

b_Trigger_AlwaysActive = {
    Name = "Trigger_AlwaysActive",
    Description = {
        en = "Trigger: the map has been started.",
        de = "Auslöser: Start der Karte.",
    },
}

function b_Trigger_AlwaysActive:GetTriggerTable()
    return {Triggers.Time, 0 }
end

Core:RegisterBehavior(b_Trigger_AlwaysActive);

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest im angegebenen Monat.
--
-- @param _Month Monat
--
-- @within Trigger
--
function Trigger_OnMonth(...)
    return b_Trigger_OnMonth:new(...);
end

b_Trigger_OnMonth = {
    Name = "Trigger_OnMonth",
    Description = {
        en = "Trigger: a specified month",
        de = "Auslöser: ein bestimmter Monat",
    },
    Parameter = {
        { ParameterType.Custom, en = "Month", de = "Monat" },
    },
}

function b_Trigger_OnMonth:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function b_Trigger_OnMonth:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Month = _Parameter * 1
    end
end

function b_Trigger_OnMonth:CustomFunction(_Quest)
    return self.Month == Logic.GetCurrentMonth()
end

function b_Trigger_OnMonth:GetCustomData( _Index )
    local Data = {}
    if _Index == 0 then
        for i = 1, 12 do
            table.insert( Data, i )
        end
    else
        assert( false )
    end
    return Data
end

function b_Trigger_OnMonth:Debug(_Quest)
    if self.Month &#x3C; 1 or self.Month &#x3E; 12 then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": Month has the wrong value")
        return true
    end
    return false;
end

Core:RegisterBehavior(b_Trigger_OnMonth);

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest sobald der Monsunregen einsetzt.
--
-- &#x3C;b&#x3E;Achtung:&#x3C;/b&#x3E; Dieses Behavior ist nur für Reich des Ostens verfügbar.
--
-- @within Trigger
--
function Trigger_OnMonsoon()
    return b_Trigger_OnMonsoon:new();
end

b_Trigger_OnMonsoon = {
    Name = "Trigger_OnMonsoon",
    Description = {
        en = "Trigger: on monsoon.",
        de = "Auslöser: wenn der Monsun beginnt.",
    },
    RequiresExtraNo = 1,
}

function b_Trigger_OnMonsoon:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function b_Trigger_OnMonsoon:CustomFunction(_Quest)
    if Logic.GetWeatherDoesShallowWaterFlood(0) then
        return true
    end
end

Core:RegisterBehavior(b_Trigger_OnMonsoon);

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest sobald der Timer abgelaufen ist.
--
-- Der Timer zählt immer vom Start der Map an.
--
-- @param _Time Zeit bis zum Start
--
-- @within Trigger
--
function Trigger_Time(...)
    return b_Trigger_Time:new(...);
end

b_Trigger_Time = {
    Name = "Trigger_Time",
    Description = {
        en = "Trigger: a given amount of time since map start",
        de = "Auslöser: eine gewisse Anzahl Sekunden nach Spielbeginn",
    },
    Parameter = {
        { ParameterType.Number, en = "Time (sec.)", de = "Zeit (Sek.)" },
    },
}

function b_Trigger_Time:GetTriggerTable()
    return {Triggers.Time, self.Time }
end

function b_Trigger_Time:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Time = _Parameter * 1
    end
end

Core:RegisterBehavior(b_Trigger_Time);

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest sobald das Wasser gefriert.
--
-- @within Trigger
--
function Trigger_OnWaterFreezes()
    return b_Trigger_OnWaterFreezes:new();
end

b_Trigger_OnWaterFreezes = {
    Name = "Trigger_OnWaterFreezes",
    Description = {
        en = "Trigger: if the water starts freezing",
        de = "Auslöser: wenn die Gewässer gefrieren",
    },
}

function b_Trigger_OnWaterFreezes:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function b_Trigger_OnWaterFreezes:CustomFunction(_Quest)
    if Logic.GetWeatherDoesWaterFreeze(0) then
        return true
    end
end

Core:RegisterBehavior(b_Trigger_OnWaterFreezes);

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest niemals.
--
-- Quests, für die dieser Trigger gesetzt ist, müssen durch einen anderen
-- Quest über Reward_QuestActive oder Reprisal_QuestActive gestartet werden.
--
-- @within Trigger
--
function Trigger_NeverTriggered()
    return b_Trigger_NeverTriggered:new();
end

b_Trigger_NeverTriggered = {
    Name = "Trigger_NeverTriggered",
    Description = {
        en = "Never triggers a Quest. The quest may be set active by Reward_QuestActivate or Reward_QuestRestartForceActive",
        de = "Löst nie eine Quest aus. Die Quest kann von Reward_QuestActivate oder Reward_QuestRestartForceActive aktiviert werden.",
    },
}

function b_Trigger_NeverTriggered:GetTriggerTable()

    return {Triggers.Custom2, {self, function() end} }

end

Core:RegisterBehavior(b_Trigger_NeverTriggered)

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest, sobald wenigstens einer von zwei Quests fehlschlägt.
--
-- @param _QuestName1 Name des ersten Quest
-- @param _QuestName2 Name des zweiten Quest
--
-- @within Trigger
--
function Trigger_OnAtLeastOneQuestFailure(...)
    return b_Trigger_OnAtLeastOneQuestFailure:new(...);
end

b_Trigger_OnAtLeastOneQuestFailure = {
    Name = "Trigger_OnAtLeastOneQuestFailure",
    Description = {
        en = "Trigger: if one or both of the given quests have failed.",
        de = "Auslöser: wenn einer oder beide der angegebenen Aufträge fehlgeschlagen sind.",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest Name 1", de = "Questname 1" },
        { ParameterType.QuestName, en = "Quest Name 2", de = "Questname 2" },
    },
}

function b_Trigger_OnAtLeastOneQuestFailure:GetTriggerTable()
    return {Triggers.Custom2, {self, self.CustomFunction}};
end

function b_Trigger_OnAtLeastOneQuestFailure:AddParameter(_Index, _Parameter)
    self.QuestTable = {};

    if (_Index == 0) then
        self.Quest1 = _Parameter;
    elseif (_Index == 1) then
        self.Quest2 = _Parameter;
    end
end

function b_Trigger_OnAtLeastOneQuestFailure:CustomFunction(_Quest)
    local Quest1 = Quests[GetQuestID(self.Quest1)];
    local Quest2 = Quests[GetQuestID(self.Quest2)];
    if (Quest1.State == QuestState.Over and Quest1.Result == QuestResult.Failure)
    or (Quest2.State == QuestState.Over and Quest2.Result == QuestResult.Failure) then
        return true;
    end
    return false;
end

function b_Trigger_OnAtLeastOneQuestFailure:Debug(_Quest)
    if self.Quest1 == self.Quest2 then
        fatal(_Quest.Identifier..": "..self.Name..": Both quests are identical!");
        return true;
    elseif not IsValidQuest(self.Quest1) then
        fatal(_Quest.Identifier..": "..self.Name..": Quest '"..self.Quest1.."' does not exist!");
        return true;
    elseif not IsValidQuest(self.Quest2) then
        fatal(_Quest.Identifier..": "..self.Name..": Quest '"..self.Quest2.."' does not exist!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Trigger_OnAtLeastOneQuestFailure);

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest, sobald wenigstens einer von zwei Quests erfolgreich ist.
--
-- @param _QuestName1 Name des ersten Quest
-- @param _QuestName2 Name des zweiten Quest
--
-- @within Trigger
--
function Trigger_OnAtLeastOneQuestSuccess(...)
    return b_Trigger_OnAtLeastOneQuestSuccess:new(...);
end

b_Trigger_OnAtLeastOneQuestSuccess = {
    Name = "Trigger_OnAtLeastOneQuestSuccess",
    Description = {
        en = "Trigger: if one or both of the given quests are won.",
        de = "Auslöser: wenn einer oder beide der angegebenen Aufträge gewonnen wurden.",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest Name 1", de = "Questname 1" },
        { ParameterType.QuestName, en = "Quest Name 2", de = "Questname 2" },
    },
}

function b_Trigger_OnAtLeastOneQuestSuccess:GetTriggerTable()
    return {Triggers.Custom2, {self, self.CustomFunction}};
end

function b_Trigger_OnAtLeastOneQuestSuccess:AddParameter(_Index, _Parameter)
    self.QuestTable = {};

    if (_Index == 0) then
        self.Quest1 = _Parameter;
    elseif (_Index == 1) then
        self.Quest2 = _Parameter;
    end
end

function b_Trigger_OnAtLeastOneQuestSuccess:CustomFunction(_Quest)
    local Quest1 = Quests[GetQuestID(self.Quest1)];
    local Quest2 = Quests[GetQuestID(self.Quest2)];
    if (Quest1.State == QuestState.Over and Quest1.Result == QuestResult.Success)
    or (Quest2.State == QuestState.Over and Quest2.Result == QuestResult.Success) then
        return true;
    end
    return false;
end

function b_Trigger_OnAtLeastOneQuestSuccess:Debug(_Quest)
    if self.Quest1 == self.Quest2 then
        fatal(_Quest.Identifier..": "..self.Name..": Both quests are identical!");
        return true;
    elseif not IsValidQuest(self.Quest1) then
        fatal(_Quest.Identifier..": "..self.Name..": Quest '"..self.Quest1.."' does not exist!");
        return true;
    elseif not IsValidQuest(self.Quest2) then
        fatal(_Quest.Identifier..": "..self.Name..": Quest '"..self.Quest2.."' does not exist!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Trigger_OnAtLeastOneQuestSuccess);

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest, sobald mindestens X von Y Quests erfolgreich sind.
--
-- @param _MinAmount   Mindestens zu erfüllen (max. 5)
-- @param _QuestAmount Anzahl geprüfter Quests (max. 5 und &#x3E;= _MinAmount)
-- @param _Quest1      Name des 1. Quest
-- @param _Quest2      Name des 2. Quest
-- @param _Quest3      Name des 3. Quest
-- @param _Quest4      Name des 4. Quest
-- @param _Quest5      Name des 5. Quest
--
-- @within Trigger
--
function Trigger_OnAtLeastXOfYQuestsSuccess(...)
    return b_Trigger_OnAtLeastXOfYQuestsSuccess:new(...);
end

b_Trigger_OnAtLeastXOfYQuestsSuccess = {
    Name = "Trigger_OnAtLeastXOfYQuestsSuccess",
    Description = {
        en = "Trigger: if at least X of Y given quests has been finished successfully.",
        de = "Auslöser: wenn X von Y angegebener Quests erfolgreich abgeschlossen wurden.",
    },
    Parameter = {
        { ParameterType.Custom, en = "Least Amount", de = "Mindest Anzahl" },
        { ParameterType.Custom, en = "Quest Amount", de = "Quest Anzahl" },
        { ParameterType.QuestName, en = "Quest name 1", de = "Questname 1" },
        { ParameterType.QuestName, en = "Quest name 2", de = "Questname 2" },
        { ParameterType.QuestName, en = "Quest name 3", de = "Questname 3" },
        { ParameterType.QuestName, en = "Quest name 4", de = "Questname 4" },
        { ParameterType.QuestName, en = "Quest name 5", de = "Questname 5" },
    },
}

function b_Trigger_OnAtLeastXOfYQuestsSuccess:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function b_Trigger_OnAtLeastXOfYQuestsSuccess:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.LeastAmount = tonumber(_Parameter)
    elseif (_Index == 1) then
        self.QuestAmount = tonumber(_Parameter)
    elseif (_Index == 2) then
        self.QuestName1 = _Parameter
    elseif (_Index == 3) then
        self.QuestName2 = _Parameter
    elseif (_Index == 4) then
        self.QuestName3 = _Parameter
    elseif (_Index == 5) then
        self.QuestName4 = _Parameter
    elseif (_Index == 6) then
        self.QuestName5 = _Parameter
    end
end

function b_Trigger_OnAtLeastXOfYQuestsSuccess:CustomFunction()
    local least = 0
    for i = 1, self.QuestAmount do
        local QuestID = GetQuestID(self["QuestName"..i]);
        if IsValidQuest(QuestID) then
			if (Quests[QuestID].Result == QuestResult.Success) then
				least = least + 1
				if least &#x3E;= self.LeastAmount then
					return true
				end
			end
		end
    end
    return false
end

function b_Trigger_OnAtLeastXOfYQuestsSuccess:Debug(_Quest)
    local leastAmount = self.LeastAmount
    local questAmount = self.QuestAmount
    if leastAmount &#x3C;= 0 or leastAmount &#x3E;5 then
        fatal(_Quest.Identifier .. ": Error in " .. self.Name .. ": LeastAmount is wrong")
        return true
    elseif questAmount &#x3C;= 0 or questAmount &#x3E; 5 then
        fatal(_Quest.Identifier .. ": Error in " .. self.Name .. ": QuestAmount is wrong")
        return true
    elseif leastAmount &#x3E; questAmount then
        fatal(_Quest.Identifier .. ": Error in " .. self.Name .. ": LeastAmount is greater than QuestAmount")
        return true
    end
    for i = 1, questAmount do
        if not IsValidQuest(self["QuestName"..i]) then
            fatal(_Quest.Identifier .. ": Error in " .. self.Name .. ": Quest ".. self["QuestName"..i] .. " not found")
            return true
        end
    end
    return false
end

function b_Trigger_OnAtLeastXOfYQuestsSuccess:GetCustomData(_Index)
    if (_Index == 0) or (_Index == 1) then
        return {"1", "2", "3", "4", "5"}
    end
end

Core:RegisterBehavior(b_Trigger_OnAtLeastXOfYQuestsSuccess)

-- -------------------------------------------------------------------------- --

---
-- Führt eine Funktion im Skript als Trigger aus.
--
-- Die Funktion muss entweder true or false zurückgeben.
--
-- Nur Skipt: Wird statt einem Funktionsnamen (String) eine Funktionsreferenz
-- übergeben, werden alle weiteren Parameter an die Funktion weitergereicht.
--
-- @param _FunctionName Name der Funktion
--
-- @within Trigger
--
function Trigger_MapScriptFunction(...)
    return b_Trigger_MapScriptFunction:new(...);
end

b_Trigger_MapScriptFunction = {
    Name = "Trigger_MapScriptFunction",
    Description = {
        en = "Calls a function within the global map script. If the function returns true the quest will be started",
        de = "Ruft eine Funktion im globalen Skript auf. Wenn sie true sendet, wird die Quest gestartet.",
    },
    Parameter = {
        { ParameterType.Default, en = "Function name", de = "Funktionsname" },
    },
}

function b_Trigger_MapScriptFunction:GetTriggerTable(_Quest)
    return {Triggers.Custom2, {self, self.CustomFunction}};
end

function b_Trigger_MapScriptFunction:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.FuncName = _Parameter
    end
end

function b_Trigger_MapScriptFunction:CustomFunction(_Quest)
    if type(self.FuncName) == "function" then
        return self.Function(unpack(self.i47ya_6aghw_frxil));
    end
    return _G[self.FuncName](self, _Quest);
end

function b_Trigger_MapScriptFunction:Debug(_Quest)
    if not self.FuncName then
        fatal(_Quest.Identifier.." "..self.Name..": function reference is invalid!");
        return true;
    end
    if type(self.FuncName) == "string" and not _G[self.FuncName] then
        fatal(_Quest.Identifier.." "..self.Name..": function does not exist!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Trigger_MapScriptFunction);

-- -------------------------------------------------------------------------- --
-- Veränderte Behavior (Build 1410)                                           --
-- -------------------------------------------------------------------------- --

---
-- Der Spieler muss im Chatdialog eine Eingabe tätigen.
--
-- Die Eingabe wird im Quest gespeichert und kann zur späteren Verarbeitung
-- angefragt werden.
--
-- Das Behaviour kann auch eingesetzt werden, um ein Passwort zu prüfen.
-- In diesem Fall wird die Eingabe mit dem Passwort verglichen. Die Anzal der
-- Versuche bestimmt, wie oft falsch eingegeben werden darf.
--
-- Wenn die Anzahl der Versuche begrenzt ist, wird eine Srandardnachricht mit
-- den übrigen Versuchen angezeigt. Optional kann eine Nachricht angegeben
-- werden, die stattdessen nach &#x3C;u&#x3E;jeder&#x3C;/u&#x3E; Falscheingabe, &#x3C;u&#x3E;außer&#x3C;/u&#x3E; der
-- letzten, angezeigt wird.
--
-- @param _Passwords Liste der Passwörter
-- @param _Trials    Anzahl versuche (0 für unendlich)
-- @param _Message   Alternative Fehlernachricht
--
-- @within Goal
--
function Goal_InputDialog(...)
    return b_Goal_InputDialog:new(...);
end

b_Goal_InputDialog  = {
    Name = "Goal_InputDialog",
    Description = {
        en = "Goal: Player must type in something. The passwords have to be seperated by ; and whitespaces will be ignored.",
        de = "Ziel: Oeffnet einen Dialog, der Spieler muss Lösungswörter eingeben. Diese sind durch ; abzutrennen. Leerzeichen werden ignoriert.",
    },
    DefaultMessage = {
        de = "Versuche bis zum Fehlschlag: ",
        en = "Trials remaining until failure: "
    },
    Parameter = {
        {ParameterType.Default, en = "Password to enter", de = "Einzugebendes Passwort" },
        {ParameterType.Number, en = "Trials till failure (0 endless)", de = "Versuche bis Fehlschlag (0 endlos)" },
        {ParameterType.Default, en = "Wrong password message", de = "Text bei Falscheingabe" },
    }
}

function b_Goal_InputDialog:GetGoalTable()
    return { Objective.Custom2, {self, self.CustomFunction}}
end

function b_Goal_InputDialog:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Password = self:LowerCase(_Parameter or "");
    elseif (_Index == 1) then
        self.Trials = (_Parameter or 0) * 1;
    elseif (_Index == 2) then
        self.Message = _Parameter;
        local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";
        if type(self.Message) == "table" then
            self.Message = self.Message[lang];
        end
    end
end

function b_Goal_InputDialog:CustomFunction(_Quest)
    local Box = function(_QuestName)
        if not self.Shown then
            self:InitReturnVariable(_QuestName);
            self:ShowBox();
            self.Shown = true;
        end
    end

    if not IsBriefingActive or (IsBriefingActive and IsBriefingActive() == false) then
        if (not self.Trials) or (self.Trials) == 0 then
            Box(_Quest.Identifier);
        elseif not self.Shown then
            self.TrialCounter = self.TrialCounter or self.Trials;
            Box(_Quest.Identifier);
            self.TrialCounter = self.TrialCounter - 1;
        end

        if _Quest.InputDialogResult then
            Logic.ExecuteInLuaLocalState([[
                GUI_Chat.Confirm = GUI_Chat.Confirm_Orig_Goal_InputDialog
                GUI_Chat.Confirm_Orig_Goal_InputDialog = nil
                GUI_Chat.Abort = GUI_Chat.Abort_Orig_Goal_InputDialog
                GUI_Chat.Abort_Orig_Goal_InputDialog = nil
            ]]);

            if self.Password ~= nil and self.Password ~= "" then
                self.Shown = nil;

                if self:LowerCase(_Quest.InputDialogResult) == self.Password then
                    return true;
                elseif (self.Trials == 0) or (self.Trials &#x3E; 0 and self.TrialCounter &#x3E; 0) then
                    self:OnWrongInput(_Quest);
                    return;
                else
                    return false;
                end
            end
            return true;
        end
    end
end

function b_Goal_InputDialog:OnWrongInput(_Quest)
    if self.Trials &#x3E; 0 and not self.Message then
        local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";
        Logic.DEBUG_AddNote(self.DefaultMessage .. self.TrialCounter);
        return;
    end
    if self.Message then
        Logic.DEBUG_AddNote(self.Message);
    end
    _Quest.InputDialogResult = nil;
end

function b_Goal_InputDialog:LowerCase(_Text)
    _Text = _Text:lower(_Text);
    -- Umlaute manuell austauschen
    -- FIXME: Ausländische Umlaute auch anpassen.
    _Text = _Text:gsub("Ä", "ä");
    _Text = _Text:gsub("Ö", "ö");
    _Text = _Text:gsub("Ü", "ü");
    return _Text;
end

function b_Goal_InputDialog:ShowBox()
    Logic.ExecuteInLuaLocalState([[
        Input.ChatMode()
        XGUIEng.ShowWidget("/InGame/Root/Normal/ChatInput",1)
        XGUIEng.SetText("/InGame/Root/Normal/ChatInput/ChatInput", "")
        XGUIEng.SetFocus("/InGame/Root/Normal/ChatInput/ChatInput")
    ]])
end

function b_Goal_InputDialog:InitReturnVariable(_QuestName)
    Logic.ExecuteInLuaLocalState([[
        GUI_Chat.Abort_Orig_Goal_InputDialog = GUI_Chat.Abort
        GUI_Chat.Confirm_Orig_Goal_InputDialog = GUI_Chat.Confirm

        GUI_Chat.Confirm = function()
            Input.GameMode()
            XGUIEng.ShowWidget("/InGame/Root/Normal/ChatInput",0)
            local ChatMessage = XGUIEng.GetText("/InGame/Root/Normal/ChatInput/ChatInput")
            g_Chat.JustClosed = 1
            GUI.SendScriptCommand("Quests[GetQuestID(']].. _QuestName ..[[')].InputDialogResult = '"..ChatMessage.."'")
        end
        GUI_Chat.Abort = function()
        end
    ]])
end

function b_Goal_InputDialog:Debug(_Quest)
    return false;
end

function b_Goal_InputDialog:GetIcon()
    return {12,2};
end

function b_Goal_InputDialog:Reset(_Quest)
    _Quest.InputDialogResult = nil;
    self.TrialCounter = nil;
    self.Shown = nil;
end

Core:RegisterBehavior(b_Goal_InputDialog);

-- -------------------------------------------------------------------------- --
-- Behavior Nachimplementiert(Build 1420)                                     --
-- -------------------------------------------------------------------------- --

---
-- Startet den Quest, sobald ein Effekt zerstört wird oder verschwindet.
--
-- &#x3C;b&#x3E;Achtung&#x3C;/b&#x3E;: Das Behavior kann nur auf Effekte angewand werden, die
-- über Effekt-Behavior erzeugt wurden.
--
-- @param _EffectName Name des Effekt
--
-- @within Trigger
--
function Trigger_OnEffectDestroyed(...)
    return b_Trigger_OnEffectDestroyed:new(...);
end

b_Trigger_OnEffectDestroyed = {
	Name = "Trigger_OnEffectDestroyed",
	Description = {
		en = "Trigger: Starts a quest after an effect was destroyed",
		de = "Ausloeser: Startet eine Quest, nachdem ein Effekt zerstoert wurde",
	},
	Parameter = {
		{ ParameterType.Default, en = "Effect name", de = "Effektname" },
	},
}

function b_Trigger_OnEffectDestroyed:GetTriggerTable()
	return { Triggers.Custom2, {self, self.CustomFunction} }
end

function b_Trigger_OnEffectDestroyed:AddParameter(_Index, _Parameter)
	if _Index == 0 then	
		self.EffectName = _Parameter
	end
end

function b_Trigger_OnEffectDestroyed:CustomFunction()
	return not QSB.EffectNameToID[self.EffectName] or not Logic.IsEffectRegistered(QSB.EffectNameToID[self.EffectName]);
end

function b_Trigger_OnEffectDestroyed:Debug(_Quest)
	if not QSB.EffectNameToID[self.EffectName] then
		fatal(_Quest.Identifier .. " " .. self.Name .. ": Effect has never existed")
		return true
	end
end
Core:RegisterBehavior(b_Trigger_OnEffectDestroyed)

-- -------------------------------------------------------------------------- --

---
-- Setzt das Upgrade Level des angegebenen Gebäudes.
--
-- Ein Geböude erhält sofort eine neue Stufe, ohne dass ein Arbeiter kommen
-- und es ausbauen muss. Für eine Werkstatt wird ein neuer Arbeiter gespawnt.
--
-- @param _ScriptName Skriptname des Gebäudes
-- @param _Level Upgrade Level
--
-- @within Reward
--
function Reward_SetBuildingUpgradeLevel(...)
    return b_Reward_SetBuildingUpgradeLevel:new(...);
end

b_Reward_SetBuildingUpgradeLevel = {
	Name = "Reward_SetBuildingUpgradeLevel",
	Description = {
		en = "Sets the upgrade level of the specified building.",
		de = "Legt das Upgrade-Level eines Gebaeudes fest.",
	},
	Parameter = {
		{ ParameterType.ScriptName, en = "Building", de = "Gebäude" },
		{ ParameterType.Custom, en = "Upgrade level", de = "Upgrade-Level" },
	}
};
 
function b_Reward_SetBuildingUpgradeLevel:GetRewardTable()

	return {Reward.Custom, self, self.CustomFunction};

end
 
function b_Reward_SetBuildingUpgradeLevel:AddParameter(_Index, _Parameter)
	if _Index == 0 then
		self.Building = _Parameter;
	elseif _Index == 1 then
		self.UpgradeLevel = tonumber(_Parameter);
	end
end
 
function b_Reward_SetBuildingUpgradeLevel:CustomFunction()
	local building = Logic.GetEntityIDByName(self.Building);
	local upgradeLevel = Logic.GetUpgradeLevel(building);
	local maxUpgradeLevel = Logic.GetMaxUpgradeLevel(building);
	if building ~= 0 
	and Logic.IsBuilding(building) == 1 
	and (Logic.IsBuildingUpgradable(building, true) 
	or (maxUpgradeLevel ~= 0 
	and maxUpgradeLevel == upgradeLevel)) 
	then
		Logic.SetUpgradableBuildingState(building, math.min(self.UpgradeLevel, maxUpgradeLevel), 0);
	end
end

function b_Reward_SetBuildingUpgradeLevel:Debug(_Quest)
	local building = Logic.GetEntityIDByName( self.Building )
	local maxUpgradeLevel = Logic.GetMaxUpgradeLevel(building);
	if not building or Logic.IsBuilding(building) == 0  then
		fatal(_Quest.Identifier .. " " .. self.Name .. ": Building " .. self.Building .. " is missing or no building.")
		return true
	elseif not self.UpgradeLevel or self.UpgradeLevel &#x3C; 0 then
		fatal(_Quest.Identifier .. " " .. self.Name .. ": Upgrade level is wrong")
		return true
	end
end

function b_Reward_SetBuildingUpgradeLevel:GetCustomData(_Index)
    if _Index == 1 then
        return { "0", "1", "2", "3" };
    end
end

Core:RegisterBehavior(b_Reward_SetBuildingUpgradeLevel)

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

BundleClassicBehaviors = {
    Global = {},
    Local = {}
};

-- Global Script ---------------------------------------------------------------

---
-- Initialisiert das Bundle im globalen Skript.
-- @within Internal
-- @local
--
function BundleClassicBehaviors.Global:Install()
    self:OverrideIsObjectiveCompleted();
end

---
-- Gibt das im Quest gespeicherte Resultat von Goal_InputDialog zurück.
--
-- &#x3C;b&#x3E;Hinweis&#x3C;/b&#x3E;: Es wird nur die letzte Eingabe zurückgegeben.
--
-- @param[type=string] _QuestName Name des Quest
-- @return[type=string] Eingabe des Spielers
-- @within Internal
-- @local
--
function BundleClassicBehaviors.Global:GetInputFromQuest(_QuestName)
    local Quest = Quests[GetQuestID(_QuestName)];
    if not Quest then
        return;
    end
    return Quest.InputDialogResult;
end

---
-- Überschreibt IsObjectiveCompleted und behebt einen Fehler in dem
-- Objective "DestroyAllPlayerUnits", der Baustellen ignorierte.
-- @within Internal
-- @local
--
function BundleClassicBehaviors.Global:OverrideIsObjectiveCompleted()
    QuestTemplate.IsObjectiveCompleted_Orig_QSB_ClassicBehaviors = QuestTemplate.IsObjectiveCompleted;
    QuestTemplate.IsObjectiveCompleted = function(self, objective)
        local objectiveType = objective.Type;
        if objective.Completed ~= nil then
            return objective.Completed;
        end
        local data = objective.Data;

        if objectiveType == Objective.DestroyAllPlayerUnits then
            local PlayerEntities = GetPlayerEntities(data, 0);
            local IllegalEntities = {};
            
            for i= #PlayerEntities, 1, -1 do
                local Type = Logic.GetEntityType(PlayerEntities[i]);
                if Logic.IsEntityInCategory(PlayerEntities[i], EntityCategories.AttackableBuilding) == 0 or Logic.IsEntityInCategory(PlayerEntities[i], EntityCategories.Wall) == 0 then
                    if Logic.IsConstructionComplete(PlayerEntities[i]) == 0 then
                        table.insert(IllegalEntities, PlayerEntities[i]);
                    end
                end
                local IndestructableEntities = {Entities.XD_ScriptEntity, Entities.S_AIHomePosition, Entities.S_AIAreaDefinition};
                if Inside(Type, IndestructableEntities) then
                    table.insert(IllegalEntities, PlayerEntities[i]);
                end
            end

            if #PlayerEntities == 0 or #PlayerEntities - #IllegalEntities == 0 then
                objective.Completed = true;
            end
        else
            return self:IsObjectiveCompleted_Orig_QSB_ClassicBehaviors(objective);
        end
    end
end

Core:RegisterBundle("BundleClassicBehaviors");

</code></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundleconstructioncontrol.lua.html">
            <div class='doclink'>
                <div>BundleConstructionControl</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><code>-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundleConstructionControl                                    # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Mit diesem Bundle kann der Bau von Gebäudetypen oder Gebäudekategorien
-- unterbunden werden. Verbote können für bestimmte Bereiche (kreisförmige
-- Gebiete um ein Zentrum) oder ganze Territorien vereinbart werden.
--
-- Das wichtigste Auf einen Blick:
-- &#x3C;ul&#x3E;
-- &#x3C;li&#x3E;
-- Den Bau von Gebäuden an bestimmten Orten steuern.&#x3C;br&#x3E;
-- &#x3C;a href="#API.BanCategoryInArea"&#x3E;Bau verbieten&#x3C;/a&#x3E;,
-- &#x3C;a href="#API.UnbanCategoryInArea"&#x3E;Bau erlauben&#x3C;/a&#x3E;
-- &#x3C;/li&#x3E;
-- &#x3C;/ul&#x3E;
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundleConstructionControl = {};

API = API or {};
QSB = QSB or {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Untersagt den Bau des Typs im Territorium.
--
-- @param[type=number] _type      Entitytyp
-- @param[type=number] _territory Territorium
-- @within Anwenderfunktionen
--
-- @usage API.BanTypeAtTerritory(Entities.B_Bakery, 1);
--
function API.BanTypeAtTerritory(_type, _territory)
    if GUI then
        local Territory = (type(_center) == "string" and "'" .._territory.. "'") or _territory;
        GUI.SendScriptCommand("API.BanTypeAtTerritory(" .._type.. ", " ..Territory.. ")");
        return;
    end
    if type(_territory) == "string" then
        _territory = GetTerritoryIDByName(_territory);
    end

    BundleConstructionControl.Global.Data.TerritoryBlockEntities[_type] = BundleConstructionControl.Global.Data.TerritoryBlockEntities[_type] or {};
    if not Inside(_territory, BundleConstructionControl.Global.Data.TerritoryBlockEntities[_type]) then
        table.insert(BundleConstructionControl.Global.Data.TerritoryBlockEntities[_type], _territory);
    end
end

---
-- Untersagt den Bau der Kategorie im Territorium.
--
-- @param[type=number] _eCat      Entitykategorie
-- @param[type=number] _territory Territorium
-- @within Anwenderfunktionen
--
-- @usage API.BanCategoryAtTerritory(EntityCategories.AttackableBuilding, 2);
--
function API.BanCategoryAtTerritory(_eCat, _territory)
    if GUI then
        local Territory = (type(_center) == "string" and "'" .._territory.. "'") or _territory;
        GUI.SendScriptCommand("API.BanTypeAtTerritory(" .._eCat.. ", " ..Territory.. ")");
        return;
    end
    if type(_territory) == "string" then
        _territory = GetTerritoryIDByName(_territory);
    end

    BundleConstructionControl.Global.Data.TerritoryBlockCategories[_eCat] = BundleConstructionControl.Global.Data.TerritoryBlockCategories[_eCat] or {};
    if not Inside(_territory, BundleConstructionControl.Global.Data.TerritoryBlockCategories[_eCat]) then
        table.insert(BundleConstructionControl.Global.Data.TerritoryBlockCategories[_eCat], _territory);
    end
end

---
-- Untersagt den Bau des Typs im Gebiet.
--
-- @param[type=number] _type   Entitytyp
-- @param[type=string] _center Gebietszentrum
-- @param[type=number] _area   Gebietsgröße
-- @within Anwenderfunktionen
--
-- @usage API.BanTypeInArea(Entities.B_Bakery, "groundZero", 4000);
--
function API.BanTypeInArea(_type, _center, _area)
    if GUI then
        local Center = (type(_center) == "string" and "'" .._center.. "'") or _center;
        GUI.SendScriptCommand("API.BanTypeInArea(" .._type.. ", " ..Center.. ", " .._area.. ")");
        return;
    end

    BundleConstructionControl.Global.Data.AreaBlockEntities[_center] = BundleConstructionControl.Global.Data.AreaBlockEntities[_center] or {};
    if not Inside(_type, BundleConstructionControl.Global.Data.AreaBlockEntities[_center], true) then
        table.insert(BundleConstructionControl.Global.Data.AreaBlockEntities[_center], {_type, _area});
    end
end

---
-- Untersagt den Bau der Kategorie im Gebiet.
--
-- @param[type=number] _eCat   Entitytyp
-- @param[type=string] _center Gebietszentrum
-- @param[type=number] _area   Gebietsgröße
-- @within Anwenderfunktionen
--
-- @usage API.BanTypeInArea(EntityCategories.CityBuilding, "groundZero", 4000);
--
function API.BanCategoryInArea(_eCat, _center, _area)
    if GUI then
        local Center = (type(_center) == "string" and "'" .._center.. "'") or _center;
        GUI.SendScriptCommand("API.BanCategoryInArea(" .._eCat.. ", " ..Center.. ", " .._area.. ")");
        return;
    end

    BundleConstructionControl.Global.Data.AreaBlockCategories[_center] = BundleConstructionControl.Global.Data.AreaBlockCategories[_center] or {};
    if not Inside(_eCat, BundleConstructionControl.Global.Data.AreaBlockCategories[_center], true) then
        table.insert(BundleConstructionControl.Global.Data.AreaBlockCategories[_center], {_eCat, _area});
    end
end

---
-- Gibt einen Typ zum Bau im Territorium wieder frei.
--
-- @param[type=number] _type      Entitytyp
-- @param[type=number] _territory Territorium
-- @within Anwenderfunktionen
--
-- @usage API.UnbanTypeAtTerritory(Entities.B_Bakery, 1);
--
function API.UnbanTypeAtTerritory(_type, _territory)
    if GUI then
        local Territory = (type(_center) == "string" and "'" .._territory.. "'") or _territory;
        GUI.SendScriptCommand("API.UnbanTypeAtTerritory(" .._type.. ", " ..Territory.. ")");
        return;
    end
    if type(_territory) == "string" then
        _territory = GetTerritoryIDByName(_territory);
    end

    if not BundleConstructionControl.Global.Data.TerritoryBlockEntities[_type] then
        return;
    end
    for i= #BundleConstructionControl.Global.Data.TerritoryBlockEntities[_type], 1, -1 do
        if BundleConstructionControl.Global.Data.TerritoryBlockEntities[_type][i] == _territory then
            table.remove(BundleConstructionControl.Global.Data.TerritoryBlockEntities[_type], i);
            break;
        end
    end
end

---
-- Gibt eine Kategorie zum Bau im Territorium wieder frei.
--
-- @param[type=number] _eCat      Entitykategorie
-- @param[type=number] _territory Territorium
-- @within Anwenderfunktionen
--
-- @usage API.UnbanCategoryAtTerritory(EntityCategories.AttackableBuilding, 1);
--
function API.UnbanCategoryAtTerritory(_eCat, _territory)
    if GUI then
        local Territory = (type(_center) == "string" and "'" .._territory.. "'") or _territory;
        GUI.SendScriptCommand("API.UnbanTypeAtTerritory(" .._eCat.. ", " ..Territory.. ")");
        return;
    end
    if type(_territory) == "string" then
        _territory = GetTerritoryIDByName(_territory);
    end

    if not BundleConstructionControl.Global.Data.TerritoryBlockCategories[_eCat] then
        return;
    end
    for i= #BundleConstructionControl.Global.Data.TerritoryBlockCategories[_eCat], 1, -1 do
        if BundleConstructionControl.Global.Data.TerritoryBlockCategories[_eCat][i] == _territory then
            table.remove(BundleConstructionControl.Global.Data.TerritoryBlockCategories[_eCat], i);
            break;
        end
    end
end

---
-- Gibt einen Typ zum Bau im Gebiet wieder frei.
--
-- @param[type=number] _type   Entitytyp
-- @param[type=string] _center Gebiet
-- @within Anwenderfunktionen
--
-- @usage API.UnbanTypeInArea(Entities.B_Bakery, "groundZero");
--
function API.UnbanTypeInArea(_type, _center)
    if GUI then
        local Center = (type(_center) == "string" and "'" .._center.. "'") or _center;
        GUI.SendScriptCommand("API.UnbanTypeInArea(" .._eCat.. ", " ..Center.. ")");
        return;
    end

    if not BundleConstructionControl.Global.Data.AreaBlockEntities[_center] then
        return;
    end
    for i= #BundleConstructionControl.Global.Data.AreaBlockEntities[_center], 1, -1 do
        if BundleConstructionControl.Global.Data.AreaBlockEntities[_center][i][1] == _type then
            table.remove(BundleConstructionControl.Global.Data.AreaBlockEntities[_center], i);
            break;
        end
    end
end

---
-- Gibt eine Kategorie zum Bau im Gebiet wieder frei.
--
-- @param[type=number] _eCat   Entitykategorie
-- @param[type=string] _center Gebiet
-- @within Anwenderfunktionen
--
-- @usage API.UnbanCategoryInArea(EntityCategories.CityBuilding, "groundZero");
--
function API.UnbanCategoryInArea(_eCat, _center)
    if GUI then
        local Center = (type(_center) == "string" and "'" .._center.. "'") or _center;
        GUI.SendScriptCommand("API.UnbanCategoryInArea(" .._type.. ", " ..Center.. ")");
        return;
    end

    if not BundleConstructionControl.Global.Data.AreaBlockCategories[_center] then
        return;
    end
    for i= #BundleConstructionControl.Global.Data.AreaBlockCategories[_center], 1, -1 do
        if BundleConstructionControl.Global.Data.AreaBlockCategories[_center][i][1] == _eCat then
            table.remove(BundleConstructionControl.Global.Data.AreaBlockCategories[_center], i);
            break;
        end
    end
end

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

BundleConstructionControl = {
    Global = {
        Data = {
            TerritoryBlockCategories = {},
            TerritoryBlockEntities = {},
            AreaBlockCategories = {},
            AreaBlockEntities = {},
        }
    },
}

-- Global Script ---------------------------------------------------------------

---
-- Initalisiert das Bundle im globalen Skript.
--
-- @within Internal
-- @local
--
function BundleConstructionControl.Global:Install()
    Core:AppendFunction(
        "GameCallback_CanPlayerPlaceBuilding",
        BundleConstructionControl.Global.CanPlayerPlaceBuilding
    );
end

---
-- Verhindert den Bau von Entities in Gebieten und Territorien.
--
-- @param[type=number] _PlayerID Spieler
-- @param[type=number] _Type     Gebäudetyp
-- @param[type=number] _x        X-Position
-- @param[type=number] _y        Y-Position
-- @within Internal
-- @local
--
function BundleConstructionControl.Global.CanPlayerPlaceBuilding(_PlayerID, _Type, _x, _y)
    -- Auf Territorium ---------------------------------------------

    -- Prüfe Kategorien
    for k,v in pairs(BundleConstructionControl.Global.Data.TerritoryBlockCategories) do
        if v then
            for key, val in pairs(v) do
                if val and Logic.GetTerritoryAtPosition(_x, _y) == val then
                    if Logic.IsEntityTypeInCategory(_Type, k) == 1 then
                        return false;
                    end
                end
            end
        end
    end

    -- Prüfe Typen
    for k,v in pairs(BundleConstructionControl.Global.Data.TerritoryBlockEntities) do
        if v then
            for key,val in pairs(v) do
                if val and Logic.GetTerritoryAtPosition(_x, _y) == val then
                    if _Type == k then
                        return false;
                    end
                end
            end
        end
    end

    -- In einem Gebiet ---------------------------------------------

    -- Prüfe Kategorien
    for k, v in pairs(BundleConstructionControl.Global.Data.AreaBlockCategories) do
        if v then
            for key, val in pairs(v) do
                if Logic.IsEntityTypeInCategory(_Type, val[1]) == 1 then
                    if GetDistance(k, {X= _x, Y= _y}) &#x3C; val[2] then
                        return false;
                    end
                end
            end
        end
    end

    -- Prüfe Typen
    for k, v in pairs(BundleConstructionControl.Global.Data.AreaBlockEntities) do
        if v then
            for key, val in pairs(v) do
                if _Type == val[1] then
                    if GetDistance(k, {X= _x, Y= _y}) &#x3C; val[2] then
                        return false;
                    end
                end
            end
        end
    end

    return true;
end

-- -------------------------------------------------------------------------- --

Core:RegisterBundle("BundleConstructionControl");

</code></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundledestructioncontrol.lua.html">
            <div class='doclink'>
                <div>BundleDestructionControl</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><code>-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundleDestructionControl                                     # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Ermöglicht es einzelne Gebäude, Typen oder Kategorien von Gebäuden vor
-- dem Abriss zu schützen. Ebenso kann jeglicher Abriss von Gebäuden auf
-- einem Territrium komplett unterbunden werden.
--
-- Das wichtigste Auf einen Blick:
-- &#x3C;ul&#x3E;
-- &#x3C;li&#x3E;
-- Den Abriss für bestimmte Entities steuern.&#x3C;br&#x3E;
-- &#x3C;a href="#API.ProtectCategory"&#x3E;Entities beschützen&#x3C;/a&#x3E;,
-- &#x3C;a href="#API.UnprotectCategory"&#x3E;Schutz aufheben&#x3C;/a&#x3E;
-- &#x3C;/li&#x3E;
-- &#x3C;/ul&#x3E;
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundleDestructionControl = {};

API = API or {};
QSB = QSB or {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Fügt ein Entity hinzu, dass nicht abgerissen werden darf.
--
-- @param[type=string] _entry Nicht abreißbares Entity
-- @within Anwenderfunktionen
--
-- @usage API.ProtectEntity("bakery");
--
function API.ProtectEntity(_entry)
    if not GUI then
        API.Bridge([[
            API.ProtectEntity("]].._entry..[[")
        ]]);
    else
        if not Inside(_enitry, BundleDestructionControl.Local.Data.Entities) then
            table.insert(BundleDestructionControl.Local.Data.Entities, _entry);
        end
    end
end

---
-- Fügt einen Entitytyp hinzu, der nicht abgerissen werden darf.
--
-- @param[type=number] _entry Nicht abreißbarer Typ
-- @within Anwenderfunktionen
--
-- @usage API.ProtectEntityType(Entities.B_Bakery);
--
function API.ProtectEntityType(_entry)
    if not GUI then
        API.Bridge([[
            API.ProtectEntityType(]].._entry..[[)
        ]]);
    else
        if not Inside(_enitry, BundleDestructionControl.Local.Data.EntityTypes) then
            table.insert(BundleDestructionControl.Local.Data.EntityTypes, _entry);
        end
    end
end

---
-- Fügt eine Kategorie hinzu, die nicht abgerissen werden darf.
--
-- @param[type=number] _entry Nicht abreißbare Kategorie
-- @within Anwenderfunktionen
--
-- @usage API.ProtectCategory(EntityCategories.CityBuilding);
--
function API.ProtectCategory(_entry)
    if not GUI then
        API.Bridge([[
            API.ProtectCategory(]].._entry..[[)
        ]]);
    else
        if not Inside(_enitry, BundleDestructionControl.Local.Data.EntityCategories) then
            table.insert(BundleDestructionControl.Local.Data.EntityCategories, _entry);
        end
    end
end

---
-- Fügt ein Territory hinzu, auf dem nichts abgerissen werden kann.
--
-- @param[type=number] _entry Geschütztes Territorium
-- @within Anwenderfunktionen
--
-- @usage API.ProtectTerritory(1);
--
function API.ProtectTerritory(_entry)
    if not GUI then
        API.Bridge([[
            API.ProtectTerritory(]].._entry..[[)
        ]]);
    else
        if not Inside(_entry, BundleDestructionControl.Local.Data.OnTerritory) then
            table.insert(BundleDestructionControl.Local.Data.OnTerritory, _entry);
        end
    end
end

---
-- Entfernt ein Entity, dass nicht abgerissen werden darf.
--
-- @param[type=string] _entry Nicht abreißbares Entity
-- @within Anwenderfunktionen
--
-- @usage API.UnprotectEntity("bakery");
--
function API.UnprotectEntity(_entry)
    if not GUI then
        API.Bridge([[
            API.UnprotectEntity("]].._entry..[[")
        ]]);
    else
        for i=1,#BundleDestructionControl.Local.Data.Entities do
            if BundleDestructionControl.Local.Data.Entities[i] == _entry then
                table.remove(BundleDestructionControl.Local.Data.Entities, i);
                return;
            end
        end
    end
end

---
-- Entfernt einen Entitytyp, der nicht abgerissen werden darf.
--
-- @param[type=number] _entry Nicht abreißbarer Typ
-- @within Anwenderfunktionen
--
-- @usage API.UnprotectEntityType(Entities.B_Bakery);
--
function API.UnprotectEntityType(_entry)
    if not GUI then
        API.Bridge([[
            API.UnprotectEntityType(]].._entry..[[)
        ]]);
    else
        for i=1,#BundleDestructionControl.Local.Data.EntityTypes do
            if BundleDestructionControl.Local.Data.EntityTypes[i] == _entry then
                table.remove(BundleDestructionControl.Local.Data.EntityTypes, i);
                return;
            end
        end
    end
end

---
-- Entfernt eine Kategorie, die nicht abgerissen werden darf.
--
-- @param[type=number] _entry Nicht abreißbare Kategorie
-- @within Anwenderfunktionen
--
-- @usage API.UnprotectCategory(EntityCategories.CityBuilding);
--
function API.UnprotectCategory(_entry)
    if not GUI then
        API.Bridge([[
            API.UnprotectCategory(]].._entry..[[)
        ]]);
    else
        for i=1,#BundleDestructionControl.Local.Data.EntityCategories do
            if BundleDestructionControl.Local.Data.EntityCategories[i] == _entry then
                table.remove(BundleDestructionControl.Local.Data.EntityCategories, i);
                return;
            end
        end
    end
end

---
-- Entfernt ein Territory, auf dem nichts abgerissen werden kann.
--
-- @param[type=number] _entry Geschütztes Territorium
-- @within Anwenderfunktionen
--
-- @usage API.UnprotectTerritory(1);
--
function API.UnprotectTerritory(_entry)
    if not GUI then
        API.Bridge([[
            API.UnprotectTerritory(]].._entry..[[)
        ]]);
    else
        for i=1,#BundleDestructionControl.Local.Data.OnTerritory do
            if BundleDestructionControl.Local.Data.OnTerritory[i] == _entry then
                table.remove(BundleDestructionControl.Local.Data.OnTerritory, i);
                return;
            end
        end
    end
end

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

BundleDestructionControl = {
    Local = {
        Data = {
            Entities = {},
            EntityTypes = {},
            EntityCategories = {},
            OnTerritory = {},
        }
    },
}

-- Local Script ----------------------------------------------------------------

---
-- Initalisiert das Bundle im lokalen Skript.
--
-- @within Internal
-- @local
--
function BundleDestructionControl.Local:Install()
    Core:AppendFunction(
        "GameCallback_GUI_DeleteEntityStateBuilding",
        BundleDestructionControl.Local.DeleteEntityStateBuilding
    );
end

---
-- Verhindert den Abriss von Entities.
--
-- @param[type=number] _BuildingID EntityID des Gebäudes
-- @within Internal
-- @local
--
function BundleDestructionControl.Local.DeleteEntityStateBuilding(_BuildingID)
    local eType = Logic.GetEntityType(_BuildingID);
    local eName = Logic.GetEntityName(_BuildingID);
    local tID   = GetTerritoryUnderEntity(_BuildingID);

    if Logic.IsConstructionComplete(_BuildingID) == 1 then
        -- Prüfe auf Namen
        if Inside(eName, BundleDestructionControl.Local.Data.Entities) then
            GUI.CancelBuildingKnockDown(_BuildingID);
            return;
        end

        -- Prüfe auf Typen
        if Inside(eType, BundleDestructionControl.Local.Data.EntityTypes) then
            GUI.CancelBuildingKnockDown(_BuildingID);
            return;
        end

        -- Prüfe auf Territorien
        if Inside(tID, BundleDestructionControl.Local.Data.OnTerritory) then
            GUI.CancelBuildingKnockDown(_BuildingID);
            return;
        end

        -- Prüfe auf Category
        for k,v in pairs(BundleDestructionControl.Local.Data.EntityCategories) do
            if Logic.IsEntityInCategory(_BuildingID, v) == 1 then
                GUI.CancelBuildingKnockDown(_BuildingID);
                return;
            end
        end
    end
end

-- -------------------------------------------------------------------------- --

Core:RegisterBundle("BundleDestructionControl");

</code></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundledialogwindows.lua.html">
            <div class='doclink'>
                <div>BundleDialogWindows</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><code>-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundleDialogWindows                                          # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Mit diesem Bundle können Dialogfenster ernstellt werden. Über Dialogfenster
-- kann der Spieler informiert werden. Er kann aber auch aufgefordert werden
-- eine Antwort auf eine Frage zu geben. Sollte bereits ein Dialog zu sehen
-- sein, werden neue Dialoge einer Warteschlange hinzugefügt und nacheinander
-- angezeigt.
--
-- Zudem bietet das Bundle ein Textfenster an, welches eine nicht limitierte
-- Menge an Text anzeigen kann. Erreicht der Text eine entsprechende Menge,
-- wird automatisch eine Scrollbar eingeblendet.
--
-- Das wichtigste Auf einen Blick:
-- &#x3C;ul&#x3E;
-- &#x3C;li&#x3E;
-- &#x3C;a href="#API.DialogInfoBox"&#x3E;Dialoge anzeigen&#x3C;/a&#x3E;
-- &#x3C;/li&#x3E;
-- &#x3C;li&#x3E;
-- &#x3C;a href="#API.SimpleTextWindow"&#x3E;Textfenster anzeigen&#x3C;/a&#x3E;
-- &#x3C;/li&#x3E;
-- &#x3C;/ul&#x3E;
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundleDialogWindows = {};

API = API or {};
QSB = QSB or {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Öffnet einen Info-Dialog. Sollte bereits ein Dialog zu sehen sein, wird
-- der Dialog der Dialogwarteschlange hinzugefügt.
--
-- &#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: UserOpenDialog
--
-- @param[type=string]   _Title  Titel des Dialog
-- @param[type=string]   _Text   Text des Dialog
-- @param[type=function] _Action Callback-Funktion
-- @within Anwenderfunktionen
--
-- @usage
-- API.DialogInfoBox("Wichtige Information", "Diese Information ist Spielentscheidend!");
--
function API.DialogInfoBox(_Title, _Text, _Action)
    if not GUI then
        API.Fatal("API.DialogInfoBox: Can only be used in the local script!");
        return;
    end

    local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";
    if type(_Title) == "table" then
       _Title = _Title[lang];
    end
    if type(_Text) == "table" then
       _Text = _Text[lang];
    end
    return BundleDialogWindows.Local:OpenDialog(_Title, _Text, _Action);
end
UserOpenDialog = API.DialogInfoBox;

---
-- Öffnet einen Ja-Nein-Dialog. Sollte bereits ein Dialog zu sehen sein, wird
-- der Dialog der Dialogwarteschlange hinzugefügt.
--
-- Um die Entscheigung des Spielers abzufragen, wird ein Callback benötigt.
-- Das Callback bekommt eine Boolean übergeben, sobald der Spieler die
-- Entscheidung getroffen hat.
--
-- &#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: UserOpenRequesterDialog
--
-- @param[type=string]   _Title    Titel des Dialog
-- @param[type=string]   _Text     Text des Dialog
-- @param[type=function] _Action   Callback-Funktion
-- @param[type=boolean]  _OkCancel Okay/Abbrechen statt Ja/Nein
-- @within Anwenderfunktionen
--
-- @usage
-- function YesNoAction(_yes)
--     if _yes then GUI.AddNote("Ja wurde gedrückt"); end
-- end
-- API.DialogRequestBox("Frage", "Möchtest du das wirklich tun?", YesNoAction, false);
--
function API.DialogRequestBox(_Title, _Text, _Action, _OkCancel)
    if not GUI then
        API.Fatal("API.DialogRequestBox: Can only be used in the local script!");
        return;
    end

    local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";
    if type(_Title) == "table" then
       _Title = _Title[lang];
    end
    if type(_Text) == "table" then
       _Text = _Text[lang];
    end
    return BundleDialogWindows.Local:OpenRequesterDialog(_Title, _Text, _Action, _OkCancel);
end
UserOpenRequesterDialog = API.DialogRequestBox;

---
-- Öffnet einen Auswahldialog. Sollte bereits ein Dialog zu sehen sein, wird
-- der Dialog der Dialogwarteschlange hinzugefügt.
--
-- In diesem Dialog wählt der Spieler eine Option aus einer Liste von Optionen
-- aus. Anschließend erhält das Callback den Index der selektierten Option.
--
-- &#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: UserOpenSelectionDialog
--
-- @param[type=string]   _Title  Titel des Dialog
-- @param[type=string]   _Text   Text des Dialog
-- @param[type=function] _Action Callback-Funktion
-- @param[type=table]    _List   Liste der Optionen
-- @within Anwenderfunktionen
--
-- @usage
-- function OptionsAction(_idx)
--     GUI.AddNote(_idx.. " wurde ausgewählt!");
-- end
-- local List = {"Option A", "Option B", "Option C"};
-- API.DialogSelectBox("Auswahl", "Wähle etwas aus!", OptionsAction, List);
--
function API.DialogSelectBox(_Title, _Text, _Action, _List)
    if not GUI then
        API.Fatal("API.DialogSelectBox: Can only be used in the local script!");
        return;
    end

    local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";
    if type(_Title) == "table" then
       _Title = _Title[lang];
    end
    if type(_Text) == "table" then
       _Text = _Text[lang];
    end
    _Text = _Text .. "{cr}";
    return BundleDialogWindows.Local:OpenSelectionDialog(_Title, _Text, _Action, _List);
end
UserOpenSelectionDialog = API.DialogSelectBox;

---
-- Öffnet ein einfaches Textfenster mit dem angegebenen Text.
--
-- Die Länge des Textes ist nicht beschränkt. Überschreitet der Text die
-- Größe des Fensters, wird automatisch eine Bildlaufleiste eingeblendet.
--
-- @param[type=string] _Caption Titel des Fenster
-- @param[type=string] _content Inhalt des Fenster
-- @within Anwenderfunktionen
--
-- @usage
-- local Text = "Lorem ipsum dolor sit amet, consetetur sadipscing elitr, "..
--              "sed diam nonumy eirmod tempor invidunt ut labore et dolore"..
--              "magna aliquyam erat, sed diam voluptua. At vero eos et"..
--              " accusam et justo duo dolores et ea rebum. Stet clita kasd"..
--              " gubergren, no sea takimata sanctus est Lorem ipsum dolor"..
--              " sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing"..
--              " elitr, sed diam nonumy eirmod tempor invidunt ut labore et"..
--              " dolore magna aliquyam erat, sed diam voluptua. At vero eos"..
--              " et accusam et justo duo dolores et ea rebum. Stet clita"..
--              " kasd gubergren, no sea takimata sanctus est Lorem ipsum"..
--              " dolor sit amet.";
-- API.SimpleTextWindow("Überschrift", Text);
--
function API.SimpleTextWindow(_Caption, _Content)
    local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";
    if type(_Caption) == "table" then
       _Caption = _Caption[lang];
    end
    if type(_Content) == "table" then
       _Content = _Content[lang];
    end
    if not GUI then
        API.Bridge("API.SimpleTextWindow('" .._Caption.. "', '" .._Content.. "')");
        return;
    end
    QSB.TextWindow:New(_Caption, _Content):Show();
end

---
-- Blendet einen Text Zeichen für Zeichen auf schwarzem Grund ein.
--
-- Diese Funktion ist der offizielle Nachfolger der Laufschrift!
--
-- Der Effekt startet erst, nachdem die Map geladen ist. Wenn ein Briefing
-- läuft, wird gewartet, bis das Briefing beendet ist. Wärhend der Effekt
-- läuft, können wiederrum keine Briefings starten.
--
-- &#x3C;b&#x3E;Hinweis&#x3C;/b&#x3E;: Steuerzeichen wie {cr} oder {@color} werden als ein Token
-- gewertet und immer sofort eingeblendet. Steht z.B. {cr}{cr} im Text, werden
-- die Zeichen atomar behandelt, als seien sie ein einzelnes Zeichen.
-- Gibt es mehr als 1 Leerzeichen hintereinander, werden alle zusammenhängenden
-- Leerzeichen auf ein Leerzeichen reduziert!
--
-- @param[type=string]   _Text     Anzuzeigender Text
-- @param[type=function] _Callback Funktion nach Ende des Effekt
--
-- @usage
-- local Text = "Lorem ipsum dolor sit amet, consetetur sadipscing elitr, "..
--              "sed diam nonumy eirmod tempor invidunt ut labore et dolore"..
--              "magna aliquyam erat, sed diam voluptua. At vero eos et"..
--              " accusam et justo duo dolores et ea rebum. Stet clita kasd"..
--              " gubergren, no sea takimata sanctus est Lorem ipsum dolor"..
--              " sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing"..
--              " elitr, sed diam nonumy eirmod tempor invidunt ut labore et"..
--              " dolore magna aliquyam erat, sed diam voluptua. At vero eos"..
--              " et accusam et justo duo dolores et ea rebum. Stet clita"..
--              " kasd gubergren, no sea takimata sanctus est Lorem ipsum"..
--              " dolor sit amet.";
-- local Callback = function(_Data)
--     -- Hier kann was passieren
-- end
-- API.SimpleTypewriter(Text, Callback);
-- @within Anwenderfunktionen
--
function API.SimpleTypewriter(_Text, _Callback)
    local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";
    if GUI then
        API.Fatal("API.SimpleTypewriter: Can only be used from global script!");
        return;
    end
    local Text = _Text;
    if type(Text) == "table" then
        Text = Text[lang];
    end
    QSB.SimpleTypewriter:New(_Text, _Callback):Start();
end

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

BundleDialogWindows = {
    Global = {
        Data = {}
    },
    Local = {
        Data = {
            Requester = {
                ActionFunction = nil,
                ActionRequester = nil,
                Next = nil,
                Queue = {},
            },
        },
    },
}

-- Typewriter class ------------------------------------------------------------

QSB.SimpleTypewriter = {
    m_Tokens     = {},
    m_Waittime   = 80,
    m_Speed      = 1,
    m_Index      = 0,
    m_Text       = nil,
    m_JobID      = nil,
    m_Callback   = nil,
    m_Loadscreen = true,
};

---
-- Erzeugt eine Neue Instanz der Schreibmaschinenschrift.
-- @param[type=string]   _Text     Anzuzeigender Text
-- @param[type=function] _Callback Funktion, die am Ende ausgeführt wird
-- @return[type=table] Neue Instanz
-- @within QSB.SimpleTypewriter
-- @local
--
function QSB.SimpleTypewriter:New(_Text, _Callback)
    local typewriter = API.InstanceTable(self);
    typewriter.m_Text = _Text;
    typewriter.m_Callback = _Callback;
    return typewriter;
end

---
-- Stellt ein, wie viele Zeichen in einer Interation angezeigt werden.
-- @param[type=number] _Speed Anzahl an Character pro 1/10 Sekunde
-- @within QSB.SimpleTypewriter
-- @local
--
function QSB.SimpleTypewriter:SetSpeed(_Speed)
    self.m_Speed = _Speed;
end

---
-- Stellt ein, wie lange nach Ausgabe des letzten Zeichens gewartet wird, bis
-- die Schreibmaschine endet.
-- @param[type=number] _Waittime Zeit in 1/10 Sekunden (8 Sekunden = 80)
-- @within QSB.SimpleTypewriter
-- @local
--
function QSB.SimpleTypewriter:SetWaittime(_Waittime)
    self.m_Waittime = _Waittime;
end

---
-- Startet die Laufschrift. Wenn ein Briefing aktiv ist, oder die Map noch
-- nicht geladen ist, wird gewartet.
-- @within QSB.SimpleTypewriter
-- @local
--
function QSB.SimpleTypewriter:Start()
    if self:CanBePlayed() then
        self:Play();
        return;
    end
    StartSimpleHiResJobEx(self.WaitForBriefingEnd, self);
end

---
-- Spielt die Schreibmaschine ab.
-- @within QSB.SimpleTypewriter
-- @local
--
function QSB.SimpleTypewriter:Play()
    if BundleBriefingSystem then
        BundleBriefingSystem.Global.Data.BriefingActive = true;
    end
    self:TokenizeText();
    API.Bridge([[
        if BundleBriefingSystem then
            BundleBriefingSystem.Local.Data.BriefingActive = true
        end

        XGUIEng.PushPage("/InGame/Root/Normal/NotesWindow", false)
        XGUIEng.PushPage("/InGame/Root/Normal/PauseScreen", false)
        XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal",0)
        XGUIEng.ShowWidget("/InGame/Root/Normal/NotesWindow",1)
        XGUIEng.ShowWidget("/InGame/Root/Normal/PauseScreen", 1)
        XGUIEng.SetMaterialColor("/InGame/Root/Normal/PauseScreen", 0, 0, 0, 0, 255)
        g_Typewriter_GameSpeedBackup = Game.GameTimeGetFactor(GUI.GetPlayerID())
        Game.GameTimeSetFactor(GUI.GetPlayerID(), 1)
        Input.CutsceneMode()
    ]]);
    self.m_JobID = StartSimpleHiResJobEx(self.ControllerJob, self);
end

---
-- Stoppt eine aktive Schreibmaschine.
-- @within QSB.SimpleTypewriter
-- @local
--
function QSB.SimpleTypewriter:Stop()
    if BundleBriefingSystem then
        BundleBriefingSystem.Global.Data.BriefingActive = false
    end
    API.Bridge([[
        if BundleBriefingSystem then
            BundleBriefingSystem.Local.Data.BriefingActive = false
        end

        GUI.ClearNotes()
        Game.GameTimeSetFactor(GUI.GetPlayerID(), g_Typewriter_GameSpeedBackup or 1)
        Input.GameMode()
        XGUIEng.PopPage()
        XGUIEng.PopPage()
        XGUIEng.ShowWidget("/InGame/Root/Normal/PauseScreen", 0)
        XGUIEng.SetMaterialColor("/InGame/Root/Normal/PauseScreen", 0, 40, 40, 40, 180)
        XGUIEng.ShowWidget("/InGame/Root/Normal/AnimatedCameraMovement", 1)
        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight",1)
        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomLeft",1)
        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft",1)
        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft/TopBar",1)
        XGUIEng.ShowWidget("/InGame/Root/Normal/InteractiveObjects",1)
        XGUIEng.ShowWidget("/InGame/Root/Normal/InteractiveObjects/Update",1)
        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopRight",1)
        XGUIEng.ShowWidget("/InGame/Root/Normal/Selected_Merchant",1)
        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopCenter",1)
        if g_PatchIdentifierExtra1 then
            XGUIEng.ShowWidget("/InGame/Root/Normal/Selected_Tradepost",1)
        end
        XGUIEng.ShowWidget("/InGame/Root/Normal/TextMessages",1)
        XGUIEng.ShowWidget("/InGame/Root/Normal/PauseScreen",0)
        XGUIEng.ShowWidget("/InGame/Root/3dOnScreenDisplay",1)
        XGUIEng.ShowWidget("/InGame/Root/Normal/ShowUi",1)
        XGUIEng.ShowWidget("/InGame/Root/3dWorldView",1)
    ]]);
    API.EndJob(self.m_JobID);
end

---
-- Spaltet den Text in Tokens auf und speichert die Tokens für die Wiedergabe.
-- @within QSB.SimpleTypewriter
-- @local
--
function QSB.SimpleTypewriter:TokenizeText()
    self.m_Text = self.m_Text:gsub("s+", " ");
    local TempTokens = {};
    local Text = self.m_Text;
    while (true) do
        local s, e = Text:find(" ");
        if not s then
            table.insert(TempTokens, Text);
            break;
        end
        local NewToken = Text:sub(1, s-1);
        if NewToken:find("}") then
            for i= #NewToken, 1, -1 do
                local Char = NewToken:sub(i, i);
                if Char == "}" then
                    table.insert(TempTokens, NewToken:sub(1, i));
                    table.insert(TempTokens, NewToken:sub(i+1));
                    break;
                end
            end
        else
            table.insert(TempTokens, NewToken);
        end
        table.insert(TempTokens, " ");
        Text = Text:sub(e+1);
    end

    for i= 1, #TempTokens, 1 do
        if TempTokens[i] == " " or TempTokens[i]:find("{") then
            table.insert(self.m_Tokens, TempTokens[i]);
        else
            local Index = 1;
            while (Index &#x3C;= #TempTokens[i]) do
                if string.byte(TempTokens[i]:sub(Index, Index)) == 195 then
                    table.insert(self.m_Tokens, TempTokens[i]:sub(Index, Index+1));
                    Index = Index +1;
                else
                    table.insert(self.m_Tokens, TempTokens[i]:sub(Index, Index)); 
                end
                Index = Index +1;
            end
        end
    end
end

---
-- Prüft, ob die Schreibmaschine gestartet werden kann.
-- @return[type=boolean] Schreibmaschine kann starten
-- @within QSB.SimpleTypewriter
-- @local
--
function QSB.SimpleTypewriter:CanBePlayed()
    if QSB.SimpleTypewriter.m_Loadscreen then
        API.Bridge([[
            if XGUIEng.IsWidgetShownEx("/LoadScreen/LoadScreen") == 0 then
                API.Bridge("QSB.SimpleTypewriter.m_Loadscreen = false")
            end
        ]])
        return false;
    end
    if BundleBriefingSystem and IsBriefingActive() then
        return false;
    end
    if AddOnCutsceneSystem and IsCutsceneActive() then
        return false;
    end
    return true;
end

---
-- Job: Warte solange, bis Briefings beendet sind.
-- @param[type=table] Data
-- @within QSB.SimpleTypewriter
-- @local
--
function QSB.SimpleTypewriter.WaitForBriefingEnd(_Data)
    if _Data:CanBePlayed() == true then
        _Data:Play();
        return true;
    end
end

---
-- Job: Kontrolliert die Anzeige der Schreibmaschine.
-- @param[type=table] Data
-- @within QSB.SimpleTypewriter
-- @local
--
function QSB.SimpleTypewriter.ControllerJob(_Data)
    _Data.m_Index = _Data.m_Index + _Data.m_Speed;
    if _Data.m_Index &#x3E; #_Data.m_Tokens then
        _Data.m_Index = #_Data.m_Tokens;
    end
    local Index = math.ceil(_Data.m_Index);

    local Text = "";
    for i= 1, Index, 1 do
        Text = Text .. _Data.m_Tokens[i];
    end
    API.Bridge([[
        GUI.ClearNotes()
        GUI.AddNote("]] ..Text.. [[");
    ]])
    
    if Index == #_Data.m_Tokens then
        _Data.m_Waittime = _Data.m_Waittime -1;
        if _Data.m_Waittime &#x3C;= 0 then
            _Data:Stop();
            if _Data.m_Callback then
                _Data.m_Callback(_Data);
            end
            return true;
        end
    end
end

-- TextWindow class ------------------------------------------------------------

QSB.TextWindow = {
    Data = {
        Shown       = false,
        Caption     = "",
        Text        = "",
        ButtonText  = "",
        Picture     = nil,
        Action      = nil,
        Callback    = function() end,
    },
};

---
-- Erzeugt ein Textfenster, dass einen beliebig großen Text anzeigen kann.
-- Optional kann ein Button genutzt werden, der eine Aktion ausführt, wenn
-- er gedrückt wird.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: TextWindow:New&#x3C;/p&#x3E;
--
-- Parameterliste:
-- &#x3C;table&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;th&#x3E;Index&#x3C;/th&#x3E;
-- &#x3C;th&#x3E;Beschreibung&#x3C;/th&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;1&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Titel des Fensters&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;2&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Text des Fensters&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;3&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Aktion nach dem Schließen&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;4&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Beschriftung des Buttons&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;5&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Callback des Buttons&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;/table&#x3E;
--
-- @param ... Parameterliste
-- @return[type=table] Instanz des konfigurierten Fensters
-- @within QSB.TextWindow
-- @local
--
-- @usage
-- local MyWindow = TextWindow:New("Fenster", "Das ist ein Text");
--
function QSB.TextWindow:New(...)
    assert(self == QSB.TextWindow, "Can not be used from instance!")
    local window           = API.InstanceTable(self);
    window.Data.Caption    = arg[1] or window.Data.Caption;
    window.Data.Text       = arg[2] or window.Data.Text;
    window.Data.Action     = arg[3];
    window.Data.ButtonText = arg[4] or window.Data.ButtonText;
    window.Data.Callback   = arg[5] or window.Data.Callback;
    return window;
end

---
-- Fügt einen beliebigen Parameter hinzu. Parameter müssen immer als
-- Schlüssel-Wert-Paare angegeben werden und dürfen vorhandene Pare nicht
-- überschreiben.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: TextWindow:AddParamater&#x3C;/p&#x3E;
--
-- @param[type=string] _Key   Schlüssel
-- @param              _Value Wert
-- @return self
-- @within QSB.TextWindow
-- @local
--
-- @usage
-- MyWindow:AddParameter("Name", "Horst");
--
function QSB.TextWindow:AddParamater(_Key, _Value)
    assert(self ~= QSB.TextWindow, "Can not be used in static context!");
    assert(self.Data[_Key] ~= nil, "Key '" .._Key.. "' already exists!");
    self.Data[_Key] = _Value;
    return self;
end

---
-- Setzt die Überschrift des TextWindow.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: TextWindow:SetCaption&#x3C;/p&#x3E;
--
-- @param[type=string] _Text Titel des Textfenster
-- @return self
-- @within QSB.TextWindow
-- @local
--
-- @usage
-- MyWindow:SetCaption("Das ist der Titel");
--
function QSB.TextWindow:SetCaption(_Text)
    assert(self ~= QSB.TextWindow, "Can not be used in static context!");
    local Language = (Network.GetDesiredLanguage() == "de" and "de") or "en";
    if type(_Text) == "table" then
        _Text = _Text[Language];
    end
    assert(type(_Text) == "string");
    self.Data.Caption = _Text;
    return self;
end

---
-- Setzt den Inhalt des TextWindow.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: TextWindow:SetContent&#x3C;/p&#x3E;
--
-- @param[type=string] _Text Inhalt des Textfenster
-- @return self
-- @within QSB.TextWindow
-- @local
--
-- @usage
-- MyWindow:SetCaption("Das ist der Text. Er ist sehr informativ!");
--
function QSB.TextWindow:SetContent(_Text)
    assert(self ~= QSB.TextWindow, "Can not be used in static context!");
    local Language = (Network.GetDesiredLanguage() == "de" and "de") or "en";
    if type(_Text) == "table" then
        _Text = _Text[Language];
    end
    assert(type(_Text) == "string");
    self.Data.Text = _Text;
    return self;
end

---
-- Setzt die Close Action des TextWindow. Die Funktion wird beim schließen
-- des Fensters ausgeführt.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: TextWindow:SetAction&#x3C;/p&#x3E;
--
-- @param[type=function] _Function Close Callback
-- @return self
-- @within QSB.TextWindow
-- @local
--
-- @usage
-- local MyAction = function(_Window)
--     -- Something is done here!
-- end
-- MyWindow:SetAction(MyAction);
--
function QSB.TextWindow:SetAction(_Function)
    assert(self ~= QSB.TextWindow, "Can not be used in static context!");
    assert(nil or type(_Function) == "function");
    self.Data.Callback = _Function;
    return self;
end

---
-- Setzt einen Aktionsbutton im TextWindow.
--
-- Der Button muss mit einer Funktion versehen werden. Sobald der Button
-- betätigt wird, wird die Funktion ausgeführt.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: TextWindow:SetButton&#x3C;/p&#x3E;
--
-- @param[type=string]   _Text     Beschriftung des Buttons
-- @param[type=function] _Callback Aktion des Buttons
-- @return self
-- @within QSB.TextWindow
-- @local
--
-- @usage
-- local MyButtonAction = function(_Window)
--     -- Something is done here!
-- end
-- MyWindow:SetAction("Button Text", MyButtonAction);
--
function QSB.TextWindow:SetButton(_Text, _Callback)
    assert(self ~= QSB.TextWindow, "Can not be used in static context!");
    if _Text then
        local Language = (Network.GetDesiredLanguage() == "de" and "de") or "en";
        if type(_Text) == "table" then
            _Text = _Text[Language];
        end
        assert(type(_Text) == "string");
        assert(type(_Callback) == "function");
    end
    self.Data.ButtonText = _Text;
    self.Data.Action     = _Callback;
    return self;
end

---
-- Zeigt ein erzeigtes Fenster an.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: TextWindow:Show&#x3C;/p&#x3E;
--
-- @within QSB.TextWindow
-- @local
--
-- @usage
-- MyWindow:Show();
--
function QSB.TextWindow:Show()
    assert(self ~= QSB.TextWindow, "Can not be used in static context!");
    QSB.TextWindow.Data.Shown = true;
    self.Data.Shown = true;
    self:Prepare();

    XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions",1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/ToggleWhisperTarget",1);
    if not self.Data.Action then
        XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/ToggleWhisperTarget",0);
    end
    XGUIEng.SetText("/InGame/Root/Normal/MessageLog/Name","{center}"..self.Data.Caption);
    XGUIEng.SetText("/InGame/Root/Normal/ChatOptions/ToggleWhisperTarget","{center}"..self.Data.ButtonText);
    GUI_Chat.ClearMessageLog();
    GUI_Chat.ChatlogAddMessage(self.Data.Text);

    local stringlen = string.len(self.Data.Text);
    local iterator  = 1;
    local carreturn = 0;
    while (true)
    do
        local s,e = string.find(self.Data.Text, "{cr}", iterator);
        if not e then
            break;
        end
        if e-iterator &#x3C;= 58 then
            stringlen = stringlen + 58-(e-iterator);
        end
        iterator = e+1;
    end
    if (stringlen + (carreturn*55)) &#x3E; 1000 then
        XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/ChatLogSlider",1);
    end
    Game.GameTimeSetFactor(GUI.GetPlayerID(), 0);
end

---
-- Initialisiert das TextWindow, bevor es angezeigt wird.
--
-- @within QSB.TextWindow
-- @local
--
function QSB.TextWindow:Prepare()
    function GUI_Chat.CloseChatMenu()
        QSB.TextWindow.Data.Shown = false;
        self.Data.Shown = false;
        if self.Data.Callback then
            self.Data.Callback(self);
        end
        XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions",0);
        XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog",0);
        XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog/BG",1);
        XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog/Close",1);
        XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog/Slider",1);
        XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog/Text",1);
        Game.GameTimeReset(GUI.GetPlayerID());
    end

    function GUI_Chat.ToggleWhisperTargetUpdate()
        Game.GameTimeSetFactor(GUI.GetPlayerID(), 0);
    end

    function GUI_Chat.CheckboxMessageTypeWhisperUpdate()
        XGUIEng.SetText("/InGame/Root/Normal/ChatOptions/TextCheckbox","{center}"..self.Data.Caption);
    end

    function GUI_Chat.ToggleWhisperTarget()
        if self.Data.Action then
            self.Data.Action(self);
        end
    end

    function GUI_Chat.ClearMessageLog()
        g_Chat.ChatHistory = {}
    end

    function GUI_Chat.ChatlogAddMessage(_Message)
        table.insert(g_Chat.ChatHistory, _Message)
        local ChatlogMessage = ""
        for i,v in ipairs(g_Chat.ChatHistory) do
            ChatlogMessage = ChatlogMessage .. v .. "{cr}"
        end
        XGUIEng.SetText("/InGame/Root/Normal/ChatOptions/ChatLog", ChatlogMessage)
    end

    local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";
    if type(self.Data.Caption) == "table" then
        self.Data.Caption = self.Data.Caption[lang];
    end
    if type(self.Data.ButtonText) == "table" then
        self.Data.ButtonText = self.Data.ButtonText[lang];
    end
    if type(self.Data.Text) == "table" then
        self.Data.Text = self.Data.Text[lang];
    end

    XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/ChatModeAllPlayers",0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/ChatModeTeam",0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/ChatModeWhisper",0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/ChatChooseModeCaption",0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/Background/TitleBig",1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/Background/TitleBig/Info",0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/ChatLogCaption",0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/BGChoose",0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/BGChatLog",0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/ChatLogSlider",0);

    XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog",1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog/BG",0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog/Close",0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog/Slider",0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog/Text",0);

    XGUIEng.DisableButton("/InGame/Root/Normal/ChatOptions/ToggleWhisperTarget",0);

    XGUIEng.SetWidgetLocalPosition("/InGame/Root/Normal/MessageLog",0,95);
    XGUIEng.SetWidgetLocalPosition("/InGame/Root/Normal/MessageLog/Name",0,0);
    XGUIEng.SetTextColor("/InGame/Root/Normal/MessageLog/Name",51,51,121,255);
    XGUIEng.SetWidgetLocalPosition("/InGame/Root/Normal/ChatOptions/ChatLog",140,150);
    XGUIEng.SetWidgetSize("/InGame/Root/Normal/ChatOptions/Background/DialogBG/1 (2)/2",150,400);
    XGUIEng.SetWidgetPositionAndSize("/InGame/Root/Normal/ChatOptions/Background/DialogBG/1 (2)/3",400,500,350,400);
    XGUIEng.SetWidgetSize("/InGame/Root/Normal/ChatOptions/ChatLog",640,580);
    XGUIEng.SetWidgetSize("/InGame/Root/Normal/ChatOptions/ChatLogSlider",46,660);
    XGUIEng.SetWidgetLocalPosition("/InGame/Root/Normal/ChatOptions/ChatLogSlider",780,130);
    XGUIEng.SetWidgetLocalPosition("/InGame/Root/Normal/ChatOptions/ToggleWhisperTarget",110,760);
end

-- Global Script ---------------------------------------------------------------

---
-- Initalisiert das Bundle im globalen Skript.
--
-- @within Internal
-- @local
--
function BundleDialogWindows.Global:Install()
end

-- Local Script ----------------------------------------------------------------

---
-- Initalisiert das Bundle im lokalen Skript.
--
-- @within Internal
-- @local
--
function BundleDialogWindows.Local:Install()
    self:DialogOverwriteOriginal();
end

---
-- Führt das Callback eines Info-Fensters oder eines Selektionsfensters aus.
--
-- @within Internal
-- @local
--
function BundleDialogWindows.Local:Callback()
    if self.Data.Requester.ActionFunction then
        self.Data.Requester.ActionFunction(CustomGame.Knight + 1);
    end
    self:OnDialogClosed();
end

---
-- Führt das Callback eines Ja-Nein-Dialogs aus.
--
-- @param[type=boolean] _yes Gegebene Antwort
-- @within Internal
-- @local
--
function BundleDialogWindows.Local:CallbackRequester(_yes)
    if self.Data.Requester.ActionRequester then
        self.Data.Requester.ActionRequester(_yes);
    end
    self:OnDialogClosed();
end

---
-- Läd den nächsten Dialog aus der Warteschlange und stellt die Speicher-Hotkeys
-- wieder her.
--
-- @within Internal
-- @local
--
function BundleDialogWindows.Local:OnDialogClosed()
    self:DialogQueueStartNext();
    self:RestoreSaveGame();
end

---
-- Startet den nächsten Dialog in der Warteschlange, sofern möglich.
--
-- @within Internal
-- @local
--
function BundleDialogWindows.Local:DialogQueueStartNext()
    self.Data.Requester.Next = table.remove(self.Data.Requester.Queue, 1);

    DialogQueueStartNext_HiResControl = function()
        local Entry = BundleDialogWindows.Local.Data.Requester.Next;
        if Entry and Entry[1] and Entry[2] then
            local Methode = Entry[1];
            BundleDialogWindows.Local[Methode]( BundleDialogWindows.Local, unpack(Entry[2]) );
            BundleDialogWindows.Local.Data.Requester.Next = nil;
        end
        return true;
    end
    StartSimpleHiResJob("DialogQueueStartNext_HiResControl");
end

---
-- Fügt der Dialogwarteschlange einen neuen Dialog hinten an.
--
-- @param[type=string] _Methode Dialogfunktion als String
-- @param[type=table] _Args    Argumente als Table
-- @within Internal
-- @local
--
function BundleDialogWindows.Local:DialogQueuePush(_Methode, _Args)
    local Entry = {_Methode, _Args};
    table.insert(self.Data.Requester.Queue, Entry);
end

---
-- Öffnet einen Info-Dialog. Sollte bereits ein Dialog zu sehen sein, wird
-- der Dialog der Dialogwarteschlange hinzugefügt.
--
-- @param[type=string]   _Title  Titel des Dialog
-- @param[type=string]   _Text   Text des Dialog
-- @param[type=function] _Action Callback-Funktion
-- @within Internal
-- @local
--
function BundleDialogWindows.Local:OpenDialog(_Title, _Text, _Action)
    if XGUIEng.IsWidgetShown(RequesterDialog) == 0 then
        assert(type(_Title) == "string");
        assert(type(_Text) == "string");

        _Title = "{center}" .. _Title;
        if string.len(_Text) &#x3C; 35 then
            _Text = _Text .. "{cr}";
        end

        g_MapAndHeroPreview.SelectKnight = function()
        end

        XGUIEng.ShowAllSubWidgets("/InGame/Dialog/BG",1);
        XGUIEng.ShowWidget("/InGame/Dialog/Backdrop",0);
        XGUIEng.ShowWidget(RequesterDialog,1);
        XGUIEng.ShowWidget(RequesterDialog_Yes,0);
        XGUIEng.ShowWidget(RequesterDialog_No,0);
        XGUIEng.ShowWidget(RequesterDialog_Ok,1);

        if type(_Action) == "function" then
            self.Data.Requester.ActionFunction = _Action;
            local Action = "XGUIEng.ShowWidget(RequesterDialog, 0)";
            Action = Action .. "; XGUIEng.PopPage()";
            Action = Action .. "; BundleDialogWindows.Local.Callback(BundleDialogWindows.Local)";
            XGUIEng.SetActionFunction(RequesterDialog_Ok, Action);
        else
            self.Data.Requester.ActionFunction = nil;
            local Action = "XGUIEng.ShowWidget(RequesterDialog, 0)";
            Action = Action .. "; XGUIEng.PopPage()";
            Action = Action .. "; BundleDialogWindows.Local.Callback(BundleDialogWindows.Local)";
            XGUIEng.SetActionFunction(RequesterDialog_Ok, Action);
        end

        XGUIEng.SetText(RequesterDialog_Message, "{center}" .. _Text);
        XGUIEng.SetText(RequesterDialog_Title, _Title);
        XGUIEng.SetText(RequesterDialog_Title.."White", _Title);
        XGUIEng.PushPage(RequesterDialog,false);

        XGUIEng.ShowWidget("/InGame/InGame/MainMenu/Container/QuickSave", 0);
        XGUIEng.ShowWidget("/InGame/InGame/MainMenu/Container/SaveGame", 0);
        if not KeyBindings_SaveGame_Orig_QSB_Windows then
            KeyBindings_SaveGame_Orig_QSB_Windows = KeyBindings_SaveGame;
            KeyBindings_SaveGame = function() end;
        end
    else
        self:DialogQueuePush("OpenDialog", {_Title, _Text, _Action});
    end
end

---
-- Öffnet einen Ja-Nein-Dialog. Sollte bereits ein Dialog zu sehen sein, wird
-- der Dialog der Dialogwarteschlange hinzugefügt.
--
-- @param[type=string]   _Title    Titel des Dialog
-- @param[type=string]   _Text     Text des Dialog
-- @param[type=function] _Action   Callback-Funktion
-- @param[type=boolean]  _OkCancel Okay/Abbrechen statt Ja/Nein
-- @within Internal
-- @local
--
function BundleDialogWindows.Local:OpenRequesterDialog(_Title, _Text, _Action, _OkCancel)
    if XGUIEng.IsWidgetShown(RequesterDialog) == 0 then
        assert(type(_Title) == "string");
        assert(type(_Text) == "string");
        _Title = "{center}" .. _Title;

        self:OpenDialog(_Title, _Text, _Action);
        XGUIEng.ShowWidget(RequesterDialog_Yes,1);
        XGUIEng.ShowWidget(RequesterDialog_No,1);
        XGUIEng.ShowWidget(RequesterDialog_Ok,0);

        if _OkCancel ~= nil then
            XGUIEng.SetText(RequesterDialog_Yes, XGUIEng.GetStringTableText("UI_Texts/Ok_center"));
            XGUIEng.SetText(RequesterDialog_No, XGUIEng.GetStringTableText("UI_Texts/Cancel_center"));
        else
            XGUIEng.SetText(RequesterDialog_Yes, XGUIEng.GetStringTableText("UI_Texts/Yes_center"));
            XGUIEng.SetText(RequesterDialog_No, XGUIEng.GetStringTableText("UI_Texts/No_center"));
        end

        self.Data.Requester.ActionRequester = nil;
        if _Action then
            assert(type(_Action) == "function");
            self.Data.Requester.ActionRequester = _Action;
        end
        local Action = "XGUIEng.ShowWidget(RequesterDialog, 0)";
        Action = Action .. "; XGUIEng.PopPage()";
        Action = Action .. "; BundleDialogWindows.Local.CallbackRequester(BundleDialogWindows.Local, true)";
        XGUIEng.SetActionFunction(RequesterDialog_Yes, Action);
        local Action = "XGUIEng.ShowWidget(RequesterDialog, 0)";
        Action = Action .. "; XGUIEng.PopPage()";
        Action = Action .. "; BundleDialogWindows.Local.CallbackRequester(BundleDialogWindows.Local, false)"
        XGUIEng.SetActionFunction(RequesterDialog_No, Action);
    else
        self:DialogQueuePush("OpenRequesterDialog", {_Title, _Text, _Action, _OkCancel});
    end
end

---
-- Öffnet einen Auswahldialog. Sollte bereits ein Dialog zu sehen sein, wird
-- der Dialog der Dialogwarteschlange hinzugefügt.
--
-- @param[type=string]   _Title  Titel des Dialog
-- @param[type=string]   _Text   Text des Dialog
-- @param[type=function] _Action Callback-Funktion
-- @param[type=table]    _List   Liste der Optionen
-- @within Internal
-- @local
--
function BundleDialogWindows.Local:OpenSelectionDialog(_Title, _Text, _Action, _List)
    if XGUIEng.IsWidgetShown(RequesterDialog) == 0 then
        self:OpenDialog(_Title, _Text, _Action);

        local HeroComboBoxID = XGUIEng.GetWidgetID(CustomGame.Widget.KnightsList);
        XGUIEng.ListBoxPopAll(HeroComboBoxID);
        for i=1,#_List do
            XGUIEng.ListBoxPushItem(HeroComboBoxID, _List[i] );
        end
        XGUIEng.ListBoxSetSelectedIndex(HeroComboBoxID, 0);
        CustomGame.Knight = 0;

        local Action = "XGUIEng.ShowWidget(RequesterDialog, 0)";
        Action = Action .. "; XGUIEng.PopPage()";
        Action = Action .. "; XGUIEng.PopPage()";
        Action = Action .. "; XGUIEng.PopPage()";
        Action = Action .. "; BundleDialogWindows.Local.Callback(BundleDialogWindows.Local)";
        XGUIEng.SetActionFunction(RequesterDialog_Ok, Action);

        local Container = "/InGame/Singleplayer/CustomGame/ContainerSelection/";
        XGUIEng.SetText(Container .. "HeroComboBoxMain/HeroComboBox", "");
        if _List[1] then
            XGUIEng.SetText(Container .. "HeroComboBoxMain/HeroComboBox", _List[1]);
        end
        XGUIEng.PushPage(Container .. "HeroComboBoxContainer", false);
        XGUIEng.PushPage(Container .. "HeroComboBoxMain",false);
        XGUIEng.ShowWidget(Container .. "HeroComboBoxContainer", 0);
        local screen = {GUI.GetScreenSize()};
        local x1, y1 = XGUIEng.GetWidgetScreenPosition(RequesterDialog_Ok);
        XGUIEng.SetWidgetScreenPosition(Container .. "HeroComboBoxMain", x1-25, y1-90);
        XGUIEng.SetWidgetScreenPosition(Container .. "HeroComboBoxContainer", x1-25, y1-20);
    else
        self:DialogQueuePush("OpenSelectionDialog", {_Title, _Text, _Action, _List});
    end
end

---
-- Stellt die Hotkeys zum Speichern des Spiels wieder her.
--
-- @within Internal
-- @local
--
function BundleDialogWindows.Local:RestoreSaveGame()
    if BundleGameHelperFunctions and not BundleGameHelperFunctions.Local.Data.ForbidSave then
        XGUIEng.ShowWidget("/InGame/InGame/MainMenu/Container/QuickSave", 1);
        XGUIEng.ShowWidget("/InGame/InGame/MainMenu/Container/SaveGame", 1);
    end
    if KeyBindings_SaveGame_Orig_QSB_Windows then
        KeyBindings_SaveGame = KeyBindings_SaveGame_Orig_QSB_Windows;
        KeyBindings_SaveGame_Orig_QSB_Windows = nil;
    end
end

---
-- Überschreibt die originalen Dialogfunktionen, um Fehler in den vorhandenen
-- Funktionen zu vermeiden.
--
-- @within Internal
-- @local
--
function BundleDialogWindows.Local:DialogOverwriteOriginal()
    OpenDialog_Orig_Windows = OpenDialog;
    OpenDialog = function(_Message, _Title, _IsMPError)
        if XGUIEng.IsWidgetShown(RequesterDialog) == 0 then
            local Action = "XGUIEng.ShowWidget(RequesterDialog, 0)";
            Action = Action .. "; XGUIEng.PopPage()";
            XGUIEng.SetActionFunction(RequesterDialog_Ok, Action);
            OpenDialog_Orig_Windows(_Title, _Message);
        end
    end

    OpenRequesterDialog_Orig_Windows = OpenRequesterDialog;
    OpenRequesterDialog = function(_Message, _Title, action, _OkCancel, no_action)
        if XGUIEng.IsWidgetShown(RequesterDialog) == 0 then
            local Action = "XGUIEng.ShowWidget(RequesterDialog, 0)";
            Action = Action .. "; XGUIEng.PopPage()";
            XGUIEng.SetActionFunction(RequesterDialog_Yes, Action);
            local Action = "XGUIEng.ShowWidget(RequesterDialog, 0)";
            Action = Action .. "; XGUIEng.PopPage()";
            XGUIEng.SetActionFunction(RequesterDialog_No, Action);
            OpenRequesterDialog_Orig_Windows(_Message, _Title, action, _OkCancel, no_action);
        end
    end
end

-- -------------------------------------------------------------------------- --

Core:RegisterBundle("BundleDialogWindows");

</code></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundleentitycommandfunctions.lua.html">
            <div class='doclink'>
                <div>BundleEntityCommandFunctions</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><code>-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundleEntityCommandFunctions                                 # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Stellt Hilfsfunktionen bereit um Entities Befehle zu erteilen oder sie
-- von A nach B zu bewegen.
--
-- Das wichtigste Auf einen Blick:
-- &#x3C;ul&#x3E;
-- &#x3C;li&#x3E;
-- &#x3C;a href="#API.CommandAttack"&#x3E;Befehle für Entities&#x3C;/a&#x3E;
-- &#x3C;/li&#x3E;
-- &#x3C;li&#x3E;
-- &#x3C;a href="#API.MoveAndLookAt"&#x3E;Entities bewegen&#x3C;/a&#x3E;
-- &#x3C;/li&#x3E;
-- &#x3C;li&#x3E;
-- &#x3C;a href="#API.PlaceAndLookAt"&#x3E;Entities platzieren&#x3C;/a&#x3E;
-- &#x3C;/li&#x3E;
-- &#x3C;/ul&#x3E;
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundleEntityCommandFunctions = {};

API = API or {};
QSB = QSB or {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Setzt ein Entity oder ein Battalion an eine neue Position.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; SetPosition&#x3C;/p&#x3E;
--
-- @param _Entity   Entity zum versetzen (Skriptname oder ID)
-- @param _Position Neue Position (Skriptname, ID oder Position)
-- @within Anwenderfunktionen
--
-- @usage
-- API.SetPostion("hakim", "hakimPos1");
--
function API.SetPosition(_Entity, _Position)
    if GUI then
        local Subject = (type(_Entity) ~= "string" and _Entity) or "'" .._Entity.. "'";
        local Position = _Position;
        if type(Position) == "table" then
            Position = "{X= " ..tostring(Position.X).. ", Y= " ..tostring(Position.Y).. "}";
        end
        API.Bridge("API.SetPosition(" ..Subject.. ", " ..Position.. ")")
        return;
    end
    if not IsExisting(_Entity) then
        local Subject = (type(_Entity) ~= "string" and _Entity) or "'" .._Entity.. "'";
        API.Fatal("API.SetPosition: Entity " ..Subject.. " does not exist!");
        return;
    end
    local Position = API.LocateEntity(_Position)
    if not API.ValidatePosition(Position) then
        API.Fatal("API.SetPosition: Position is invalid!");
        return;
    end
    return BundleEntityCommandFunctions.Global:SetPosition(_Entity, Position);
end
SetPosition = API.SetPosition;

---
-- Das Entity wird relativ zu einem Winkel zum Ziel bewegt. Nachdem das Entity
-- angekommen ist, wird es zum Ziel ausgerichtet.
--
-- &#x3C;b&#x3E;Hinweis&#x3C;/b&#x3E;: Beim Alias MoveEntityToPositionToAnotherOne sind die
-- Parameter _Position und _Distance im Sinne der Kompatibelität vertauscht!
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; MoveEntityToPositionToAnotherOne&#x3C;/p&#x3E;
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; MoveEx&#x3C;/br&#x3E;&#x3C;/p&#x3E;
--
-- @param               _Entity       Entity zum versetzen (Skriptname oder ID)
-- @param               _Position     Neue Position (Skriptname oder ID)
-- @param[type=number]  _Distance     Entfernung zum Ziel
-- @param[type=number]  _Angle        Winkel
-- @param[type=boolean] _moveAsEntity Blocking ignorieren
-- @within Anwenderfunktionen
--
-- @usage
-- API.MoveToPosition("hakim", "saraya", 300, 0);
--
function API.MoveToPosition(_Entity, _Position, _Distance, _Angle, _moveAsEntity)
    if GUI then
        API.Bridge("API.MoveToPosition(" ..GetID(_Entity).. ", " ..GetID(_Position).. ", " .._Distance.. ", " .._Angle.. ", " ..tostring(_moveAsEntity).. ")")
        return;
    end
    if not IsExisting(_Entity) then
        local Subject = (type(_Entity) ~= "string" and _Entity) or "'" .._Entity.. "'";
        API.Fatal("API.MoveToPosition: Entity " ..Subject.. " does not exist!");
        return;
    end
    if not IsExisting(_Position) then
        local Subject = (type(_Position) ~= "string" and _Position) or "'" .._Position.. "'";
        API.Fatal("API.MoveToPosition: Entity " ..Subject.. " does not exist!");
        return;
    end
    return BundleEntityCommandFunctions.Global:MoveToPosition(_Entity, _Position, _Distance, _Angle, _moveAsEntity);
end
MoveEntityToPositionToAnotherOne = function(_Entity, _Distance, _Position, _Angle, _moveAsEntity)
    API.MoveToPosition(_Entity, _Position, _Distance, _Angle, _moveAsEntity);
end
MoveEx = API.MoveToPosition;

---
-- Das Entity wird zum Ziel bewegt und schaut es anschließend an.
--
-- &#x3C;b&#x3E;Hinweis&#x3C;/b&#x3E;: Beim Alias MoveEntityFaceToFaceToAnotherOne sind die
-- Parameter _Position und _Distance im Sinne der Kompatibelität vertauscht!
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; MoveEntityFaceToFaceToAnotherOne&#x3C;/p&#x3E;
--
-- @param               _Entity       Entity zum versetzen (Skriptname oder ID)
-- @param               _Position     Neue Ziel (Skriptname oder ID)
-- @param[type=number]  _Distance     Entfernung zum Ziel
-- @param[type=boolean] _moveAsEntity Blocking ignorieren
-- @within Anwenderfunktionen
--
-- @usage
-- API.MoveAndLookAt("hakim", "saraya", 300);
--
function API.MoveAndLookAt(_Entity, _Position, _Distance, _moveAsEntity)
    if GUI then
        API.Bridge("API.MoveAndLookAt(" ..GetID(_Entity).. ", " ..GetID(_Position).. ", " .._Distance.. ", " ..tostring(_moveAsEntity).. ")")
        return;
    end
    if not IsExisting(_Entity) then
        local Subject = (type(_Entity) ~= "string" and _Entity) or "'" .._Entity.. "'";
        API.Fatal("API.MoveAndLookAt: Entity " ..Subject.. " does not exist!");
        return;
    end
    if not IsExisting(_Position) then
        local Subject = (type(_Position) ~= "string" and _Position) or "'" .._Position.. "'";
        API.Fatal("API.MoveAndLookAt: Entity " ..Subject.. " does not exist!");
        return;
    end
    return BundleEntityCommandFunctions.Global:MoveToPosition(_Entity, _Position, _Distance, 0, _moveAsEntity);
end
MoveEntityFaceToFaceToAnotherOne = function(_Entity, _Distance, _Position, _moveAsEntity)
    API.MoveAndLookAt(_Entity, _Position, _Distance, _moveAsEntity)
end

---
-- Das Entity wird relativ zu einem Winkel zum Zielpunkt gesetzt.
--
-- &#x3C;b&#x3E;Hinweis&#x3C;/b&#x3E;: Beim Alias PlaceEntityToPositionToAnotherOne sind die
-- Parameter _Position und _Distance im Sinne der Kompatibelität vertauscht!
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; PlaceEntityToPositionToAnotherOne&#x3C;/p&#x3E;
--
-- @param               _Entity   Entity zum versetzen (Skriptname oder ID)
-- @param               _Position Neue Ziel (Skriptname oder ID)
-- @param[type=number]  _Distance Entfernung zum Ziel
-- @param[type=number]  _Angle    Winkel
-- @within Anwenderfunktionen
--
-- @usage
-- API.PlaceToPosition("hakim", "saraya", 300, 45);
--
function API.PlaceToPosition(_Entity, _Position, _Distance, _Angle)
    if GUI then
        API.Bridge("API.PlaceToPosition(" ..GetID(_Entity).. ", " ..GetID(_Position).. ", " .._Distance.. ", " .._Angle.. ")")
        return;
    end
    if not IsExisting(_Entity) then
        local Subject = (type(_Entity) ~= "string" and _Entity) or "'" .._Entity.. "'";
        API.Fatal("API.PlaceToPosition: Entity " ..Subject.. " does not exist!");
        return;
    end
    if not IsExisting(_Position) then
        local Subject = (type(_Position) ~= "string" and _Position) or "'" .._Position.. "'";
        API.Fatal("API.PlaceToPosition: Entity " ..Subject.. " does not exist!");
        return;
    end
    local Position = BundleEntityCommandFunctions.Shared:GetRelativePos(_Position, _Distance, _Angle, true);
    API.SetPosition(_Entity, Position);
end
PlaceEntityToPositionToAnotherOne = function(_Entity, _Distance, _Position, _Angle)
    API.PlaceToPosition(_Entity, _Position, _Distance, _Angle);
end

---
-- Das Entity wird zum Zielpunkt gesetzt und schaut das Ziel an.
--
-- &#x3C;b&#x3E;Hinweis&#x3C;/b&#x3E;: Beim Alias PlaceEntityFaceToFaceToAnotherOne sind die
-- Parameter _Position und _Distance im Sinne der Kompatibelität vertauscht!
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; PlaceEntityFaceToFaceToAnotherOne&#x3C;/p&#x3E;
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; SetPositionEx&#x3C;br&#x3E;&#x3C;/p&#x3E;
--
-- @param              _Entity   Entity zum versetzen (Skriptname oder ID)
-- @param              _Position Neue Ziel (Skriptname oder ID)
-- @param[type=number] _Distance Entfernung
-- @within Anwenderfunktionen
--
-- @usage
-- API.PlaceAndLookAt("hakim", "saraya", 300);
--
function API.PlaceAndLookAt(_Entity, _Position, _Distance)
    if GUI then
        API.Bridge("API.PlaceAndLookAt(" ..GetID(_Entity).. ", " ..GetID(_Position).. ", " .._Distance.. ")")
        return;
    end
    API.PlaceToPosition(_Entity, _Position, _Distance, 0);
    LookAt(_Entity, _Position);
end
PlaceEntityFaceToFaceToAnotherOne = function(_Entity, _Distance, _Position)
    API.PlaceAndLookAt(_Entity, _Position, _Distance);
end
SetPositionEx = API.PlaceAndLookAt;

---
-- Das Entity greift ein anderes Entity an, sofern möglich.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; Attack&#x3C;/p&#x3E;
--
-- @param _Entity Entity zum versetzen (Skriptname oder ID)
-- @param _Target Neue Ziel (Skriptname oder ID)
-- @within Anwenderfunktionen
--
-- @usage
-- API.CommandAttack("hakim", "marcus");
--
function API.CommandAttack(_Entity, _Target)
    if GUI then
        API.Bridge("API.CommandAttack(" ..GetID(_Entity).. ", " ..GetID(_Target).. ")")
        return;
    end
    if not IsExisting(_Entity) then
        local Subject = (type(_Entity) == "string" and "'" .._Entity.. "'") or _Entity;
        API.Fatal("API.CommandAttack: Entity " ..Subject.. " does not exist!");
        return;
    end
    if not IsExisting(_Target) then
        local Subject = (type(_Target) == "string" and "'" .._Target.. "'") or _Target;
        API.Fatal("API.CommandAttack: Target " ..Subject.. " does not exist!");
        return;
    end
    local EntityID = GetID(_Entity);
    local TargetID = GetID(_Target);
    Logic.GroupAttack(EntityID, TargetID);
end
Attack = API.CommandAttack;

---
-- Ein Entity oder ein Battalion wird zu einer Position laufen und
-- alle gültigen Ziele auf dem Weg angreifen.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; AttackMove&#x3C;/p&#x3E;
--
-- @param              _Entity   Angreifendes Entity (Skriptname oder ID)
-- @param[type=string] _Position Zielposition
-- @within Anwenderfunktionen
--
-- @usage
-- API.CommandAttackMove("hakim", "area");
--
function API.CommandAttackMove(_Entity, _Position)
    if GUI then
        API.Fatal("API.CommandAttackMove: Cannot be used from local script!");
        return;
    end
    if not IsExisting(_Entity) then
        local Subject = (type(_Entity) == "string" and "'" .._Entity.. "'") or _Entity;
        API.Fatal("API.CommandAttackMove: Entity " ..Subject.. " does not exist!");
        return;
    end
    local Position = API.LocateEntity(_Position)
    if not API.ValidatePosition(Position) then
        API.Fatal("API.CommandAttackMove: Position is invalid!");
        return;
    end
    local EntityID = GetID(_Entity);
    local Position = GetPosition(_Position);
    Logic.GroupAttackMove(EntityID, Position.X, Position.Y);
end
AttackMove = API.CommandAttackMove;

---
-- Bewegt das Entity zur Zielposition.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; Move&#x3C;/p&#x3E;
--
-- @param             _Entity   Angreifendes Entity (Skriptname oder ID)
-- @param[type=table] _Position  Positionstable
-- @within Anwenderfunktionen
--
-- @usage
-- API.CommandMove("hakim", "pos");
--
function API.CommandMove(_Entity, _Position)
    if GUI then
        API.Fatal("API.CommandMove: Cannot be used from local script!");
        return;
    end
    if not IsExisting(_Entity) then
        local Subject = (type(_Entity) == "string" and "'" .._Entity.. "'") or _Entity;
        API.Fatal("API.CommandMove: Entity " ..Subject.. " does not exist!");
        return;
    end
    local Position = API.LocateEntity(_Position)
    if not API.ValidatePosition(Position) then
        API.Fatal("API.CommandMove: Position is invalid!");
        return;
    end
    local EntityID = GetID(_Entity);
    local Position = GetPosition(_Position);
    Logic.MoveSettler(EntityID, Position.X, Position.Y);
end
Move = API.CommandMove;

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

BundleEntityCommandFunctions = {
    Global = {
        Data = {}
    },
    Shared = {
        Data = {}
    },
}

-- Global Script ---------------------------------------------------------------

---
-- Initalisiert das Bundle im globalen Skript.
--
-- @within Internal
-- @local
--
function BundleEntityCommandFunctions.Global:Install()
end

-- Setzt ein Entity oder ein Battalion an eine neue Position.
--
-- @param _Entity   Entity zum versetzen (Skriptname oder ID)
-- @param _Position Neue Position (Skriptname, ID oder Position)
-- @within Internal
-- @local
--
function BundleEntityCommandFunctions.Global:SetPosition(_Entity,_Position)
    if not IsExisting(_Entity)then
        return
    end
    local EntityID = GetEntityId(_Entity);
    Logic.DEBUG_SetSettlerPosition(EntityID, _Position.X, _Position.Y);
    if Logic.IsLeader(EntityID) == 1 then
        local soldiers = {Logic.GetSoldiersAttachedToLeader(EntityID)};
        if soldiers[1] &#x3E; 0 then
            for i=1,#soldiers do
                Logic.DEBUG_SetSettlerPosition(soldiers[i], _Position.X, _Position.Y);
            end
        end
    end
end

---
-- Das Entity wird relativ zu einem Winkel zum Zielpunkt bewegt.
--
-- @param               _Entity       Entity zum versetzen (Skriptname oder ID)
-- @param               _Position     Neue Position (Skriptname oder ID)
-- @param[type=number]  _Distance     Entfernung zum Ziel
-- @param[type=number]  _Angle        Winkel
-- @param[type=boolean] _moveAsEntity Blocking ignorieren
-- @within Internal
-- @local
--
function BundleEntityCommandFunctions.Global:MoveToPosition(_Entity, _Position, _Distance, _Angle, _moveAsEntity)
    if not IsExisting(_Entity)then
        return
    end
    local eID = GetID(_Entity);
    local tID = GetID(_Position);
    local pos = BundleEntityCommandFunctions.Shared:GetRelativePos(_Position, _Distance or 0, _Angle or 0);

    if _moveAsEntity then
        Logic.MoveEntity(eID, pos.X, pos.Y);
    else
        Logic.MoveSettler(eID, pos.X, pos.Y);
    end

    StartSimpleJobEx( function(_EntityID, _TargetID)
        if not IsExisting(_EntityID) or not IsExisting(_EntityID) then
            return true;
        end
        if not Logic.IsEntityMoving(_EntityID) then
            LookAt(_EntityID, _TargetID);
            return true;
        end
    end, eID, tID);
end

-- Shared ----------------------------------------------------------------------

---
-- Errechnet eine Position relativ im angegebenen Winkel und Position zur
-- Basisposition. Die Basis kann ein Entity oder eine Positionstabelle sein.
--
-- @param               _target          Basisposition (Skriptname, ID oder Position)
-- @param[type=number]  _distance        Entfernung
-- @param[type=number]  _angle           Winkel
-- @param[type=boolean] _buildingRealPos Gebäudemitte statt Gebäudeeingang
-- @return[type=table] Position
-- @within Internal
-- @local
--
function BundleEntityCommandFunctions.Shared:GetRelativePos(_target,_distance,_angle,_buildingRealPos)
    if not type(_target) == "table" and not IsExisting(_target)then
        return
    end
    if _angle == nil then
        _angle = 0;
    end

    local pos1;
    if type(_target) == "table" then
        local pos = _target;
        local ori = 0+_angle;
        pos1 = { X= pos.X+_distance * math.cos(math.rad(ori)),
                 Y= pos.Y+_distance * math.sin(math.rad(ori))};
    else
        local eID = GetID(_target);
        local pos = GetPosition(eID);
        local ori = Logic.GetEntityOrientation(eID)+_angle;
        if Logic.IsBuilding(eID) == 1 and not _buildingRealPos then
            x, y = Logic.GetBuildingApproachPosition(eID);
            pos = {X= x, Y= y};
            ori = ori -90;
        end
        pos1 = { X= pos.X+_distance * math.cos(math.rad(ori)),
                 Y= pos.Y+_distance * math.sin(math.rad(ori))};
    end
    return pos1;
end

-- -------------------------------------------------------------------------- --

Core:RegisterBundle("BundleEntityCommandFunctions");

</code></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundleentityhelperfunctions.lua.html">
            <div class='doclink'>
                <div>BundleEntityHelperFunctions</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><code>-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundleEntityHelperFunctions                                  # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Stellt Hilfsfunktionen bereit um die Eigenschaften von Entities zu
-- ermitteln oder zu verändern.
--
-- Das wichtigste Auf einen Blick:
-- &#x3C;ul&#x3E;
-- &#x3C;li&#x3E;
-- &#x3C;a href="#API.EntityGetName"&#x3E;Eigenschaften von Entities&#x3C;/a&#x3E;
-- &#x3C;/li&#x3E;
-- &#x3C;li&#x3E;
-- &#x3C;a href="#API.GetEntitiesByPrefix"&#x3E;Entities ermitteln&#x3C;/a&#x3E;
-- &#x3C;/li&#x3E;
-- &#x3C;/ul&#x3E;
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundleEntityHelperFunctions = {};

API = API or {};
QSB = QSB or {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Sucht auf den angegebenen Territorium nach Entities mit bestimmten
-- Kategorien. Dabei kann für eine Partei oder für mehrere Parteien gesucht
-- werden.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; GetEntitiesOfCategoriesInTerritories&#x3C;br&#x3E;&#x3C;/p&#x3E;
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; EntitiesInCategories&#x3C;/p&#x3E;
--
-- @param _player      PlayerID [0-8] oder Table mit PlayerIDs (Einzelne Spielernummer oder Table)
-- @param _category    Kategorien oder Table mit Kategorien (Einzelne Kategorie oder Table)
-- @param _territory   Zielterritorium oder Table mit Territorien (Einzelnes Territorium oder Table)
-- @return[type=table] Liste mit Resultaten
-- @within Anwenderfunktionen
--
-- @usage
-- local Result = API.GetEntitiesOfCategoriesInTerritories({1, 2, 3}, EntityCategories.Hero, {5, 12, 23, 24});
--
function API.GetEntitiesOfCategoriesInTerritories(_player, _category, _territory)
    -- Tables erzwingen
    local p = (type(_player) == "table" and _player) or {_player};
    local c = (type(_category) == "table" and _category) or {_category};
    local t = (type(_territory) == "table" and _territory) or {_territory};

    local PlayerEntities = {};
    for i=1, #p, 1 do
        for j=1, #c, 1 do
            for k=1, #t, 1 do
                local Units = API.GetEntitiesOfCategoryInTerritory(p[i], c[j], t[k]);
                PlayerEntities = Array_Append(PlayerEntities, Units);
            end
        end
    end
    return PlayerEntities;
end
GetEntitiesOfCategoriesInTerritories = API.GetEntitiesOfCategoriesInTerritories;
EntitiesInCategories = API.GetEntitiesOfCategoriesInTerritories;

---
-- Gibt alle Entities zurück, deren Name mit dem Prefix beginnt.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; GetEntitiesNamedWith&#x3C;/p&#x3E;
--
-- @param[type=string] _Prefix Präfix des Skriptnamen
-- @return[type=table] Liste mit Entities
-- @within Anwenderfunktionen
--
-- @usage
-- -- Alle Entities mit "entranceCave" -&#x3E; entranceCave1, entranceCave2, ...
-- local Result = API.GetEntitiesByPrefix("entranceCave");
--
function API.GetEntitiesByPrefix(_Prefix)
    local list = {};
    local i = 1;
    local bFound = true;
    while bFound do
        local entity = GetID(_Prefix ..i);
        if entity ~= 0 then
            table.insert(list, entity);
        else
            bFound = false;
        end
        i = i + 1;
    end
    return list;
end
GetEntitiesNamedWith = API.GetEntitiesByPrefix;

---
-- Setzt die Menge an Rohstoffen und die durchschnittliche Auffüllmenge
-- in einer Mine.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; SetResourceAmount&#x3C;/p&#x3E;
--
-- @param              _Entity       Rohstoffvorkommen (Skriptname oder ID)
-- @param[type=number] _StartAmount  Menge an Rohstoffen
-- @param[type=number] _RefillAmount Minimale Nachfüllmenge (&#x3E; 0)
-- @within Anwenderfunktionen
--
-- @usage
-- API.SetResourceAmount("mine1", 250, 150);
--
function API.SetResourceAmount(_Entity, _StartAmount, _RefillAmount)
    if GUI then
        local Subject = (type(_Entity) ~= "string" and _Entity) or "'" .._Entity.. "'";
        API.Bridge("API.SetResourceAmount(" ..Subject..", " .._StartAmount.. ", " .._RefillAmount.. ")")
        return;
    end
    if not IsExisting(_Entity) then
        local Subject = (type(_Entity) ~= "string" and _Entity) or "'" .._Entity.. "'";
        API.Fatal("API.SetResourceAmount: Entity " ..Subject.. " does not exist!");
        return;
    end
    return BundleEntityHelperFunctions.Global:SetResourceAmount(_Entity, _StartAmount, _RefillAmount);
end
SetResourceAmount = API.SetResourceAmount;

---
-- Errechnet eine Position relativ im angegebenen Winkel und Position zur
-- Basisposition. Die Basis kann ein Entity oder eine Positionstabelle sein.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; GetRelativePos&#x3C;/p&#x3E;
--
-- @param               _target          Basisposition (Skriptname, ID oder Position)
-- @param[type=number]  _distance        Entfernung
-- @param[type=number]  _angle           Winkel
-- @param[type=boolean] _buildingRealPos Gebäudemitte statt Gebäudeeingang
-- @return[type=table] Position
-- @within Anwenderfunktionen
--
-- @usage
-- local RelativePostion = API.GetRelativePosition("pos1", 1000, 32);
--
function API.GetRelativePosition(_target, _distance, _angle, _buildingRealPos)
    if not API.ValidatePosition(_target) then
        if not IsExisting(_target) then
            API.Fatal("API.GetRelativePosition: Target is invalid!");
            return;
        end
    end
    return BundleEntityHelperFunctions.Shared:GetRelativePos(_target, _distance, _angle, _buildingRealPos);
end
GetRelativePos = API.GetRelativePosition;

---
-- Gibt den Skriptnamen des Entity zurück.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; GetEntityName&#x3C;/p&#x3E;
--
-- @param[type=number] _entity Gesuchtes Entity
-- @return[type=string] Skriptname
-- @within Anwenderfunktionen
--
-- @usage
-- local Name = API.EntityGetName(SomeEntityID);
--
function API.EntityGetName(_entity)
    if not IsExisting(_entity) then
        local Subject = (type(_entity) ~= "string" and _entity) or "'" .._entity.. "'";
        API.Warn("API.EntityGetName: Entity " ..Subject.. " does not exist!");
        return nil;
    end
    return Logic.GetEntityName(GetID(_entity));
end
GetEntityName = API.EntityGetName;

---
-- Setzt den Skriptnamen des Entity.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; SetEntityName&#x3C;/p&#x3E;
--
-- @param[type=number] _entity Entity
-- @param[type=string] _name   Skriptname
-- @return[type=string] Skriptname
-- @within Anwenderfunktionen
--
-- @usage
-- API.EntitySetName(SomeEntityID, "myEntity");
--
function API.EntitySetName(_entity, _name)
    if GUI then
        API.Bridge("API.EntitySetName(" ..GetID(_EntityID).. ", '" .._name.. "')")
        return;
    end
    if IsExisting(_name) then
        API.Fatal("API.EntitySetName: Entity '" .._name.. "' already exists!");
        return;
    end
    return Logic.SetEntityName(GetID(_entity), _name);
end
SetEntityName = API.EntitySetName;

---
-- Setzt die Orientierung des Entity.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; SetOrientation&#x3C;/p&#x3E;
--
-- @param              _entity Betreffendes Entity (Skriptname oder ID)
-- @param[type=number] _ori    Ausrichtung in Grad
-- @within Anwenderfunktionen
--
-- @usage
-- API.EntitySetOrientation("marcus", 52);
--
function API.EntitySetOrientation(_entity, _ori)
    if GUI then
        API.Bridge("API.EntitySetOrientation(" ..GetID(_entity).. ", " .._ori.. ")")
        return;
    end
    if not IsExisting(_entity) then
        local Subject = (type(_entity) ~= "string" and _entity) or "'" .._entity.. "'";
        API.Fatal("API.EntitySetOrientation: Entity " ..Subject.. " does not exist!");
        return;
    end
    return Logic.SetOrientation(GetID(_entity), _ori);
end
SetOrientation = API.EntitySetOrientation;

---
-- Gibt die Orientierung des Entity zurück.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; GetOrientation&#x3C;/p&#x3E;
--
-- @param               _entity Betreffendes Entity (Skriptname oder ID)
-- @param[type=boolean] _Round  Wert wird kaufmännisch auf Ganzzahl gerundet
-- @return[type=number] Orientierung in Grad
-- @within Anwenderfunktionen
--
-- @usage
-- local Orientation = API.EntityGetOrientation("marcus");
--
function API.EntityGetOrientation(_entity, _Round)
    if not IsExisting(_entity) then
        local Subject = (type(_entity) ~= "string" and _entity) or "'" .._entity.. "'";
        API.Warn("API.EntityGetOrientation: Entity " ..Subject.. " does not exist!");
        return 0;
    end
    local Orientation = Logic.GetEntityOrientation(GetID(_entity));
    if _Round then
        Orientation = math.floor(Orientation + 0.5);
    end
    return Logic.GetEntityOrientation(GetID(_entity));
end
GetOrientation = API.EntityGetOrientation;

---
-- Ermittelt den Helden eines Spielers, ders dem Basis-Entity am nächsten ist.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; GetClosestKnight&#x3C;/p&#x3E;
--
-- @param[type=number] _eID      Basis-Entity
-- @param[type=number] _playerID Besitzer der Helden
-- @return[type=number] Nächstes Entity
-- @within Anwenderfunktionen
--
-- @usage
-- local Knight = API.GetKnightsNearby(GetID("IO1"), 1);
--
function API.GetKnightsNearby(_eID, _playerID)
    local Knights = {};
    Logic.GetKnights(_playerID, Knights);
    return API.GetEntitiesNearby(_eID, Knights);
end
GetClosestKnight = API.GetKnightsNearby;

---
-- Ermittelt aus einer liste von Entity-IDs das Entity, dass dem Basis-Entity
-- am nächsten ist.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; GetClosestEntity&#x3C;/p&#x3E;
--
-- @param[type=number] _eID      Basis-Entity
-- @param[type=table]  _entities Liste von Entities
-- @return[type=number] Nächstes Entity
-- @within Anwenderfunktionen
--
-- @usage
-- local EntityList = API.GetEntitiesOfCategoriesInTerritories({1, 2, 3}, EntityCategories.Hero, {5, 12, 23, 24});
-- local Knight = API.GetEntitiesNearby(GetID("IO1"), EntityList);
--
function API.GetEntitiesNearby(_eID, _entities)
    if not IsExisting(_eID) then
        return;
    end
    if #_entities == 0 then
        API.Fatal("API.GetEntitiesNearby: The target list is empty!");
        return;
    end
    for i= 1, #_entities, 1 do
        if not IsExisting(_entities[i]) then
            API.Fatal("API.GetEntitiesNearby: At least one target entity is dead!");
            return;
        end
    end
    return BundleEntityHelperFunctions.Shared:GetNearestEntity(_eID,_entities);
end
GetClosestEntity = API.GetEntitiesNearby;

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

BundleEntityHelperFunctions = {
    Global = {
        Data = {
            RefillAmounts = {},
        }
    },
    Shared = {
        Data = {}
    },
}

-- Global Script ---------------------------------------------------------------

---
-- Initalisiert das Bundle im globalen Skript.
--
-- @within Internal
-- @local
--
function BundleEntityHelperFunctions.Global:Install()
    BundleEntityHelperFunctions.Global:OverwriteGeologistRefill();
end

---
-- Überschreibt das Auffüll-Callback, wenn es vorhanden ist, um Auffüllmengen
-- auch während des Spiels setzen zu können.
--
-- @within Internal
-- @local
--
function BundleEntityHelperFunctions.Global:OverwriteGeologistRefill()
    if Framework.GetGameExtraNo() &#x3E;= 1 then
        GameCallback_OnGeologistRefill_Orig_QSBPlusComforts1 = GameCallback_OnGeologistRefill
        GameCallback_OnGeologistRefill = function( _PlayerID, _TargetID, _GeologistID )
            GameCallback_OnGeologistRefill_Orig_QSBPlusComforts1( _PlayerID, _TargetID, _GeologistID )
            if BundleEntityHelperFunctions.Global.Data.RefillAmounts[_TargetID] then
                local RefillAmount = BundleEntityHelperFunctions.Global.Data.RefillAmounts[_TargetID];
                local RefillRandom = RefillAmount + math.random(1, math.floor((RefillAmount * 0.2) + 0.5));
                Logic.SetResourceDoodadGoodAmount(_TargetID, RefillRandom);
            end
        end
    end
end

-- Setzt die Menge an Rohstoffen und die durchschnittliche Auffüllmenge
-- in einer Mine.
--
-- @param              _Entity       Rohstoffvorkommen (Skriptname oder ID)
-- @param[type=number] _StartAmount  Menge an Rohstoffen
-- @param[type=number] _RefillAmount Minimale Nachfüllmenge (&#x3E; 0)
-- @return[type=boolean] Operation erfolgreich
-- @within Internal
-- @local
--
function BundleEntityHelperFunctions.Global:SetResourceAmount(_Entity, _StartAmount, _RefillAmount)
    assert(type(_StartAmount) == "number");
    assert(type(_RefillAmount) == "number");

    local EntityID = GetID(_Entity);
    if not IsExisting(EntityID) or Logic.GetResourceDoodadGoodType(EntityID) == 0 then
        API.Fatal("SetResourceAmount: Resource entity is invalid!");
        return false;
    end
    if Logic.GetResourceDoodadGoodAmount(EntityID) == 0 then
        EntityID = ReplaceEntity(EntityID, Logic.GetEntityType(EntityID));
    end
    Logic.SetResourceDoodadGoodAmount(EntityID, _StartAmount);
    if _RefillAmount then
        self.Data.RefillAmounts[EntityID] = _RefillAmount;
    end
    return true;
end

-- Shared ----------------------------------------------------------------------

---
-- Errechnet eine Position relativ im angegebenen Winkel und Position zur
-- Basisposition. Die Basis kann ein Entity oder eine Positionstabelle sein.
--
-- @param               _target          Basisposition (Skriptname, ID oder Position)
-- @param[type=number]  _distance        Entfernung
-- @param[type=number]  _angle           Winkel
-- @param[type=boolean] _buildingRealPos Gebäudemitte statt Gebäudeeingang
-- @return[type=table] Position
-- @within Internal
-- @local
--
function BundleEntityHelperFunctions.Shared:GetRelativePos(_target,_distance,_angle,_buildingRealPos)
    if not type(_target) == "table" and not IsExisting(_target)then
        return
    end
    if _angle == nil then
        _angle = 0;
    end

    local pos1;
    if type(_target) == "table" then
        local pos = _target;
        local ori = 0+_angle;
        pos1 = { X= pos.X+_distance * math.cos(math.rad(ori)),
                 Y= pos.Y+_distance * math.sin(math.rad(ori))};
    else
        local eID = GetID(_target);
        local pos = GetPosition(eID);
        local ori = Logic.GetEntityOrientation(eID)+_angle;
        if Logic.IsBuilding(eID) == 1 and not _buildingRealPos then
            x, y = Logic.GetBuildingApproachPosition(eID);
            pos = {X= x, Y= y};
            ori = ori -90;
        end
        pos1 = { X= pos.X+_distance * math.cos(math.rad(ori)),
                 Y= pos.Y+_distance * math.sin(math.rad(ori))};
    end
    return pos1;
end

---
-- Ermittelt aus einer liste von Entity-IDs das Entity, dass dem Basis-Entity
-- am nächsten ist.
--
-- @param[type=number] _eID      Basis-Entity
-- @param[type=table]  _entities Liste von Entities
-- @return[type=number] Nächstes Entity
-- @within Internal
-- @local
--
function BundleEntityHelperFunctions.Shared:GetNearestEntity(_eID,_entities)
    local bestDistance = Logic.WorldGetSize();
    local best = nil;
    for i=1,#_entities do
        local distanceBetween = Logic.GetDistanceBetweenEntities(_entities[i], _eID);
        if distanceBetween &#x3C; bestDistance and _entities[i] ~= _eID then
            bestDistance = distanceBetween;
            best = _entities[i];
        end
    end
    return best;
end

-- -------------------------------------------------------------------------- --

Core:RegisterBundle("BundleEntityHelperFunctions");

</code></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundleentityproperties.lua.html">
            <div class='doclink'>
                <div>BundleEntityProperties</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><code>-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundleEntityProperties                                       # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- In diesem Bundle wird eine Klasse bereitgestellt, die alle wichtigen
-- Abfragen an ein Entity in sich vereint. Mit diesem Properties Wrapper
-- kannst Du bequem die Eigenschaften von Entities abfragen und ändern.
--
-- 
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundleEntityProperties = {};

API = API or {};
QSB = QSB or {};

-- -------------------------------------------------------------------------- --
-- Backwards compability                                                      --
-- -------------------------------------------------------------------------- --

function API.GetEntityScale(_Entity)
    return QSB.EntityProperty:GetInstance(_Entity):EntitySize();
end
GetScale = API.GetEntityScale;

function API.GetEntityPlayer(_Entity)
    return QSB.EntityProperty:GetInstance(_Entity):PlayerID();
end
GetPlayer = API.GetEntityPlayer;

function API.GetMovementTarget(_Entity)
    return QSB.EntityProperty:GetInstance(_Entity):GetDestination();
end
GetMovingTarget = API.GetMovementTarget;

function API.IsActiveNpc(_Entity)
    return QSB.EntityProperty:GetInstance(_Entity):OnScreenInfo();
end
IsNpc = API.IsActiveNpc;

function API.IsEntityVisible(_Entity)
    return QSB.EntityProperty:GetInstance(_Entity):Visible();
end
IsVisible = API.IsEntityVisible;

function API.SetEntityScale(_Entity, _Scale)
    return QSB.EntityProperty:GetInstance(_Entity):EntitySize(_Scale);
end
SetScale = API.SetEntityScale;

function API.SetEntityPlayer(_Entity, _PlayerID)
    return QSB.EntityProperty:GetInstance(_Entity):PlayerID(_PlayerID);
end
ChangePlayer = API.SetEntityPlayer;

function API.GetEntityHealth(_Entity)
    return QSB.EntityProperty:GetInstance(_Entity):Health();
end
GetHealth = API.GetEntityHealth;

function API.ChangeEntityHealth(_Entity, _Percentage)
    return QSB.EntityProperty:GetInstance(_Entity):Health(_Percentage, true);
end
SetHealth = API.ChangeEntityHealth;

function API.SetBuildingOnFire(_Entity, _FireSize)
    QSB.EntityProperty:GetInstance(_Entity):Burning(_FireSize)
end
SetOnFire = API.SetBuildingOnFire;

function API.HurtEntity(_Entity, _Damage, _Attacker)
    QSB.EntityProperty:GetInstance(_Entity):Hurt(_Damage);
end
HurtEntityEx = API.HurtEntity;

-- -------------------------------------------------------------------------- --
-- Scripting Values Class                                                     --
-- -------------------------------------------------------------------------- --

QSB.EntityPropertyObjects = {};

QSB.EntityProperty = {};

---
-- Konstruktor
-- @param[type=string] _Entity Skriptname des Entity
-- @return[type=table] Neue Instanz
-- @within QSB.EntityProperty
--
function QSB.EntityProperty:New(_Entity)
    assert(self == QSB.EntityProperty, "Can not be used from instance!");
    local property = API.InstanceTable(self);
    property.m_EntityName = _Entity;
    QSB.EntityPropertyObjects[_Entity] = property;
    return property;
end

---
-- Gibt die Properties Instanz des Entity zurück.
--
-- Wenn zu dem Entity keine Instanz existiert, wird eine neue
-- Instanz erzeugt.
--
-- @param[type=string] _Entity Skriptname des Entity
-- @return[type=table] Instanz
-- @within QSB.EntityProperty
--
function QSB.EntityProperty:GetInstance(_Entity)
    assert(self == QSB.EntityProperty, "Can not be used from instance!");

    if not QSB.EntityPropertyObjects[_Entity] then
        QSB.EntityPropertyObjects[_Entity] = QSB.EntityProperty:New(_Entity);
    end
    return QSB.EntityPropertyObjects[_Entity];
end

---
-- Gibt die Größe des Entity zurück. Optional kann der
-- Größenfaktor geändert werden.
--
-- @param[type=number] _Scale (Optional) Neuer Größenfaktor
-- @return[type=number] Größenfaktor
-- @within QSB.EntityProperty
--
function QSB.EntityProperty:EntitySize(_Scale)
    assert(self ~= QSB.EntityProperty, "Can not be used in static context!");

    local SV = (QSB.HistoryEdition and -42) or -45;
    if _Scale then
        local EntityID = GetID(self.m_EntityName);
        if EntityID &#x3E; 0 then
            Logic.SetEntityScriptingValue(EntityID, SV, self:Float2Int(_Scale));
            if Logic.IsSettler(EntityID) == 1 then
                Logic.SetSpeedFactor(EntityID, _Scale);
            end
        end
    end
    return self:GetValueAsFloat(SV);
end

---
-- Gibt die Ausrichtung des Entity zurück. Optional kann die
-- Ausrichtung geändert werden.
--
-- @param[type=number] _Orientation (Optional) Neue Ausrichtung
-- @return[type=number] Ausrichtung in Grad
-- @within QSB.EntityProperty
--
function QSB.EntityProperty:Orientation(_Orientation)
    assert(self ~= QSB.EntityProperty, "Can not be used in static context!");

    local EntityID = GetID(self.m_EntityName);
    if EntityID == 0 then
        return 0;
    end
    if _Orientation then
        Logic.SetOrientation(EntityID, _Orientation);
    end
    return Logic.GetEntityOrientation(EntityID);
end

---
-- Gibt die Menge an Rohstoffen des Entity zurück. Optional kann
-- eine neue Menge gesetzt werden.
--
-- @param[type=number] _Amount (Optional) Menge an Rohstoffen
-- @return[type=number] Menge an Rohstoffen
-- @within QSB.EntityProperty
--
function QSB.EntityProperty:Resource(_Amount)
    assert(self ~= QSB.EntityProperty, "Can not be used in static context!");

    local EntityID = GetID(self.m_EntityName);
    if EntityID == 0 or Logic.GetResourceDoodadGoodType(EntityID) == 0 then
        return 0;
    end
    if _Amount then
        if Logic.GetResourceDoodadGoodAmount(EntityID) == 0 then
            EntityID = ReplaceEntity(EntityID, Logic.GetEntityType(EntityID));
        end
        Logic.SetResourceDoodadGoodAmount(EntityID, _Amount);
    end
    return Logic.GetResourceDoodadGoodAmount(EntityID);
end

---
-- Gibt den Besitzer des Entity zurück. Optional kann das
-- Entity einem neuen Besitzer zugeordnet werden.
--
-- @param[type=number] _PlayerID (Optional) Neuer Besitzer des Entity
-- @return[type=number] Besitzer
-- @within QSB.EntityProperty
--
function QSB.EntityProperty:PlayerID(_PlayerID)
    assert(self ~= QSB.EntityProperty, "Can not be used in static context!");

    local SV = (QSB.HistoryEdition and -68) or -71;
    if _PlayerID then
        local EntityID = GetID(self.m_EntityName);
        if EntityID &#x3E; 0 then
            if Logic.IsLeader(EntityID) == 1 then
                Logic.ChangeSettlerPlayerID(EntityID, _PlayerID);
            else
                Logic.SetEntityScriptingValue(EntityID, SV, _PlayerID);
            end
        end
    end
    return self:GetValueAsInteger(SV);
end

---
-- Gibt die Gesundheit des Entity zurück. Optional kann die
-- Gesundheit geändert werden.
--
-- @param[type=number]  _Health   (Optional) Neue aktuelle Gesundheit
-- @param[type=boolean] _Relative (Optional) Relativ zur maximalen Gesundheit
-- @return[type=number] Aktuelle Gesundheit
-- @within QSB.EntityProperty
--
function QSB.EntityProperty:Health(_Health, _Relative)
    assert(self ~= QSB.EntityProperty, "Can not be used in static context!");

    local EntityID = GetID(self.m_EntityName);
    if EntityID == 0 or Logic.IsLeader(EntityID) == 1 then
        return 0;
    end
    local SV = (QSB.HistoryEdition and -38) or -41;
    if _Health then
        local NewHealth = _Health;
        -- Relative Gesundheit berechnen
        if _Relative then
            _Health = (_Health &#x3C; 0 and 0) or _Health;
            _Health = (_Health &#x3E; 100 and 100) or _Health;
            local MaxHealth = Logic.GetEntityMaxHealth(EntityID);
            NewHealth = math.ceil((MaxHealth) * (_Health/100));
        end
        Logic.SetEntityScriptingValue(EntityID, SV, NewHealth);
    end
    return self:GetValueAsInteger(SV);
end

---
-- Heilt das Entity um die angegebene Menge an Gesundheit.
--
-- @param[type=number]  _Amount   Geheilte Gesundheit
-- @within QSB.EntityProperty
--
function QSB.EntityProperty:Heal(_Amount)
    assert(self ~= QSB.EntityProperty, "Can not be used in static context!");
    local EntityID = GetID(self.m_EntityName);
    if EntityID == 0 or Logic.IsLeader(EntityID) == 1 then
        return;
    end
    self:Health(self:Health() + _Amount);
end

---
-- Verwundet ein Entity oder ein Battallion um die angegebene
-- Menge an Schaden. Bei einem Battalion wird der Schaden solange
-- auf Soldaten aufgeteilt, bis er komplett verrechnet wurde.
--
-- @param[type=number] _Damage   Schaden
-- @within QSB.EntityProperty
--
function QSB.EntityProperty:Hurt(_Damage)
    assert(self ~= QSB.EntityProperty, "Can not be used in static context!");

    local EntityID = GetID(self.m_EntityName);
    if EntityID == 0 then
        return;
    end
    if self:InGategory(EntityCategories.Soldier) then
        local Leader = GiveEntityName(self:GetLeader());
        QSB.EntityProperty:GetInstance(Leader):Hurt(_Damage);
        return;
    end

    local EntityToHurt = EntityID;
    local IsLeader = self:InGategory(EntityCategories.Leader);
    if IsLeader then
        EntityToHurt = self:GetSoldiers()[1];
    end

    local EntityKilled = false;
    local Health = Logic.GetEntityHealth(EntityToHurt);
    if EntityToHurt then
        if Health &#x3C;= _Damage then
            _Damage = _Damage - Health;
            EntityKilled = true;
            Logic.HurtEntity(EntityToHurt, Health);
            if IsLeader and _Damage &#x3E; 0 then
                self:Hurt(_Damage);
            end
        else
            Logic.HurtEntity(EntityToHurt, _Damage);
        end
    end
end

---
-- Gibt zurück, ob das Gebäude brennt. Optional kann die Stärke
-- des Feuers verändert werden.
--
-- @param[type=number]  _FireSize (Optional) Neue aktuelle Gesundheit
-- @return[type=boolean] Gebäude steht in Flammen
-- @within QSB.EntityProperty
--
function QSB.EntityProperty:Burning(_FireSize)
    assert(self ~= QSB.EntityProperty, "Can not be used in static context!");

    local EntityID = GetID(self.m_EntityName);
    if EntityID == 0 or Logic.IsBuilding(EntityID) == 0 then
        return false;
    end
    -- TODO: Gebäude per Skript löschen!
    if _FireSize and _FireSize &#x3E; 0 then
        Logic.DEBUG_SetBuildingOnFire(EntityID, _FireSize);
    end
    return Logic.IsBurning(EntityID);
end

---
-- Gibt zurück, ob das Entity sichtbar ist. Optional
-- kann die Sichtbarkeit neu gesetzt werden.
--
-- @param[type=boolean] _Visible (Optional) Sichtbarkeit ändern
-- @return[type=boolean] Ist sichtbar
-- @within QSB.EntityProperty
--
function QSB.EntityProperty:Visible(_Visble)
    assert(self ~= QSB.EntityProperty, "Can not be used in static context!");

    local EntityID = GetID(self.m_EntityName);
    if EntityID == 0 then
        return false;
    end
    if _Visble ~= nil then
        Logic.SetVisible(EntityID, _Visble);
    end
    local SV = (QSB.HistoryEdition and -47) or -50;
    return self:GetValueAsInteger(SV) == 801280;
end

---
-- Prüft, ob das Entity krank ist. Optional kann das Entity vorher
-- krank gemacht werden.
--
-- @param[type=boolean] _SetIll (Optional) Entity krank machen
-- @return[type=boolean] Entity ist krank
-- @within QSB.EntityProperty
--
function QSB.EntityProperty:Ill(_SetIll)
    assert(self ~= QSB.EntityProperty, "Can not be used in static context!");

    local EntityID = GetID(self.m_EntityName);
    local FarmAnimal = false;
    if self:InGategory(EntityCategories.CattlePasture) or self:InGategory(EntityCategories.SheepPasture) then
        FarmAnimal = true;
    end
    if EntityID == 0 or (Logic.IsSettler(EntityID) == 0 and FarmAnimal == false) then
        return false;
    end
    if FarmAnimal then
        if _SetIll == true then
            Logic.MakeFarmAnimalIll(EntityID);
        end
        return Logic.IsFarmAnimalIll(EntityID);
    else
        if _SetIll == true then
            Logic.MakeSettlerIll(EntityID);
        end
        return Logic.IsIll(EntityID);
    end
end

---
-- Gibt zurück, ob eine NPC-Interaktion mit dem Siedler möglich ist.
--
-- @return[type=boolean] Ist NPC
-- @within QSB.EntityProperty
--
function QSB.EntityProperty:OnScreenInfo()
    assert(self ~= QSB.EntityProperty, "Can not be used in static context!");

    local EntityID = GetID(self.m_EntityName);
    if EntityID == 0 or Logic.IsSettler(EntityID) == 0 then
        return false;
    end
    return self:GetValueAsInteger(6) &#x3E; 0;
end

---
-- Gibt das Bewegungsziel des Entity zurück.
--
-- @return[type=table] Positionstabelle
-- @within QSB.EntityProperty
--
function QSB.EntityProperty:GetDestination()
    assert(self ~= QSB.EntityProperty, "Can not be used in static context!");

    local EntityID = GetID(self.m_EntityName);
    if EntityID &#x3E; 0 then
        local SVX = (QSB.HistoryEdition and 17) or 19;
        local SVY = (QSB.HistoryEdition and 18) or 20;
        return {X= self:GetValueAsFloat(SVX), Y= self:GetValueAsFloat(SVY)};
    end
    return {X= 0, Y= 0};
end

---
-- Gibt die Mänge an Soldaten zurück, die dem Entity unterstehen
--
-- @return[type=number] Menge an Soldaten
-- @within QSB.EntityProperty
--
function QSB.EntityProperty:CountSoldiers()
    assert(self ~= QSB.EntityProperty, "Can not be used in static context!");

    local EntityID = GetID(self.m_EntityName);
    if EntityID &#x3E; 0 and Logic.IsLeader(EntityID) == 1 then
        local SoldierTable = {Logic.GetSoldiersAttachedToLeader(EntityID)};
        return #SoldierTable;
    end
    return 0;
end

---
-- Gibt die IDs aller Soldaten zurück, die zum Battalion gehören.
--
-- @return[type=table] Liste aller Soldaten
-- @within QSB.EntityProperty
--
function QSB.EntityProperty:GetSoldiers()
    assert(self ~= QSB.EntityProperty, "Can not be used in static context!");

    local EntityID = GetID(self.m_EntityName);
    if EntityID &#x3E; 0 and Logic.IsLeader(EntityID) == 1 then
        local SoldierTable = {Logic.GetSoldiersAttachedToLeader(EntityID)};
        table.remove(SoldierTable, 1);
        return SoldierTable;
    end
    return {};
end

---
-- Gibt den Leader des Soldaten zurück.
--
-- @return[type=number] Menge an Soldaten
-- @within QSB.EntityProperty
--
function QSB.EntityProperty:GetLeader()
    assert(self ~= QSB.EntityProperty, "Can not be used in static context!");

    local EntityID = GetID(self.m_EntityName);
    if EntityID &#x3E; 0 and Logic.IsEntityInCategory(EntityID, EntityCategories.Soldier) == 1 then
        return Logic.SoldierGetLeaderEntityID(EntityID);
    end
    return 0;
end

---
-- Gibt den Typen des Entity zurück. Optinal kann das Entity
-- mit einem neuen Entity anderen Typs ersetzt werden.
--
-- @param[type=number] _NewType (optional) Typ neues Entity
-- @return[type=number] Typ des Entity
-- @within QSB.EntityProperty
--
function QSB.EntityProperty:Type(_NewType)
    assert(self ~= QSB.EntityProperty, "Can not be used in static context!");

    local EntityID = GetID(self.m_EntityName);
    if EntityID == 0 then
        return 0;
    end
    if _NewType then
        EntityID = ReplaceEntity(EntityID, _NewType);
    end
    return Logic.GetEntityType(EntityID);
end

---
-- Gibt den Typnamen des Entity zurück.
--
-- @return[type=string] Typname des Entity
-- @within QSB.EntityProperty
--
function QSB.EntityProperty:GetTypeName()
    assert(self ~= QSB.EntityProperty, "Can not be used in static context!");

    local EntityID = GetID(self.m_EntityName);
    if EntityID == 0 then
        return;
    end
    return Logic.GetEntityTypeName(self:Type());
end

---
-- Gibt alle Kategorien zurück, zu denen das Entity gehört.
--
-- @return[type=table] Kategorien des Entity
-- @within QSB.EntityProperty
--
function QSB.EntityProperty:GetGategories()
    assert(self ~= QSB.EntityProperty, "Can not be used in static context!");

    local EntityID = GetID(self.m_EntityName);
    if EntityID == 0 then
        return {};
    end
    local Categories = {};
    for k, v in pairs(EntityCategories) do
        if Logic.IsEntityInCategory(EntityID, v) == 1 then 
            Categories[#Categories+1] = v;
        end
    end
    return Categories;
end

---
-- Prüft, ob das Entity zur angegebenen Kategorie gehört.
--
-- @param[type=number] _Category Kategorie
-- @return[type=boolean] Entity hat Kategorie
-- @within QSB.EntityProperty
--
function QSB.EntityProperty:InGategory(_Category)
    assert(self ~= QSB.EntityProperty, "Can not be used in static context!");
    return Inside(_Category, self:GetGategories());
end

---
-- Gibt die Scripting Value des Entity als Ganzzahl zurück.
--
-- @param[type=number] _index  Index im RAM
-- @return[type=number] Ganzzahl
-- @within QSB.EntityProperty
--
function QSB.EntityProperty:GetValueAsInteger(_index)
    assert(self ~= QSB.EntityProperty, "Can not be used in static context!");

    local EntityID = GetID(self.m_EntityName);
    if EntityID == 0 then
        return 0;
    end
    return math.floor(Logic.GetEntityScriptingValue(EntityID, _index) + 0.5);
end

---
-- Gibt die Scripting Value des Entity als Dezimalzahl zurück.
--
-- @param[type=number] _index  Index im RAM
-- @return[type=number] Dezimalzahl
-- @within QSB.EntityProperty
--
function QSB.EntityProperty:GetValueAsFloat(_index)
    assert(self ~= QSB.EntityProperty, "Can not be used in static context!");

    local EntityID = GetID(self.m_EntityName);
    if EntityID == 0 then
        return 0.0;
    end
    return self:Int2Float(Logic.GetEntityScriptingValue(EntityID,_index));
end

-- -------------------------------------------------------------------------- --

---
-- Bestimmt das Modul b der Zahl a.
--
-- @param[type=number] a Zahl
-- @param[type=number] b Modul
-- @return[type=number] qmod der Zahl
-- @within QSB.EntityProperty
-- @local
--
function QSB.EntityProperty:qmod(a, b)
    return a - math.floor(a/b)*b
end

---
-- Konvertiert eine Ganzzahl in eine Dezimalzahl.
--
-- @param[type=number] num Integer
-- @return[type=number] Integer als Float
-- @within QSB.EntityProperty
-- @local
--
function QSB.EntityProperty:Int2Float(num)
    if(num == 0) then return 0 end
    local sign = 1
    if(num &#x3C; 0) then num = 2147483648 + num; sign = -1 end
    local frac = self:qmod(num, 8388608)
    local headPart = (num-frac)/8388608
    local expNoSign = self:qmod(headPart, 256)
    local exp = expNoSign-127
    local fraction = 1
    local fp = 0.5
    local check = 4194304
    for i = 23, 0, -1 do
        if(frac - check) &#x3E; 0 then fraction = fraction + fp; frac = frac - check end
        check = check / 2; fp = fp / 2
    end
    return fraction * math.pow(2, exp) * sign
end

---
-- Gibt den Integer als Bits zurück.
--
-- @param[type=number] num Bits
-- @return[type=table] Table mit Bits
-- @within QSB.EntityProperty
-- @local
--
function QSB.EntityProperty:bitsInt(num)
    local t={}
    while num&#x3E;0 do
        rest=self:qmod(num, 2) table.insert(t,1,rest) num=(num-rest)/2
    end
    table.remove(t, 1)
    return t
end

---
-- Stellt eine Zahl als eine Folge von Bits in einer Table dar.
--
-- @param[type=number] num Integer
-- @param[type=table]  t   Table
-- @return[type=table] Table mit Bits
-- @within QSB.EntityProperty
-- @local
--
function QSB.EntityProperty:bitsFrac(num, t)
    for i = 1, 48 do
        num = num * 2
        if(num &#x3E;= 1) then table.insert(t, 1); num = num - 1 else table.insert(t, 0) end
        if(num == 0) then return t end
    end
    return t
end

---
-- Konvertiert eine Dezimalzahl in eine Ganzzahl.
--
-- @param[type=number] fval Float
-- @return[type=number] Float als Integer
-- @within QSB.EntityProperty
-- @local
--
function QSB.EntityProperty:Float2Int(fval)
    if(fval == 0) then return 0 end
    local signed = false
    if(fval &#x3C; 0) then signed = true; fval = fval * -1 end
    local outval = 0;
    local bits
    local exp = 0
    if fval &#x3E;= 1 then
        local intPart = math.floor(fval); local fracPart = fval - intPart;
        bits = self:bitsInt(intPart); exp = table.getn(bits); self:bitsFrac(fracPart, bits)
    else
        bits = {}; self:bitsFrac(fval, bits)
        while(bits[1] == 0) do exp = exp - 1; table.remove(bits, 1) end
        exp = exp - 1
        table.remove(bits, 1)
    end
    local bitVal = 4194304; local start = 1
    for bpos = start, 23 do
        local bit = bits[bpos]
        if(not bit) then break; end
        if(bit == 1) then outval = outval + bitVal end
        bitVal = bitVal / 2
    end
    outval = outval + (exp+127)*8388608
    if(signed) then outval = outval - 2147483648 end
    return outval;
end

-- -------------------------------------------------------------------------- --

Core:RegisterBundle("BundleEntityProperties");

</code></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundleentityselection.lua.html">
            <div class='doclink'>
                <div>BundleEntitySelection</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><code>-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundleEntitySelection                                        # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Mit diesem Bundle kann die Selektion von Entities gesteuert werden.
--
-- &#x3C;p&#x3E;Das wichtigste auf einen Blick:&#x3C;/p&#x3E;
-- &#x3C;ul&#x3E;
-- &#x3C;li&#x3E;&#x3C;a href="#API.DisableReleaseSoldiers"&#x3E;Einheiten entlassen&#x3C;/a&#x3E;&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;&#x3C;a href="#API.GetSelectedEntities"&#x3E;Selektierte Entities ermitteln&#x3C;/a&#x3E;&#x3C;/li&#x3E;
-- &#x3C;/ul&#x3E;
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundleEntitySelection = {};

API = API or {};
QSB = QSB or {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Deaktiviert oder aktiviert das Nachfüllen von Trebuchets.
-- @param[type=boolean] _Flag Deaktiviert (false) / Aktiviert (true)
-- @within Anwenderfunktionen
--
-- @usage
-- API.DisableRefillTrebuchet(true);
--
function API.DisableRefillTrebuchet(_Flag)
    if not GUI then
        API.Bridge("API.DisableRefillTrebuchet(" ..tostring(_Flag).. ")");
        return;
    end
    API.Bridge("BundleEntitySelection.Local.Data.RefillTrebuchet = " ..tostring(not _Flag));
    BundleEntitySelection.Local.Data.RefillTrebuchet = not _Flag;
end

---
-- Deaktiviert oder aktiviert das Entlassen von Dieben.
-- @param[type=boolean] _Flag Deaktiviert (false) / Aktiviert (true)
-- @within Anwenderfunktionen
--
-- @usage
-- API.DisableReleaseThieves(false);
--
function API.DisableReleaseThieves(_Flag)
    if not GUI then
        API.Bridge("API.DisableReleaseThieves(" ..tostring(_Flag).. ")");
        return;
    end
    BundleEntitySelection.Local.Data.ThiefRelease = not _Flag;
end

---
-- Deaktiviert oder aktiviert das Entlassen von Kriegsmaschinen.
-- @param[type=boolean] _Flag Deaktiviert (false) / Aktiviert (true)
-- @within Anwenderfunktionen
--
-- @usage
-- API.DisableReleaseSiegeEngines(true);
--
function API.DisableReleaseSiegeEngines(_Flag)
    if not GUI then
        API.Bridge("API.DisableReleaseSiegeEngines(" ..tostring(_Flag).. ")");
        return;
    end
    BundleEntitySelection.Local.Data.SiegeEngineRelease = not _Flag;
end

---
-- Deaktiviert oder aktiviert das Entlassen von Soldaten.
-- @param[type=boolean] _Flag Deaktiviert (false) / Aktiviert (true)
-- @within Anwenderfunktionen
--
-- @usage
-- API.DisableReleaseSoldiers(false);
--
function API.DisableReleaseSoldiers(_Flag)
    if not GUI then
        API.Bridge("API.DisableReleaseSoldiers(" ..tostring(_Flag).. ")");
        return;
    end
    BundleEntitySelection.Local.Data.MilitaryRelease = not _Flag;
end

---
-- Prüpft ob das Entity selektiert ist.
--
-- @param _Entity Entity das selektiert sein soll (Skriptname oder ID)
-- @return[type=boolean] Entity ist selektiert
-- @within Anwenderfunktionen
--
-- @usage
-- if API.IsEntityInSelection("hakim") then
--     -- Do something
-- end
--
function API.IsEntityInSelection(_Entity)
    if IsExisting(_Entity) then
        local EntityID = GetID(_Entity);
        local SelectedEntities = BundleEntitySelection.Global.Data.SelectedEntities;
        if GUI then
            SelectedEntities = {GUI.GetSelectedEntities()};
        end
        for i= 1, #SelectedEntities, 1 do
            if SelectedEntities[i] == EntityID then
                return true;
            end
        end
    end
    return false;
end
IsEntitySelected = API.IsEntityInSelection;

---
-- Gibt die ID des selektierten Entity zurück.
--
-- Wenn mehr als ein Entity selektiert sind, wird das erste Entity
-- zurückgegeben. Sind keine Entities selektiert, wird 0 zurückgegeben.
--
-- @return[type=number] ID des selektierten Entities
-- @within Anwenderfunktionen
--
-- @usage
-- local SelectedEntity = API.GetSelectedEntity();
--
function API.GetSelectedEntity()
    local SelectedEntity = BundleEntitySelection.Global.Data.SelectedEntities[1];
    if GUI then
        SelectedEntity = GUI.GetSelectedEntity();
    end
    return SelectedEntity or 0;
end
GetSelectedEntity = API.GetSelectedEntity;

---
-- Gibt alle selektierten Entities zurück.
--
-- @return[type=table] ID des selektierten Entities
-- @within Anwenderfunktionen
--
-- @usage
-- local Selection = API.GetSelectedEntities();
--
function API.GetSelectedEntities()
    local SelectedEntities = BundleEntitySelection.Global.Data.SelectedEntities;
    if GUI then
        SelectedEntities = {GUI.GetSelectedEntities()};
    end
    return SelectedEntities;
end
GetSelectedEntities = API.GetSelectedEntities;

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

BundleEntitySelection = {
    Global = {
        Data = {
            RefillTrebuchet = true,
            AmmunitionUnderway = {},
            TrebuchetIDToCart = {},
            SelectedEntities = {};
        },
    },
    Local = {
        Data = {
            RefillTrebuchet = true,
            ThiefRelease = false,
            SiegeEngineRelease = true,
            MilitaryRelease = true,

            Tooltips = {
                KnightButton = {
                    Title = {
                        de = "Ritter selektieren",
                        en = "Select Knight",
                    },
                    Text = {
                        de = "- Klick selektiert den Ritter {cr}- Doppelklick springt zum Ritter{cr}- STRG halten selektiert alle Ritter",
                        en = "- Click selects the knight {cr}- Double click jumps to knight{cr}- Press CTRL to select all knights",
                    },
                },

                BattalionButton = {
                    Title = {
                        de = "Militär selektieren",
                        en = "Select Units",
                    },
                    Text = {
                        de = "- Selektiert alle Militäreinheiten {cr}- SHIFT halten um auch Munitionswagen und Trebuchets auszuwählen",
                        en = "- Selects all military units {cr}- Press SHIFT to additionally select ammunition carts and trebuchets",
                    },
                },

                ReleaseSoldiers = {
                    Title = {
                        de = "Militär entlassen",
                        en = "Release military unit",
                    },
                    Text = {
                        de = "- Eine Militäreinheit entlassen {cr}- Soldaten werden nacheinander entlassen",
                        en = "- Dismiss a military unit {cr}- Soldiers will be dismissed each after another",
                    },
                    Disabled = {
                        de = "Kann nicht entlassen werden!",
                        en = "Releasing is impossible!",
                    },
                },

                TrebuchetCart = {
                    Title = {
                        de = "Trebuchetwagen",
                        en = "Trebuchet cart",
                    },
                    Text = {
                        de = "- Kann einmalig zum Trebuchet ausgebaut werden",
                        en = "- Can uniquely be transmuted into a trebuchet",
                    },
                },

                Trebuchet = {
                    Title = {
                        de = "Trebuchet",
                        en = "Trebuchet",
                    },
                    Text = {
                        de = "- Kann über weite Strecken Gebäude angreifen {cr}- Kann Gebäude in Brand stecken {cr}- Kann nur durch Munitionsanforderung befüllt werden {cr}- Trebuchet kann manuell zurückgeschickt werden",
                        en = "- Can perform long range attacks on buildings {cr}- Can set buildings on fire {cr}- Can only be filled by ammunition request {cr}- The trebuchet can be manually send back to the city",
                    },
                },

                TrebuchetRefiller = {
                    Title = {
                        de = "Aufladen",
                        en = "Refill",
                    },
                    Text = {
                        de = "- Läd das Trebuchet mit Karren aus dem Lagerhaus nach {cr}- Benötigt die Differenz an Steinen {cr}- Kann jeweils nur einen Wagen zu selben Zeit senden",
                        en = "- Refill the Trebuchet with a cart from the storehouse {cr}- Stones for missing ammunition required {cr}- Only one cart at the time allowed",
                    },
                },
            },
        },
    },

};

-- Global Script ---------------------------------------------------------------

---
-- Initialisiert das Bundle im globalen Skript.
-- @within Internal
-- @local
--
function BundleEntitySelection.Global:Install()
end

---
-- Deaktiviert oder aktiviert das Nachfüllen von Trebuchets.
-- @param[type=boolean] _Boolean Nachfüllen deaktiviert
-- @within Internal
-- @local
--
function BundleEntitySelection.Global:DeactivateRefillTrebuchet(_Boolean)
    self.Data.RefillTrebuchet = not _Boolean;
    Logic.ExecuteInLuaLocalState([[
        BundleEntitySelection.Local:DeactivateRefillTrebuchet(]]..tostring(_Boolean)..[[)
    ]]);
end

---
-- Baut ein Trebuchet zu einem Trebuchet-Wagen ab.
-- @param[type=number] _EntityID EntityID of Trebuchet
-- @within Internal
-- @local
--
function BundleEntitySelection.Global:MilitaryDisambleTrebuchet(_EntityID)
    local x,y,z = Logic.EntityGetPos(_EntityID);
    local PlayerID = Logic.EntityGetPlayer(_EntityID);

    -- Externes Callback für das Kartenskript
    -- Bricht die Ausführung dieser Funktion ab!
    if GameCallback_QSB_OnDisambleTrebuchet then
        GameCallback_QSB_OnDisambleTrebuchet(_EntityID, PlayerID, x, y, z);
        return;
    end

    if self.Data.AmmunitionUnderway[_EntityID] then
        API.Message {
            de = "Eine Munitionslieferung ist auf dem Weg!",
            en = "A ammunition card is on the way!",
        };
        return;
    end

    Logic.CreateEffect(EGL_Effects.E_Shockwave01, x, y, 0);
    Logic.SetEntityInvulnerabilityFlag(_EntityID, 1);
    Logic.SetEntitySelectableFlag(_EntityID, 0);
    Logic.SetVisible(_EntityID, false);

    local TrebuchetCart = self.Data.TrebuchetIDToCart[_EntityID];
    if TrebuchetCart ~= nil then
        Logic.SetEntityInvulnerabilityFlag(TrebuchetCart, 0);
        Logic.SetEntitySelectableFlag(TrebuchetCart, 1);
        Logic.SetVisible(TrebuchetCart, true);
    else
        TrebuchetCart = Logic.CreateEntity(Entities.U_SiegeEngineCart, x, y, 0, PlayerID);
        self.Data.TrebuchetIDToCart[_EntityID] = TrebuchetCart;
    end

    Logic.DEBUG_SetSettlerPosition(TrebuchetCart, x, y);
    Logic.SetTaskList(TrebuchetCart, TaskLists.TL_NPC_IDLE);
    Logic.ExecuteInLuaLocalState([[
        GUI.SelectEntity(]]..TrebuchetCart..[[)
    ]]);
end

---
-- Baut einen Trebuchet-Wagen zu einem Trebuchet aus.
-- @param[type=number] _EntityID EntityID of Trebuchet
-- @within Internal
-- @local
--
function BundleEntitySelection.Global:MilitaryErectTrebuchet(_EntityID)
    local x,y,z = Logic.EntityGetPos(_EntityID);
    local PlayerID = Logic.EntityGetPlayer(_EntityID);

    -- Externes Callback für das Kartenskript
    -- Bricht die Ausführung dieser Funktion ab!
    if GameCallback_QSB_OnErectTrebuchet then
        GameCallback_QSB_OnErectTrebuchet(_EntityID, PlayerID, x, y, z);
        return;
    end

    Logic.CreateEffect(EGL_Effects.E_Shockwave01, x, y, 0);
    Logic.SetEntityInvulnerabilityFlag(_EntityID, 1);
    Logic.SetEntitySelectableFlag(_EntityID, 0);
    Logic.SetVisible(_EntityID, false);

    local Trebuchet;
    for k, v in pairs(self.Data.TrebuchetIDToCart) do
        if v == _EntityID then
            Trebuchet = tonumber(k);
        end
    end
    if Trebuchet == nil then
        Trebuchet = Logic.CreateEntity(Entities.U_Trebuchet, x, y, 0, PlayerID);
        self.Data.TrebuchetIDToCart[Trebuchet] = _EntityID;
    end

    Logic.SetEntityInvulnerabilityFlag(Trebuchet, 0);
    Logic.SetEntitySelectableFlag(Trebuchet, 1);
    Logic.SetVisible(Trebuchet, true);
    Logic.DEBUG_SetSettlerPosition(Trebuchet, x, y);
    Logic.ExecuteInLuaLocalState([[
        GUI.SelectEntity(]]..Trebuchet..[[)
    ]]);
end

---
-- Erzeugt einen Wagen, der zu dem Trebuchet fährt und es auffüll.
-- @param[type=number] _EntityID EntityID of Trebuchet
-- @within Internal
-- @local
--
function BundleEntitySelection.Global:MilitaryCallForRefiller(_EntityID)
    local PlayerID = Logic.EntityGetPlayer(_EntityID);
    local StoreID = Logic.GetStoreHouse(PlayerID);
    local HaveAmount = Logic.GetAmmunitionAmount(_EntityID);
    local Stones = GetPlayerResources(Goods.G_Stone, PlayerID)

    -- Externes Callback für das Kartenskript
    -- Bricht die Ausführung dieser Funktion ab!
    if GameCallback_tHEA_OnRefillerCartCalled then
        GameCallback_tHEA_OnRefillerCartCalled(_EntityID, PlayerID, StoreID, HaveAmount, Stones);
        return;
    end

    if self.Data.AmmunitionUnderway[_EntityID] or StoreID == 0 then
        API.Message {
            de = "Eine Munitionslieferung ist auf dem Weg!",
            en = "A ammunition card is on the way!",
        };
        return;
    end

    if HaveAmount == 10 or Stones &#x3C; 10-HaveAmount then
        API.Message {
            de = "Nicht genug Steine oder das Trebuchet ist voll!",
            en = "Not enough stones or the trebuchet is full!",
        };
        return;
    end

    local x,y = Logic.GetBuildingApproachPosition(StoreID);
    local CartID = Logic.CreateEntity(Entities.U_AmmunitionCart, x, y, 0, PlayerID);
    self.Data.AmmunitionUnderway[_EntityID] = {CartID, 10-HaveAmount};
    Logic.SetEntityInvulnerabilityFlag(CartID, 1);
    Logic.SetEntitySelectableFlag(CartID, 0);
    AddGood(Goods.G_Stone, (10-HaveAmount)*(-1), PlayerID);

    StartSimpleJobEx( function(_Trebuchet)
        local CartID = self.Data.AmmunitionUnderway[_EntityID][1];
        local Amount = self.Data.AmmunitionUnderway[_EntityID][2];

        if not IsExisting(CartID) or not IsExisting(_Trebuchet) then
            self.Data.AmmunitionUnderway[_EntityID] = nil;
            return true;
        end

        if not Logic.IsEntityMoving(CartID) then
            local x,y,z = Logic.EntityGetPos(_Trebuchet);
            Logic.MoveSettler(CartID, x, y);
        end

        if IsNear(CartID, _Trebuchet, 500) then
            for i=1, Amount, 1 do
                Logic.RefillAmmunitions(_Trebuchet);
            end
            DestroyEntity(CartID);
        end
    end, _EntityID);
end

-- Local Script ----------------------------------------------------------------

---
-- Initialisiert das Bundle im lokalen Skript.
-- @within Internal
-- @local
--
function BundleEntitySelection.Local:Install()
    self:OverwriteSelectAllUnits();
    self:OverwriteSelectKnight();
    self:OverwriteNamesAndDescription();
    self:OverwriteThiefDeliver();
    self:OverwriteMilitaryDismount();
    self:OverwriteMultiselectIcon();
    self:OverwriteMilitaryDisamble();
    self:OverwriteMilitaryErect();
    self:OverwriteMilitaryCommands();
    self:OverwriteGetStringTableText();

    Core:AppendFunction(
        "GameCallback_GUI_SelectionChanged",
        self.OnSelectionCanged
    );
end

---
-- Deaktiviert oder aktiviert das Nachfüllen von Trebuchets.
-- @param[type=boolean] _Boolean Nachfüllen deaktiviert
-- @within Internal
-- @local
--
function BundleEntitySelection.Local:DeactivateRefillTrebuchet(_Boolean)
    self.Data.RefillTrebuchet = not _Boolean;
end

---
-- Callback-Funktion, die aufgerufen wird, wenn sich die Selektion ändert.
--
-- @param[type=number] _Source Selection Source
-- @within Internal
-- @local
--
function BundleEntitySelection.Local.OnSelectionCanged(_Source)
    local SelectedEntities = {GUI.GetSelectedEntities()}
    local PlayerID = GUI.GetPlayerID();
    local EntityID = GUI.GetSelectedEntity();
    local EntityType = Logic.GetEntityType(EntityID);

    -- Schreibe die selektierten Entities ins globale Skript
    local SelectedEntitiesString = API.ConvertTableToString(SelectedEntities);
    API.Bridge("BundleEntitySelection.Global.Data.SelectedEntities = " ..SelectedEntitiesString);

    if EntityID ~= nil then
        if EntityType == Entities.U_SiegeEngineCart then
            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection", 1);
            XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomRight/Selection", 0);
            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/BGMilitary", 1);
            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/DialogButtons", 1);
            XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomRight/DialogButtons", 0);
            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/DialogButtons/SiegeEngineCart", 1);
        elseif EntityType == Entities.U_Trebuchet then
            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection", 1);
            XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomRight/Selection", 0);
            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/BGMilitary", 1);
            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/DialogButtons", 1);
            XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomRight/DialogButtons", 0);
            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/DialogButtons/Military", 1);
            XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomRight/DialogButtons/Military", 1);
            if BundleEntitySelection.Local.Data.RefillTrebuchet then
                XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/DialogButtons/Military/Attack", 1);
            else
                XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/DialogButtons/Military/Attack", 0);
            end
            GUI_Military.StrengthUpdate();
            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/DialogButtons/SiegeEngine", 1);
        end
    end
end

---
-- Überscheibt die Funktion, die die Ingame-Texte aus den Quellen ausließt,
-- sodass eigene Texte für Keys angezeigt werden.
--
-- @within Internal
-- @local
--
function BundleEntitySelection.Local:OverwriteGetStringTableText()
    GetStringTableText_Orig_BundleEntitySelection = XGUIEng.GetStringTableText;
    XGUIEng.GetStringTableText = function(_key)
        local Language = (Network.GetDesiredLanguage() == "de" and "de") or "en";
        if _key == "UI_ObjectDescription/Attack" then
            local EntityID = GUI.GetSelectedEntity();
            if Logic.GetEntityType(EntityID) == Entities.U_Trebuchet then
                return BundleEntitySelection.Local.Data.Tooltips.TrebuchetRefiller.Text[Language];
            end
        end
        if _key == "UI_ObjectNames/Attack" then
            local EntityID = GUI.GetSelectedEntity();
            if Logic.GetEntityType(EntityID) == Entities.U_Trebuchet then
                return BundleEntitySelection.Local.Data.Tooltips.TrebuchetRefiller.Title[Language];
            end
        end

        return GetStringTableText_Orig_BundleEntitySelection(_key);
    end
end

---
-- Überschreibt die Millitärkommandos "Stop" und "Angreifen".
--
-- @within Internal
-- @local
--
function BundleEntitySelection.Local:OverwriteMilitaryCommands()
    GUI_Military.AttackClicked = function()
        Sound.FXPlay2DSound( "ui\\menu_click");
        local SelectedEntities = {GUI.GetSelectedEntities()};
        local EntityType = Logic.GetEntityType(SelectedEntities[1]);

        if EntityType == Entities.U_Trebuchet then
            for i=1, #SelectedEntities, 1 do
                EntityType = Logic.GetEntityType(SelectedEntities[i]);
                if EntityType == Entities.U_Trebuchet then
                    GUI.SendScriptCommand([[
                        BundleEntitySelection.Global:MilitaryCallForRefiller(]]..SelectedEntities[i]..[[)
                    ]]);
                end
            end
        else
            GUI.ActivateExplicitAttackCommandState();
        end
    end

    GUI_Military.StandGroundClicked = function()
        Sound.FXPlay2DSound( "ui\\menu_click");
        local SelectedEntities = {GUI.GetSelectedEntities()};

        for i=1,#SelectedEntities do
            local LeaderID = SelectedEntities[i];
            local eType = Logic.GetEntityType(LeaderID);
            GUI.SendCommandStationaryDefend(LeaderID);
            if eType == Entities.U_Trebuchet then
                GUI.SendScriptCommand([[
                    Logic.SetTaskList(]]..LeaderID..[[, TaskLists.TL_NPC_IDLE)
                ]]);
            end
        end

    end

    GUI_Military.StandGroundUpdate = function()
        local WidgetAttack = "/InGame/Root/Normal/AlignBottomRight/DialogButtons/Military/Attack";
        local SelectedEntities = {GUI.GetSelectedEntities()};

        SetIcon(WidgetAttack, {12, 4});

        if #SelectedEntities == 1 then
            local eID = SelectedEntities[1];
            local eType = Logic.GetEntityType(eID);
            if eType == Entities.U_Trebuchet then
                if Logic.GetAmmunitionAmount(eID) &#x3E; 0 then
                    XGUIEng.ShowWidget(WidgetAttack, 0);
                else
                    XGUIEng.ShowWidget(WidgetAttack, 1);
                end
                SetIcon(WidgetAttack, {1, 10});
            else
                XGUIEng.ShowWidget(WidgetAttack, 1);
            end
        end
    end
end

---
-- Überschreibt das Aufbauen von Kriegsmaschinen, sodass auch Trebuchets
-- auf- und abgebaut werden können.
--
-- @within Internal
-- @local
--
function BundleEntitySelection.Local:OverwriteMilitaryErect()
    GUI_Military.ErectClicked_Orig_BundleEntitySelection = GUI_Military.ErectClicked;
    GUI_Military.ErectClicked = function()
        GUI_Military.ErectClicked_Orig_BundleEntitySelection();

        local PlayerID = GUI.GetPlayerID();
        local SelectedEntities = {GUI.GetSelectedEntities()};
        for i=1, #SelectedEntities, 1 do
            local EntityType = Logic.GetEntityType(SelectedEntities[i]);
            if EntityType == Entities.U_SiegeEngineCart then
                GUI.SendScriptCommand([[
                    BundleEntitySelection.Global:MilitaryErectTrebuchet(]]..SelectedEntities[i]..[[)
                ]]);
            end
        end
    end

    GUI_Military.ErectUpdate_Orig_BundleEntitySelection = GUI_Military.ErectUpdate;
    GUI_Military.ErectUpdate = function()
        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();
        local SiegeCartID = GUI.GetSelectedEntity();
        local PlayerID = GUI.GetPlayerID();
        local EntityType = Logic.GetEntityType(SiegeCartID);

        if EntityType == Entities.U_SiegeEngineCart then
            XGUIEng.DisableButton(CurrentWidgetID, 0);
            SetIcon(CurrentWidgetID, {12, 6});
        else
            GUI_Military.ErectUpdate_Orig_BundleEntitySelection();
        end
    end

    GUI_Military.ErectMouseOver_Orig_BundleEntitySelection = GUI_Military.ErectMouseOver;
    GUI_Military.ErectMouseOver = function()
        local SiegeCartID = GUI.GetSelectedEntity();
        local TooltipTextKey;
        if Logic.GetEntityType(SiegeCartID) == Entities.U_SiegeEngineCart then
            TooltipTextKey = "ErectCatapult";
        else
            GUI_Military.ErectMouseOver_Orig_BundleEntitySelection();
            return;
        end
        GUI_Tooltip.TooltipNormal(TooltipTextKey, "Erect");
    end
end

---
-- Überschreibt das Abbauen von Kriegsmaschinen, sodass auch Trebuchets
-- abgebaut werden können.
--
-- @within Internal
-- @local
--
function BundleEntitySelection.Local:OverwriteMilitaryDisamble()
    GUI_Military.DisassembleClicked_Orig_BundleEntitySelection = GUI_Military.DisassembleClicked;
    GUI_Military.DisassembleClicked = function()
        GUI_Military.DisassembleClicked_Orig_BundleEntitySelection();

        local PlayerID = GUI.GetPlayerID();
        local SelectedEntities = {GUI.GetSelectedEntities()};
        for i=1, #SelectedEntities, 1 do
            local EntityType = Logic.GetEntityType(SelectedEntities[i]);
            if EntityType == Entities.U_Trebuchet then
                GUI.SendScriptCommand([[
                    BundleEntitySelection.Global:MilitaryDisambleTrebuchet(]]..SelectedEntities[i]..[[)
                ]]);
            end
        end
    end

    GUI_Military.DisassembleUpdate_Orig_BundleEntitySelection = GUI_Military.DisassembleUpdate;
    GUI_Military.DisassembleUpdate = function()
        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();
        local PlayerID = GUI.GetPlayerID();
        local SiegeEngineID = GUI.GetSelectedEntity();
        local EntityType = Logic.GetEntityType(SiegeEngineID);

        if EntityType == Entities.U_Trebuchet then
            XGUIEng.DisableButton(CurrentWidgetID, 0);
            SetIcon(CurrentWidgetID, {12, 9});
        else
            GUI_Military.DisassembleUpdate_Orig_BundleEntitySelection();
        end
    end
end

---
-- Überschreibt die Multiselektion, damit Trebuchets ein Icon bekommen.
--
-- @within Internal
-- @local
--
function BundleEntitySelection.Local:OverwriteMultiselectIcon()
    GUI_MultiSelection.IconUpdate_Orig_BundleEntitySelection = GUI_MultiSelection.IconUpdate;
    GUI_MultiSelection.IconUpdate = function()
        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();
        local CurrentMotherID = XGUIEng.GetWidgetsMotherID(CurrentWidgetID);
        local CurrentMotherName = XGUIEng.GetWidgetNameByID(CurrentMotherID);
        local Index = CurrentMotherName + 0;
        local CurrentMotherPath = XGUIEng.GetWidgetPathByID(CurrentMotherID);
        local HealthWidgetPath = CurrentMotherPath .. "/Health";
        local EntityID = g_MultiSelection.EntityList[Index];
        local EntityType = Logic.GetEntityType(EntityID);
        local HealthState = Logic.GetEntityHealth(EntityID);
        local EntityMaxHealth = Logic.GetEntityMaxHealth(EntityID);

        if EntityType ~= Entities.U_SiegeEngineCart and EntityType ~= Entities.U_Trebuchet then
            GUI_MultiSelection.IconUpdate_Orig_BundleEntitySelection();
            return;
        end
        if Logic.IsEntityAlive(EntityID) == false then
            XGUIEng.ShowWidget(CurrentMotherID, 0);
            GUI_MultiSelection.CreateEX();
            return;
        end

        SetIcon(CurrentWidgetID, g_TexturePositions.Entities[EntityType]);

        HealthState = math.floor(HealthState / EntityMaxHealth * 100);
        if HealthState &#x3C; 50 then
            local green = math.floor(2*255* (HealthState/100));
            XGUIEng.SetMaterialColor(HealthWidgetPath,0,255,green, 20,255);
        else
            local red = 2*255 - math.floor(2*255* (HealthState/100));
            XGUIEng.SetMaterialColor(HealthWidgetPath,0,red, 255, 20,255);
        end
        XGUIEng.SetProgressBarValues(HealthWidgetPath,HealthState, 100);
    end

    GUI_MultiSelection.IconMouseOver_Orig_BundleEntitySelection = GUI_MultiSelection.IconMouseOver;
    GUI_MultiSelection.IconMouseOver = function()
        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();
        local CurrentMotherID = XGUIEng.GetWidgetsMotherID(CurrentWidgetID);
        local CurrentMotherName = XGUIEng.GetWidgetNameByID(CurrentMotherID);
        local Index = tonumber(CurrentMotherName);
        local EntityID = g_MultiSelection.EntityList[Index];
        local EntityType = Logic.GetEntityType(EntityID);

        if EntityType ~= Entities.U_SiegeEngineCart and EntityType ~= Entities.U_Trebuchet then
            GUI_MultiSelection.IconMouseOver_Orig_BundleEntitySelection();
            return;
        end

        local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";
        if EntityType == Entities.U_SiegeEngineCart then
            local TooltipData = BundleEntitySelection.Local.Data.Tooltips.TrebuchetCart;
            BundleEntitySelection.Local:SetTooltip(TooltipData.Title[lang], TooltipData.Text[lang]);
        elseif EntityType == Entities.U_Trebuchet then
            local TooltipData = BundleEntitySelection.Local.Data.Tooltips.Trebuchet;
            BundleEntitySelection.Local:SetTooltip(TooltipData.Title[lang], TooltipData.Text[lang]);
        end
    end
end

---
-- Überschreibt die Funktion zur Beendigung der Eskorte, damit Einheiten auch
-- entlassen werden können.
--
-- @within Internal
-- @local
--
function BundleEntitySelection.Local:OverwriteMilitaryDismount()
    GUI_Military.DismountClicked_Orig_BundleEntitySelection = GUI_Military.DismountClicked;
    GUI_Military.DismountClicked = function()
        local Selected = GUI.GetSelectedEntity(Selected);
        local Type = Logic.GetEntityType(Selected);
        local PlayerID = GUI.GetPlayerID();
        if Logic.GetGuardianEntityID(Selected) == 0 and Logic.IsKnight(Selected) == false then
            if (Type == Entities.U_SiegeEngineCart or Type == Entities.U_MilitarySiegeTower or
                Type == Entities.U_MilitaryCatapult or Type == Entities.U_MilitaryBatteringRam or
                Type == Entities.U_SiegeTowerCart or Type == Entities.U_CatapultCart or
                Type == Entities.U_BatteringRamCart or Type == Entities.U_AmmunitionCart)
            and BundleEntitySelection.Local.Data.SiegeEngineRelease then
                Sound.FXPlay2DSound( "ui\\menu_click");
                GUI.SendScriptCommand([[DestroyEntity(]]..Selected..[[)]]);
                return;
            end
            if (Logic.IsLeader(Selected) == 1 and BundleEntitySelection.Local.Data.MilitaryRelease) then
                Sound.FXPlay2DSound( "ui\\menu_click");
                local Soldiers = {Logic.GetSoldiersAttachedToLeader(Selected)};
                GUI.SendScriptCommand([[DestroyEntity(]]..Soldiers[#Soldiers]..[[)]]);
                return;
            end
        else
            GUI_Military.DismountClicked_Orig_BundleEntitySelection();
        end
    end

    GUI_Military.DismountUpdate_Orig_BundleEntitySelection = GUI_Military.DismountUpdate;
    GUI_Military.DismountUpdate = function()
        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();
        local Selected = GUI.GetSelectedEntity();
        local Type = Logic.GetEntityType(Selected);
        if (Logic.GetGuardianEntityID(Selected) == 0 and Logic.IsKnight(Selected) == false and Logic.IsEntityInCategory(Selected, EntityCategories.AttackableMerchant) == 0) then
            if Logic.IsLeader(Selected) == 1 and not BundleEntitySelection.Local.Data.MilitaryRelease then
                XGUIEng.DisableButton(CurrentWidgetID, 1);
            elseif  Logic.IsLeader(Selected) == 0 then
                if not BundleEntitySelection.Local.Data.SiegeEngineRelease then
                    XGUIEng.DisableButton(CurrentWidgetID, 1);
                end
                if Type == Entities.U_Trebuchet then
                    XGUIEng.DisableButton(CurrentWidgetID, 1);
                end
            else
                SetIcon(CurrentWidgetID, {12, 1});
                XGUIEng.DisableButton(CurrentWidgetID, 0);
            end
            SetIcon(CurrentWidgetID, {14, 12});
        else
            SetIcon(CurrentWidgetID, {12, 1});
            GUI_Military.DismountUpdate_Orig_BundleEntitySelection();
        end
    end
end

---
-- Überschreibt "Beute abließern", sodass Diebe entlassen werden können.
--
-- @within Internal
-- @local
--
function BundleEntitySelection.Local:OverwriteThiefDeliver()
    GUI_Thief.ThiefDeliverClicked_Orig_BundleEntitySelection = GUI_Thief.ThiefDeliverClicked;
    GUI_Thief.ThiefDeliverClicked = function()
        if not BundleEntitySelection.Local.Data.ThiefRelease then
            GUI_Thief.ThiefDeliverClicked_Orig_BundleEntitySelection();
            return;
        end

        Sound.FXPlay2DSound( "ui\\menu_click");
        local PlayerID = GUI.GetPlayerID();
        local ThiefID = GUI.GetSelectedEntity()
        if ThiefID == nil or Logic.GetEntityType(ThiefID) ~= Entities.U_Thief then
            return;
        end
        GUI.SendScriptCommand([[DestroyEntity(]]..ThiefID..[[)]]);
    end

    GUI_Thief.ThiefDeliverMouseOver_Orig_BundleEntitySelection = GUI_Thief.ThiefDeliverMouseOver;
    GUI_Thief.ThiefDeliverMouseOver = function()
        if not BundleEntitySelection.Local.Data.ThiefRelease then
            GUI_Thief.ThiefDeliverMouseOver_Orig_BundleEntitySelection();
            return;
        end

        local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";
        BundleEntitySelection.Local:SetTooltip(
            BundleEntitySelection.Local.Data.Tooltips.ReleaseSoldiers.Title[lang],
            BundleEntitySelection.Local.Data.Tooltips.ReleaseSoldiers.Text[lang]
        );
    end

    GUI_Thief.ThiefDeliverUpdate_Orig_BundleEntitySelection = GUI_Thief.ThiefDeliverUpdate;
    GUI_Thief.ThiefDeliverUpdate = function()
        if not BundleEntitySelection.Local.Data.ThiefRelease then
            GUI_Thief.ThiefDeliverUpdate_Orig_BundleEntitySelection();
            return;
        end

        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();
        local ThiefID = GUI.GetSelectedEntity();
        if ThiefID == nil or Logic.GetEntityType(ThiefID) ~= Entities.U_Thief then
            XGUIEng.DisableButton(CurrentWidgetID, 1);
        else
            XGUIEng.DisableButton(CurrentWidgetID, 0);
        end
        SetIcon(CurrentWidgetID, {14, 12});
    end
end

---
-- Hängt eine Funktion an die GUI_Tooltip.SetNameAndDescription an, sodass
-- Tooltips überschrieben werden können.
--
-- @within Internal
-- @local
--
function BundleEntitySelection.Local:OverwriteNamesAndDescription()
    GUI_Tooltip.SetNameAndDescription_Orig_QSB_EntitySelection = GUI_Tooltip.SetNameAndDescription;
    GUI_Tooltip.SetNameAndDescription = function(_TooltipNameWidget, _TooltipDescriptionWidget, _OptionalTextKeyName, _OptionalDisabledTextKeyName, _OptionalMissionTextFileBoolean)
        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();
        local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";

        if XGUIEng.GetWidgetID("/InGame/Root/Normal/AlignBottomRight/MapFrame/KnightButton") == CurrentWidgetID then
            BundleEntitySelection.Local:SetTooltip(
                BundleEntitySelection.Local.Data.Tooltips.KnightButton.Title[lang],
                BundleEntitySelection.Local.Data.Tooltips.KnightButton.Text[lang]
            );
            return;
        end

        if XGUIEng.GetWidgetID("/InGame/Root/Normal/AlignBottomRight/MapFrame/BattalionButton") == CurrentWidgetID then
            BundleEntitySelection.Local:SetTooltip(
                BundleEntitySelection.Local.Data.Tooltips.BattalionButton.Title[lang],
                BundleEntitySelection.Local.Data.Tooltips.BattalionButton.Text[lang]
            );
            return;
        end

        if XGUIEng.GetWidgetID("/InGame/Root/Normal/AlignBottomRight/DialogButtons/SiegeEngineCart/Dismount") == CurrentWidgetID 
        or XGUIEng.GetWidgetID("/InGame/Root/Normal/AlignBottomRight/DialogButtons/AmmunitionCart/Dismount") == CurrentWidgetID 
        or XGUIEng.GetWidgetID("/InGame/Root/Normal/AlignBottomRight/DialogButtons/Military/Dismount") == CurrentWidgetID 
        then
            local SelectedEntity = GUI.GetSelectedEntity();
            if SelectedEntity ~= 0 then
                if Logic.IsEntityInCategory(SelectedEntity, EntityCategories.Military) == 1
                and Logic.IsEntityInCategory(SelectedEntity, EntityCategories.Hero) == 0
                then
                    local GuardianEntity = Logic.GetGuardianEntityID(SelectedEntity)
                    if GuardianEntity == nil or GuardianEntity == 0 then
                        BundleEntitySelection.Local:SetTooltip(
                            BundleEntitySelection.Local.Data.Tooltips.ReleaseSoldiers.Title[lang],
                            BundleEntitySelection.Local.Data.Tooltips.ReleaseSoldiers.Text[lang],
                            BundleEntitySelection.Local.Data.Tooltips.ReleaseSoldiers.Disabled[lang]
                        );
                        return;
                    end
                end
            end
        end

        GUI_Tooltip.SetNameAndDescription_Orig_QSB_EntitySelection(_TooltipNameWidget, _TooltipDescriptionWidget, _OptionalTextKeyName, _OptionalDisabledTextKeyName, _OptionalMissionTextFileBoolean);
    end
end

---
-- Schreibt einen anderen Text in einen normalen Tooltip.
--
-- @param[type=string] _TitleText    Titel des Tooltip
-- @param[type=string] _DescText     Text des Tooltip
-- @param[type=string] _DisabledText Disabled Text des Tooltip
-- @within Internal
-- @local
--
function BundleEntitySelection.Local:SetTooltip(_TitleText, _DescText, _DisabledText)
    local TooltipContainerPath = "/InGame/Root/Normal/TooltipNormal";
    local TooltipContainer = XGUIEng.GetWidgetID(TooltipContainerPath);
    local TooltipNameWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Name");
    local TooltipDescriptionWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Text");
    local PositionWidget = XGUIEng.GetCurrentWidgetID();

    _DisabledText = _DisabledText or "";
    local DisabledText = "";
    if XGUIEng.IsButtonDisabled(PositionWidget) == 1 and _disabledText ~= "" and _text ~= "" then
        DisabledText = DisabledText .. "{cr}{@color:255,32,32,255}" .. _DisabledText;
    end

    XGUIEng.SetText(TooltipNameWidget, "{center}" .. _TitleText);
    XGUIEng.SetText(TooltipDescriptionWidget, _DescText .. DisabledText);
    local Height = XGUIEng.GetTextHeight(TooltipDescriptionWidget, true);
    local W, H = XGUIEng.GetWidgetSize(TooltipDescriptionWidget);
    XGUIEng.SetWidgetSize(TooltipDescriptionWidget, W, Height);
end

---
-- Überschreibt den SelectKnight-Button. Durch drücken von CTLR können alle
-- Helden selektiert werden, die der Spieler kontrolliert.
--
-- @within Internal
-- @local
--
function BundleEntitySelection.Local:OverwriteSelectKnight()
    GUI_Knight.JumpToButtonClicked = function()
        local PlayerID = GUI.GetPlayerID();
        local KnightID = Logic.GetKnightID(PlayerID);
        if KnightID &#x3E; 0 then
            g_MultiSelection.EntityList = {};
            g_MultiSelection.Highlighted = {};
            GUI.ClearSelection();

            if XGUIEng.IsModifierPressed(Keys.ModifierControl) then
                local knights = {}
                Logic.GetKnights(PlayerID, knights);
                for i=1,#knights do
                    GUI.SelectEntity(knights[i]);
                end
            else
                GUI.SelectEntity(Logic.GetKnightID(PlayerID));

                if ((Framework.GetTimeMs() - g_Selection.LastClickTime ) &#x3C; g_Selection.MaxDoubleClickTime) then
                    local pos = GetPosition(KnightID);
                    Camera.RTS_SetLookAtPosition(pos.X, pos.Y);
                else
                    Sound.FXPlay2DSound("ui\\mini_knight");
                end

                g_Selection.LastClickTime = Framework.GetTimeMs();
            end
            GUI_MultiSelection.CreateMultiSelection(g_SelectionChangedSource.User);
        else
            GUI.AddNote("Debug: You do not have a knight");
        end
    end
end

---
-- Überschreibt die Militärselektion, sodass der Spieler mit SHIFT zusätzlich
-- die Munitionswagen und Trebuchets selektieren kann.
-- @within Internal
-- @local
--
function BundleEntitySelection.Local:OverwriteSelectAllUnits()
    GUI_MultiSelection.SelectAllPlayerUnitsClicked = function()
        if XGUIEng.IsModifierPressed(Keys.ModifierShift) then
            BundleEntitySelection.Local:ExtendedLeaderSortOrder();
        else
            BundleEntitySelection.Local:NormalLeaderSortOrder();
        end

        Sound.FXPlay2DSound("ui\\menu_click");
        GUI.ClearSelection();

        local PlayerID = GUI.GetPlayerID()
        for i = 1, #LeaderSortOrder do
            local EntitiesOfThisType = GetPlayerEntities(PlayerID, LeaderSortOrder[i])
            for j = 1, #EntitiesOfThisType do
                GUI.SelectEntity(EntitiesOfThisType[j])
            end
        end

        local Knights = {}
        Logic.GetKnights(PlayerID, Knights)
        for k = 1, #Knights do
            GUI.SelectEntity(Knights[k])
        end
        GUI_MultiSelection.CreateMultiSelection(g_SelectionChangedSource.User);
    end
end

---
-- Erzeugt die normale Sortierung ohne Munitionswagen und Trebuchets.
-- @within Internal
-- @local
--
function BundleEntitySelection.Local:NormalLeaderSortOrder()
    g_MultiSelection = {};
    g_MultiSelection.EntityList = {};
    g_MultiSelection.Highlighted = {};

    LeaderSortOrder     = {};
    LeaderSortOrder[1]  = Entities.U_MilitarySword;
    LeaderSortOrder[2]  = Entities.U_MilitaryBow;
    LeaderSortOrder[3]  = Entities.U_MilitarySword_RedPrince;
    LeaderSortOrder[4]  = Entities.U_MilitaryBow_RedPrince;
    LeaderSortOrder[5]  = Entities.U_MilitaryBandit_Melee_ME;
    LeaderSortOrder[6]  = Entities.U_MilitaryBandit_Melee_NA;
    LeaderSortOrder[7]  = Entities.U_MilitaryBandit_Melee_NE;
    LeaderSortOrder[8]  = Entities.U_MilitaryBandit_Melee_SE;
    LeaderSortOrder[9]  = Entities.U_MilitaryBandit_Ranged_ME;
    LeaderSortOrder[10] = Entities.U_MilitaryBandit_Ranged_NA;
    LeaderSortOrder[11] = Entities.U_MilitaryBandit_Ranged_NE;
    LeaderSortOrder[12] = Entities.U_MilitaryBandit_Ranged_SE;
    LeaderSortOrder[13] = Entities.U_MilitaryCatapult;
    LeaderSortOrder[14] = Entities.U_MilitarySiegeTower;
    LeaderSortOrder[15] = Entities.U_MilitaryBatteringRam;
    LeaderSortOrder[16] = Entities.U_CatapultCart;
    LeaderSortOrder[17] = Entities.U_SiegeTowerCart;
    LeaderSortOrder[18] = Entities.U_BatteringRamCart;
    LeaderSortOrder[19] = Entities.U_Thief;

    -- Asien wird nur in der Erweiterung gebraucht.
    if g_GameExtraNo &#x3E;= 1 then
        table.insert(LeaderSortOrder,  4, Entities.U_MilitarySword_Khana);
        table.insert(LeaderSortOrder,  6, Entities.U_MilitaryBow_Khana);
        table.insert(LeaderSortOrder,  7, Entities.U_MilitaryBandit_Melee_AS);
        table.insert(LeaderSortOrder, 12, Entities.U_MilitaryBandit_Ranged_AS);
    end
end

---
-- Erzeugt die erweiterte Selektion mit Munitionswagen und Trebuchets.
-- @within Internal
-- @local
--
function BundleEntitySelection.Local:ExtendedLeaderSortOrder()
    g_MultiSelection = {};
    g_MultiSelection.EntityList = {};
    g_MultiSelection.Highlighted = {};

    LeaderSortOrder     = {};
    LeaderSortOrder[1]  = Entities.U_MilitarySword;
    LeaderSortOrder[2]  = Entities.U_MilitaryBow;
    LeaderSortOrder[3]  = Entities.U_MilitarySword_RedPrince;
    LeaderSortOrder[4]  = Entities.U_MilitaryBow_RedPrince;
    LeaderSortOrder[5]  = Entities.U_MilitaryBandit_Melee_ME;
    LeaderSortOrder[6]  = Entities.U_MilitaryBandit_Melee_NA;
    LeaderSortOrder[7]  = Entities.U_MilitaryBandit_Melee_NE;
    LeaderSortOrder[8]  = Entities.U_MilitaryBandit_Melee_SE;
    LeaderSortOrder[9]  = Entities.U_MilitaryBandit_Ranged_ME;
    LeaderSortOrder[10] = Entities.U_MilitaryBandit_Ranged_NA;
    LeaderSortOrder[11] = Entities.U_MilitaryBandit_Ranged_NE;
    LeaderSortOrder[12] = Entities.U_MilitaryBandit_Ranged_SE;
    LeaderSortOrder[13] = Entities.U_MilitaryCatapult;
    LeaderSortOrder[14] = Entities.U_Trebuchet;
    LeaderSortOrder[15] = Entities.U_MilitarySiegeTower;
    LeaderSortOrder[16] = Entities.U_MilitaryBatteringRam;
    LeaderSortOrder[17] = Entities.U_CatapultCart;
    LeaderSortOrder[18] = Entities.U_SiegeTowerCart;
    LeaderSortOrder[19] = Entities.U_BatteringRamCart;
    LeaderSortOrder[20] = Entities.U_AmmunitionCart;
    LeaderSortOrder[21] = Entities.U_Thief;

    -- Asien wird nur in der Erweiterung gebraucht.
    if g_GameExtraNo &#x3E;= 1 then
        table.insert(LeaderSortOrder,  4, Entities.U_MilitarySword_Khana);
        table.insert(LeaderSortOrder,  6, Entities.U_MilitaryBow_Khana);
        table.insert(LeaderSortOrder,  7, Entities.U_MilitaryBandit_Melee_AS);
        table.insert(LeaderSortOrder, 12, Entities.U_MilitaryBandit_Ranged_AS);
    end
end

-- -------------------------------------------------------------------------- --

Core:RegisterBundle("BundleEntitySelection");

</code></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundleextendedzoom.lua.html">
            <div class='doclink'>
                <div>BundleExtendedZoom</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><code>-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundleExtendedZoom                                           # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Manchmal ist der maximale Zoom nicht genug! Löse Dich von den Fesseln, die
-- Dich einschränken! Dieses Bundle ermöglicht es den tatsächlichen maximalen
-- Zoom zu nutzen.
--
-- &#x3C;p&#x3E;&#x3C;a href="#API.AllowExtendedZoom"&#x3E;Zoom entriegeln oder sperren&#x3C;/a&#x3E;&#x3C;/p&#x3E;
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundleExtendedZoom = {};

API = API or {};
QSB = QSB or {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Aktiviert den Hotkey zum Wechsel zwischen normalen und erweiterten Zoom.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; AllowExtendedZoom&#x3C;/p&#x3E;
--
-- @param _Flag [boolean] Erweiterter Zoom gestattet
-- @within Anwenderfunktionen
--
function API.AllowExtendedZoom(_Flag)
    if GUI then
        API.Bridge("API.AllowExtendedZoom(".. tostring(_Flag) ..")");
        return;
    end
    BundleExtendedZoom.Global.Data.ExtendedZoomAllowed = _Flag == true;
    if _Flag == false then
        BundleExtendedZoom.Global:DeactivateExtendedZoom();
    end
end
AllowExtendedZoom = API.AllowExtendedZoom;

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

BundleExtendedZoom = {
    Global = {
        Data = {
            ExtendedZoomAllowed = true,
        }
    },
    Local = {},
}

-- Global Script ---------------------------------------------------------------

---
-- Initalisiert das Bundle im globalen Skript.
--
-- @within Internal
-- @local
--
function BundleExtendedZoom.Global:Install()
    self:InitExtendedZoomHotkeyFunction();
    self:InitExtendedZoomHotkeyDescription();
    API.AddSaveGameAction(BundleExtendedZoom.Global.OnSaveGameLoaded);
end

-- -------------------------------------------------------------------------- --

---
-- Schaltet zwischen dem normalen und dem erweiterten Zoom um.
--
-- @within Internal
-- @local
--
function BundleExtendedZoom.Global:ToggleExtendedZoom()
    if self.Data.ExtendedZoomAllowed then
        if self.Data.ExtendedZoomActive then
            self:DeactivateExtendedZoom();
        else
            self:ActivateExtendedZoom();
        end
    end
end

---
-- Aktiviert den erweiterten Zoom.
--
-- @within Internal
-- @local
--
function BundleExtendedZoom.Global:ActivateExtendedZoom()
    self.Data.ExtendedZoomActive = true;
    API.Bridge("BundleExtendedZoom.Local:ActivateExtendedZoom()");
end

---
-- Deaktiviert den erweiterten Zoom.
--
-- @within Internal
-- @local
--
function BundleExtendedZoom.Global:DeactivateExtendedZoom()
    self.Data.ExtendedZoomActive = false;
    API.Bridge("BundleExtendedZoom.Local:DeactivateExtendedZoom()");
end

---
-- Initialisiert den erweiterten Zoom.
--
-- @within Internal
-- @local
--
function BundleExtendedZoom.Global:InitExtendedZoomHotkeyFunction()
    API.Bridge([[
        BundleExtendedZoom.Local:ActivateExtendedZoomHotkey()
    ]]);
end

---
-- Initialisiert den erweiterten Zoom.
--
-- @within Internal
-- @local
--
function BundleExtendedZoom.Global:InitExtendedZoomHotkeyDescription()
    API.Bridge([[
        BundleExtendedZoom.Local:RegisterExtendedZoomHotkey()
    ]]);
end

-- -------------------------------------------------------------------------- --

---
-- Stellt nicht-persistente Änderungen nach dem laden wieder her.
--
-- @within Internal
-- @local
--
function BundleExtendedZoom.Global.OnSaveGameLoaded()
    -- Geänderter Zoom --
    if BundleExtendedZoom.Global.Data.ExtendedZoomActive then
        BundleExtendedZoom.Global:ActivateExtendedZoom();
    end
    BundleExtendedZoom.Global:InitExtendedZoomHotkeyFunction();
end

-- Local Script ----------------------------------------------------------------

---
-- Initalisiert das Bundle im lokalen Skript.
--
-- @within Internal
-- @local
--
function BundleExtendedZoom.Local:Install()
end

-- -------------------------------------------------------------------------- --

---
-- Schreibt den Hotkey für den erweiterten Zoom in das Hotkey-Register.
--
-- @within Internal
-- @local
--
function BundleExtendedZoom.Local:RegisterExtendedZoomHotkey()
    API.AddHotKey(
        {de = "Strg + Umschalt + K",       en = "Ctrl + Shift + K"},
        {de = "Alternativen Zoom ein/aus", en = "Alternative zoom on/off"}
    )
end

---
-- Aktiviert den Hotkey zum Wechsel zwischen normalen und erweiterten Zoom.
--
-- @within Internal
-- @local
--
function BundleExtendedZoom.Local:ActivateExtendedZoomHotkey()
    Input.KeyBindDown(
        Keys.ModifierControl + Keys.ModifierShift + Keys.K,
        "BundleExtendedZoom.Local:ToggleExtendedZoom()",
        2,
        false
    );
end

---
-- Wechselt zwischen erweitertem und normalen Zoom.
--
-- @within Internal
-- @local
--
function BundleExtendedZoom.Local:ToggleExtendedZoom()
    API.Bridge("BundleExtendedZoom.Global:ToggleExtendedZoom()");
end

---
-- Erweitert die Zoomrestriktion auf das Maximum.
--
-- @within Internal
-- @local
--
function BundleExtendedZoom.Local:ActivateExtendedZoom()
    Camera.RTS_SetZoomFactorMax(0.8701);
    Camera.RTS_SetZoomFactor(0.8700);
    Camera.RTS_SetZoomFactorMin(0.0999);
end

---
-- Stellt die normale Zoomrestriktion wieder her.
--
-- @within Internal
-- @local
--
function BundleExtendedZoom.Local:DeactivateExtendedZoom()
    Camera.RTS_SetZoomFactor(0.5000);
    Camera.RTS_SetZoomFactorMax(0.5001);
    Camera.RTS_SetZoomFactorMin(0.0999);
end

-- -------------------------------------------------------------------------- --

Core:RegisterBundle("BundleExtendedZoom");

</code></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundlegamehelperfunctions.lua.html">
            <div class='doclink'>
                <div>BundleGameHelperFunctions</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><code>-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundleGameHelperFunctions                                    # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Dieses Bundle gibt dem Mapper Werkzeuge in die Hand, um einige Features zu
-- gewähren oder zu entziehen.
--
-- Das wichtigste Auf einen Blick:
-- &#x3C;ul&#x3E;
-- &#x3C;li&#x3E;
-- &#x3C;a href="#API.AllowCheats"&#x3E;Features aktivieren&#x3C;/a&#x3E;&#x3C;br&#x3E;Cheats, Erweiterter
-- Zoom, Feste feiern für KIs
-- &#x3C;/li&#x3E;
-- &#x3C;li&#x3E;
-- &#x3C;a href="#API.ForbidCheats"&#x3E;Features deaktivieren&#x3C;/a&#x3E;&#x3C;br&#x3E;Cheats, Erweiterter
-- Zoom, Feste feiern für KIs
-- &#x3C;/li&#x3E;
-- &#x3C;li&#x3E;
-- &#x3C;a href="#API.SpeedLimitActivate"&#x3E;Spielgeschwindigkeit steuern&#x3C;/a&#x3E;&#x3C;br&#x3E;
-- Maximale Spielgeschwindigkeit festlegen
-- &#x3C;/li&#x3E;
-- &#x3C;/ul&#x3E;
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundleGameHelperFunctions = {};

API = API or {};
QSB = QSB or {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Fokusiert die Kamera auf dem Primärritter des Spielers.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; SetCameraToPlayerKnight&#x3C;/p&#x3E;
--
-- @param[type=number] _Player Partei
-- @param[type=number] _Rotation Kamerawinkel
-- @param[type=number] _ZoomFactor Zoomfaktor
-- @within Anwenderfunktionen
--
function API.FocusCameraOnKnight(_Player, _Rotation, _ZoomFactor)
    API.FocusCameraOnEntity(Logic.GetKnightID(_Player), _Rotation, _ZoomFactor)
end
SetCameraToPlayerKnight = API.FocusCameraOnKnight;

---
-- Fokusiert die Kamera auf dem Entity.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; SetCameraToEntity&#x3C;/p&#x3E;
--
-- @param _Entity Entity (Skriptname oder ID)
-- @param[type=number] _Rotation Kamerawinkel
-- @param[type=number] _ZoomFactor Zoomfaktor
-- @within Anwenderfunktionen
--
function API.FocusCameraOnEntity(_Entity, _Rotation, _ZoomFactor)
    if not GUI then
        local Subject = (type(_Entity) ~= "string" and _Entity) or "'" .._Entity.. "'";
        API.Bridge("API.FocusCameraOnEntity(" ..Subject.. ", " .._Rotation.. ", " .._ZoomFactor.. ")")
        return;
    end
    if not IsExisting(_Entity) then
        local Subject = (type(_Entity) ~= "string" and _Entity) or "'" .._Entity.. "'";
        API.Warn("API.FocusCameraOnEntity: Entity " ..Subject.. " does not exist!");
        return;
    end
    return BundleGameHelperFunctions.Local:SetCameraToEntity(_Entity, _Rotation, _ZoomFactor);
end
SetCameraToEntity = API.FocusCameraOnEntity;

---
-- Setzt die Obergrenze für die Spielgeschwindigkeit fest.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; SetSpeedLimit&#x3C;/p&#x3E;
--
-- @param[type=number] _Limit Obergrenze
-- @within Anwenderfunktionen
--
function API.SpeedLimitSet(_Limit)
    if not GUI then
        API.Bridge("API.SpeedLimitSet(" .._Limit.. ")");
        return;
    end
    return BundleGameHelperFunctions.Local:SetSpeedLimit(_Limit);
end
SetSpeedLimit = API.SpeedLimitSet

---
-- Aktiviert die Speedbremse. Die vorher eingestellte Maximalgeschwindigkeit
-- kann nicht mehr überschritten werden.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; ActivateSpeedLimit&#x3C;/p&#x3E;
--
-- @param[type=boolean] _Flag Speedbremse ist aktiv
-- @within Anwenderfunktionen
--
function API.SpeedLimitActivate(_Flag)
    if GUI then
        API.Bridge("API.SpeedLimitActivate(" ..tostring(_Flag).. ")");
        return;
    end
    return API.Bridge("BundleGameHelperFunctions.Local:ActivateSpeedLimit(" ..tostring(_Flag).. ")");
end
ActivateSpeedLimit = API.SpeedLimitActivate;

---
-- Deaktiviert die Tastenkombination zum Einschalten der Cheats.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; KillCheats&#x3C;/p&#x3E;
--
-- @within Anwenderfunktionen
--
function API.ForbidCheats()
    if GUI then
        API.Bridge("API.ForbidCheats()");
        return;
    end
    return BundleGameHelperFunctions.Global:KillCheats();
end
KillCheats = API.ForbidCheats;

---
-- Aktiviert die Tastenkombination zum Einschalten der Cheats.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; RessurectCheats&#x3C;/p&#x3E;
--
-- @within Anwenderfunktionen
--
function API.AllowCheats()
    if GUI then
        API.Bridge("API.AllowCheats()");
        return;
    end
    return BundleGameHelperFunctions.Global:RessurectCheats();
end
RessurectCheats = API.AllowCheats;

---
-- Sperrt das Speichern von Spielständen oder gibt es wieder frei.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; ForbidSaveGame&#x3C;/p&#x3E;
--
-- @param[type=boolean] _Flag Speichern gesperrt
-- @within Anwenderfunktionen
--
function API.ForbidSaveGame(_Flag)
    if GUI then
        API.Bridge("API.ForbidSaveGame(".. tostring(_Flag) ..")");
        return;
    end
    API.Bridge([[
        BundleGameHelperFunctions.Local.Data.ForbidSave = ]].. tostring(_Flag) ..[[ == true
        BundleGameHelperFunctions.Local:DisplaySaveButtons(]].. tostring(_Flag) ..[[)
    ]]);
end
ForbidSaveGame = API.ForbidSaveGame;

---
-- Lässt einen Siedler einem Helden folgen. Gibt die ID des Jobs
-- zurück, der die Verfolgung steuert.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Hinweis:&#x3C;/b&#x3E; Wenn eines der Entities zerstört wird, oder ins
-- Koma fällt, wird der Job beendet!&#x3C;/p&#x3E;
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; AddFollowKnightSave&#x3C;/p&#x3E;
--
-- @param              _Entity Entity das folgt (skriptname oder ID)
-- @param              _Knight Held (Skriptname oder ID)
-- @param[type=number] _Distance Entfernung, die uberschritten sein muss
-- @param[type=number] _Angle Ausrichtung
-- @return[type=number] Job-ID
-- @within Anwenderfunktionen
--
function API.FollowKnightSaveStart(_Entity, _Knight, _Distance, _Angle)
    if GUI then
        local Target = (type(_Entity) == "string" and "'".._Entity.."'") or _Entity;
        local Knight = (type(_Knight) == "string" and "'".._Knight.."'") or _Knight;
        API.Bridge("API.FollowKnightSaveStart(" ..Target.. ", " ..Knight.. ", " .._Distance.. "," .._Angle.. ")");
        return;
    end
    return BundleGameHelperFunctions.Global:AddFollowKnightSave(_Entity, _Knight, _Distance, _Angle);
end
AddFollowKnightSave = API.FollowKnightSaveStart;

---
-- Beendet einen Verfolgungsjob.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; StopFollowKnightSave&#x3C;/p&#x3E;
--
-- @param[type=number] _JobID Job-ID
-- @within Anwenderfunktionen
--
function API.FollowKnightSaveStop(_JobID)
    if GUI then
        API.Bridge("API.FollowKnightSaveStop(" .._JobID.. ")");
        return;
    end
    return BundleGameHelperFunctions.Global:StopFollowKnightSave(_JobID)
end

StopFollowKnightSave = API.FollowKnightSaveStop;

---
-- &#x3C;p&#x3E;Ändert die Bodentextur innerhalb des Quadrates. Offset bestimmt die
-- Abstände der Eckpunkte zum Zentralpunkt.&#x3C;/p&#x3E;
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Hinweis:&#x3C;/b&#x3E; Für weitere Informationen zu Terraintexturen siehe
-- https://siedelwood-neu.de/23879-2/&#x3C;/p&#x3E;
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; TerrainType&#x3C;/p&#x3E;
--
-- @param              _Center Zentralpunkt (Skriptname oder ID)
-- @param[type=number] _Offset Entfernung der Ecken zum Zentrum
-- @param[type=number] _TerrainType Textur ID
-- @within Anwenderfunktionen
--
-- @usage
-- API.ChangeTerrainTypeInSquare("area", 500, 48)
--
function API.ChangeTerrainTypeInSquare(_Center, _Offset, _TerrainType)
    if GUI then
        local Target = (type(_Center) == "string" and "'".._Center.."'") or _Center;
        API.Bridge("API.ChangeTerrainTypeInSquare(" ..Target.. ", " .._Offset.. ", " .._TerrainType.. ")");
        return;
    end
    if not IsExisting(_Center) then
        API.Fatal("API.ChangeTerrainTypeInSquare: Central point does not exist!");
        return;
    end
    if _Offset &#x3C; 100 then
        API.Warn("API.ChangeTerrainTypeInSquare: Check your offset! It seems to small!");
    end
    return BundleGameHelperFunctions.Global:ChangeTerrainTypeInSquare(_Center, _Offset, _TerrainType);
end
TerrainType = API.ChangeTerrainTypeInSquare;

---
-- Ändert die Wasserhöhe in einem Quadrat. Offset bestimmt die Abstände
-- der Eckpunkte zum Zentrum.
--
-- Wird die relative Höhe verwendet, wird die Wasserhöhe nicht absolut
-- gesetzt sondern von der aktuellen Wasserhöhe ausgegangen.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; WaterHeight&#x3C;/p&#x3E;
--
-- @param               _Center Zentralpunkt (Skriptname oder ID)
-- @param[type=number]  _Offset Entfernung der Ecken zum Zentrum
-- @param[type=number]  _Height Neue Höhe
-- @param[type=boolean] _Relative Relative Höhe benutzen
-- @within Anwenderfunktionen
--
-- @usage
-- API.ChangeWaterHeightInSquare("area", 500, 5555, true);
--
function API.ChangeWaterHeightInSquare(_Center, _Offset, _Height, _Relative)
    if GUI then
        local Target = (type(_Center) == "string" and "'".._Center.."'") or _Center;
        API.Bridge("API.ChangeWaterHeightInSquare(" ..Target.. ", " .._Offset.. ", " .._Height.. ", " ..tostring(_Relative).. ")");
        return;
    end
    if not IsExisting(_Center) then
        API.Fatal("API.ChangeWaterHeightInSquare: Central point does not exist!");
        return;
    end
    if _Offset &#x3C; 100 then
        API.Warn("API.ChangeWaterHeightInSquare: Check your offset! It seems to small!");
    end
    return BundleGameHelperFunctions.Global:ChangeWaterHeightInSquare(_Center, _Offset, _Height, _Relative);
end
WaterHeight = API.ChangeWaterHeightInSquare;

---
-- Ändert die Landhöhe in einem Quadrat. Offset bestimmt die Abstände
-- der Eckpunkte zum Zentralpunkt.
--
-- Wird die relative Höhe verwendet, wird die Landhöhe nicht absolut
-- gesetzt sondern von der aktuellen Landhöhe ausgegangen. Das Land muss nicht
-- eben sein. Auf diese Weise können Strukturen unverändert angehoben werden.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; TerrainHeight&#x3C;/p&#x3E;
--
-- @param               _Center Zentralpunkt (Skriptname oder ID)
-- @param[type=number]  _Offset Entfernung der Ecken zum Zentrum
-- @param[type=number]  _Height Neue Höhe
-- @param[type=boolean] _Relative Relative Höhe benutzen
-- @within Anwenderfunktionen
--
-- @usage
-- API.ChangeTerrainHeightInSquare("area", 500, 5555, true);
--
function API.ChangeTerrainHeightInSquare(_Center, _Offset, _Height, _Relative)
    if GUI then
        local Target = (type(_Center) == "string" and "'".._Center.."'") or _Center;
        API.Bridge("API.ChangeTerrainHeightInSquare(" ..Target.. ", " .._Offset.. ", " .._Height.. ", " ..tostring(_Relative).. ")");
        return;
    end
    if not IsExisting(_Center) then
        API.Fatal("API.ChangeTerrainHeightInSquare: Central point does not exist!");
        return;
    end
    if _Offset &#x3C; 100 then
        API.Warn("API.ChangeTerrainHeightInSquare: Check your offset! It seems to small!");
    end
    return BundleGameHelperFunctions.Global:ChangeTerrainHeightInSquare(_Center, _Offset, _Height, _Relative);
end
TerrainHeight = API.ChangeTerrainHeightInSquare;

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

BundleGameHelperFunctions = {
    Global = {
        Data = {
            HumanPlayerChangedOnce = false,
            HumanKnightType = 0,
            HumanPlayerID = 1,
            FollowKnightSave = {},
        }
    },
    Local = {
        Data = {
            SpeedLimit = 32,
        }
    },
}

-- Global Script ---------------------------------------------------------------

---
-- Initalisiert das Bundle im globalen Skript.
--
-- @within Internal
-- @local
--
function BundleGameHelperFunctions.Global:Install()
    API.AddSaveGameAction(BundleGameHelperFunctions.Global.OnSaveGameLoaded);
end

-- -------------------------------------------------------------------------- --

---
-- Deaktiviert die Tastenkombination zum Einschalten der Cheats.
--
-- @within Internal
-- @local
--
function BundleGameHelperFunctions.Global:KillCheats()
    self.Data.CheatsForbidden = true;
    API.Bridge("BundleGameHelperFunctions.Local:KillCheats()");
end

---
-- Aktiviert die Tastenkombination zum Einschalten der Cheats.
--
-- @within Internal
-- @local
--
function BundleGameHelperFunctions.Global:RessurectCheats()
    self.Data.CheatsForbidden = false;
    API.Bridge("BundleGameHelperFunctions.Local:RessurectCheats()");
end

-- -------------------------------------------------------------------------- --

---
-- Lässt einen Siedler einem Helden folgen. Gibt die ID des Jobs
-- zurück, der die Verfolgung steuert.
--
-- @param              _Entity Entity das folgt (skriptname oder ID)
-- @param              _Knight Held (Skriptname oder ID)
-- @param[type=number] _Distance Entfernung, die uberschritten sein muss
-- @param[type=number] _Angle Ausrichtung
-- @return[type=number] Job-ID
-- @within Internal
-- @local
--
function BundleGameHelperFunctions.Global:AddFollowKnightSave(_Entity, _Knight, _Distance, _Angle)
    local EntityID = GetID(_Entity);
    local KnightID = GetID(_Knight);
    _Angle = _Angle or 0;

    local JobID = Trigger.RequestTrigger(Events.LOGIC_EVENT_EVERY_TURN,
                                         nil,
                                         "ControlFollowKnightSave",
                                         1,
                                         {},
                                         {EntityID, KnightID, _Distance, _Angle});

    table.insert(self.Data.FollowKnightSave, JobID);
    return JobID;
end

---
-- Beendet einen Verfolgungsjob.
--
-- @param[type=number] _JobID Job-ID
-- @within Internal
-- @local
--
function BundleGameHelperFunctions.Global:StopFollowKnightSave(_JobID)
    for k,v in pairs(self.Data.FollowKnightSave) do
        if _JobID == v then
            self.Data.FollowKnightSave[k] = nil;
            EndJob(_JobID);
        end
    end
end

---
-- Kontrolliert die Verfolgung eines Helden durch einen Siedler.
--
-- @param              _Entity Entity das folgt (skriptname oder ID)
-- @param              _Knight Held (Skriptname oder ID)
-- @param[type=number] _Distance Entfernung, die uberschritten sein muss
-- @param[type=number] _Angle Ausrichtung
-- @within Internal
-- @local
--
function BundleGameHelperFunctions.Global.ControlFollowKnightSave(_EntityID, _KnightID, _Distance, _Angle)
    -- Entity oder Held sind hinüber bzw. haben ihre ID verändert
    if not IsExisting(_KnightID) or not IsExisting(_EntityID) then
        return true;
    end

    -- Wenn Entity ein Held ist, dann nur, wenn Entity nicht komatös ist
    if Logic.IsKnight(_EntityID) and Logic.KnightGetResurrectionProgress(_EntityID) ~= 1 then
        return false;
    end
    -- Wenn Knight ein Held ist, dann nur, wenn Knight nicht komatös ist
    if Logic.IsKnight(_KnightID) and Logic.KnightGetResurrectionProgress(_KnightID) ~= 1 then
        return false;
    end

    if  Logic.IsEntityMoving(_EntityID) == false and Logic.IsFighting(_EntityID) == false
    and IsNear(_EntityID, _KnightID, _Distance+300) == false then
        -- Relative Position hinter Held bestimmen
        local x, y, z = Logic.EntityGetPos(_KnightID);
        local orientation = Logic.GetEntityOrientation(_KnightID)-(180+_Angle);
        local xBehind = x + _Distance * math.cos(math.rad(orientation));
        local yBehind = y + _Distance * math.sin(math.rad(orientation));

        -- Relative Position blockingsicher machen
        local NoBlocking = Logic.CreateEntityOnUnblockedLand(Entities.XD_ScriptEntity, xBehind, yBehind, 0, 0);
        local x, y, z = Logic.EntityGetPos(NoBlocking);
        DestroyEntity(NoBlocking);

        -- Zur neuen unblockierten Position bewegen
        Logic.MoveSettler(_EntityID, x, y);
    end
end
ControlFollowKnightSave = BundleGameHelperFunctions.Global.ControlFollowKnightSave;

-- -------------------------------------------------------------------------- --

---
-- Ändert die Bodentextur innerhalb des Quadrates. Offset bestimmt die
-- Abstände der Eckpunkte zum Zentralpunkt.
-- @param              _Center Zentralpunkt (Skriptname oder ID)
-- @param[type=number] _Offset Entfernung der Ecken zum Zentrum
-- @param[type=number] _TerrainType Textur ID
-- @within Internal
-- @local
--
function BundleGameHelperFunctions.Global:ChangeTerrainTypeInSquare(_Center, _Offset, _TerrainType)
    local Xmin, Ymin, Xmax, Ymax, z = self:GetSquareForWaterAndTerrain(_Center, _Offset);
    if Xmin == -1 or Xmin == -2 then
        return Xmin;
    end
    if type(_TerrainType) == "number" then
        for x10 = Xmin, Xmax do
            for y10 = Ymin, Ymax do
                Logic.SetTerrainNodeType( x10, y10, _TerrainType );
            end
        end
    end
    Logic.UpdateBlocking( Xmin, Ymin, Xmax, Ymax);
end

---
-- Ändert die Wasserhöhe in einem Quadrat. Offset bestimmt die Abstände
-- der Eckpunkte zum Zentralpunkt.
-- @param               _Center Zentralpunkt (Skriptname oder ID)
-- @param[type=number]  _Offset Entfernung der Ecken zum Zentrum
-- @param[type=number]  _Height Neue Höhe
-- @param[type=boolean] _Relative Relative Höhe benutzen
-- @within Internal
-- @local
--
function BundleGameHelperFunctions.Global:ChangeWaterHeightInSquare(_Center, _Offset, _Height, _Relative)
    local Xmin, Ymin, Xmax, Ymax, z = self:GetSquareForWaterAndTerrain(_Center, _Offset);
    if Xmin == -1 or Xmin == -2 then
        return Xmin;
    end
    if not _Relative then
        if _Height &#x3C; 0 then
            return -3;
        end
        Logic.WaterSetAbsoluteHeight(Xmin, Ymin, Xmax, Ymax, _Height);
    else
        if z+_Height &#x3C; 0 then
            return -3;
        end
        Logic.WaterSetAbsoluteHeight(Xmin, Ymin, Xmax, Ymax, z+_Height);
    end
    Logic.UpdateBlocking(Xmin, Ymin, Xmax, Ymax);
    return 0;
end

---
-- Ändert die Landhöhe in einem Quadrat. Offset bestimmt die Abstände
-- der Eckpunkte zum Zentralpunkt.
-- @param               _Center Zentralpunkt (Skriptname oder ID)
-- @param[type=number]  _Offset Entfernung der Ecken zum Zentrum
-- @param[type=number]  _Height Neue Höhe
-- @param[type=boolean] _Relative Relative Höhe benutzen
-- @within Internal
-- @local
--
function BundleGameHelperFunctions.Global:ChangeTerrainHeightInSquare(_Center, _Offset, _Height, _Relative)
    local Xmin, Ymin, Xmax, Ymax, z = self:GetSquareForWaterAndTerrain(_Center, _Offset);
    if Xmin == -1 or Xmin == -2 then
        return Xmin;
    end
    local Height;
    if not _Relative then
        if _Height &#x3C; 0 then
            return -3;
        end
        Height = _Height;
    else
        if z+_Height &#x3C; 0 then
            return -3;
        end
        Height = z+_Height;
    end

    for x10 = Xmin, Xmax do
        for y10 = Ymin, Ymax do
            Logic.SetTerrainNodeHeight(x10, y10, Height);
        end
    end
    Logic.UpdateBlocking(Xmin, Ymin, Xmax, Ymax);
    return 0;
end

---
-- Gibt ein Quadrat für Land- und Wassermanipulation zurück.
--
-- Wird verwendet von: WaterHeight, TerrainHeight, TerrainType
--
-- @param              _Center Zentralpunkt des Quadrat (Skriptname oder ID)
-- @param[type=number] _Offset Abstand der Ecken zum Zentrum
-- @return[type=number] X-Koordinate von Punkt 1
-- @return[type=number] Y-Koordinate von Punkt 1
-- @return[type=number] X-Koordinate von Punkt 2
-- @return[type=number] Y-Koordinate von Punkt 2
-- @return[type=number] Bodenhöhe
-- @within Internal
-- @local
--
function BundleGameHelperFunctions.Global:GetSquareForWaterAndTerrain(_Center, _Offset)
    local Type = type(_Center);
    if (Type ~= "string" and Type ~= "number") or not IsExisting(_Center) then
        return -1;
    end
    local Xmin, Ymin, Xmax, Ymax;
    local eID = GetID(_Center);
    local x,y,z = Logic.EntityGetPos(eID);
    Xmin = math.floor((x - _Offset)/100);
    Ymin = math.floor((y - _Offset)/100);
    Xmax = math.floor((x + _Offset)/100);
    Ymax = math.floor((y + _Offset)/100);
    if IsValidPosition({X= Xmin, Y= Ymin}) == false or IsValidPosition({X= Xmax, Y= Ymax}) == false then
        return -2;
    end
    return Xmin, Ymin, Xmax, Ymax, z;
end

-- -------------------------------------------------------------------------- --

---
-- Stellt nicht-persistente Änderungen nach dem laden wieder her.
--
-- @within Internal
-- @local
--
function BundleGameHelperFunctions.Global.OnSaveGameLoaded()
    -- Cheats sperren --
    if BundleGameHelperFunctions.Global.Data.CheatsForbidden == true then
        BundleGameHelperFunctions.Global:KillCheats();
    end
    -- Illegale Speicherstände
    API.Bridge("BundleGameHelperFunctions.Local:CloseIllegalSaveGame()");
end

-- Local Script ----------------------------------------------------------------

---
-- Initalisiert das Bundle im lokalen Skript.
--
-- @within Internal
-- @local
--
function BundleGameHelperFunctions.Local:Install()
    self:InitForbidSpeedUp()
    self:InitForbidSaveGame();
end

---
-- Fokusiert die Kamera auf dem Entity.
--
-- @param _Entity Entity (Skriptname oder ID)
-- @param[type=number] _Rotation Kamerawinkel
-- @param[type=number] _ZoomFactor Zoomfaktor
-- @within Internal
-- @local
--
function BundleGameHelperFunctions.Local:SetCameraToEntity(_Entity, _Rotation, _ZoomFactor)
    local pos = GetPosition(_Entity);
    local rotation = (_Rotation or -45);
    local zoomFactor = (_ZoomFactor or 0.5);
    Camera.RTS_SetLookAtPosition(pos.X, pos.Y);
    Camera.RTS_SetRotationAngle(rotation);
    Camera.RTS_SetZoomFactor(zoomFactor);
end

-- -------------------------------------------------------------------------- --

---
-- Setzt die Obergrenze für die Spielgeschwindigkeit fest.
--
-- @param[type=number] _Limit Obergrenze
-- @within Internal
-- @local
--
function BundleGameHelperFunctions.Local:SetSpeedLimit(_Limit)
    _Limit = (_Limit &#x3C; 1 and 1) or math.floor(_Limit);
    self.Data.SpeedLimit = _Limit;
end

---
-- Aktiviert die Speedbremse. Die vorher eingestellte Maximalgeschwindigkeit
-- kann nicht mehr überschritten werden.
--
-- @param[type=boolean] _Flag Speedbremse ist aktiv
-- @within Internal
-- @local
--
function BundleGameHelperFunctions.Local:ActivateSpeedLimit(_Flag)
    self.Data.UseSpeedLimit = _Flag == true;
    if _Flag and Game.GameTimeGetFactor(GUI.GetPlayerID()) &#x3E; self.Data.SpeedLimit then
        Game.GameTimeSetFactor(GUI.GetPlayerID(), self.Data.SpeedLimit);
    end
end

---
-- Überschreibt das Callback, das nach dem Ändern der Spielgeschwindigkeit
-- aufgerufen wird und installiert die Speedbremse.
--
-- @within Internal
-- @local
--
function BundleGameHelperFunctions.Local:InitForbidSpeedUp()
    GameCallback_GameSpeedChanged_Orig_Preferences_ForbidSpeedUp = GameCallback_GameSpeedChanged;
    GameCallback_GameSpeedChanged = function( _Speed )
        GameCallback_GameSpeedChanged_Orig_Preferences_ForbidSpeedUp( _Speed );
        if BundleGameHelperFunctions.Local.Data.UseSpeedLimit == true then
            if _Speed &#x3E; BundleGameHelperFunctions.Local.Data.SpeedLimit then
                Game.GameTimeSetFactor(GUI.GetPlayerID(), BundleGameHelperFunctions.Local.Data.SpeedLimit);
            end
        end
    end
end

-- -------------------------------------------------------------------------- --

---
-- Deaktiviert die Tastenkombination zum Einschalten der Cheats.
--
-- @within Internal
-- @local
--
function BundleGameHelperFunctions.Local:KillCheats()
    Input.KeyBindDown(
        Keys.ModifierControl + Keys.ModifierShift + Keys.Divide,
        "KeyBindings_EnableDebugMode(0)",
        2,
        false
    );
end

---
-- Aktiviert die Tastenkombination zum Einschalten der Cheats.
--
-- @within Internal
-- @local
--
function BundleGameHelperFunctions.Local:RessurectCheats()
    Input.KeyBindDown(
        Keys.ModifierControl + Keys.ModifierShift + Keys.Divide,
        "KeyBindings_EnableDebugMode(2)",
        2,
        false
    );
end

-- -------------------------------------------------------------------------- --

---
-- Überschreibt die Hotkey-Funktion, die das Spiel speichert.
--
-- @within Internal
-- @local
--
function BundleGameHelperFunctions.Local:InitForbidSaveGame()
    KeyBindings_SaveGame_Orig_Preferences_SaveGame = KeyBindings_SaveGame;
    KeyBindings_SaveGame = function()
        if BundleGameHelperFunctions.Local.Data.ForbidSave then
            return;
        end
        KeyBindings_SaveGame_Orig_Preferences_SaveGame();
    end
end

---
-- Schließt einen Spielstand, der während des Speicherverbots erstellt wurde.
--
-- &#x3C;b&#x3E;Hinweis&#x3C;/b&#x3E;: Dies ist ein Fallback wegen dem automatischen Speichern
-- der History Edition, dass nicht auf Lua-Ebene verhindert werden kann.
--
-- @within Internal
-- @local
--
function BundleGameHelperFunctions.Local:CloseIllegalSaveGame()
    if BundleGameHelperFunctions.Local.Data.ForbidSave then
        Framework.CloseGame();
    end
end

---
-- Zeigt oder versteckt die Speicherbuttons im Spielmenü.
--
-- @param[type=boolean] _Flag Speicherbuttons sichtbar
-- @within Internal
-- @local
--
function BundleGameHelperFunctions.Local:DisplaySaveButtons(_Flag)
    XGUIEng.ShowWidget("/InGame/InGame/MainMenu/Container/SaveGame",  (_Flag and 0) or 1);
    XGUIEng.ShowWidget("/InGame/InGame/MainMenu/Container/QuickSave", (_Flag and 0) or 1);
end

-- -------------------------------------------------------------------------- --

Core:RegisterBundle("BundleGameHelperFunctions");

</code></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundleinteractiveobjects.lua.html">
            <div class='doclink'>
                <div>BundleInteractiveObjects</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><code>-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundleInteractiveObjects                                     # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Interaktive Objekte sind Gegenstände auf der Karte, mit denen interagiert
-- werden kann. Diese Interaktion geschieht über einen Button. Ziel dieses
-- Bundels ist es, die funktionalität von interaktiven Objekten zu erweitern.
-- Es ist möglich, beliebige Objekte zu interaktiven Objekten zu machen.
--
-- Die Einsatzmöglichkeiten sind vielfältig. Wenn ein Gegenstand oder ein
-- Objekt mit einer Funktion versehen ist, kann dies in verschiedenem Kontext
-- an die Geschichte angepasst werden: z.B. Helbel öffnen eine Geheimtür,
-- ein Gegenstand wird vom Helden aufgehoben, ein Marktstand, der etwas
-- verkauft, ....
--
-- Das wichtigste Auf einen Blick:
-- &#x3C;ul&#x3E;
-- &#x3C;li&#x3E;
-- &#x3C;a href="#API.CreateObject"&#x3E;Objekt erzeugen&#x3C;/a&#x3E;
-- &#x3C;/li&#x3E;
-- &#x3C;li&#x3E;
-- &#x3C;a href="#API.InteractiveObjectActivate"&#x3E;Ein- und ausschalten von
-- interaktiven Objekten&#x3C;/a&#x3E;
-- &#x3C;/li&#x3E;
-- &#x3C;li&#x3E;
-- &#x3C;a href="#API.AddCustomIOName"&#x3E;Anzeigenamen im Questfenster definieren&#x3C;/a&#x3E;
-- &#x3C;/li&#x3E;
-- &#x3C;/ul&#x3E;
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundleInteractiveObjects = {};

API = API or {};
QSB = QSB or {};

QSB.IOList = {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Erzeugt ein interaktives Objekt.
--
-- Die Parameter des interaktiven Objektes werden durch seine Beschreibung
-- festgelegt. Die Beschreibung ist eine Table, die bestimmte Werte für das
-- Objekt beinhaltet. Dabei müssen nicht immer alle Werte angegeben werden.
--
-- Mögliche Angaben:
-- &#x3C;table border="1"&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;&#x3C;b&#x3E;Feldname&#x3C;/b&#x3E;&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;&#x3C;b&#x3E;Beschreibung&#x3C;/b&#x3E;&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;&#x3C;b&#x3E;Optional&#x3C;/b&#x3E;&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;Name&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Der Skriptname des Entity, das zum interaktiven Objekt wird.&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;nein&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;Title&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Der angezeigter Name im Beschreibungsfeld.&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;ja&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;Text&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Der Beschreibungstext, der im Tooltip angezeigt wird.&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;ja&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;Texture&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Bestimmt die Icongrafik, die angezeigt wird. Dabei kann es sich um
-- eine Ingame-Grafik oder eine eigene Grafik halten.&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;ja&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;Distance&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Die minimale Entfernung zum Objekt, die ein Held benötigt um das
-- objekt zu aktivieren.&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;ja&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;Waittime&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Die Zeit, die ein Held benötigt, um das Objekt zu aktivieren. Die
-- Wartezeit ist nur für I_X_ Entities verfügbar.&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;ja&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;Costs&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Eine Table mit dem Typ und der Menge der Kosten.&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;ja&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;Reward&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Der Warentyp und die Menge der gefundenen Waren im Objekt.&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;ja&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;Callback&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Eine Funktion, die ausgeführt wird, sobald das Objekt aktiviert wird.&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;ja&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;Condition&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Eine Funktion, die vor der Aktivierung eine Beringung prüft.&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;ja&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;ConditionUnfulfilled&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Eine Nachricht, die angezeigt wird, falls die Bedingung nicht
-- erfüllt ist.&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;ja&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;Opener&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Ein spezieller Held, der als einziger das Objekt aktivieren kann.&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;ja&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;WrongKnight&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Nachricht, die angezeigt wird, wenn der falsche Held das Objekt
-- aktivieren will.&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;ja&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;State&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Bestimmt, wie sich der Button des interaktiven Objektes verhält.&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;ja&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;/table&#x3E;
--
-- Zusätzlich können beliebige weitere Felder an das Objekt angehangen
-- werden. Sie sind ausnahmslos im Callback und in der Condition des Objektes
-- abrufbar.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; CreateObject&#x3C;/p&#x3E;
--
-- @param[type=table] _Description Beschreibung
-- @within Anwenderfunktionen
--
-- @usage
-- -- Ein einfaches Objekt erstellen:
-- CreateObject {
--     Name     = "hut",
--     Distance = 1500,
--     Callback = function(_Data)
--         API.Note("Do something...");
--     end,
-- }
--
function API.CreateObject(_Description)
    if GUI then
        API.Fatal("API.CreateObject: Can not be used from local enviorment!");
        return;
    end
    return BundleInteractiveObjects.Global:CreateObject(_Description);
end
CreateObject = API.CreateObject;

---
-- Löscht ein interaktives Objekt.
--
-- Das Entity wird dabei nicht gelöscht. Es wird ausschließlich die
-- Konfiguration des Objektes entfernt.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; RemoveInteractiveObject&#x3C;/p&#x3E;
--
-- @param[type=string] _EntityName Skriptname des IO
-- @within Anwenderfunktionen
--
function API.RemoveInteractiveObject(_EntityName)
    if GUI then
        API.Bridge("API.RemoveInteractiveObject('" .._EntityName.. "')");
        return;
    end
    if not IsExisting(_EntityName) then
        API.Warn("API.RemoveInteractiveObject: Entity \"" .._EntityName.. "\" is invalid!");
        return;
    end
    return BundleInteractiveObjects.Global:RemoveInteractiveObject(_EntityName);
end
RemoveInteractiveObject = API.RemoveInteractiveObject;

---
-- Aktiviert ein Interaktives Objekt, sodass es vom Spieler
-- aktiviert werden kann.
--
-- Der State bestimmt, ob es immer aktiviert werden kann, oder ob der Spieler
-- einen Helden benutzen muss. Wird der Parameter weggelassen, muss immer ein
-- Held das Objekt aktivieren.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: InteractiveObjectActivate&#x3C;/p&#x3E;
--
-- @param[type=string] _EntityName Skriptname des Objektes
-- @param[type=number] _State  State des Objektes
-- @within Anwenderfunktionen
--
function API.InteractiveObjectActivate(_EntityName, _State)
    if GUI then
        API.Bridge("API.InteractiveObjectActivate('" .._EntityName.. "', " ..tostring(_State).. ")");
        return;
    end
    if not IsExisting(_EntityName) then
        API.Warn("API.InteractiveObjectActivate: Entity \"" .._EntityName.. "\" is invalid!");
        return;
    end

    if not Logic.IsInteractiveObject(GetID(_EntityName)) then
        if IO[_EntityName] then
            IO[_EntityName].Inactive = false;
            IO[_EntityName].Used = false;
        end
    else
        API.ActivateIO(_EntityName, _State);
    end
end
InteractiveObjectActivate = API.InteractiveObjectActivate;

---
-- Deaktiviert ein interaktives Objekt, sodass es nicht mehr vom Spieler
-- benutzt werden kann.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: InteractiveObjectDeactivate&#x3C;/p&#x3E;
--
-- @param[type=string] _EntityName Scriptname des Objektes
-- @within Anwenderfunktionen
--
function API.InteractiveObjectDeactivate(_EntityName)
    if GUI then
        API.Bridge("API.InteractiveObjectDeactivate('" .._EntityName.. "')");
        return;
    end
    if not IsExisting(_EntityName) then
        API.Warn("API.InteractiveObjectDeactivate: Entity \"" .._EntityName.. "\" is invalid!");
        return;
    end

    if not Logic.IsInteractiveObject(GetID(_EntityName)) then
        if IO[_EntityName] then
            IO[_EntityName].Inactive = true;
        end
    else
        API.DeactivateIO(_EntityName);
    end
end
InteractiveObjectDeactivate = API.InteractiveObjectDeactivate;

---
-- Erzeugt eine Beschriftung für Custom Objects.
--
-- Im Questfenster werden die Namen von Custom Objects als ungesetzt angezeigt.
-- Mit dieser Funktion kann ein Name angelegt werden.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; AddCustomIOName&#x3C;/p&#x3E;
--
-- @param[type=string] _Key Typname des Entity
-- @param              _Text Text der Beschriftung
-- @within Anwenderfunktionen
--
-- @usage
-- API.AddCustomIOName("D_X_ChestClosed", {de = "Schatztruhe", en = "Treasure");
-- API.AddCustomIOName("D_X_ChestOpenEmpty", "Leere Schatztruhe");
--
function API.AddCustomIOName(_Key, _Text)
    if type(_Text) == "table" then
        local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";
        _Text = _Text[lang];
    end
    if GUI then
        API.Bridge("API.AddCustomIOName('" .._Key.. "', '" .._Text.. "')");
        return;
    end
    return BundleInteractiveObjects.Global:AddCustomIOName(_Key, _Text);
end
AddCustomIOName = API.AddCustomIOName;

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

BundleInteractiveObjects = {
    Global = {
        Data = {}
    },
    Local = {
        Data = {
            IOCustomNames = {},
            IOCustomNamesByEntityName = {},
        },
    },
}

-- Global Script ---------------------------------------------------------------

---
-- Initalisiert das Bundle im globalen Skript.
--
-- @within Internal
-- @local
--
function BundleInteractiveObjects.Global:Install()
    IO = {};
    self:OverrideVanillaBehavior();
end

---
-- Überschreibt Reward_ObjectInit, damit IO korrekt funktionieren.
--
-- @within Internal
-- @local
--
function BundleInteractiveObjects.Global:OverrideVanillaBehavior()
    if b_Reward_ObjectInit then
        b_Reward_ObjectInit.CustomFunction = function(_Behavior, _Quest)
            local eID = GetID(_Behavior.ScriptName);
            if eID == 0 then
                return;
            end
            QSB.InitalizedObjekts[eID] = _Quest.Identifier;
            
            local RewardTable = nil;
            if _Behavior.RewardType and _Behavior.RewardType ~= "-" then
                RewardTable = {Goods[_Behavior.RewardType], _Behavior.RewardAmount};
            end

            local CostsTable = nil;
            if _Behavior.FirstCostType and _Behavior.FirstCostType ~= "-" then
                CostsTable = {Goods[_Behavior.FirstCostType], _Behavior.FirstCostAmount};
                if _Behavior.SecondCostType and _Behavior.SecondCostType ~= "-" then
                    table.insert(CostsTable, Goods[_Behavior.SecondCostType]);
                    table.insert(CostsTable, _Behavior.SecondCostAmount);
                end
            end

            API.CreateObject{
                Name        = _Behavior.ScriptName,
                State       = _Behavior.UsingState or 0,
                Distance    = _Behavior.Distance,
                Waittime    = _Behavior.Waittime,
                Reward      = RewardTable,
                Costs       = CostsTable,
            };
        end
    end
end

---
-- Erzeugt ein interaktives Objekt. Dabei können sowohl interaktive
-- Objekte (alle mit I_X_), eine Auswahl von normalen Entities und
-- sogar (sichtbare) XD_ScriptEntities verwendet werden.
-- Name, Titel und Icon müssen immer angegeben werden. Die restlichen
-- Angaben hängen teilweise vom Typ der Entity, teilweise vom
-- Verwendungszweck ab.
--
-- @param[type=table] _Description Beschreibung
-- @within Internal
-- @local
--
function BundleInteractiveObjects.Global:CreateObject(_Description)
    local lang = Network.GetDesiredLanguage();

    self:HackOnInteractionEvent();
    self:RemoveInteractiveObject(_Description.Name);

    if type(_Description.Title) == "table" then
        _Description.Title = _Description.Title[lang];
    end
    if not _Description.Title or _Description.Title == "" then
        _Description.Title = (lang == "de" and "Interaktion") or "Interaction";
    end

    if type(_Description.Text) == "table" then
        _Description.Text = _Description.Text[lang];
    end
    if not _Description.Text then
        _Description.Text = "";
    end

    if type(_Description.WrongKnight) == "table" then
        _Description.WrongKnight = _Description.WrongKnight[lang];
    end
    _Description.WrongKnight = _Description.WrongKnight or "";

    if type(_Description.ConditionUnfulfilled) == "table" then
        _Description.ConditionUnfulfilled = _Description.ConditionUnfulfilled[lang];
    end
    _Description.ConditionUnfulfilled = _Description.ConditionUnfulfilled or "";

    _Description.Condition = _Description.Condition or function() return true end
    _Description.Callback = _Description.Callback or function() end
    _Description.Distance = _Description.Distance or 1200;
    _Description.Waittime = _Description.Waittime or 15;
    _Description.Texture = _Description.Texture or {14,10};
    _Description.Reward = _Description.Reward or {};
    _Description.Costs = _Description.Costs or {};
    _Description.State = _Description.State or 0;

    Logic.ExecuteInLuaLocalState([[
        QSB.IOList[#QSB.IOList+1] = "]].._Description.Name..[["
        if not BundleInteractiveObjects.Local.Data.InteractionHackStarted then
            BundleInteractiveObjects.Local:ActivateInteractiveObjectControl()
            BundleInteractiveObjects.Local.Data.InteractionHackStarted = true;
        end
    ]]);
    IO[_Description.Name] = API.InstanceTable(_Description);

    local eID = GetID(_Description.Name);
    if Logic.IsInteractiveObject(eID) == true then
        Logic.InteractiveObjectClearCosts(eID);
        Logic.InteractiveObjectClearRewards(eID);
        Logic.InteractiveObjectSetInteractionDistance(eID,_Description.Distance);
        Logic.InteractiveObjectSetTimeToOpen(eID,_Description.Waittime);
        Logic.InteractiveObjectAddRewards(eID,_Description.Reward[1],_Description.Reward[2]);
        if _Description.Costs[1] then
            Logic.InteractiveObjectAddCosts(eID, _Description.Costs[1], _Description.Costs[2]);
        end
        if _Description.Costs[3] then
            Logic.InteractiveObjectAddCosts(eID, _Description.Costs[3], _Description.Costs[4]);
        end

        Logic.InteractiveObjectSetAvailability(eID, true);
        Logic.InteractiveObjectSetPlayerState(eID, _Description.PlayerID or 1, _Description.State);
        Logic.InteractiveObjectSetRewardResourceCartType(eID, Entities.U_ResourceMerchant);
        Logic.InteractiveObjectSetRewardGoldCartType(eID, Entities.U_GoldCart);
        table.insert(HiddenTreasures,eID);
    end
end

---
-- Löscht ein interaktives Objekt.
--
-- Das Entity wird dabei nicht gelöscht. Es wird ausschließlich die
-- Konfiguration des Objektes entfernt.
--
-- @param[type=string] _EntityName Skriptname des IO
-- @within Internal
-- @local
--
function BundleInteractiveObjects.Global:RemoveInteractiveObject(_EntityName)
    for k,v in pairs(IO) do
        if k == _EntityName then
            Logic.ExecuteInLuaLocalState([[
                IO["]].._EntityName..[["] = nil;
            ]]);
            IO[_EntityName] = nil;
        end
    end
end

---
-- Erzeugt eine Beschriftung für Custom Objects.
--
-- Im Questfenster werden die Namen von Cusrom Objects als ungesetzt angezeigt.
-- Mit dieser Funktion kann ein Name angelegt werden.
--
-- @param[type=string] _Key Identifier der Beschriftung
-- @param[type=string] _Text Text der Beschriftung
-- @within Internal
-- @local
--
function BundleInteractiveObjects.Global:AddCustomIOName(_Key, _Text)
    if type(_Text) == "table" then
        local GermanText  = _Text.de;
        local EnglishText = _Text.en;

        Logic.ExecuteInLuaLocalState([[
            BundleInteractiveObjects.Local.Data.IOCustomNames["]].._Key..[["] = {
                de = "]]..GermanText..[[",
                en = "]]..EnglishText..[["
            }
        ]]);
    else
        Logic.ExecuteInLuaLocalState([[
            BundleInteractiveObjects.Local.Data.IOCustomNames["]].._Key..[["] = "]].._Text..[["
        ]]);
    end
end

---
-- Überschreibt die Events, die ausgelöst werden, wenn interaktive Objekte
-- benutzt werden.
--
-- @within Internal
-- @local
--
function BundleInteractiveObjects.Global:HackOnInteractionEvent()
    if not BundleInteractiveObjects.Global.Data.InteractionEventHacked then
        StartSimpleJobEx(BundleInteractiveObjects.Global.ControlInteractiveObjects);
        BundleInteractiveObjects.Global.Data.InteractionEventHacked = true;

        OnTreasureFound = function(_TreasureID, _PlayerID)
            for i=1, #HiddenTreasures do
                local HiddenTreasureID = HiddenTreasures[i]
                if HiddenTreasureID == _TreasureID then
                    Logic.InteractiveObjectSetAvailability(_TreasureID,false)
                    for PlayerID = 1, 8 do
                        Logic.InteractiveObjectSetPlayerState(_TreasureID,PlayerID, 2)
                    end
                    table.remove(HiddenTreasures,i)
                    HiddenTreasures[0] = #HiddenTreasures

                    local ActivationSound = "menu_left_prestige";
                    local eName = Logic.GetEntityName(_TreasureID);
                    if IO[eName] and IO[eName].ActivationSound then
                        ActivationSound = IO[eName].ActivationSound;
                    end
                    Logic.ExecuteInLuaLocalState("Play2DSound(" .. _PlayerID ..",'" .. ActivationSound .. "')");
                end
            end
        end

        GameCallback_OnObjectInteraction = function(__entityID_, _PlayerID)
            OnInteractiveObjectOpened(__entityID_, _PlayerID);
            OnTreasureFound(__entityID_, _PlayerID);
            local eName = Logic.GetEntityName(__entityID_);
            for k,v in pairs(IO)do
                if k == eName then
                    if not v.Used then
                        IO[k].Used = true;
                        v.Callback(v, _PlayerID);
                    end
                end
            end
        end

        GameCallback_ExecuteCustomObjectReward = function(_PlayerID, _SpawnPos, _Type, _Amount)
            local pos = GetPosition(_SpawnPos);
            local resCat = Logic.GetGoodCategoryForGoodType(_Type);
            local ID;
            if resCat == GoodCategories.GC_Resource then
                ID = Logic.CreateEntityOnUnblockedLand(Entities.U_ResourceMerchant, pos.X, pos.Y,0,_PlayerID);
            elseif _Type == Goods.G_Medicine then
                ID = Logic.CreateEntityOnUnblockedLand(Entities.U_Medicus, pos.X, pos.Y,0,_PlayerID);
            elseif _Type == Goods.G_Gold then
                ID = Logic.CreateEntityOnUnblockedLand(Entities.U_GoldCart, pos.X, pos.Y,0,_PlayerID);
            else
                ID = Logic.CreateEntityOnUnblockedLand(Entities.U_Marketer, pos.X, pos.Y,0,_PlayerID);
            end
            Logic.HireMerchant(ID,_PlayerID,_Type,_Amount,_PlayerID);
        end

        function QuestTemplate:AreObjectsActivated(objectList)
            for i=1, objectList[0] do
                if not objectList[-i] then
                    objectList[-i] = GetEntityId(objectList[i]);
                end
                local EntityName = Logic.GetEntityName(objectList[-i]);

                if Logic.IsInteractiveObject(objectList[-i]) then
                    if not IsInteractiveObjectOpen(objectList[-i]) then
                        return false;
                    end
                else
                    if not IO[EntityName] then
                        return;
                    end
                    if IO[EntityName].Used ~= true then
                        return false;
                    end
                end
            end
            return true;
        end
    end
end

---
-- Prüft für alle unbenutzten interaktiven Objekte, ob ihre Bedingung erfüllt
-- ist und erlaubt die Benutzung.
--
-- @within Internal
-- @local
--
function BundleInteractiveObjects.Global.ControlInteractiveObjects()
    for k,v in pairs(IO) do
        if not v.Used == true then
            v.ConditionFullfilled = v.Condition(v);
        end
    end
end

-- Local Script ----------------------------------------------------------------

---
-- Initalisiert das Bundle im lokalen Skript.
--
-- @within Internal
-- @local
--
function BundleInteractiveObjects.Local:Install()
    IO = Logic.CreateReferenceToTableInGlobaLuaState("IO");
end

---
-- Prüft, ob die Kosten für ein interaktives Objekt beglichen werden können.
--
-- @param[type=number] _PlayerID Spieler, der zahlt
-- @param[type=number] _Good Typ der Ware
-- @param[type=number] _Amount Menge der Ware
-- @within Internal
-- @local
--
function BundleInteractiveObjects.Local:CanBeBought(_PlayerID, _Good, _Amount)
    local AmountOfGoods = GetPlayerGoodsInSettlement(_Good, _PlayerID, true);
    if AmountOfGoods &#x3C; _Amount then
        return false;
    end
    return true;
end

---
-- Zieht die Kosten des Objektes aus dem Lagerhaus des Spielers ab.
--
-- @param[type=number] _PlayerID Spieler, der zahlt
-- @param[type=number] _Good Typ der Ware
-- @param[type=number] _Amount Menge der Ware
-- @within Internal
-- @local
--
function BundleInteractiveObjects.Local:BuyObject(_PlayerID, _Good, _Amount)
    if Logic.GetGoodCategoryForGoodType(_Good) ~= GoodCategories.GC_Resource and _Good ~= Goods.G_Gold then
        local buildings = GetPlayerEntities(_PlayerID,0);
        local goodAmount = _Amount;
        for i=1,#buildings do
            if Logic.IsBuilding(buildings[i]) == 1 and goodAmount &#x3E; 0 then
                if Logic.GetBuildingProduct(buildings[i]) == _Good then
                    local goodAmountInBuilding = Logic.GetAmountOnOutStockByIndex(buildings[i],0);
                    for j=1,goodAmountInBuilding do
                        API.Bridge("Logic.RemoveGoodFromStock("..buildings[i]..",".._Good..",1)");
                        goodAmount = goodAmount -1;
                    end
                end
            end
        end
    else
        API.Bridge("AddGood(".._Good..","..(_Amount*(-1))..",".._PlayerID..")");
    end
end

---
-- Überschreibt die Spielfunktione, die interaktive Objekte steuern.
--
-- @within Internal
-- @local
--
function BundleInteractiveObjects.Local:ActivateInteractiveObjectControl()
    g_Interaction.ActiveObjectsOnScreen = g_Interaction.ActiveObjectsOnScreen or {};
    g_Interaction.ActiveObjects = g_Interaction.ActiveObjects or {};

    GUI_Interaction.InteractiveObjectUpdate = function()
        local PlayerID = GUI.GetPlayerID();
        if g_Interaction.ActiveObjects == nil then
            return;
        end

        for i = 1, #g_Interaction.ActiveObjects do
            local ObjectID = g_Interaction.ActiveObjects[i];
            local X, Y = GUI.GetEntityInfoScreenPosition(ObjectID);
            local ScreenSizeX, ScreenSizeY = GUI.GetScreenSize();

            if X ~= 0 and Y ~= 0 and X &#x3E; -50 and Y &#x3E; -50 and X &#x3C; (ScreenSizeX + 50) and Y &#x3C; (ScreenSizeY + 50) then
                if Inside(ObjectID, g_Interaction.ActiveObjectsOnScreen) == false then
                    table.insert(g_Interaction.ActiveObjectsOnScreen, ObjectID);
                end
            else
                for i = 1, #g_Interaction.ActiveObjectsOnScreen do
                    if g_Interaction.ActiveObjectsOnScreen[i] == ObjectID then
                        table.remove(g_Interaction.ActiveObjectsOnScreen, i);
                    end
                end
            end
        end

        for i = 1, #g_Interaction.ActiveObjectsOnScreen do
            local Widget = "/InGame/Root/Normal/InteractiveObjects/" .. i;
            if XGUIEng.IsWidgetExisting(Widget) == 1 then
                local ObjectID = g_Interaction.ActiveObjectsOnScreen[i];
                local EntityType = Logic.GetEntityType(ObjectID);
                local X, Y = GUI.GetEntityInfoScreenPosition(ObjectID);
                local WidgetSize = {XGUIEng.GetWidgetScreenSize(Widget)};
                local BaseCosts = {Logic.InteractiveObjectGetCosts(ObjectID)};
                local EffectiveCosts = {Logic.InteractiveObjectGetEffectiveCosts(ObjectID, PlayerID)};
                local IsAvailable = Logic.InteractiveObjectGetAvailability(ObjectID);
                local eType = Logic.GetEntityType(ObjectID);
                local entityName = Logic.GetEntityName(ObjectID);
                local eTypeName = Logic.GetEntityTypeName(eType);
                local Disable = false;

                XGUIEng.SetWidgetScreenPosition(Widget, X - (WidgetSize[1]/2), Y - (WidgetSize[2]/2));

                if BaseCosts[1] ~= nil and EffectiveCosts[1] == nil and IsAvailable == true then
                    Disable = true;
                end
                local HasSpace = Logic.InteractiveObjectHasPlayerEnoughSpaceForRewards(ObjectID, PlayerID);
                if HasSpace == false then
                    Disable = true;
                end
                if Disable == true then
                    XGUIEng.DisableButton(Widget, 1);
                else
                    XGUIEng.DisableButton(Widget, 0);
                end

                if GUI_Interaction.InteractiveObjectUpdateEx1 ~= nil then
                    GUI_Interaction.InteractiveObjectUpdateEx1(Widget, EntityType);
                end
                if IO[entityName] then
                    BundleInteractiveObjects.Local:SetIcon(Widget, IO[entityName].Texture);
                end
                XGUIEng.ShowWidget(Widget, 1);
            end
        end

        for k,v in pairs(QSB.IOList) do
            local pID = GUI.GetPlayerID();
            local eType = Logic.GetEntityType(GetID(v));
            local eTypeName = Logic.GetEntityTypeName(eType);
            if eTypeName and v ~= "" then
                if  not(string.find(eTypeName,"I_X_")) and not(string.find(eTypeName,"Mine"))
                and not(string.find(eTypeName,"B_Wel")) and not(string.find(eTypeName,"B_Cis")) then
                    if IO[v].State == 0 and IO[v].Distance ~= nil and IO[v].Distance &#x3E; 0 then
                        local knights = {};
                        Logic.GetKnights(pID,knights);

                        local found = false;
                        for i=1,#knights do
                            if IsNear(knights[i], v, IO[v].Distance) then
                                found = true;
                                break;
                            end
                        end
                        if not IO[v].Used and not IO[v].Inactive then
                            if found then
                                ScriptCallback_ObjectInteraction(pID,GetID(v));
                            else
                                ScriptCallback_CloseObjectInteraction(pID,GetID(v));
                            end
                        else
                            ScriptCallback_CloseObjectInteraction(pID,GetID(v));
                        end
                    else
                        if not IO[v].Used and not IO[v].Inactive then
                            ScriptCallback_ObjectInteraction(pID,GetID(v));
                        else
                            ScriptCallback_CloseObjectInteraction(pID,GetID(v));
                        end
                    end
                end
            end
        end

        for i = #g_Interaction.ActiveObjectsOnScreen + 1, 2 do
            local Widget = "/InGame/Root/Normal/InteractiveObjects/" .. i;
            XGUIEng.ShowWidget(Widget, 0);
        end
    end

    GUI_Interaction.InteractiveObjectMouseOver_Orig_BundleInteractiveObjects = GUI_Interaction.InteractiveObjectMouseOver;
    GUI_Interaction.InteractiveObjectMouseOver = function()
        local PlayerID = GUI.GetPlayerID();
        local ButtonNumber = tonumber(XGUIEng.GetWidgetNameByID(XGUIEng.GetCurrentWidgetID()));
        local ObjectID = g_Interaction.ActiveObjectsOnScreen[ButtonNumber];
        local EntityType = Logic.GetEntityType(ObjectID);

        -- Führe für Minen und Brunnen Originalfunction aus
        if g_GameExtraNo &#x3E; 0 then
            local EntityTypeName = Logic.GetEntityTypeName(EntityType);
            if Inside (EntityTypeName, {"R_StoneMine", "R_IronMine", "B_Cistern", "I_X_TradePostConstructionSite"}) then
                GUI_Interaction.InteractiveObjectMouseOver_Orig_BundleInteractiveObjects();
                return;
            end
        end

        -- Führe für Ruinen Originalfunktion aus, wenn Skriptname Nummer ist
        local EntityTypeName = Logic.GetEntityTypeName(EntityType);
        if string.find(EntityTypeName, "^I_X_") and tonumber(Logic.GetEntityName(ObjectID)) ~= nil then
            GUI_Interaction.InteractiveObjectMouseOver_Orig_BundleInteractiveObjects();
            return;
        end

        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();
        local Costs = {Logic.InteractiveObjectGetEffectiveCosts(ObjectID, PlayerID)};
        local IsAvailable = Logic.InteractiveObjectGetAvailability(ObjectID);

        local TooltipTextKey;
        local TooltipDisabledTextKey;
        local eName = Logic.GetEntityName(ObjectID);

        if IsAvailable == true then
           TooltipTextKey = "InteractiveObjectAvailable";
        else
           TooltipTextKey = "InteractiveObjectNotAvailable";
        end
        if Logic.InteractiveObjectHasPlayerEnoughSpaceForRewards(ObjectID, PlayerID) == false then
           TooltipDisabledTextKey = "InteractiveObjectAvailableReward";
        end

        local CheckSettlement;
        if Costs and Costs[1] and Logic.GetGoodCategoryForGoodType(Costs[1]) ~= GoodCategories.GC_Resource then
           CheckSettlement = true;
        end

        if IO[eName] and IO[eName].Used ~= true then
            local title;
            local text;
            if IO[eName].Title or IO[eName].Text then
                title = IO[eName].Title or "";
                text  = IO[eName].Text or "";
            end
            Costs = IO[eName].Costs;
            if Costs and Costs[1] and Logic.GetGoodCategoryForGoodType(Costs[1]) ~= GoodCategories.GC_Resource then
                CheckSettlement = true;
            end
            BundleInteractiveObjects.Local:TextCosts(title, text, nil, {Costs[1], Costs[2], Costs[3], Costs[4]}, CheckSettlement);
            return;
        end
    end

    GUI_Interaction.InteractiveObjectClicked_Orig_BundleInteractiveObjects = GUI_Interaction.InteractiveObjectClicked
    GUI_Interaction.InteractiveObjectClicked = function()
        local i = tonumber(XGUIEng.GetWidgetNameByID(XGUIEng.GetCurrentWidgetID()));
        local eID = g_Interaction.ActiveObjectsOnScreen[i];
        local pID = GUI.GetPlayerID();
        local EntityType = Logic.GetEntityType(eID);
        local lang = Network.GetDesiredLanguage();
        lang = (lang == "de" and lang) or "en";

        -- Führe für Minen und Brunnen Originalfunction aus
        if g_GameExtraNo &#x3E; 0 then
            local EntityTypeName = Logic.GetEntityTypeName(EntityType);
            if Inside (EntityTypeName, {"R_StoneMine", "R_IronMine", "B_Cistern", "I_X_TradePostConstructionSite"}) then
                GUI_Interaction.InteractiveObjectClicked_Orig_BundleInteractiveObjects();
                return;
            end
        end
        -- Führe für Ruinen Originalfunktion aus, wenn Skriptname Nummer ist
        local EntityTypeName = Logic.GetEntityTypeName(EntityType);
        if string.find(EntityTypeName, "^I_X_") and tonumber(Logic.GetEntityName(eID)) ~= nil then
            GUI_Interaction.InteractiveObjectClicked_Orig_BundleInteractiveObjects();
            return;
        end

        for k,v in pairs(IO)do
            if eID == GetID(k)then
                BundleInteractiveObjects.Local:OnObjectClicked(v);
            end
        end
    end

    GUI_Interaction.DisplayQuestObjective_Orig_BundleInteractiveObjects = GUI_Interaction.DisplayQuestObjective
    GUI_Interaction.DisplayQuestObjective = function(_QuestIndex, _MessageKey)
        local lang = Network.GetDesiredLanguage();
        if lang ~= "de" then lang = "en" end

        local QuestIndexTemp = tonumber(_QuestIndex);
        if QuestIndexTemp then
            _QuestIndex = QuestIndexTemp;
        end

        local Quest, QuestType = GUI_Interaction.GetPotentialSubQuestAndType(_QuestIndex);
        local QuestObjectivesPath = "/InGame/Root/Normal/AlignBottomLeft/Message/QuestObjectives";
        XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomLeft/Message/QuestObjectives", 0);
        local QuestObjectiveContainer;
        local QuestTypeCaption;

        local ParentQuest = Quests[_QuestIndex];
        local ParentQuestIdentifier;
        if ParentQuest ~= nil
        and type(ParentQuest) == "table" then
            ParentQuestIdentifier = ParentQuest.Identifier;
        end
        local HookTable = {};

        g_CurrentDisplayedQuestID = _QuestIndex;

        if QuestType == Objective.Object then
            QuestObjectiveContainer = QuestObjectivesPath .. "/List"
            QuestTypeCaption = Wrapped_GetStringTableText(_QuestIndex, "UI_Texts/QuestInteraction")
            local ObjectList = {}

            for i = 1, Quest.Objectives[1].Data[0] do
                local ObjectType
                if Logic.IsEntityDestroyed(Quest.Objectives[1].Data[i]) then
                    ObjectType = g_Interaction.SavedQuestEntityTypes[_QuestIndex][i]
                else
                    ObjectType = Logic.GetEntityType(GetEntityId(Quest.Objectives[1].Data[i]))
                end
                local ObjectEntityName = Logic.GetEntityName(Quest.Objectives[1].Data[i]);
                local ObjectName = ""
                if ObjectType ~= 0 then
                    local ObjectTypeName = Logic.GetEntityTypeName(ObjectType)
                    ObjectName = Wrapped_GetStringTableText(_QuestIndex, "Names/" .. ObjectTypeName)
                    if ObjectName == "" then
                        ObjectName = Wrapped_GetStringTableText(_QuestIndex, "UI_ObjectNames/" .. ObjectTypeName)
                    end
                    if ObjectName == "" then
                        ObjectName = BundleInteractiveObjects.Local.Data.IOCustomNames[ObjectTypeName];
                        if type(ObjectName) == "table" then
                            local lang = Network.GetDesiredLanguage();
                            lang = (lang == "de" and "de") or "en";
                            ObjectName = ObjectName[lang];
                        end
                    end
                    if ObjectName == nil then
                        ObjectName = BundleInteractiveObjects.Local.Data.IOCustomNames[ObjectEntityName];
                        if type(ObjectName) == "table" then
                            local lang = Network.GetDesiredLanguage();
                            lang = (lang == "de" and "de") or "en";
                            ObjectName = ObjectName[lang];
                        end
                    end
                    if ObjectName == nil then
                        ObjectName = "Debug: ObjectName missing for " .. ObjectTypeName
                    end
                end
                table.insert(ObjectList, ObjectName)
            end
            for i = 1, 4 do
                local String = ObjectList[i]
                if String == nil then
                    String = ""
                end
                XGUIEng.SetText(QuestObjectiveContainer .. "/Entry" .. i, "{center}" .. String)
            end

            SetIcon(QuestObjectiveContainer .. "/QuestTypeIcon",{14, 10});
            XGUIEng.SetText(QuestObjectiveContainer.."/Caption","{center}"..QuestTypeCaption);
            XGUIEng.ShowWidget(QuestObjectiveContainer, 1);
        else
            GUI_Interaction.DisplayQuestObjective_Orig_BundleInteractiveObjects(_QuestIndex, _MessageKey);
        end
    end
end

---
-- Führt die Objektinteraktion aus.
--
-- @param[type=table]    _IO Table des IO
-- @within Internal
-- @local
--
function BundleInteractiveObjects.Local:OnObjectClicked(_IO)
    if not self:OnObjectClicked_DoesRewardFitInStorehouse(_IO) then
        return;
    end
    if not self:OnObjectClicked_CanPlayerPayCosts(_IO) then
        return;
    end
    if not self:OnObjectClicked_IsConditionFulfulled(_IO) then
        return;
    end

    local PlayerID = GUI.GetPlayerID();
    local EntityID = GetID(_IO.Name);
    if Logic.IsInteractiveObject(EntityID) == false then
        if _IO.Costs[1] ~= nil then
            self:BuyObject(PlayerID, _IO.Costs[1], _IO.Costs[2]);
        end
        if _IO.Costs[3] ~= nil then
            self:BuyObject(PlayerID, _IO.Costs[3], _IO.Costs[4]);
        end
        if _IO.Reward[1] ~= nil then
            GUI.SendScriptCommand("GameCallback_ExecuteCustomObjectReward("..PlayerID..",'".._IO.Name.."',".._IO.Reward[1]..",".._IO.Reward[2]..")");
        end
        Play2DSound(pID, _IO.ActivationSound or "menu_left_prestige");
        GUI.SendScriptCommand("GameCallback_OnObjectInteraction("..EntityID..","..PlayerID..")");
        return;
    end

    GUI_FeedbackSpeech.Add("SpeechOnly_CartsSent", g_FeedbackSpeech.Categories.CartsUnderway, nil, nil);
    Sound.FXPlay2DSound( "ui\\menu_click");
    GUI.ExecuteObjectInteraction(EntityID, PlayerID);
end

---
-- Prüft, ob die Aktivierungsbedinung erfüllt ist. Wenn das nicht der Fall
-- ist, wird eine optionale Nachricht angezeigt.
--
-- @param[type=table]    _IO Table des IO
-- @return[type=boolean] Bedingung ist erfüllt
-- @within Internal
-- @local
--
function BundleInteractiveObjects.Local:OnObjectClicked_IsConditionFulfulled(_IO)
    local PlayerID = GUI.GetPlayerID();
    local Language = (Network.GetDesiredLanguage() == "de" and "de") or "en";
    if not _IO.ConditionFullfilled then
        if _IO.ConditionUnfulfilled then
            local MessageText = _IO.ConditionUnfulfilled;
            if type(MessageText) == "table" then
                MessageText = MessageText[Language];
            end
            Message(MessageText);
        end
        return false;
    end
    return true;
end

---
-- Prüft, ob der Schatz in das Lagerhaus des Spielers passt und zeigt eine
-- Meldung an, sollte das nicht der Fall sein.
--
-- @param[type=table]    _IO Table des IO
-- @return[type=boolean] Schatz passt ins Lagerhaus
-- @within Internal
-- @local
--
function BundleInteractiveObjects.Local:OnObjectClicked_DoesRewardFitInStorehouse(_IO)
    local PlayerID = GUI.GetPlayerID();
    if not _IO.Reward or type(_IO.Reward[1]) ~= "number" then
        return true;
    end
    if  _IO.Reward[1] ~= Goods.G_Gold 
    and Logic.GetGoodCategoryForGoodType(_IO.Reward[1]) ~= GoodCategories.GC_Resource then
        return true;
    end
    if Logic.GetPlayerUnreservedStorehouseSpace(PlayerID) &#x3E;= _IO.Reward[2] then
        return true;
    end
    local MessageText = XGUIEng.GetStringTableText("Feedback_TextLines/TextLine_MerchantStorehouseSpace");
    Message(MessageText);
    return false;
end

---
-- Prüft, ob der Spieler die Kosten des interaktiven Objektes begleichen kann
-- und zeigt eine Meldung an, wenn das nicht der Fall ist.
--
-- @param[type=table]    _IO Table des IO
-- @return[type=boolean] Kosten können bezahlt werden
-- @within Internal
-- @local
--
function BundleInteractiveObjects.Local:OnObjectClicked_CanPlayerPayCosts(_IO)
    local PlayerID = GUI.GetPlayerID();
    local CanBuyBoolean = true;
    if not _IO.Costs or type(_IO.Costs[1]) ~= "number" then
        return true;
    end
    if _IO.Costs[2] then
        CanBuyBoolean = CanBuyBoolean and BundleInteractiveObjects.Local:CanBeBought(PlayerID, _IO.Costs[1], _IO.Costs[2]);
    end
    if _IO.Costs[4] then
        CanBuyBoolean = CanBuyBoolean and BundleInteractiveObjects.Local:CanBeBought(PlayerID, _IO.Costs[3], _IO.Costs[4]);
    end
    if not CanBuyBoolean then
        local CanNotBuyString = XGUIEng.GetStringTableText("Feedback_TextLines/TextLine_NotEnough_Resources");
        Message(CanNotBuyString);
    end
    return CanBuyBoolean;
end

---
-- Setzt den Kostentooltip des aktuellen Widgets.
--
-- @param[type=string]  _Title Titel des Tooltip
-- @param[type=string]  _Text Text des Tooltip
-- @param[type=string]  _DisabledText (optional) Textzusatz wenn inaktiv
-- @param[type=table]   _Costs Kostentabelle
-- @param[type=boolean] _InSettlement Kosten in Siedlung suchen
-- @within Internal
-- @local
--
function BundleInteractiveObjects.Local:TextCosts(_Title, _Text, _DisabledText, _Costs, _InSettlement)
    local TooltipContainerPath = "/InGame/Root/Normal/TooltipBuy"
    local TooltipContainer = XGUIEng.GetWidgetID(TooltipContainerPath)
    local TooltipNameWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Name")
    local TooltipDescriptionWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Text")
    local TooltipBGWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/BG")
    local TooltipFadeInContainer = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn")
    local TooltipCostsContainer = XGUIEng.GetWidgetID(TooltipContainerPath .. "/Costs")
    local PositionWidget = XGUIEng.GetCurrentWidgetID()
    GUI_Tooltip.ResizeBG(TooltipBGWidget, TooltipDescriptionWidget)
    GUI_Tooltip.SetCosts(TooltipCostsContainer, _Costs, _InSettlement)
    local TooltipContainerSizeWidgets = {TooltipContainer, TooltipCostsContainer, TooltipBGWidget}
    GUI_Tooltip.SetPosition(TooltipContainer, TooltipContainerSizeWidgets, PositionWidget, nil, true)
    GUI_Tooltip.OrderTooltip(TooltipContainerSizeWidgets, TooltipFadeInContainer, TooltipCostsContainer, PositionWidget, TooltipBGWidget)
    GUI_Tooltip.FadeInTooltip(TooltipFadeInContainer)

    _DisabledText = _DisabledText or "";
    local disabled = ""
    if XGUIEng.IsButtonDisabled(PositionWidget) == 1 and _DisabledText ~= "" and _Text ~= "" then
        disabled = disabled .. "{cr}{@color:255,32,32,255}" .. _DisabledText
    end

    XGUIEng.SetText(TooltipNameWidget, "{center}" .. _Title)
    XGUIEng.SetText(TooltipDescriptionWidget, _Text .. disabled)
    local Height = XGUIEng.GetTextHeight(TooltipDescriptionWidget, true)
    local W, H = XGUIEng.GetWidgetSize(TooltipDescriptionWidget)
    XGUIEng.SetWidgetSize(TooltipDescriptionWidget, W, Height)
end

---
-- Ändert die Textur eines Icons des aktuellen Widget.
-- TODO: Eigene Matrizen funktionieren nicht - Grund unbekannt.
--
-- @param[type=string] _Widget Icon Widget
-- @param              _Icon Icon Textur (Dateiname oder Positionsmatrix)
-- @within Internal
-- @local
--
function BundleInteractiveObjects.Local:SetIcon(_Widget, _Icon)
    if type(_Icon) == "table" then
        if type(_Icon[3]) == "string" then
            local ButtonState = 1;
            if XGUIEng.IsButton(_Widget) == 1 then
                ButtonState = 7;
            end

            local u0, u1, v0, v1;
            u0 = (_Icon[1] - 1) * 64;
            v0 = (_Icon[2] - 1) * 64;
            u1 = (_Icon[1]) * 64;
            v1 = (_Icon[2]) * 64;
            XGUIEng.SetMaterialAlpha(_Widget, ButtonState, 255);
            XGUIEng.SetMaterialTexture(_Widget, ButtonState, _Icon[3].. "big.png");
            XGUIEng.SetMaterialUV(_Widget, ButtonState, u0, v0, u1, v1);
        else
            SetIcon(_Widget, _Icon);
        end
    else
        local screenSize = {GUI.GetScreenSize()};
        local Scale = 330;
        if screenSize[2] &#x3E;= 800 then
            Scale = 260;
        end
        if screenSize[2] &#x3E;= 1000 then
            Scale = 210;
        end
        XGUIEng.SetMaterialAlpha(_Widget, 1, 255);
        XGUIEng.SetMaterialTexture(_Widget, 1, _file);
        XGUIEng.SetMaterialUV(_Widget, 1, 0, 0, Scale, Scale);
    end
end

-- -------------------------------------------------------------------------- --

Core:RegisterBundle("BundleInteractiveObjects");

-- -------------------------------------------------------------------------- --

---
-- Der Spieler muss bis zu 4 interaktive Objekte benutzen.
--
-- @param[type=string] _ScriptName1 Erstes Objekt
-- @param[type=string] _ScriptName2 (optional) Zweites Objekt
-- @param[type=string] _ScriptName3 (optional) Drittes Objekt
-- @param[type=string] _ScriptName4 (optional) Viertes Objekt
--
-- @within Goal
--
function Goal_ActivateSeveralObjects(...)
    return b_Goal_ActivateSeveralObjects:new(...);
end

b_Goal_ActivateSeveralObjects = {
    Name = "Goal_ActivateSeveralObjects",
    Description = {
        en = "Goal: Activate an interactive object",
        de = "Ziel: Aktiviere ein interaktives Objekt",
    },
    Parameter = {
        { ParameterType.Default, en = "Object name 1", de = "Skriptname 1" },
        { ParameterType.Default, en = "Object name 2", de = "Skriptname 2" },
        { ParameterType.Default, en = "Object name 3", de = "Skriptname 3" },
        { ParameterType.Default, en = "Object name 4", de = "Skriptname 4" },
    },
    ScriptNames = {};
}

function b_Goal_ActivateSeveralObjects:GetGoalTable()
    return {Objective.Object, { unpack(self.ScriptNames) } }
end

function b_Goal_ActivateSeveralObjects:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        assert(_Parameter ~= nil and _Parameter ~= "", "Goal_ActivateSeveralObjects: At least one IO needed!");
    end
    if _Parameter ~= nil and _Parameter ~= "" then
        table.insert(self.ScriptNames, _Parameter);
    end
end

function b_Goal_ActivateSeveralObjects:GetMsgKey()
    return "Quest_Object_Activate"
end

Core:RegisterBehavior(b_Goal_ActivateSeveralObjects);

</code></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundleinterfaceapperance.lua.html">
            <div class='doclink'>
                <div>BundleInterfaceApperance</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><code>-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundleInterfaceApperance                                     # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Dieses Bundle bietet dem Nutzer Funktionen zur Manipulation der Oberfläche
-- des Spiels. Der Mapper hat die Möglichkeit, eigene Texte und Grafiken im
-- Interface anzuzeigen.
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundleInterfaceApperance = {};

API = API or {};
QSB = QSB or {};

QSB.PlayerNames = {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Setzt eine Grafik als Bild für einen Icon oder einen Button.
--
-- Die Größe des Bildes ist auf 200x200 Pixel festgelegt. Es kann an jedem
-- beliebigen Ort im interen Verzeichnis oder auf der Festplatte liegen. Es
-- muss jedoch immer der korrekte Pfad angegeben werden.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Hinweis:&#x3C;/b&#x3E; Es kann vorkommen, dass das Bild nicht genau da ist, wo es
-- sein soll, sondern seine Position, je nach Auflösung, um ein paar Pixel
-- unterschiedlich ist.&#x3C;/p&#x3E;
--
-- @param[type=string] _widget Widgetpfad oder ID
-- @param[type=string] _file Pfad zur Datei
-- @within Anwenderfunktionen
--
function API.InterfaceSetTexture(_widget, _file)
    if not GUI then
        return;
    end
    BundleInterfaceApperance.Local:SetTexture(_widget, _file)
end
UserSetTexture = API.InterfaceSetTexture;

---
-- Setzt einen Icon aus einer benutzerdefinierten Icon Matrix.
--
-- Dabei müssen die Quellen nach gui_768, gui_920 und gui_1080 in der
-- entsprechenden Größe gepackt werden. Die Ordner liegen in graphics/textures.
-- Jede Map muss einen eigenen eindeutigen Namen für jede Grafik verwenden.
--
-- &#x3C;u&#x3E;Größen:&#x3C;/u&#x3E;
-- Die Gesamtgröße ergibt sich aus der Anzahl der Buttons und der Pixelbreite
-- für die jeweilige Grö0e. z.B. 64 Buttons -&#x3E; Größe * 8 x Größe * 8
-- &#x3C;ul&#x3E;
-- &#x3C;li&#x3E;768: 41x41&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;960: 52x52&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;1200: 64x64&#x3C;/li&#x3E;
-- &#x3C;/ul&#x3E;
--
-- &#x3C;u&#x3E;Namenskonvention:&#x3C;/u&#x3E;
-- Die Namenskonvention wird durch das Spiel vorgegeben. Je nach Größe sind
-- die Namen der Matrizen erweitert mit .png, big.png und verybig.png. Du
-- gibst also niemals die Dateiendung mit an!
-- &#x3C;ul&#x3E;
-- &#x3C;li&#x3E;Für normale Icons: _Name .. .png&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;Für große Icons: _Name .. big.png&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;Für riesige Icons: _Name .. verybig.png&#x3C;/li&#x3E;
-- &#x3C;/ul&#x3E;
--
-- @param[type=string] _WidgetID Widgetpfad oder ID
-- @param[type=table]  _Coordinates Koordinaten
-- @param[type=number] _Size Größe des Icon
-- @param[type=string] _Name Name der Icon Matrix
-- @within Anwenderfunktionen
--
function API.InterfaceSetIcon(_WidgetID, _Coordinates, _Size, _Name)
    if not GUI then
        return;
    end
    BundleInterfaceApperance.Local:SetIcon(_WidgetID, _Coordinates, _Size, _Name)
end
UserSetIcon = API.InterfaceSetIcon;

---
-- Ändert den aktuellen Tooltip mit der Beschreibung.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; UserSetTextNormal&#x3C;/p&#x3E;
--
-- Die Funtion ermittelt das aktuelle GUI Widget und ändert den Text des
-- Tooltip. Dazu muss die Funktion innerhalb der Mouseover-Funktion eines
-- Buttons oder Widgets mit Tooltip aufgerufen werden.
--
-- Die Funktion kann auch mit deutsch/english lokalisierten Tabellen als
-- Text gefüttert werden. In diesem Fall wird der deutsche Text genommen,
-- wenn es sich um eine deutsche Spielversion handelt. Andernfalls wird
-- immer der englische Text verwendet.
--
-- @param[type=string] _title        Titel des Tooltip
-- @param[type=string] _text         Text des Tooltip
-- @param[type=string] _disabledText Textzusatz wenn inaktiv
-- @within Anwenderfunktionen
--
function API.InterfaceSetTooltipNormal(_title, _text, _disabledText)
    if not GUI then
        return;
    end
    BundleInterfaceApperance.Local:TextNormal(_title, _text, _disabledText);
end
UserSetTextNormal = API.InterfaceSetTooltipNormal;

---
-- Ändert den aktuellen Tooltip mit der Beschreibung und den Kosten.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; UserSetTextBuy&#x3C;/p&#x3E;
--
-- @see API.InterfaceSetTooltipNormal
--
-- @param[type=string]  _title        Titel des Tooltip
-- @param[type=string]  _text         Text des Tooltip
-- @param[type=string]  _disabledText Textzusatz wenn inaktiv
-- @param[type=table]   _costs        Kostentabelle
-- @param[type=boolean] _inSettlement Kosten in Siedlung suchen
-- @within Anwenderfunktionen
--
function API.InterfaceSetTooltipCosts(_title,_text,_disabledText,_costs,_inSettlement)
    if not GUI then
        return;
    end
    BundleInterfaceApperance.Local:TextCosts(_title,_text,_disabledText,_costs,_inSettlement);
end
UserSetTextBuy = API.InterfaceSetTooltipCosts;

---
-- Gibt den Namen des Territoriums zurück.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; GetTerritoryName&#x3C;/p&#x3E;
--
-- @param[type=number] _TerritoryID ID des Territoriums
-- @return[type=string]  Name des Territorium
-- @within Anwenderfunktionen
--
function API.InterfaceGetTerritoryName(_TerritoryID)
    local Name = Logic.GetTerritoryName(_TerritoryID);
    local MapType = Framework.GetCurrentMapTypeAndCampaignName();
    if MapType == 1 or MapType == 3 then
        return Name;
    end

    local MapName = Framework.GetCurrentMapName();
    local StringTable = "Map_" .. MapName;
    local TerritoryName = string.gsub(Name, " ","");
    TerritoryName = XGUIEng.GetStringTableText(StringTable .. "/Territory_" .. TerritoryName);
    if TerritoryName == "" then
        TerritoryName = Name .. "(key?)";
    end
    return TerritoryName;
end
GetTerritoryName = API.InterfaceGetTerritoryName;

---
-- Gibt den Namen des Spielers zurück.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; GetPlayerName&#x3C;/p&#x3E;
--
-- @param[type=number] _PlayerID ID des Spielers
-- @return[type=string]  Name des Spielers
-- @within Anwenderfunktionen
--
function API.InterfaceGetPlayerName(_PlayerID)
    local PlayerName = Logic.GetPlayerName(_PlayerID);
    local name = QSB.PlayerNames[_PlayerID];
    if name ~= nil and name ~= "" then
        PlayerName = name;
    end

    local MapType = Framework.GetCurrentMapTypeAndCampaignName();
    local MutliplayerMode = Framework.GetMultiplayerMapMode(Framework.GetCurrentMapName(), MapType);

    if MutliplayerMode &#x3E; 0 then
        return PlayerName;
    end
    if MapType == 1 or MapType == 3 then
        local PlayerNameTmp, PlayerHeadTmp, PlayerAITmp = Framework.GetPlayerInfo(_PlayerID);
        if PlayerName ~= "" then
            return PlayerName;
        end
        return PlayerNameTmp;
    end
end
GetPlayerName_OrigName = GetPlayerName;
GetPlayerName = API.InterfaceGetPlayerName;

---
-- Gibt dem Spieler einen neuen Namen.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; SetPlayerName&#x3C;/p&#x3E;
--
-- @param[type=number] _playerID ID des Spielers
-- @param[type=string] _name Name des Spielers
-- @within Anwenderfunktionen
--
function API.InterfaceSetPlayerName(_playerID,_name)
    assert(type(_playerID) == "number");
    assert(type(_name) == "string");
    if not GUI then
        Logic.ExecuteInLuaLocalState("SetPlayerName(".._playerID..",'".._name.."')");
    else
        GUI_MissionStatistic.PlayerNames[_playerID] = _name;
        GUI.SendScriptCommand("QSB.PlayerNames[".._playerID.."] = '".._name.."'");
    end
    QSB.PlayerNames[_playerID] = _name;
end
SetPlayerName = API.InterfaceSetPlayerName;

---
-- Setzt zu Spielbeginn eine andere Spielerfarbe.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _Color Spielerfarbe
-- @param[type=number] _Logo Logo (optional)
-- @param[type=number] _Pattern Pattern (optional)
-- @within Anwenderfunktionen
--
function API.InterfaceSetPlayerColor(_PlayerID, _Color, _Logo, _Pattern)
    if GUI then
        return;
    end
    g_ColorIndex["ExtraColor1"] = 16;
    g_ColorIndex["ExtraColor2"] = 17;

    local Type    = type(_Color);
    local Col     = (type(_Color) == "string" and g_ColorIndex[_Color]) or _Color;
    local Logo    = _Logo or -1;
    local Pattern = _Pattern or -1;

    StartSimpleJobEx( function(Col, _PlayerID, _Logo, _Pattern)
        Logic.PlayerSetPlayerColor(_PlayerID, Col, _Logo, _Pattern);
        return true;
    end, Col, _PlayerID, Logo, Pattern);
end

---
-- Setzt das Portrait des Spielers.
--
-- Dabei gibt es 3 verschiedene Varianten:
-- &#x3C;ul&#x3E;
-- &#x3C;li&#x3E;Wenn _Portrait nicht gesetzt wird, wird das Portrait des Primary
-- Knight genommen.&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;Wenn _Portrait ein existierendes Entity ist, wird anhand des Typs
-- das Portrait bestimmt.&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;Wenn _Portrait der Modellname eines Portrait ist, wird der Wert
-- als Portrait gesetzt.&#x3C;/li&#x3E;
-- &#x3C;/ul&#x3E;
--
-- Wenn kein Portrait bestimmt werden kann, wird H_NPC_Generic_Trader verwendet.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=string] _Portrait Name des Models
-- @within Anwenderfunktionen
--
-- @usage -- Primary Knight
-- API.InterfaceSetPlayerPortrait(2);
-- -- Durch Entity
-- API.InterfaceSetPlayerPortrait(2, "amma");
-- -- Durch Modelname
-- API.InterfaceSetPlayerPortrait(2, "H_NPC_Monk_AS");
--
function API.InterfaceSetPlayerPortrait(_PlayerID, _Portrait)
    if not _PlayerID or type(_PlayerID) ~= "number" or (_PlayerID &#x3C; 1 or _PlayerID &#x3E; 8) then
        API.Fatal("API.InterfaceSetPlayerPortrait: Invalid player ID!");
        return;
    end
    if not GUI then
        local Portrait = (_Portrait ~= nil and "'" .._Portrait.. "'") or "nil";
        API.Bridge("API.InterfaceSetPlayerPortrait(" .._PlayerID.. ", " ..Portrait.. ")")
        return;
    end
    
    if _Portrait == nil then
        BundleInterfaceApperance.Local:SetPlayerPortraitByPrimaryKnight(_PlayerID);
        return;
    end
    if _Portrait ~= nil and IsExisting(_Portrait) then
        BundleInterfaceApperance.Local:SetPlayerPortraitBySettler(_PlayerID, _Portrait);
        return;
    end
    BundleInterfaceApperance.Local:SetPlayerPortraitByModelName(_PlayerID, _Portrait);
end

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

BundleInterfaceApperance = {
    Global = {},
    Local = {}
};

-- Local Script ----------------------------------------------------------------

---
-- Initialisiert das Bundle im lokalen Skript.
-- @within Internal
-- @local
--
function BundleInterfaceApperance.Local:Install()
    StartMissionGoodOrEntityCounter = function(_Icon, _AmountToReach)
        if type(_Icon) == "string" then
            BundleInterfaceApperance.Local:SetTexture("/InGame/Root/Normal/MissionGoodOrEntityCounter/Icon", _Icon);
        else
            if type(_Icon[3]) == "string" then
                BundleInterfaceApperance.Local:SetIcon("/InGame/Root/Normal/MissionGoodOrEntityCounter/Icon", _Icon, 64, _Icon[3]);
            else
                SetIcon("/InGame/Root/Normal/MissionGoodOrEntityCounter/Icon", _Icon);
            end
        end

        g_MissionGoodOrEntityCounterAmountToReach = _AmountToReach;
        g_MissionGoodOrEntityCounterIcon = _Icon;

        XGUIEng.ShowWidget("/InGame/Root/Normal/MissionGoodOrEntityCounter", 1);
    end
end

---
-- Setzt das Portrait des Spielers anhand des Primary Knight.
-- @param[type=number] _PlayerID ID des Spielers
-- @within Internal
-- @local
--
function BundleInterfaceApperance.Local:SetPlayerPortraitByPrimaryKnight(_PlayerID)
    local KnightID = Logic.GetKnightID(_PlayerID);
    if KnightID == 0 then
        return;
    end
    local KnightType = Logic.GetEntityType(KnightID);
    local KnightTypeName = Logic.GetEntityTypeName(KnightType);
    local HeadModelName = "H" .. string.sub(KnightTypeName, 2, 8) .. "_" .. string.sub(KnightTypeName, 9);

    if not Models["Heads_" .. HeadModelName] then
        HeadModelName = "H_NPC_Generic_Trader";
    end
    g_PlayerPortrait[_PlayerID] = HeadModelName;
end

---
-- Setzt das Portrait des Spielers anhand der übergebenen Script Entity.
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=string] _Portrait Skriptname des Entity
-- @within Internal
-- @local
--
function BundleInterfaceApperance.Local:SetPlayerPortraitBySettler(_PlayerID, _Portrait)
    local PortraitMap = {
        ["U_KnightChivalry"]           = "H_Knight_Chivalry",
        ["U_KnightHealing"]            = "H_Knight_Healing",
        ["U_KnightPlunder"]            = "H_Knight_Plunder",
        ["U_KnightRedPrince"]          = "H_Knight_RedPrince",
        ["U_KnightSabatta"]            = "H_Knight_Sabatt",
        ["U_KnightSong"]               = "H_Knight_Song",
        ["U_KnightTrading"]            = "H_Knight_Trading",
        ["U_KnightWisdom"]             = "H_Knight_Wisdom",
        ["U_NPC_Amma_NE"]              = "H_NPC_Amma",
        ["U_NPC_Castellan_ME"]         = "H_NPC_Castellan_ME",
        ["U_NPC_Castellan_NA"]         = "H_NPC_Castellan_NA",
        ["U_NPC_Castellan_NE"]         = "H_NPC_Castellan_NE",
        ["U_NPC_Castellan_SE"]         = "H_NPC_Castellan_SE",
        ["U_MilitaryBandit_Ranged_ME"] = "H_NPC_Mercenary_ME",
        ["U_MilitaryBandit_Melee_NA"]  = "H_NPC_Mercenary_NA",
        ["U_MilitaryBandit_Melee_NE"]  = "H_NPC_Mercenary_NE",
        ["U_MilitaryBandit_Melee_SE"]  = "H_NPC_Mercenary_SE",
        ["U_NPC_Monk_ME"]              = "H_NPC_Monk_ME",
        ["U_NPC_Monk_NA"]              = "H_NPC_Monk_NA",
        ["U_NPC_Monk_NE"]              = "H_NPC_Monk_NE",
        ["U_NPC_Monk_SE"]              = "H_NPC_Monk_SE",
        ["U_NPC_Villager01_ME"]        = "H_NPC_Villager01_ME",
        ["U_NPC_Villager01_NA"]        = "H_NPC_Villager01_NA",
        ["U_NPC_Villager01_NE"]        = "H_NPC_Villager01_NE",
        ["U_NPC_Villager01_SE"]        = "H_NPC_Villager01_SE",
    }

    if g_GameExtraNo &#x3E; 0 then
        PortraitMap["U_KnightPraphat"]           = "H_Knight_Praphat";
        PortraitMap["U_KnightSaraya"]            = "H_Knight_Saraya";
        PortraitMap["U_KnightKhana"]             = "H_Knight_Khana";
        PortraitMap["U_MilitaryBandit_Melee_AS"] = "H_NPC_Mercenary_AS";
        PortraitMap["U_NPC_Castellan_AS"]        = "H_NPC_Castellan_AS";
        PortraitMap["U_NPC_Villager_AS"]         = "H_NPC_Villager_AS";
        PortraitMap["U_NPC_Monk_AS"]             = "H_NPC_Monk_AS";
        PortraitMap["U_NPC_Monk_Khana"]          = "H_NPC_Monk_Khana";
    end

    local HeadModelName = "H_NPC_Generic_Trader";
    local EntityID = GetID(_Portrait);
    if EntityID ~= 0 then
        local EntityType = Logic.GetEntityType(EntityID);
        local EntityTypeName = Logic.GetEntityTypeName(EntityType);
        HeadModelName = PortraitMap[EntityTypeName] or "H_NPC_Generic_Trader";
        if not HeadModelName then
            HeadModelName = "H_NPC_Generic_Trader";
        end
    end
    g_PlayerPortrait[_PlayerID] = HeadModelName;
end

---
-- Setzt das Portrait des Spielers anhand des angegebenen Models.
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=string] _Portrait Name des Models
-- @within Internal
-- @local
--
function BundleInterfaceApperance.Local:SetPlayerPortraitByModelName(_PlayerID, _Portrait)
    if not Models["Heads_" .. tostring(_Portrait)] then
        _Portrait = "H_NPC_Generic_Trader";
    end
    g_PlayerPortrait[_PlayerID] = _Portrait;
end

---
-- Setzt einen Icon aus einer benutzerdefinerten Datei.
--
-- @param[type=string] _widget Widgetpfad oder ID
-- @param[type=string] _file Pfad zur Datei
-- @within Internal
-- @local
--
function BundleInterfaceApperance.Local:SetTexture(_widget, _file)
    assert((type(_widget) == "string" or type(_widget) == "number"));
    local wID = (type(_widget) == "string" and XGUIEng.GetWidgetID(_widget)) or _widget;
    local screenSize = {GUI.GetScreenSize()};

    local state = 1;
    if XGUIEng.IsButton(wID) == 1 then
        state = 7;
    end

    local Scale = 330;
    if screenSize[2] &#x3E;= 800 then
        Scale = 260;
    end
    if screenSize[2] &#x3E;= 1000 then
        Scale = 210;
    end
    XGUIEng.SetMaterialAlpha(wID, state, 255);
    XGUIEng.SetMaterialTexture(wID, state, _file);
    XGUIEng.SetMaterialUV(wID, state, 0, 0, Scale, Scale);
end

---
-- Setzt einen Icon aus einer benutzerdefinierten Matrix.
--
-- @param[type=string] _WidgetID Widgetpfad oder ID
-- @param[type=table]  _Coordinates Koordinaten
-- @param[type=number] _Size Größe des Icon
-- @param[type=string] _Name Name der Icon Matrix
-- @within Internal
-- @local
--
function BundleInterfaceApperance.Local:SetIcon(_WidgetID, _Coordinates, _Size, _Name)
    if _Name == nil then
        _Name = "usericons";
    end
    if _Size == nil then
        _Size = 64;
    end

    if _Size == 44 then
        _Name = _Name .. ".png"
    end
    if _Size == 64 then
        _Name = _Name .. "big.png"
    end
    if _Size == 128 then
        _Name = _Name .. "verybig.png"
    end

    local u0, u1, v0, v1;
    u0 = (_Coordinates[1] - 1) * _Size;
    v0 = (_Coordinates[2] - 1) * _Size;
    u1 = (_Coordinates[1]) * _Size;
    v1 = (_Coordinates[2]) * _Size;

    State = 1;
    if XGUIEng.IsButton(_WidgetID) == 1 then
        State = 7;
    end
    XGUIEng.SetMaterialAlpha(_WidgetID, State, 255);
    XGUIEng.SetMaterialTexture(_WidgetID, State, _Name);
    XGUIEng.SetMaterialUV(_WidgetID, State, u0, v0, u1, v1);
end

---
-- Setzt einen Beschreibungstooltip.
--
-- @param[type=string] _title        Titel des Tooltip
-- @param[type=string] _text         Text des Tooltip
-- @param[type=string] _disabledText Textzusatz wenn inaktiv
-- @within Internal
-- @local
--
function BundleInterfaceApperance.Local:TextNormal(_title, _text, _disabledText)
    local lang = Network.GetDesiredLanguage()
    if lang ~= "de" then lang = "en" end

    if type(_title) == "table" then
        _title = _title[lang];
    end
    if type(_text) == "table" then
        _text = _text[lang];
    end
    _text = _text or "";
    if type(_disabledText) == "table" then
        _disabledText = _disabledText[lang];
    end

    local TooltipContainerPath = "/InGame/Root/Normal/TooltipNormal"
    local TooltipContainer = XGUIEng.GetWidgetID(TooltipContainerPath)
    local TooltipNameWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Name")
    local TooltipDescriptionWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Text")
    local TooltipBGWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/BG")
    local TooltipFadeInContainer = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn")
    local PositionWidget = XGUIEng.GetCurrentWidgetID()
    GUI_Tooltip.ResizeBG(TooltipBGWidget, TooltipDescriptionWidget)
    local TooltipContainerSizeWidgets = {TooltipBGWidget}
    GUI_Tooltip.SetPosition(TooltipContainer, TooltipContainerSizeWidgets, PositionWidget)
    GUI_Tooltip.FadeInTooltip(TooltipFadeInContainer)

    _disabledText = _disabledText or "";
    local disabled = "";
    if XGUIEng.IsButtonDisabled(PositionWidget) == 1 and _disabledText ~= "" and _text ~= "" then
        disabled = disabled .. "{cr}{@color:255,32,32,255}" .. _disabledText
    end

    XGUIEng.SetText(TooltipNameWidget, "{center}" .. _title)
    XGUIEng.SetText(TooltipDescriptionWidget, _text .. disabled)
    local Height = XGUIEng.GetTextHeight(TooltipDescriptionWidget, true)
    local W, H = XGUIEng.GetWidgetSize(TooltipDescriptionWidget)
    XGUIEng.SetWidgetSize(TooltipDescriptionWidget, W, Height)
end

---
-- Setzt den Kostentooltip.
--
-- @param[type=string]  _title        Titel des Tooltip
-- @param[type=string]  _text         Text des Tooltip
-- @param[type=string]  _disabledText Textzusatz wenn inaktiv
-- @param[type=table]   _costs        Kostentabelle
-- @param[type=boolean] _inSettlement Kosten in Siedlung suchen
-- @within Internal
-- @local
--
function BundleInterfaceApperance.Local:TextCosts(_title,_text,_disabledText,_costs,_inSettlement)
    local lang = Network.GetDesiredLanguage()
    if lang ~= "de" then lang = "en" end
    _costs = _costs or {};

    if type(_title) == "table" then
        _title = _title[lang];
    end
    if type(_text) == "table" then
        _text = _text[lang];
    end
    _text = _text or "";
    if type(_disabledText) == "table" then
        _disabledText = _disabledText[lang];
    end

    local TooltipContainerPath = "/InGame/Root/Normal/TooltipBuy"
    local TooltipContainer = XGUIEng.GetWidgetID(TooltipContainerPath)
    local TooltipNameWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Name")
    local TooltipDescriptionWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Text")
    local TooltipBGWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/BG")
    local TooltipFadeInContainer = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn")
    local TooltipCostsContainer = XGUIEng.GetWidgetID(TooltipContainerPath .. "/Costs")
    local PositionWidget = XGUIEng.GetCurrentWidgetID()
    GUI_Tooltip.ResizeBG(TooltipBGWidget, TooltipDescriptionWidget)
    GUI_Tooltip.SetCosts(TooltipCostsContainer, _costs, _inSettlement)
    local TooltipContainerSizeWidgets = {TooltipContainer, TooltipCostsContainer, TooltipBGWidget}
    GUI_Tooltip.SetPosition(TooltipContainer, TooltipContainerSizeWidgets, PositionWidget, nil, true)
    GUI_Tooltip.OrderTooltip(TooltipContainerSizeWidgets, TooltipFadeInContainer, TooltipCostsContainer, PositionWidget, TooltipBGWidget)
    GUI_Tooltip.FadeInTooltip(TooltipFadeInContainer)

    _disabledText = _disabledText or "";
    local disabled = ""
    if XGUIEng.IsButtonDisabled(PositionWidget) == 1 and _disabledText ~= "" and _text ~= "" then
        disabled = disabled .. "{cr}{@color:255,32,32,255}" .. _disabledText
    end

    XGUIEng.SetText(TooltipNameWidget, "{center}" .. _title)
    XGUIEng.SetText(TooltipDescriptionWidget, _text .. disabled)
    local Height = XGUIEng.GetTextHeight(TooltipDescriptionWidget, true)
    local W, H = XGUIEng.GetWidgetSize(TooltipDescriptionWidget)
    XGUIEng.SetWidgetSize(TooltipDescriptionWidget, W, Height)
end

-- -------------------------------------------------------------------------- --

Core:RegisterBundle("BundleInterfaceApperance");

</code></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundleinterfacefeaturevisibility.lua.html">
            <div class='doclink'>
                <div>BundleInterfaceFeatureVisibility</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><code>-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundleInterfaceFeatureVisibility                             # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Dieses Bundle bietet dem Nutzer Funktionen um ausgewählte Buttons und
-- Widgets auszublenden oder einzublenden. Auf diese Weise können dem Spieler
-- Funktionalitäten vorenthalten werden.
--
-- &#x3C;p&#x3E;&#x3C;a href="#API.InterfaceHideBuildMenu"&#x3E;Interface-Steuerung&#x3C;/a&#x3E;&#x3C;/p&#x3E;
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundleInterfaceFeatureVisibility = {};

API = API or {};
QSB = QSB or {};

QSB.PlayerNames = {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Graut die Minimap aus oder macht sie wieder verwendbar.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Hinweis:&#x3C;/b&#x3E; Diese Änderung bleibt auch nach dem Laden eines Spielstandes
-- aktiv und muss explizit zurückgenommen werden!&#x3C;/p&#x3E;
--
-- @param[type=boolean] _Flag Widget versteckt
-- @within Anwenderfunktionen
--
function API.InterfaceHideMinimap(_Flag)
    if not GUI then
        Logic.ExecuteInLuaLocalState("API.InterfaceHideMinimap(" ..tostring(_Flag).. ")");
        return;
    end

    BundleInterfaceFeatureVisibility.Local:HideInterfaceButton(
        "/InGame/Root/Normal/AlignBottomRight/MapFrame/Minimap/MinimapOverlay",
        _Flag
    );
    BundleInterfaceFeatureVisibility.Local:HideInterfaceButton(
        "/InGame/Root/Normal/AlignBottomRight/MapFrame/Minimap/MinimapTerrain",
        _Flag
    );
end

---
-- Versteckt den Umschaltknopf der Minimap oder blendet ihn ein.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Hinweis:&#x3C;/b&#x3E; Diese Änderung bleibt auch nach dem Laden eines Spielstandes
-- aktiv und muss explizit zurückgenommen werden!&#x3C;/p&#x3E;
--
-- @param[type=boolean] _Flag Widget versteckt
-- @within Anwenderfunktionen
--
function API.InterfaceHideToggleMinimap(_Flag)
    if not GUI then
        Logic.ExecuteInLuaLocalState("API.InterfaceHideToggleMinimap(" ..tostring(_Flag).. ")");
        return;
    end

    BundleInterfaceFeatureVisibility.Local:HideInterfaceButton(
        "/InGame/Root/Normal/AlignBottomRight/MapFrame/MinimapButton",
        _Flag
    );
end

---
-- Versteckt den Button des Diplomatiemenü oder blendet ihn ein.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Hinweis:&#x3C;/b&#x3E; Diese Änderung bleibt auch nach dem Laden eines Spielstandes
-- aktiv und muss explizit zurückgenommen werden!&#x3C;/p&#x3E;
--
-- @param[type=boolean] _Flag Widget versteckt
-- @within Anwenderfunktionen
--
function API.InterfaceHideDiplomacyMenu(_Flag)
    if not GUI then
        Logic.ExecuteInLuaLocalState("API.InterfaceHideDiplomacyMenu(" ..tostring(_Flag).. ")");
        return;
    end

    BundleInterfaceFeatureVisibility.Local:HideInterfaceButton(
        "/InGame/Root/Normal/AlignBottomRight/MapFrame/DiplomacyMenuButton",
        _Flag
    );
end

---
-- Versteckt den Button des Produktionsmenü oder blendet ihn ein.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Hinweis:&#x3C;/b&#x3E; Diese Änderung bleibt auch nach dem Laden eines Spielstandes
-- aktiv und muss explizit zurückgenommen werden!&#x3C;/p&#x3E;
--
-- @param[type=boolean] _Flag Widget versteckt
-- @within Anwenderfunktionen
--
function API.InterfaceHideProductionMenu(_Flag)
    if not GUI then
        Logic.ExecuteInLuaLocalState("API.InterfaceHideProductionMenu(" ..tostring(_Flag).. ")");
        return;
    end

    BundleInterfaceFeatureVisibility.Local:HideInterfaceButton(
        "/InGame/Root/Normal/AlignBottomRight/MapFrame/ProductionMenuButton",
        _Flag
    );
end

---
-- Versteckt den Button des Wettermenüs oder blendet ihn ein.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Hinweis:&#x3C;/b&#x3E; Diese Änderung bleibt auch nach dem Laden eines Spielstandes
-- aktiv und muss explizit zurückgenommen werden!&#x3C;/p&#x3E;
--
-- @param[type=boolean] _Flag Widget versteckt
-- @within Anwenderfunktionen
--
function API.InterfaceHideWeatherMenu(_Flag)
    if not GUI then
        Logic.ExecuteInLuaLocalState("API.InterfaceHideWeatherMenu(" ..tostring(_Flag).. ")");
        return;
    end

    BundleInterfaceFeatureVisibility.Local:HideInterfaceButton(
        "/InGame/Root/Normal/AlignBottomRight/MapFrame/WeatherMenuButton",
        _Flag
    );
end

---
-- Versteckt den Button zum Territorienkauf oder blendet ihn ein.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Hinweis:&#x3C;/b&#x3E; Diese Änderung bleibt auch nach dem Laden eines Spielstandes
-- aktiv und muss explizit zurückgenommen werden!&#x3C;/p&#x3E;
--
-- @param[type=boolean] _Flag Widget versteckt
-- @within Anwenderfunktionen
--
function API.InterfaceHideBuyTerritory(_Flag)
    if not GUI then
        Logic.ExecuteInLuaLocalState("API.InterfaceHideBuyTerritory(" ..tostring(_Flag).. ")");
        return;
    end

    BundleInterfaceFeatureVisibility.Local:HideInterfaceButton(
        "/InGame/Root/Normal/AlignBottomRight/DialogButtons/Knight/ClaimTerritory",
        _Flag
    );
end

---
-- Versteckt den Button der Heldenfähigkeit oder blendet ihn ein.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Hinweis:&#x3C;/b&#x3E; Diese Änderung bleibt auch nach dem Laden eines Spielstandes
-- aktiv und muss explizit zurückgenommen werden!&#x3C;/p&#x3E;
--
-- @param[type=boolean] _Flag Widget versteckt
-- @within Anwenderfunktionen
--
function API.InterfaceHideKnightAbility(_Flag)
    if not GUI then
        Logic.ExecuteInLuaLocalState("API.InterfaceHideKnightAbility(" ..tostring(_Flag).. ")");
        return;
    end

    BundleInterfaceFeatureVisibility.Local:HideInterfaceButton(
        "/InGame/Root/Normal/AlignBottomRight/DialogButtons/Knight/StartAbilityProgress",
        _Flag
    );
    BundleInterfaceFeatureVisibility.Local:HideInterfaceButton(
        "/InGame/Root/Normal/AlignBottomRight/DialogButtons/Knight/StartAbility",
        _Flag
    );
end

---
-- Versteckt den Button zur Heldenselektion oder blendet ihn ein.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Hinweis:&#x3C;/b&#x3E; Diese Änderung bleibt auch nach dem Laden eines Spielstandes
-- aktiv und muss explizit zurückgenommen werden!&#x3C;/p&#x3E;
--
-- @param[type=boolean] _Flag Widget versteckt
-- @within Anwenderfunktionen
--
function API.InterfaceHideKnightButton(_Flag)
    if not GUI then
        Logic.ExecuteInLuaLocalState("API.InterfaceHideKnightButton(" ..tostring(_Flag).. ")");
        return;
    end

    local KnightID = Logic.GetKnightID(GUI.GetPlayerID());
    if _Flag == true then
        GUI.SendScriptCommand("Logic.SetEntitySelectableFlag("..KnightID..", 0)");
        GUI.DeselectEntity(KnightID);
    else
        GUI.SendScriptCommand("Logic.SetEntitySelectableFlag("..KnightID..", 1)");
    end

    BundleInterfaceFeatureVisibility.Local:HideInterfaceButton(
        "/InGame/Root/Normal/AlignBottomRight/MapFrame/KnightButtonProgress",
        _Flag
    );
    BundleInterfaceFeatureVisibility.Local:HideInterfaceButton(
        "/InGame/Root/Normal/AlignBottomRight/MapFrame/KnightButton",
        _Flag
    );
end

---
-- Versteckt den Button zur Selektion des Militärs oder blendet ihn ein.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Hinweis:&#x3C;/b&#x3E; Diese Änderung bleibt auch nach dem Laden eines Spielstandes
-- aktiv und muss explizit zurückgenommen werden!&#x3C;/p&#x3E;
--
-- @param[type=boolean] _Flag Widget versteckt
-- @within Anwenderfunktionen
--
function API.InterfaceHideSelectionButton(_Flag)
    if not GUI then
        Logic.ExecuteInLuaLocalState("API.InterfaceHideSelectionButton(" ..tostring(_Flag).. ")");
        return;
    end
    API.InterfaceHideKnightButton(_Flag);
    GUI.ClearSelection();

    BundleInterfaceFeatureVisibility.Local:HideInterfaceButton(
        "/InGame/Root/Normal/AlignBottomRight/MapFrame/BattalionButton",
        _Flag
    );
end

---
-- Versteckt das Baumenü oder blendet es ein.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Hinweis:&#x3C;/b&#x3E; Diese Änderung bleibt auch nach dem Laden eines Spielstandes
-- aktiv und muss explizit zurückgenommen werden!&#x3C;/p&#x3E;
--
-- @param[type=boolean] _Flag Widget versteckt
-- @within Anwenderfunktionen
--
function API.InterfaceHideBuildMenu(_Flag)
    if not GUI then
        Logic.ExecuteInLuaLocalState("API.InterfaceHideBuildMenu(" ..tostring(_Flag).. ")");
        return;
    end

    BundleInterfaceFeatureVisibility.Local:HideInterfaceButton(
        "/InGame/Root/Normal/AlignBottomRight/BuildMenu",
        _Flag
    );
end

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

BundleInterfaceFeatureVisibility = {
    Global = {},
    Local = {
        Data = {
            HiddenWidgets = {},
        },
    }
};

-- Global Script ---------------------------------------------------------------

---
-- Initialisiert das Bundle im globalen Skript.
-- @within Internal
-- @local
--
function BundleInterfaceFeatureVisibility.Global:Install()
    API.AddSaveGameAction(BundleInterfaceFeatureVisibility.Global.RestoreAfterLoad);
end

---
-- Stellt alle versteckten Buttons nach dem Laden eines Spielstandes wieder her.
-- @within Internal
-- @local
--
function BundleInterfaceFeatureVisibility.Global.RestoreAfterLoad()
    Logic.ExecuteInLuaLocalState([[
        BundleInterfaceFeatureVisibility.Local:RestoreAfterLoad();
    ]]);
end

-- Local Script ----------------------------------------------------------------

---
-- Initialisiert das Bundle im lokalen Skript.
-- @within Internal
-- @local
--
function BundleInterfaceFeatureVisibility.Local:Install()
    Core:StackFunction("GUI_Knight.ClaimTerritoryUpdate", self.UpdateClaimTerritory);
end

---
-- Versteht ein Widget oder blendet es ein.
--
-- @param _Widget [string|number] Widgetpfad oder ID
-- @param _Hide [boolean] Hidden Flag
-- @within Internal
-- @local
--
function BundleInterfaceFeatureVisibility.Local:HideInterfaceButton(_Widget, _Hide)
    self.Data.HiddenWidgets[_Widget] = _Hide == true;
    XGUIEng.ShowWidget(_Widget, (_Hide == true and 0) or 1);
end

---
-- Stellt alle versteckten Buttons nach dem Laden eines Spielstandes wieder her.
-- @within Internal
-- @local
--
function BundleInterfaceFeatureVisibility.Local:RestoreAfterLoad()
    for k, v in pairs(self.Data.HiddenWidgets) do
        if v then
            XGUIEng.ShowWidget(k, 0);
        end
    end
end

---
-- Versteckt den Claim-Territory-Button.
-- @within Internal
-- @local
--
function BundleInterfaceFeatureVisibility.Local.UpdateClaimTerritory()
    local Key = "/InGame/Root/Normal/AlignBottomRight/DialogButtons/Knight/ClaimTerritory";
    if BundleInterfaceFeatureVisibility.Local.Data.HiddenWidgets[Key] == true then
        XGUIEng.ShowWidget(Key, 0);
        return true;
    end
end

-- -------------------------------------------------------------------------- --

Core:RegisterBundle("BundleInterfaceFeatureVisibility");

</code></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundleknighttitlerequirements.lua.html">
            <div class='doclink'>
                <div>BundleKnightTitleRequirements</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><code>-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundleKnightTitleRequirements                                # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Erlaubt es dem Mapper die vorgegebenen Aufstiegsbedingungen idividuell
-- an die eigenen Vorstellungen anzupassen.
--
-- Die Aufstiegsbedingungen werden in der Funktion InitKnightTitleTables
-- angegeben und bearbeitet.
--
-- &#x3C;p&#x3E;&#x3C;a href="#InitKnightTitleTables"&#x3E;Aufstiegsbedingungen steuern&#x3C;/a&#x3E;&#x3C;/p&#x3E;
--
-- &#x3C;p&#x3E;Mögliche Aufstiegsbedingungen:
-- &#x3C;ul&#x3E;
-- &#x3C;li&#x3E;&#x3C;b&#x3E;Entitytyp besitzen&#x3C;/b&#x3E;&#x3C;br/&#x3E;
-- Der Spieler muss eine bestimmte Anzahl von Entities eines Typs besitzen.
-- &#x3C;pre&#x3E;&#x3C;code&#x3E;
-- KnightTitleRequirements[KnightTitles.Mayor].Entities = {
--     {Entities.B_Bakery, 2},
--     ...
-- }
-- &#x3C;/code&#x3E;&#x3C;/pre&#x3E;
-- &#x3C;/li&#x3E;
--
-- &#x3C;li&#x3E;&#x3C;b&#x3E;Entitykategorie besitzen&#x3C;/b&#x3E;&#x3C;br/&#x3E;
-- Der Spieler muss eine bestimmte Anzahl von Entities einer Kategorie besitzen.
-- &#x3C;pre&#x3E;&#x3C;code&#x3E;
-- KnightTitleRequirements[KnightTitles.Mayor].Category = {
--     {EntitiyCategories.CattlePasture, 10},
--     ...
-- }
-- &#x3C;/code&#x3E;&#x3C;/pre&#x3E;
-- &#x3C;/li&#x3E;
--
-- &#x3C;li&#x3E;&#x3C;b&#x3E;Gütertyp besitzen&#x3C;/b&#x3E;&#x3C;br/&#x3E;
-- Der Spieler muss Rohstoffe oder Güter eines Typs besitzen.
-- &#x3C;pre&#x3E;&#x3C;code&#x3E;
-- KnightTitleRequirements[KnightTitles.Mayor].Goods = {
--     {Goods.G_RawFish, 35},
--     ...
-- }
-- &#x3C;/code&#x3E;&#x3C;/pre&#x3E;
-- &#x3C;/li&#x3E;
--
-- &#x3C;li&#x3E;&#x3C;b&#x3E;Produkte erzeugen&#x3C;/b&#x3E;&#x3C;br/&#x3E;
-- Der Spieler muss Gebrauchsgegenstände für ein Bedürfnis bereitstellen.
-- &#x3C;pre&#x3E;&#x3C;code&#x3E;
-- KnightTitleRequirements[KnightTitles.Mayor].Products = {
--     {GoodCategories.GC_Clothes, 6},
--     ...
-- }
-- &#x3C;/code&#x3E;&#x3C;/pre&#x3E;
-- &#x3C;/li&#x3E;
--
-- &#x3C;li&#x3E;&#x3C;b&#x3E;Güter konsumieren&#x3C;/b&#x3E;&#x3C;br/&#x3E;
-- Die Siedler müssen eine Menge einer bestimmten Waren konsumieren.
-- &#x3C;pre&#x3E;&#x3C;code&#x3E;
-- KnightTitleRequirements[KnightTitles.Mayor].Consume = {
--     {Goods.G_Bread, 30},
--     ...
-- }
-- &#x3C;/code&#x3E;&#x3C;/pre&#x3E;
-- &#x3C;/li&#x3E;
--
-- &#x3C;li&#x3E;&#x3C;b&#x3E;Vielfältigkeit bereitstellen&#x3C;/b&#x3E;&#x3C;br/&#x3E;
-- Der Spieler muss einen Vielfältigkeits-Buff aktivieren.
-- &#x3C;pre&#x3E;&#x3C;code&#x3E;
-- KnightTitleRequirements[KnightTitles.Mayor].Buff = {
--     Buffs.Buff_FoodDiversity,
--     ...
-- }
-- &#x3C;/code&#x3E;&#x3C;/pre&#x3E;
-- &#x3C;/li&#x3E;
--
-- &#x3C;li&#x3E;&#x3C;b&#x3E;Stadtruf erreichen&#x3C;/b&#x3E;&#x3C;br/&#x3E;
-- Der Ruf der Stadt muss einen bestimmten Wert erreichen oder überschreiten.
-- &#x3C;pre&#x3E;&#x3C;code&#x3E;
-- KnightTitleRequirements[KnightTitles.Mayor].Reputation = 20
-- &#x3C;/code&#x3E;&#x3C;/pre&#x3E;
--
-- &#x3C;li&#x3E;&#x3C;b&#x3E;Anzahl an Dekorationen&#x3C;/b&#x3E;&#x3C;br/&#x3E;
-- Der Spieler muss mindestens die Anzahl der angegebenen Dekoration besitzen.
-- &#x3C;code&#x3E;&#x3C;pre&#x3E;
-- KnightTitleRequirements[KnightTitles.Mayor].DecoratedBuildings = {
--     {Goods.G_Banner, 9 },
-- }
-- &#x3C;/code&#x3E;&#x3C;/pre&#x3E;
-- &#x3C;/li&#x3E;
--
-- &#x3C;li&#x3E;&#x3C;b&#x3E;Anzahl voll dekorierter Gebäude&#x3C;/b&#x3E;&#x3C;br/&#x3E;
-- Anzahl an Gebäuden, an die alle vier Dekorationen angebracht sein müssen.
-- &#x3C;pre&#x3E;&#x3C;code&#x3E;
-- KnightTitleRequirements[KnightTitles.Mayor].FullDecoratedBuildings = 12
-- &#x3C;/code&#x3E;&#x3C;/pre&#x3E;
-- &#x3C;/li&#x3E;
--
-- &#x3C;li&#x3E;&#x3C;b&#x3E;Spezialgebäude ausbauen&#x3C;/b&#x3E;&#x3C;br/&#x3E;
-- Ein Spezielgebäude muss ausgebaut werden.
-- &#x3C;pre&#x3E;&#x3C;code&#x3E;
-- KnightTitleRequirements[KnightTitles.Mayor].Headquarters = 1
-- KnightTitleRequirements[KnightTitles.Mayor].Storehouse = 1
-- KnightTitleRequirements[KnightTitles.Mayor].Cathedrals = 1
-- &#x3C;/code&#x3E;&#x3C;/pre&#x3E;
-- &#x3C;/li&#x3E;
--
-- &#x3C;li&#x3E;&#x3C;b&#x3E;Anzahl Siedler&#x3C;/b&#x3E;&#x3C;br/&#x3E;
-- Der Spieler benötigt eine Gesamtzahl an Siedlern.
-- &#x3C;pre&#x3E;&#x3C;code&#x3E;
-- KnightTitleRequirements[KnightTitles.Mayor].Settlers = 40
-- &#x3C;/code&#x3E;&#x3C;/pre&#x3E;
-- &#x3C;/li&#x3E;
--
-- &#x3C;li&#x3E;&#x3C;b&#x3E;Anzahl reiche Stadtgebäude&#x3C;/b&#x3E;&#x3C;br/&#x3E;
-- Eine Anzahl an Gebäuden muss durch Einnahmen Reichtum erlangen.
-- &#x3C;pre&#x3E;&#x3C;code&#x3E;
-- KnightTitleRequirements[KnightTitles.Mayor].RichBuildings = 30
-- &#x3C;/code&#x3E;&#x3C;/pre&#x3E;
-- &#x3C;/li&#x3E;
--
-- &#x3C;li&#x3E;&#x3C;b&#x3E;Benutzerdefiniert&#x3C;/b&#x3E;&#x3C;br/&#x3E;
-- Eine benutzerdefinierte Funktion, die entweder als Schalter oder als Zähler
-- fungieren kann und true oder false zurückgeben muss.
-- &#x3C;pre&#x3E;&#x3C;code&#x3E;
-- KnightTitleRequirements[KnightTitles.Mayor].Custom = {
--     {SomeFunction, {1, 1}, "Überschrift", "Beschreibung"}
-- }
-- &#x3C;/code&#x3E;&#x3C;/pre&#x3E;
-- &#x3C;/li&#x3E;
-- &#x3C;/ul&#x3E;&#x3C;/p&#x3E;
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundleKnightTitleRequirements = {};

API = API or {};
QSB = QSB or {};

QSB.RequirementTooltipTypes = {};
QSB.ConsumedGoodsCounter = {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --



-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

BundleKnightTitleRequirements = {
    Global = {},
    Local = {
        Data = {},
    }
};

-- Global Script ---------------------------------------------------------------

---
-- Installiert das Bundle im globalen Skript.
-- @within BundleKnightTitleRequirements
-- @local
--
function BundleKnightTitleRequirements.Global:Install()
    self:OverwriteConsumedGoods();
end

---
-- Zählt den Konsumzähler rauf, sobald eine Ware konsumiert wird.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _Good Warentyp
-- @within BundleKnightTitleRequirements
-- @local
--
function BundleKnightTitleRequirements.Global:RegisterConsumedGoods(_PlayerID, _Good)
    QSB.ConsumedGoodsCounter[_PlayerID]        = QSB.ConsumedGoodsCounter[_PlayerID] or {};
    QSB.ConsumedGoodsCounter[_PlayerID][_Good] = QSB.ConsumedGoodsCounter[_PlayerID][_Good] or 0;
    QSB.ConsumedGoodsCounter[_PlayerID][_Good] = QSB.ConsumedGoodsCounter[_PlayerID][_Good] +1;
end

---
-- Überschreibt GameCallback_ConsumeGood, sodass konsumierte Waren gezählt
-- werden können.
-- @within BundleKnightTitleRequirements
-- @local
--
function BundleKnightTitleRequirements.Global:OverwriteConsumedGoods()
    GameCallback_ConsumeGood_Orig_QSB_Requirements = GameCallback_ConsumeGood
    GameCallback_ConsumeGood = function(_Consumer, _Good, _Building)
        GameCallback_ConsumeGood_Orig_QSB_Requirements(_Consumer, _Good, _Building)

        local PlayerID = Logic.EntityGetPlayer(_Consumer);
        BundleKnightTitleRequirements.Global:RegisterConsumedGoods(PlayerID, _Good);
        Logic.ExecuteInLuaLocalState([[
            BundleKnightTitleRequirements.Local:RegisterConsumedGoods(
                ]] ..PlayerID.. [[, ]] .._Good.. [[
            );
        ]]);
    end
end

-- Local Script ----------------------------------------------------------------

---
-- Installiert das Bundle im lokalen Skript.
-- @within BundleKnightTitleRequirements
-- @local
--
function BundleKnightTitleRequirements.Local:Install()
    self:OverwriteTooltips();
    self:InitTexturePositions();
    self:OverwriteUpdateRequirements();
    self:OverwritePromotionCelebration();
end

---
-- Zählt den Konsumzähler rauf, sobald eine Ware konsumiert wird.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _Good Warentyp
-- @within BundleKnightTitleRequirements
-- @local
--
function BundleKnightTitleRequirements.Local:RegisterConsumedGoods(_PlayerID, _Good)
    QSB.ConsumedGoodsCounter[_PlayerID]        = QSB.ConsumedGoodsCounter[_PlayerID] or {};
    QSB.ConsumedGoodsCounter[_PlayerID][_Good] = QSB.ConsumedGoodsCounter[_PlayerID][_Good] or 0;
    QSB.ConsumedGoodsCounter[_PlayerID][_Good] = QSB.ConsumedGoodsCounter[_PlayerID][_Good] +1;
end

---
-- Fügt einige weitere Einträge zu den Texturpositionen hinzu.
-- @within BundleKnightTitleRequirements
-- @local
--
function BundleKnightTitleRequirements.Local:InitTexturePositions()
    g_TexturePositions.EntityCategories[EntityCategories.GC_Food_Supplier]          = { 1, 1};
    g_TexturePositions.EntityCategories[EntityCategories.GC_Clothes_Supplier]       = { 1, 2};
    g_TexturePositions.EntityCategories[EntityCategories.GC_Hygiene_Supplier]       = {16, 1};
    g_TexturePositions.EntityCategories[EntityCategories.GC_Entertainment_Supplier] = { 1, 4};
    g_TexturePositions.EntityCategories[EntityCategories.GC_Luxury_Supplier]        = {16, 3};
    g_TexturePositions.EntityCategories[EntityCategories.GC_Weapon_Supplier]        = { 1, 7};
    g_TexturePositions.EntityCategories[EntityCategories.GC_Medicine_Supplier]      = { 2,10};
    g_TexturePositions.EntityCategories[EntityCategories.Outpost]                   = {12, 3};
    g_TexturePositions.EntityCategories[EntityCategories.Spouse]                    = { 5,15};
    g_TexturePositions.EntityCategories[EntityCategories.CattlePasture]             = { 3,16};
    g_TexturePositions.EntityCategories[EntityCategories.SheepPasture]              = { 4, 1};
    g_TexturePositions.EntityCategories[EntityCategories.Soldier]                   = { 7,12};
    g_TexturePositions.EntityCategories[EntityCategories.GrainField]                = {14, 2};
    g_TexturePositions.EntityCategories[EntityCategories.OuterRimBuilding]          = { 3, 4};
    g_TexturePositions.EntityCategories[EntityCategories.CityBuilding]              = { 8, 1};
    g_TexturePositions.EntityCategories[EntityCategories.Leader]                    = { 7, 11};
    g_TexturePositions.EntityCategories[EntityCategories.Range]                     = { 9, 8};
    g_TexturePositions.EntityCategories[EntityCategories.Melee]                     = { 9, 7};
    g_TexturePositions.EntityCategories[EntityCategories.SiegeEngine]               = { 2,15};

    g_TexturePositions.Entities[Entities.B_Outpost]                                 = {12, 3};
    g_TexturePositions.Entities[Entities.B_Outpost_AS]                              = {12, 3};
    g_TexturePositions.Entities[Entities.B_Outpost_ME]                              = {12, 3};
    g_TexturePositions.Entities[Entities.B_Outpost_NA]                              = {12, 3};
    g_TexturePositions.Entities[Entities.B_Outpost_NE]                              = {12, 3};
    g_TexturePositions.Entities[Entities.B_Outpost_SE]                              = {12, 3};
    g_TexturePositions.Entities[Entities.B_Cathedral_Big]                           = { 3,12};
    g_TexturePositions.Entities[Entities.U_MilitaryBallista]                        = {10, 5};
    g_TexturePositions.Entities[Entities.U_Trebuchet]                               = { 9, 1};
    g_TexturePositions.Entities[Entities.U_SiegeEngineCart]                         = { 9, 4};

    g_TexturePositions.Needs[Needs.Medicine]                                        = { 2,10};

    g_TexturePositions.Technologies[Technologies.R_Castle_Upgrade_1]                = { 4, 7};
    g_TexturePositions.Technologies[Technologies.R_Castle_Upgrade_2]                = { 4, 7};
    g_TexturePositions.Technologies[Technologies.R_Castle_Upgrade_3]                = { 4, 7};
    g_TexturePositions.Technologies[Technologies.R_Cathedral_Upgrade_1]             = { 4, 5};
    g_TexturePositions.Technologies[Technologies.R_Cathedral_Upgrade_2]             = { 4, 5};
    g_TexturePositions.Technologies[Technologies.R_Cathedral_Upgrade_3]             = { 4, 5};
    g_TexturePositions.Technologies[Technologies.R_Storehouse_Upgrade_1]            = { 4, 6};
    g_TexturePositions.Technologies[Technologies.R_Storehouse_Upgrade_2]            = { 4, 6};
    g_TexturePositions.Technologies[Technologies.R_Storehouse_Upgrade_3]            = { 4, 6};

    g_TexturePositions.Buffs = g_TexturePositions.Buffs or {};

    g_TexturePositions.Buffs[Buffs.Buff_ClothesDiversity]                           = { 1, 2};
    g_TexturePositions.Buffs[Buffs.Buff_EntertainmentDiversity]                     = { 1, 4};
    g_TexturePositions.Buffs[Buffs.Buff_FoodDiversity]                              = { 1, 1};
    g_TexturePositions.Buffs[Buffs.Buff_HygieneDiversity]                           = { 1, 3};
    g_TexturePositions.Buffs[Buffs.Buff_Colour]                                     = { 5,11};
    g_TexturePositions.Buffs[Buffs.Buff_Entertainers]                               = { 5,12};
    g_TexturePositions.Buffs[Buffs.Buff_ExtraPayment]                               = { 1, 8};
    g_TexturePositions.Buffs[Buffs.Buff_Sermon]                                     = { 4,14};
    g_TexturePositions.Buffs[Buffs.Buff_Spice]                                      = { 5,10};
    g_TexturePositions.Buffs[Buffs.Buff_NoTaxes]                                    = { 1, 6};
    if Framework.GetGameExtraNo() ~= 0 then
        g_TexturePositions.Buffs[Buffs.Buff_Gems]                                   = { 1, 1, 1};
        g_TexturePositions.Buffs[Buffs.Buff_MusicalInstrument]                      = { 1, 3, 1};
        g_TexturePositions.Buffs[Buffs.Buff_Olibanum]                               = { 1, 2, 1};
    end

    g_TexturePositions.GoodCategories = g_TexturePositions.GoodCategories or {};

    g_TexturePositions.GoodCategories[GoodCategories.GC_Ammunition]                 = {10, 6};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Animal]                     = { 4,16};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Clothes]                    = { 1, 2};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Document]                   = { 5, 6};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Entertainment]              = { 1, 4};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Food]                       = { 1, 1};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Gold]                       = { 1, 8};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Hygiene]                    = {16, 1};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Luxury]                     = {16, 3};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Medicine]                   = { 2,10};
    g_TexturePositions.GoodCategories[GoodCategories.GC_None]                       = {15,16};
    g_TexturePositions.GoodCategories[GoodCategories.GC_RawFood]                    = { 3, 4};
    g_TexturePositions.GoodCategories[GoodCategories.GC_RawMedicine]                = { 2, 2};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Research]                   = { 5, 6};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Resource]                   = { 3, 4};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Tools]                      = { 4,12};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Water]                      = { 1,16};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Weapon]                     = { 8, 5};
end

---
-- Überschreibt die Aktualisierungsfunktion der Aufstiegsbedingungen.
-- @within BundleKnightTitleRequirements
-- @local
--
function BundleKnightTitleRequirements.Local:OverwriteUpdateRequirements()
    GUI_Knight.UpdateRequirements = function()
        local WidgetPos = BundleKnightTitleRequirements.Local.Data.RequirementWidgets;
        local RequirementsIndex = 1;

        local PlayerID = GUI.GetPlayerID();
        local CurrentTitle = Logic.GetKnightTitle(PlayerID);
        local NextTitle = CurrentTitle + 1;

        --Headline
        local KnightID = Logic.GetKnightID(PlayerID);
        local KnightType = Logic.GetEntityType(KnightID);
        XGUIEng.SetText("/InGame/Root/Normal/AlignBottomRight/KnightTitleMenu/NextKnightTitle", "{center}" .. GUI_Knight.GetTitleNameByTitleID(KnightType, NextTitle));
        XGUIEng.SetText("/InGame/Root/Normal/AlignBottomRight/KnightTitleMenu/NextKnightTitleWhite", "{center}" .. GUI_Knight.GetTitleNameByTitleID(KnightType, NextTitle));

        -- show Settlers
        if KnightTitleRequirements[NextTitle].Settlers ~= nil then
            SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", {5,16})
            local IsFulfilled, CurrentAmount, NeededAmount = DoesNeededNumberOfSettlersForKnightTitleExist(PlayerID, NextTitle)
            XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount)
            if IsFulfilled then
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1)
            else
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0)
            end
            XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1)

            QSB.RequirementTooltipTypes[RequirementsIndex] = "Settlers";
            RequirementsIndex = RequirementsIndex +1;
        end

        -- show rich buildings
        if KnightTitleRequirements[NextTitle].RichBuildings ~= nil then
            SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", {8,4});
            local IsFulfilled, CurrentAmount, NeededAmount = DoNeededNumberOfRichBuildingsForKnightTitleExist(PlayerID, NextTitle);
            if NeededAmount == -1 then
                NeededAmount = Logic.GetNumberOfPlayerEntitiesInCategory(PlayerID, EntityCategories.CityBuilding);
            end
            XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);
            if IsFulfilled then
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
            else
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
            end
            XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);

            QSB.RequirementTooltipTypes[RequirementsIndex] = "RichBuildings";
            RequirementsIndex = RequirementsIndex +1;
        end

        -- Castle
        if KnightTitleRequirements[NextTitle].Headquarters ~= nil then
            SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", {4,7});
            local IsFulfilled, CurrentAmount, NeededAmount = DoNeededSpecialBuildingUpgradeForKnightTitleExist(PlayerID, NextTitle, EntityCategories.Headquarters);
            XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount + 1 .. "/" .. NeededAmount + 1);
            if IsFulfilled then
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
            else
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
            end
            XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);

            QSB.RequirementTooltipTypes[RequirementsIndex] = "Headquarters";
            RequirementsIndex = RequirementsIndex +1;
        end

        -- Storehouse
        if KnightTitleRequirements[NextTitle].Storehouse ~= nil then
            SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", {4,6});
            local IsFulfilled, CurrentAmount, NeededAmount = DoNeededSpecialBuildingUpgradeForKnightTitleExist(PlayerID, NextTitle, EntityCategories.Storehouse);
            XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount + 1 .. "/" .. NeededAmount + 1);
            if IsFulfilled then
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
            else
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
            end
            XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);

            QSB.RequirementTooltipTypes[RequirementsIndex] = "Storehouse";
            RequirementsIndex = RequirementsIndex +1;
        end

        -- Cathedral
        if KnightTitleRequirements[NextTitle].Cathedrals ~= nil then
            SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", {4,5});
            local IsFulfilled, CurrentAmount, NeededAmount = DoNeededSpecialBuildingUpgradeForKnightTitleExist(PlayerID, NextTitle, EntityCategories.Cathedrals);
            XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount + 1 .. "/" .. NeededAmount + 1);
            if IsFulfilled then
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
            else
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
            end
            XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);

            QSB.RequirementTooltipTypes[RequirementsIndex] = "Cathedrals";
            RequirementsIndex = RequirementsIndex +1;
        end

        -- Neue Bedingungen --------------------------------------------

        -- Volldekorierte Gebäude
        if KnightTitleRequirements[NextTitle].FullDecoratedBuildings ~= nil then
            local IsFulfilled, CurrentAmount, NeededAmount = DoNeededNumberOfFullDecoratedBuildingsForKnightTitleExist(PlayerID, NextTitle);
            local EntityCategory = KnightTitleRequirements[NextTitle].FullDecoratedBuildings;
            SetIcon(WidgetPos[RequirementsIndex].."/Icon"  , g_TexturePositions.Needs[Needs.Wealth]);

            XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);
            if IsFulfilled then
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
            else
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
            end
            XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] , 1);

            QSB.RequirementTooltipTypes[RequirementsIndex] = "FullDecoratedBuildings";
            RequirementsIndex = RequirementsIndex +1;
        end

        -- Stadtruf
        if KnightTitleRequirements[NextTitle].Reputation ~= nil then
            SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", {5,14});
            local IsFulfilled, CurrentAmount, NeededAmount = DoesNeededCityReputationForKnightTitleExist(PlayerID, NextTitle);
            XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);
            if IsFulfilled then
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
            else
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
            end
            XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);

            QSB.RequirementTooltipTypes[RequirementsIndex] = "Reputation";
            RequirementsIndex = RequirementsIndex +1;
        end

        -- Güter sammeln
        if KnightTitleRequirements[NextTitle].Goods ~= nil then
            for i=1, #KnightTitleRequirements[NextTitle].Goods do
                local GoodType = KnightTitleRequirements[NextTitle].Goods[i][1];
                SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", g_TexturePositions.Goods[GoodType]);
                local IsFulfilled, CurrentAmount, NeededAmount = DoesNeededNumberOfGoodTypesForKnightTitleExist(PlayerID, NextTitle, i);
                XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);
                if IsFulfilled then
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
                else
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
                end
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);

                QSB.RequirementTooltipTypes[RequirementsIndex] = "Goods" .. i;
                RequirementsIndex = RequirementsIndex +1;
            end
        end

        -- Kategorien
        if KnightTitleRequirements[NextTitle].Category ~= nil then
            for i=1, #KnightTitleRequirements[NextTitle].Category do
                local Category = KnightTitleRequirements[NextTitle].Category[i][1];
                SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", g_TexturePositions.EntityCategories[Category]);
                local IsFulfilled, CurrentAmount, NeededAmount = DoesNeededNumberOfEntitiesInCategoryForKnightTitleExist(PlayerID, NextTitle, i);
                XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);
                if IsFulfilled then
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
                else
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
                end
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);

                local EntitiesInCategory = {Logic.GetEntityTypesInCategory(Category)};
                if Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.GC_Weapon_Supplier) == 1 then
                    QSB.RequirementTooltipTypes[RequirementsIndex] = "Weapons" .. i;
                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.SiegeEngine) == 1 then
                    QSB.RequirementTooltipTypes[RequirementsIndex] = "HeavyWeapons" .. i;
                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.Spouse) == 1 then
                    QSB.RequirementTooltipTypes[RequirementsIndex] = "Spouse" .. i;
                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.Worker) == 1 then
                    QSB.RequirementTooltipTypes[RequirementsIndex] = "Worker" .. i;
                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.Soldier) == 1 then
                    QSB.RequirementTooltipTypes[RequirementsIndex] = "Soldiers" .. i;
                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.Leader) == 1 then
                    QSB.RequirementTooltipTypes[RequirementsIndex] = "Leader" .. i;
                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.Outpost) == 1 then
                    QSB.RequirementTooltipTypes[RequirementsIndex] = "Outposts" .. i;
                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.CattlePasture) == 1 then
                    QSB.RequirementTooltipTypes[RequirementsIndex] = "Cattle" .. i;
                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.SheepPasture) == 1 then
                    QSB.RequirementTooltipTypes[RequirementsIndex] = "Sheep" .. i;
                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.CityBuilding) == 1 then
                    QSB.RequirementTooltipTypes[RequirementsIndex] = "CityBuilding" .. i;
                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.OuterRimBuilding) == 1 then
                    QSB.RequirementTooltipTypes[RequirementsIndex] = "OuterRimBuilding" .. i;
                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.AttackableBuilding) == 1 then
                    QSB.RequirementTooltipTypes[RequirementsIndex] = "Buildings" .. i;
                else
                    QSB.RequirementTooltipTypes[RequirementsIndex] = "EntityCategoryDefault" .. i;
                end
                RequirementsIndex = RequirementsIndex +1;
            end
        end

        -- Entities
        if KnightTitleRequirements[NextTitle].Entities ~= nil then
            for i=1, #KnightTitleRequirements[NextTitle].Entities do
                local EntityType = KnightTitleRequirements[NextTitle].Entities[i][1];
                SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", g_TexturePositions.Entities[EntityType]);
                local IsFulfilled, CurrentAmount, NeededAmount = DoesNeededNumberOfEntitiesOfTypeForKnightTitleExist(PlayerID, NextTitle, i);
                XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);
                if IsFulfilled then
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
                else
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
                end
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);

                QSB.RequirementTooltipTypes[RequirementsIndex] = "Entities" .. i;
                RequirementsIndex = RequirementsIndex +1;
            end
        end

        -- Güter konsumieren
        if KnightTitleRequirements[NextTitle].Consume ~= nil then
            for i=1, #KnightTitleRequirements[NextTitle].Consume do
                local GoodType = KnightTitleRequirements[NextTitle].Consume[i][1];
                SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", g_TexturePositions.Goods[GoodType]);
                local IsFulfilled, CurrentAmount, NeededAmount = DoNeededNumberOfConsumedGoodsForKnightTitleExist(PlayerID, NextTitle, i);
                XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);
                if IsFulfilled then
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
                else
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
                end
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);

                QSB.RequirementTooltipTypes[RequirementsIndex] = "Consume" .. i;
                RequirementsIndex = RequirementsIndex +1;
            end
        end

        -- Güter aus Gruppe produzieren
        if KnightTitleRequirements[NextTitle].Products ~= nil then
            for i=1, #KnightTitleRequirements[NextTitle].Products do
                local Product = KnightTitleRequirements[NextTitle].Products[i][1];
                SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", g_TexturePositions.GoodCategories[Product]);
                local IsFulfilled, CurrentAmount, NeededAmount = DoNumberOfProductsInCategoryExist(PlayerID, NextTitle, i);
                XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);
                if IsFulfilled then
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
                else
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
                end
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);

                QSB.RequirementTooltipTypes[RequirementsIndex] = "Products" .. i;
                RequirementsIndex = RequirementsIndex +1;
            end
        end

        -- Bonus aktivieren
        if KnightTitleRequirements[NextTitle].Buff ~= nil then
            for i=1, #KnightTitleRequirements[NextTitle].Buff do
                local Buff = KnightTitleRequirements[NextTitle].Buff[i];
                SetIcon(WidgetPos[RequirementsIndex] .. "/Icon", g_TexturePositions.Buffs[Buff]);
                local IsFulfilled = DoNeededDiversityBuffForKnightTitleExist(PlayerID, NextTitle, i);
                XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "");
                if IsFulfilled then
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
                else
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
                end
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);

                QSB.RequirementTooltipTypes[RequirementsIndex] = "Buff" .. i;
                RequirementsIndex = RequirementsIndex +1;
            end
        end

        -- Selbstdefinierte Bedingung
        if KnightTitleRequirements[NextTitle].Custom ~= nil then
            for i=1, #KnightTitleRequirements[NextTitle].Custom do
                local Icon = KnightTitleRequirements[NextTitle].Custom[i][2];
                BundleKnightTitleRequirements.Local:RequirementIcon(WidgetPos[RequirementsIndex] .. "/Icon", Icon);
                local IsFulfilled, CurrentAmount, NeededAmount = DoCustomFunctionForKnightTitleSucceed(PlayerID, NextTitle, i);
                if CurrentAmount and NeededAmount then
                    XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);
                else
                    XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "");
                end
                if IsFulfilled then
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
                else
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
                end
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);

                QSB.RequirementTooltipTypes[RequirementsIndex] = "Custom" .. i;
                RequirementsIndex = RequirementsIndex +1;
            end
        end

        -- Dekorationselemente
        if KnightTitleRequirements[NextTitle].DecoratedBuildings ~= nil then
            for i=1, #KnightTitleRequirements[NextTitle].DecoratedBuildings do
                local GoodType = KnightTitleRequirements[NextTitle].DecoratedBuildings[i][1];
                SetIcon(WidgetPos[RequirementsIndex].."/Icon", g_TexturePositions.Goods[GoodType]);
                local IsFulfilled, CurrentAmount, NeededAmount = DoNeededNumberOfDecoratedBuildingsForKnightTitleExist(PlayerID, NextTitle, i);
                XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);
                if IsFulfilled then
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
                else
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
                end
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);

                QSB.RequirementTooltipTypes[RequirementsIndex] = "DecoratedBuildings" ..i;
                RequirementsIndex = RequirementsIndex +1;
            end
        end

        -- Übrige ausblenden
        for i=RequirementsIndex, 6 do
            XGUIEng.ShowWidget(WidgetPos[i], 0);
        end
    end
end

---
-- Überschreibt die Beförderung des Primary Knight.
-- @within BundleKnightTitleRequirements
-- @local
--
function BundleKnightTitleRequirements.Local:OverwritePromotionCelebration()
    StartKnightsPromotionCelebration = function( _PlayerID , _OldTitle, _FirstTime)
        if _PlayerID ~= GUI.GetPlayerID() or Logic.GetTime() &#x3C; 5 then
            return;
        end

        local MarketplaceID = Logic.GetMarketplace(_PlayerID);

        if _FirstTime == 1 then
            local KnightID = Logic.GetKnightID(_PlayerID);
            local Random

            repeat
                Random = 1 + XGUIEng.GetRandom(3)
            until Random ~= g_LastGotPromotionMessageRandom

            g_LastGotPromotionMessageRandom = Random;
            local TextKey = "Title_GotPromotion" .. Random;
            LocalScriptCallback_QueueVoiceMessage(_PlayerID, TextKey, false, _PlayerID);
            GUI.StartFestival(_PlayerID, 1);
        end

        -- reset local
        local Consume = QSB.ConsumedGoodsCounter[_PlayerID];
        QSB.ConsumedGoodsCounter[_PlayerID] = Consume or {};
        for k,v in pairs(QSB.ConsumedGoodsCounter[_PlayerID]) do
            QSB.ConsumedGoodsCounter[_PlayerID][k] = 0;
        end

        -- reset global
        GUI.SendScriptCommand([[
            local Consume = QSB.ConsumedGoodsCounter[]].._PlayerID..[[];
            QSB.ConsumedGoodsCounter[]].._PlayerID..[[] = Consume or {};
            for k,v in pairs(QSB.ConsumedGoodsCounter[]].._PlayerID..[[]) do
                QSB.ConsumedGoodsCounter[]].._PlayerID..[[][k] = 0;
            end
        ]]);

        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/KnightTitleMenu", 0);
        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopCenter/KnightTitleMenuBig", 0);
        g_WantsPromotionMessageInterval = 30;
        g_TimeOfPromotionPossible = nil;
    end
end

---
-- Überschreibt die Tooltips im Aufstiegsmenü.
-- @within BundleKnightTitleRequirements
-- @local
--
function BundleKnightTitleRequirements.Local:OverwriteTooltips()
    GUI_Tooltip.SetNameAndDescription_Orig_QSB_Requirements = GUI_Tooltip.SetNameAndDescription;
    GUI_Tooltip.SetNameAndDescription = function(_TooltipNameWidget, _TooltipDescriptionWidget, _OptionalTextKeyName, _OptionalDisabledTextKeyName, _OptionalMissionTextFileBoolean)
        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();
        local Selected = GUI.GetSelectedEntity();
        local PlayerID = GUI.GetPlayerID();

        for k,v in pairs(BundleKnightTitleRequirements.Local.Data.RequirementWidgets) do
            if v .. "/Icon" == XGUIEng.GetWidgetPathByID(CurrentWidgetID) then
                local key = QSB.RequirementTooltipTypes[k];
                local num = tonumber(string.sub(key, string.len(key)));
                if num ~= nil then
                    key = string.sub(key, 1, string.len(key)-1);
                end
                BundleKnightTitleRequirements.Local:RequirementTooltipWrapped(key, num);
                return;
            end
        end
        GUI_Tooltip.SetNameAndDescription_Orig_QSB_Requirements(_TooltipNameWidget, _TooltipDescriptionWidget, _OptionalTextKeyName, _OptionalDisabledTextKeyName, _OptionalMissionTextFileBoolean);
    end

    GUI_Knight.RequiredGoodTooltip = function()
        local key = QSB.RequirementTooltipTypes[2];
        local num = tonumber(string.sub(key, string.len(key)));
        if num ~= nil then
            key = string.sub(key, 1, string.len(key)-1);
        end
        BundleKnightTitleRequirements.Local:RequirementTooltipWrapped(key, num);
    end

    if Framework.GetGameExtraNo() ~= 0 then
        BundleKnightTitleRequirements.Local.Data.BuffTypeNames[Buffs.Buff_Gems] = {
            de = "Edelsteine beschaffen", en = "Obtain gems"
        }
        BundleKnightTitleRequirements.Local.Data.BuffTypeNames[Buffs.Buff_Olibanum] = {
            de = "Weihrauch beschaffen", en = "Obtain olibanum"
        }
        BundleKnightTitleRequirements.Local.Data.BuffTypeNames[Buffs.Buff_MusicalInstrument] = {
            de = "Muskinstrumente beschaffen", en = "Obtain instruments"
        }
    end
end

---
-- Ändert die Textur eines Icons in den Aufstiegsbedingungen.
--
-- Icons für Aufstiegsbedingungen können sein:
-- &#x3C;ul&#x3E;
-- &#x3C;li&#x3E;Koordinaten auf der Spielinternen Icon Matrix&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;Koordinaten auf einer externen Icon Matrix (Name .. "big.png")&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;Pfad zu einelnem Icon (200x200 Pixel)&#x3C;/li&#x3E;
-- &#x3C;/ul&#x3E;
--
-- @param[type=string] _Widget Icon Widget
-- @param              _Icon Icon Textur (Dateiname oder Matrix)
-- @within BundleKnightTitleRequirements
-- @local
--
function BundleKnightTitleRequirements.Local:RequirementIcon(_Widget, _Icon)
    if type(_Icon) == "table" then
        if type(_Icon[3]) == "string" then
            local ButtonState = 1;
            if XGUIEng.IsButton(_Widget) == 1 then
                ButtonState = 7;
            end

            local u0, u1, v0, v1;
            u0 = (_Icon[1] - 1) * 64;
            v0 = (_Icon[2] - 1) * 64;
            u1 = (_Icon[1]) * 64;
            v1 = (_Icon[2]) * 64;
            XGUIEng.SetMaterialAlpha(_Widget, ButtonState, 255);
            XGUIEng.SetMaterialTexture(_Widget, ButtonState, _Icon[3].. "big.png");
            XGUIEng.SetMaterialUV(_Widget, ButtonState, u0, v0, u1, v1);
        else
            SetIcon(_Widget, _Icon);
        end
    else
        local screenSize = {GUI.GetScreenSize()};
        local Scale = 330;
        if screenSize[2] &#x3E;= 800 then
            Scale = 260;
        end
        if screenSize[2] &#x3E;= 1000 then
            Scale = 210;
        end
        XGUIEng.SetMaterialAlpha(_Widget, 1, 255);
        XGUIEng.SetMaterialTexture(_Widget, 1, _file);
        XGUIEng.SetMaterialUV(_Widget, 1, 0, 0, Scale, Scale);
    end
end

---
-- Setzt einen für den Tooltip des aktuellen Widget einen neuen Text.
--
-- @param[type=string] _Title Titel des Tooltip
-- @param[type=string] _Text  Text des Tooltip
-- @within BundleKnightTitleRequirements
-- @local
--
function BundleKnightTitleRequirements.Local:RequirementTooltip(_Title, _Text)
    local TooltipContainerPath = "/InGame/Root/Normal/TooltipNormal";
    local TooltipContainer = XGUIEng.GetWidgetID(TooltipContainerPath);
    local TooltipNameWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Name");
    local TooltipDescriptionWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Text");
    local TooltipBGWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/BG");
    local TooltipFadeInContainer = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn");
    local PositionWidget = XGUIEng.GetCurrentWidgetID();
    GUI_Tooltip.ResizeBG(TooltipBGWidget, TooltipDescriptionWidget);
    local TooltipContainerSizeWidgets = {TooltipBGWidget};
    GUI_Tooltip.SetPosition(TooltipContainer, TooltipContainerSizeWidgets, PositionWidget);
    GUI_Tooltip.FadeInTooltip(TooltipFadeInContainer);

    XGUIEng.SetText(TooltipNameWidget, "{center}" .. _Title);
    XGUIEng.SetText(TooltipDescriptionWidget, _Text);
    local Height = XGUIEng.GetTextHeight(TooltipDescriptionWidget, true);
    local W, H = XGUIEng.GetWidgetSize(TooltipDescriptionWidget);
    XGUIEng.SetWidgetSize(TooltipDescriptionWidget, W, Height);
end

---
-- Ermittelt die veränderten Texte für den Tooltip hinter dem angegebenen Key.
--
-- @param[type=string] _key Index in Description
-- @param[type=number] _i   Buttonindex
-- @within BundleKnightTitleRequirements
-- @local
--
function BundleKnightTitleRequirements.Local:RequirementTooltipWrapped(_key, _i)
    local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";
    local PlayerID = GUI.GetPlayerID();
    local KnightTitle = Logic.GetKnightTitle(PlayerID);
    local Title = ""
    local Text = "";

    if _key == "Consume" or _key == "Goods" or _key == "DecoratedBuildings" then
        local GoodType     = KnightTitleRequirements[KnightTitle+1][_key][_i][1];
        local GoodTypeName = Logic.GetGoodTypeName(GoodType);
        local GoodName     = XGUIEng.GetStringTableText("UI_ObjectNames/" .. GoodTypeName);

        if GoodName == nil then
            GoodName = "Goods." .. GoodTypeName;
        end
        Title = GoodName;
        Text  = BundleKnightTitleRequirements.Local.Data.Description[_key].Text;

    elseif _key == "Products" then
        local GoodCategoryNames = BundleKnightTitleRequirements.Local.Data.GoodCategoryNames;
        local Category = KnightTitleRequirements[KnightTitle+1][_key][_i][1];
        local CategoryName = GoodCategoryNames[Category][lang];

        if CategoryName == nil then
            CategoryName = "ERROR: Name missng!";
        end
        Title = CategoryName;
        Text  = BundleKnightTitleRequirements.Local.Data.Description[_key].Text;

    elseif _key == "Entities" then
        local EntityType     = KnightTitleRequirements[KnightTitle+1][_key][_i][1];
        local EntityTypeName = Logic.GetEntityTypeName(EntityType);
        local EntityName = XGUIEng.GetStringTableText("Names/" .. EntityTypeName);

        if EntityName == nil then
            EntityName = "Entities." .. EntityTypeName;
        end

        Title = EntityName;
        Text  = BundleKnightTitleRequirements.Local.Data.Description[_key].Text;

    elseif _key == "Custom" then
        local Custom = KnightTitleRequirements[KnightTitle+1].Custom[_i];
        Title = Custom[3];
        Text  = Custom[4];

    elseif _key == "Buff" then
        local BuffTypeNames = BundleKnightTitleRequirements.Local.Data.BuffTypeNames;
        local BuffType = KnightTitleRequirements[KnightTitle+1][_key][_i];
        local BuffTitle = BuffTypeNames[BuffType][lang];

        if BuffTitle == nil then
            BuffTitle = "ERROR: Name missng!";
        end
        Title = BuffTitle;
        Text  = BundleKnightTitleRequirements.Local.Data.Description[_key].Text;

    else
        Title = BundleKnightTitleRequirements.Local.Data.Description[_key].Title;
        Text  = BundleKnightTitleRequirements.Local.Data.Description[_key].Text;
    end

    Title = (type(Title) == "table" and Title[lang]) or Title;
    Text  = (type(Text) == "table" and Text[lang]) or Text;
    self:RequirementTooltip(Title, Text);
end

BundleKnightTitleRequirements.Local.Data.RequirementWidgets = {
    [1] = "/InGame/Root/Normal/AlignBottomRight/KnightTitleMenu/Requirements/Settlers",
    [2] = "/InGame/Root/Normal/AlignBottomRight/KnightTitleMenu/Requirements/Goods",
    [3] = "/InGame/Root/Normal/AlignBottomRight/KnightTitleMenu/Requirements/RichBuildings",
    [4] = "/InGame/Root/Normal/AlignBottomRight/KnightTitleMenu/Requirements/Castle",
    [5] = "/InGame/Root/Normal/AlignBottomRight/KnightTitleMenu/Requirements/Storehouse",
    [6] = "/InGame/Root/Normal/AlignBottomRight/KnightTitleMenu/Requirements/Cathedral",
};

BundleKnightTitleRequirements.Local.Data.GoodCategoryNames = {
    [GoodCategories.GC_Ammunition]      = {de = "Munition", en = "Ammunition"},
    [GoodCategories.GC_Animal]          = {de = "Nutztiere", en = "Livestock"},
    [GoodCategories.GC_Clothes]         = {de = "Kleidung", en = "Clothes"},
    [GoodCategories.GC_Document]        = {de = "Dokumente", en = "Documents"},
    [GoodCategories.GC_Entertainment]   = {de = "Unterhaltung", en = "Entertainment"},
    [GoodCategories.GC_Food]            = {de = "Nahrungsmittel", en = "Food"},
    [GoodCategories.GC_Gold]            = {de = "Gold", en = "Gold"},
    [GoodCategories.GC_Hygiene]         = {de = "Hygieneartikel", en = "Hygiene"},
    [GoodCategories.GC_Luxury]          = {de = "Dekoration", en = "Decoration"},
    [GoodCategories.GC_Medicine]        = {de = "Medizin", en = "Medicine"},
    [GoodCategories.GC_None]            = {de = "Nichts", en = "None"},
    [GoodCategories.GC_RawFood]         = {de = "Nahrungsmittel", en = "Food"},
    [GoodCategories.GC_RawMedicine]     = {de = "Medizin", en = "Medicine"},
    [GoodCategories.GC_Research]        = {de = "Forschung", en = "Research"},
    [GoodCategories.GC_Resource]        = {de = "Rohstoffe", en = "Resource"},
    [GoodCategories.GC_Tools]           = {de = "Werkzeug", en = "Tools"},
    [GoodCategories.GC_Water]           = {de = "Wasser", en = "Water"},
    [GoodCategories.GC_Weapon]          = {de = "Waffen", en = "Weapon"},
};

BundleKnightTitleRequirements.Local.Data.BuffTypeNames = {
    [Buffs.Buff_ClothesDiversity]        = {de = "Abwechslungsreiche Kleidung", en = "Clothes diversity"},
    [Buffs.Buff_Colour]                  = {de = "Farben beschaffen", en = "Obtain color"},
    -- Funktioniert nicht, belegt MP
    [Buffs.Buff_Entertainers]            = {de = "Gaukler anheuern", en = "Hire entertainer"},
    [Buffs.Buff_EntertainmentDiversity]  = {de = "Abwechslungsreiche Unterhaltung", en = "Entertainment diversity"},
    [Buffs.Buff_ExtraPayment]            = {de = "Sonderzahlung", en = "Extra payment"},
    -- Funktioniert nicht, belegt MP
    [Buffs.Buff_Festival]                = {de = "Fest veranstalten", en = "Hold Festival"},
    [Buffs.Buff_FoodDiversity]           = {de = "Abwechslungsreiche Nahrung", en = "Food diversity"},
    [Buffs.Buff_HygieneDiversity]        = {de = "Abwechslungsreiche Hygiene", en = "Hygiene diversity"},
    [Buffs.Buff_NoTaxes]                 = {de = "Steuerbefreiung", en = "No taxes"},
    [Buffs.Buff_Sermon]                  = {de = "Pregigt abhalten", en = "Hold sermon"},
    [Buffs.Buff_Spice]                   = {de = "Salz beschaffen", en = "Obtain salt"},
};

BundleKnightTitleRequirements.Local.Data.Description = {
    Settlers = {
        Title = {
            de = "Benötigte Siedler",
            en = "Needed settlers",
        },
        Text = {
            de = "- Benötigte Menge an Siedlern",
            en = "- Needed number of settlers",
        },
    },

    RichBuildings = {
        Title = {
            de = "Reiche Stadtgebäude",
            en = "Rich city buildings",
        },
        Text = {
            de = "- Menge an reichen Stadtgebäuden",
            en = "- Needed amount of rich city buildings",
        },
    },

    Goods = {
        Title = {
            de = "Waren lagern",
            en = "Store Goods",
        },
        Text = {
            de = "- Benötigte Menge",
            en = "- Needed amount",
        },
    },

    FullDecoratedBuildings = {
        Title = {
            de = "Dekorierte Stadtgebäude",
            en = "Decorated City buildings",
        },
        Text = {
            de = "- Menge an voll dekorierten Gebäuden",
            en = "- Amount of full decoraded city buildings",
        },
    },

    DecoratedBuildings = {
        Title = {
            de = "Dekoration",
            en = "Decoration",
        },
        Text = {
            de = "- Menge an Dekorationsgütern in der Siedlung",
            en = "- Amount of decoration goods in settlement",
        },
    },

    Headquarters = {
        Title = {
            de = "Burgstufe",
            en = "Castle level",
        },
        Text = {
            de = "- Benötigte Ausbauten der Burg",
            en = "- Needed castle upgrades",
        },
    },

    Storehouse = {
        Title = {
            de = "Lagerhausstufe",
            en = "Storehouse level",
        },
        Text = {
            de = "- Benötigte Ausbauten des Lagerhauses",
            en = "- Needed storehouse upgrades",
        },
    },

    Cathedrals = {
        Title = {
            de = "Kirchenstufe",
            en = "Cathedral level",
        },
        Text = {
            de = "- Benötigte Ausbauten der Kirche",
            en = "- Needed cathedral upgrades",
        },
    },

    Reputation = {
        Title = {
            de = "Ruf der Stadt",
            en = "City reputation",
        },
        Text = {
            de = "- Benötigter Ruf der Stadt",
            en = "- Needed city reputation",
        },
    },

    EntityCategoryDefault = {
        Title = {
            de = "",
            en = "",
        },
        Text = {
            de = "- Benötigte Anzahl",
            en = "- Needed amount",
        },
    },

    Cattle = {
        Title = {
            de = "Kühe",
            en = "Cattle",
        },
        Text = {
            de = "- Benötigte Menge an Kühen",
            en = "- Needed amount of cattle",
        },
    },

    Sheep = {
        Title = {
            de = "Schafe",
            en = "Sheeps",
        },
        Text = {
            de = "- Benötigte Menge an Schafen",
            en = "- Needed amount of sheeps",
        },
    },

    Outposts = {
        Title = {
            de = "Territorien",
            en = "Territories",
        },
        Text = {
            de = "- Zu erobernde Territorien",
            en = "- Territories to claim",
        },
    },

    CityBuilding = {
        Title = {
            de = "Stadtgebäude",
            en = "City buildings",
        },
        Text = {
            de = "- Menge benötigter Stadtgebäude",
            en = "- Needed amount of city buildings",
        },
    },

    OuterRimBuilding = {
        Title = {
            de = "Rohstoffgebäude",
            en = "Gatherer",
        },
        Text = {
            de = "- Menge benötigter Rohstoffgebäude",
            en = "- Needed amount of gatherer",
        },
    },

    Consume = {
        Title = {
            de = "",
            en = "",
        },
        Text = {
            de = "- Durch Siedler zu konsumierende Menge",
            en = "- Amount to be consumed by the settlers",
        },
    },

    Products = {
        Title = {
            de = "",
            en = "",
        },
        Text = {
            de = "- Benötigte Menge",
            en = "- Needed amount",
        },
    },

    Buff = {
        Title = {
            de = "Bonus aktivieren",
            en = "Activate Buff",
        },
        Text = {
            de = "- Aktiviere diesen Bonus auf den Ruf der Stadt",
            en = "- Raise the city reputatition with this buff",
        },
    },

    Leader = {
        Title = {
            de = "Batalione",
            en = "Battalions",
        },
        Text = {
            de = "- Menge an Batalionen unterhalten",
            en = "- Battalions you need under your command",
        },
    },

    Soldiers = {
        Title = {
            de = "Soldaten",
            en = "Soldiers",
        },
        Text = {
            de = "- Menge an Streitkräften unterhalten",
            en = "- Soldiers you need under your command",
        },
    },

    Worker = {
        Title = {
            de = "Arbeiter",
            en = "Workers",
        },
        Text = {
            de = "- Menge an arbeitender Bevölkerung",
            en = "- Workers you need under your reign",
        },
    },

    Entities = {
        Title = {
            de = "",
            en = "",
        },
        Text = {
            de = "- Benötigte Menge",
            en = "- Needed Amount",
        },
    },

    Buildings = {
        Title = {
            de = "Gebäude",
            en = "Buildings",
        },
        Text = {
            de = "- Gesamtmenge an Gebäuden",
            en = "- Amount of buildings",
        },
    },

    Weapons = {
        Title = {
            de = "Waffen",
            en = "Weapons",
        },
        Text = {
            de = "- Benötigte Menge an Waffen",
            en = "- Needed amount of weapons",
        },
    },

    HeavyWeapons = {
        Title = {
            de = "Belagerungsgeräte",
            en = "Siege Engines",
        },
        Text = {
            de = "- Benötigte Menge an Belagerungsgeräten",
            en = "- Needed amount of siege engine",
        },
    },

    Spouse = {
        Title = {
            de = "Ehefrauen",
            en = "Spouses",
        },
        Text = {
            de = "- Benötigte Anzahl Ehefrauen in der Stadt",
            en = "- Needed amount of spouses in your city",
        },
    },
};

Core:RegisterBundle("BundleKnightTitleRequirements");

-- -------------------------------------------------------------------------- --
-- Spielfunktionen                                                            --
-- -------------------------------------------------------------------------- --

---
-- Prüft, ob genug Entities in einer bestimmten Kategorie existieren.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _KnightTitle Nächster Titel
-- @param[type=number] _i Button Index
-- @within Originalfunktionen
-- @local
--
DoesNeededNumberOfEntitiesInCategoryForKnightTitleExist = function(_PlayerID, _KnightTitle, _i)
    if KnightTitleRequirements[_KnightTitle].Category == nil then
        return;
    end
    if _i then
        local EntityCategory = KnightTitleRequirements[_KnightTitle].Category[_i][1];
        local NeededAmount = KnightTitleRequirements[_KnightTitle].Category[_i][2];

        local ReachedAmount = 0;
        if EntityCategory == EntityCategories.Spouse then
            ReachedAmount = Logic.GetNumberOfSpouses(_PlayerID);
        else
            local Buildings = {Logic.GetPlayerEntitiesInCategory(_PlayerID, EntityCategory)};
            for i=1, #Buildings do
                if Logic.IsBuilding(Buildings[i]) == 1 then
                    if Logic.IsConstructionComplete(Buildings[i]) == 1 then
                        ReachedAmount = ReachedAmount +1;
                    end
                else
                    ReachedAmount = ReachedAmount +1;
                end
            end
        end

        if ReachedAmount &#x3E;= NeededAmount then
            return true, ReachedAmount, NeededAmount;
        end
        return false, ReachedAmount, NeededAmount;
    else
        local bool, reach, need;
        for i=1,#KnightTitleRequirements[_KnightTitle].Category do
            bool, reach, need = DoesNeededNumberOfEntitiesInCategoryForKnightTitleExist(_PlayerID, _KnightTitle, i);
            if bool == false then
                return bool, reach, need
            end
        end
        return bool;
    end
end

---
-- Prüft, ob genug Entities eines bestimmten Typs existieren.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _KnightTitle Nächster Titel
-- @param[type=number] _i Button Index
-- @within Originalfunktionen
-- @local
--
DoesNeededNumberOfEntitiesOfTypeForKnightTitleExist = function(_PlayerID, _KnightTitle, _i)
    if KnightTitleRequirements[_KnightTitle].Entities == nil then
        return;
    end
    if _i then
        local EntityType = KnightTitleRequirements[_KnightTitle].Entities[_i][1];
        local NeededAmount = KnightTitleRequirements[_KnightTitle].Entities[_i][2];
        local Buildings = GetPlayerEntities(_PlayerID, EntityType);

        local ReachedAmount = 0;
        for i=1, #Buildings do
            if Logic.IsBuilding(Buildings[i]) == 1 then
                if Logic.IsConstructionComplete(Buildings[i]) == 1 then
                    ReachedAmount = ReachedAmount +1;
                end
            else
                ReachedAmount = ReachedAmount +1;
            end
        end

        if ReachedAmount &#x3E;= NeededAmount then
            return true, ReachedAmount, NeededAmount;
        end
        return false, ReachedAmount, NeededAmount;
    else
        local bool, reach, need;
        for i=1,#KnightTitleRequirements[_KnightTitle].Entities do
            bool, reach, need = DoesNeededNumberOfEntitiesOfTypeForKnightTitleExist(_PlayerID, _KnightTitle, i);
            if bool == false then
                return bool, reach, need
            end
        end
        return bool;
    end
end

---
-- Prüft, ob es genug Einheiten eines Warentyps gibt.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _KnightTitle Nächster Titel
-- @param[type=number] _i Button Index
-- @within Originalfunktionen
-- @local
--
DoesNeededNumberOfGoodTypesForKnightTitleExist = function(_PlayerID, _KnightTitle, _i)
    if KnightTitleRequirements[_KnightTitle].Goods == nil then
        return;
    end
    if _i then
        local GoodType = KnightTitleRequirements[_KnightTitle].Goods[_i][1];
        local NeededAmount = KnightTitleRequirements[_KnightTitle].Goods[_i][2];
        local ReachedAmount = GetPlayerGoodsInSettlement(GoodType, _PlayerID, true);

        if ReachedAmount &#x3E;= NeededAmount then
            return true, ReachedAmount, NeededAmount;
        end
        return false, ReachedAmount, NeededAmount;
    else
        local bool, reach, need;
        for i=1,#KnightTitleRequirements[_KnightTitle].Goods do
            bool, reach, need = DoesNeededNumberOfGoodTypesForKnightTitleExist(_PlayerID, _KnightTitle, i);
            if bool == false then
                return bool, reach, need
            end
        end
        return bool;
    end
end

---
-- Prüft, ob die Siedler genug Einheiten einer Ware konsumiert haben.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _KnightTitle Nächster Titel
-- @param[type=number] _i Button Index
-- @within Originalfunktionen
-- @local
--
DoNeededNumberOfConsumedGoodsForKnightTitleExist = function( _PlayerID, _KnightTitle, _i)
    if KnightTitleRequirements[_KnightTitle].Consume == nil then
        return;
    end
    if _i then
        QSB.ConsumedGoodsCounter[_PlayerID] = QSB.ConsumedGoodsCounter[_PlayerID] or {};

        local GoodType = KnightTitleRequirements[_KnightTitle].Consume[_i][1];
        local GoodAmount = QSB.ConsumedGoodsCounter[_PlayerID][GoodType] or 0;
        local NeededGoodAmount = KnightTitleRequirements[_KnightTitle].Consume[_i][2];
        if GoodAmount &#x3E;= NeededGoodAmount then
            return true, GoodAmount, NeededGoodAmount;
        else
            return false, GoodAmount, NeededGoodAmount;
        end
    else
        local bool, reach, need;
        for i=1,#KnightTitleRequirements[_KnightTitle].Consume do
            bool, reach, need = DoNeededNumberOfConsumedGoodsForKnightTitleExist(_PlayerID, _KnightTitle, i);
            if bool == false then
                return false, reach, need
            end
        end
        return true, reach, need;
    end
end

---
-- Prüft, ob genug Waren der Kategorie hergestellt wurde.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _KnightTitle Nächster Titel
-- @param[type=number] _i Button Index
-- @within Originalfunktionen
-- @local
--
DoNumberOfProductsInCategoryExist = function(_PlayerID, _KnightTitle, _i)
    if KnightTitleRequirements[_KnightTitle].Products == nil then
        return;
    end
    if _i then
        local GoodAmount = 0;
        local NeedAmount = KnightTitleRequirements[_KnightTitle].Products[_i][2];
        local GoodCategory = KnightTitleRequirements[_KnightTitle].Products[_i][1];
        local GoodsInCategory = {Logic.GetGoodTypesInGoodCategory(GoodCategory)};

        for i=1, #GoodsInCategory do
            GoodAmount = GoodAmount + GetPlayerGoodsInSettlement(GoodsInCategory[i], _PlayerID, true);
        end
        return (GoodAmount &#x3E;= NeedAmount), GoodAmount, NeedAmount;
    else
        local bool, reach, need;
        for i=1,#KnightTitleRequirements[_KnightTitle].Products do
            bool, reach, need = DoNumberOfProductsInCategoryExist(_PlayerID, _KnightTitle, i);
            if bool == false then
                return bool, reach, need
            end
        end
        return bool;
    end
end

---
-- Prüft, ob ein bestimmter Buff für den Spieler aktiv ist.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _KnightTitle Nächster Titel
-- @param[type=number] _i Button Index
-- @within Originalfunktionen
-- @local
--
DoNeededDiversityBuffForKnightTitleExist = function(_PlayerID, _KnightTitle, _i)
    if KnightTitleRequirements[_KnightTitle].Buff == nil then
        return;
    end
    if _i then
        local buff = KnightTitleRequirements[_KnightTitle].Buff[_i];
        if Logic.GetBuff(_PlayerID,buff) and Logic.GetBuff(_PlayerID,buff) ~= 0 then
            return true;
        end
        return false;
    else
        local bool, reach, need;
        for i=1,#KnightTitleRequirements[_KnightTitle].Buff do
            bool, reach, need = DoNeededDiversityBuffForKnightTitleExist(_PlayerID, _KnightTitle, i);
            if bool == false then
                return bool, reach, need
            end
        end
        return bool;
    end
end

---
-- Prüft, ob die Custom Function true vermeldet.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _KnightTitle Nächster Titel
-- @param[type=number] _i Button Index
-- @within Originalfunktionen
-- @local
--
DoCustomFunctionForKnightTitleSucceed = function(_PlayerID, _KnightTitle, _i)
    if KnightTitleRequirements[_KnightTitle].Custom == nil then
        return;
    end
    if _i then
        return KnightTitleRequirements[_KnightTitle].Custom[_i][1]();
    else
        local bool, reach, need;
        for i=1,#KnightTitleRequirements[_KnightTitle].Custom do
            bool, reach, need = DoCustomFunctionForKnightTitleSucceed(_PlayerID, _KnightTitle, i);
            if bool == false then
                return bool, reach, need
            end
        end
        return bool;
    end
end

---
-- Prüft, ob genug Dekoration eines Typs angebracht wurde.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _KnightTitle Nächster Titel
-- @param[type=number] _i Button Index
-- @within Originalfunktionen
-- @local
--
DoNeededNumberOfDecoratedBuildingsForKnightTitleExist = function( _PlayerID, _KnightTitle, _i)
    if KnightTitleRequirements[_KnightTitle].DecoratedBuildings == nil then
        return
    end

    if _i then
        local CityBuildings = {Logic.GetPlayerEntitiesInCategory(_PlayerID, EntityCategories.CityBuilding)}
        local DecorationGoodType = KnightTitleRequirements[_KnightTitle].DecoratedBuildings[_i][1]
        local NeededBuildingsWithDecoration = KnightTitleRequirements[_KnightTitle].DecoratedBuildings[_i][2]
        local BuildingsWithDecoration = 0

        for i=1, #CityBuildings do
            local BuildingID = CityBuildings[i]
            local GoodState = Logic.GetBuildingWealthGoodState(BuildingID, DecorationGoodType)
            if GoodState &#x3E; 0 then
                BuildingsWithDecoration = BuildingsWithDecoration + 1
            end
        end

        if BuildingsWithDecoration &#x3E;= NeededBuildingsWithDecoration then
            return true, BuildingsWithDecoration, NeededBuildingsWithDecoration
        else
            return false, BuildingsWithDecoration, NeededBuildingsWithDecoration
        end
    else
        local bool, reach, need;
        for i=1,#KnightTitleRequirements[_KnightTitle].DecoratedBuildings do
            bool, reach, need = DoNeededNumberOfDecoratedBuildingsForKnightTitleExist(_PlayerID, _KnightTitle, i);
            if bool == false then
                return bool, reach, need
            end
        end
        return bool;
    end
end

---
-- Prüft, ob die Spezialgebäude weit genug ausgebaut sind.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _KnightTitle Nächster Titel
-- @param[type=number] _EntityCategory Entity Category
-- @within Originalfunktionen
-- @local
--
DoNeededSpecialBuildingUpgradeForKnightTitleExist = function( _PlayerID, _KnightTitle, _EntityCategory)
    local SpecialBuilding
    local SpecialBuildingName
    if _EntityCategory == EntityCategories.Headquarters then
        SpecialBuilding = Logic.GetHeadquarters(_PlayerID)
        SpecialBuildingName = "Headquarters"
    elseif _EntityCategory == EntityCategories.Storehouse then
        SpecialBuilding = Logic.GetStoreHouse(_PlayerID)
        SpecialBuildingName = "Storehouse"
    elseif _EntityCategory == EntityCategories.Cathedrals then
        SpecialBuilding = Logic.GetCathedral(_PlayerID)
        SpecialBuildingName = "Cathedrals"
    else
        return
    end
    if KnightTitleRequirements[_KnightTitle][SpecialBuildingName] == nil then
        return
    end
    local NeededUpgradeLevel = KnightTitleRequirements[_KnightTitle][SpecialBuildingName]
    if SpecialBuilding ~= nil then
        local SpecialBuildingUpgradeLevel = Logic.GetUpgradeLevel(SpecialBuilding)
        if SpecialBuildingUpgradeLevel &#x3E;= NeededUpgradeLevel then
            return true, SpecialBuildingUpgradeLevel, NeededUpgradeLevel
        else
            return false, SpecialBuildingUpgradeLevel, NeededUpgradeLevel
        end
    else
        return false, 0, NeededUpgradeLevel
    end
end

---
-- Prüft, ob der Ruf der Stadt hoch genug ist.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _KnightTitle Nächster Titel
-- @within Originalfunktionen
-- @local
--
DoesNeededCityReputationForKnightTitleExist = function(_PlayerID, _KnightTitle)
    if KnightTitleRequirements[_KnightTitle].Reputation == nil then
        return;
    end
    local NeededAmount = KnightTitleRequirements[_KnightTitle].Reputation;
    if not NeededAmount then
        return;
    end
    local ReachedAmount = math.floor((Logic.GetCityReputation(_PlayerID) * 100) + 0.5);
    if ReachedAmount &#x3E;= NeededAmount then
        return true, ReachedAmount, NeededAmount;
    end
    return false, ReachedAmount, NeededAmount;
end

---
-- Prüft, ob genug Gebäude vollständig dekoriert sind.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _KnightTitle Nächster Titel
-- @within Originalfunktionen
-- @local
--
DoNeededNumberOfFullDecoratedBuildingsForKnightTitleExist = function( _PlayerID, _KnightTitle)
    if KnightTitleRequirements[_KnightTitle].FullDecoratedBuildings == nil then
        return
    end
    local CityBuildings = {Logic.GetPlayerEntitiesInCategory(_PlayerID, EntityCategories.CityBuilding)}
    local NeededBuildingsWithDecoration = KnightTitleRequirements[_KnightTitle].FullDecoratedBuildings
    local BuildingsWithDecoration = 0

    for i=1, #CityBuildings do
        local BuildingID = CityBuildings[i]
        local AmountOfWealthGoodsAtBuilding = 0

        if Logic.GetBuildingWealthGoodState(BuildingID, Goods.G_Banner ) &#x3E; 0 then
            AmountOfWealthGoodsAtBuilding = AmountOfWealthGoodsAtBuilding  + 1
        end
        if Logic.GetBuildingWealthGoodState(BuildingID, Goods.G_Sign  ) &#x3E; 0 then
            AmountOfWealthGoodsAtBuilding = AmountOfWealthGoodsAtBuilding  + 1
        end
        if Logic.GetBuildingWealthGoodState(BuildingID, Goods.G_Candle) &#x3E; 0 then
            AmountOfWealthGoodsAtBuilding = AmountOfWealthGoodsAtBuilding  + 1
        end
        if Logic.GetBuildingWealthGoodState(BuildingID, Goods.G_Ornament  ) &#x3E; 0 then
            AmountOfWealthGoodsAtBuilding = AmountOfWealthGoodsAtBuilding  + 1
        end
        if AmountOfWealthGoodsAtBuilding &#x3E;= 4 then
            BuildingsWithDecoration = BuildingsWithDecoration + 1
        end
    end

    if BuildingsWithDecoration &#x3E;= NeededBuildingsWithDecoration then
        return true, BuildingsWithDecoration, NeededBuildingsWithDecoration
    else
        return false, BuildingsWithDecoration, NeededBuildingsWithDecoration
    end
end

---
-- Prüft, ob der Spieler befördert werden kann.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _KnightTitle Nächster Titel
-- @within Originalfunktionen
-- @local
--
CanKnightBePromoted = function(_PlayerID, _KnightTitle)
    if _KnightTitle == nil then
        _KnightTitle = Logic.GetKnightTitle(_PlayerID) + 1;
    end

    if Logic.CanStartFestival(_PlayerID, 1) == true then
        if  KnightTitleRequirements[_KnightTitle] ~= nil
        and DoesNeededNumberOfSettlersForKnightTitleExist(_PlayerID, _KnightTitle) ~= false
        and DoNeededNumberOfGoodsForKnightTitleExist( _PlayerID, _KnightTitle)  ~= false
        and DoNeededSpecialBuildingUpgradeForKnightTitleExist( _PlayerID, _KnightTitle, EntityCategories.Headquarters) ~= false
        and DoNeededSpecialBuildingUpgradeForKnightTitleExist( _PlayerID, _KnightTitle, EntityCategories.Storehouse) ~= false
        and DoNeededSpecialBuildingUpgradeForKnightTitleExist( _PlayerID, _KnightTitle, EntityCategories.Cathedrals)  ~= false
        and DoNeededNumberOfRichBuildingsForKnightTitleExist( _PlayerID, _KnightTitle)  ~= false
        and DoNeededNumberOfFullDecoratedBuildingsForKnightTitleExist( _PlayerID, _KnightTitle) ~= false
        and DoNeededNumberOfDecoratedBuildingsForKnightTitleExist( _PlayerID, _KnightTitle) ~= false
        and DoesNeededCityReputationForKnightTitleExist( _PlayerID, _KnightTitle) ~= false
        and DoesNeededNumberOfEntitiesInCategoryForKnightTitleExist( _PlayerID, _KnightTitle) ~= false
        and DoesNeededNumberOfEntitiesOfTypeForKnightTitleExist( _PlayerID, _KnightTitle) ~= false
        and DoesNeededNumberOfGoodTypesForKnightTitleExist( _PlayerID, _KnightTitle) ~= false
        and DoNeededDiversityBuffForKnightTitleExist( _PlayerID, _KnightTitle) ~= false
        and DoCustomFunctionForKnightTitleSucceed( _PlayerID, _KnightTitle) ~= false
        and DoNeededNumberOfConsumedGoodsForKnightTitleExist( _PlayerID, _KnightTitle) ~= false
        and DoNumberOfProductsInCategoryExist( _PlayerID, _KnightTitle) ~= false then
            return true;
        end
    end
    return false;
end

---
-- Der Spieler gewinnt das Spiel
-- @within Originalfunktionen
-- @local
--
VictroryBecauseOfTitle = function()
    QuestTemplate:TerminateEventsAndStuff();
    Victory(g_VictoryAndDefeatType.VictoryMissionComplete);
end

-- -------------------------------------------------------------------------- --
-- Aufstiegsbedingungen                                                       --
-- -------------------------------------------------------------------------- --

---
-- Definiert andere Aufstiegsbedingungen für den Spieler. Muss stets nach dem
-- Laden der QSB im globalen und lokalen Skript aufgerufen werden!
--
-- Diese Funktion muss entweder in der QSB modifiziert oder sowohl im globalen
-- als auch im lokalen Skript überschrieben werden. Bei Modifikationen muss
-- das Schema für Aufstiegsbedingungen und Rechtevergabe immer beibehalten
-- werden.
--
-- @within Originalfunktionen
--
InitKnightTitleTables = function()
    KnightTitles = {}
    KnightTitles.Knight     = 0
    KnightTitles.Mayor      = 1
    KnightTitles.Baron      = 2
    KnightTitles.Earl       = 3
    KnightTitles.Marquees   = 4
    KnightTitles.Duke       = 5
    KnightTitles.Archduke   = 6

    -- ---------------------------------------------------------------------- --
    -- Rechte und Pflichten                                                   --
    -- ---------------------------------------------------------------------- --

    NeedsAndRightsByKnightTitle = {}

    -- Ritter ------------------------------------------------------------------

    NeedsAndRightsByKnightTitle[KnightTitles.Knight] = {
        ActivateNeedForPlayer,
        {
            Needs.Nutrition,                                    -- Bedürfnis: Nahrung
            Needs.Medicine,                                     -- Bedürfnis: Medizin
        },
        ActivateRightForPlayer,
        {
            Technologies.R_Gathering,                           -- Recht: Rohstoffsammler
            Technologies.R_Woodcutter,                          -- Recht: Holzfäller
            Technologies.R_StoneQuarry,                         -- Recht: Steinbruch
            Technologies.R_HuntersHut,                          -- Recht: Jägerhütte
            Technologies.R_FishingHut,                          -- Recht: Fischerhütte
            Technologies.R_CattleFarm,                          -- Recht: Kuhfarm
            Technologies.R_GrainFarm,                           -- Recht: Getreidefarm
            Technologies.R_SheepFarm,                           -- Recht: Schaffarm
            Technologies.R_IronMine,                            -- Recht: Eisenmine
            Technologies.R_Beekeeper,                           -- Recht: Imkerei
            Technologies.R_HerbGatherer,                        -- Recht: Kräutersammler
            Technologies.R_Nutrition,                           -- Recht: Nahrung
            Technologies.R_Bakery,                              -- Recht: Bäckerei
            Technologies.R_Dairy,                               -- Recht: Käserei
            Technologies.R_Butcher,                             -- Recht: Metzger
            Technologies.R_SmokeHouse,                          -- Recht: Räucherhaus
            Technologies.R_Clothes,                             -- Recht: Kleidung
            Technologies.R_Tanner,                              -- Recht: Ledergerber
            Technologies.R_Weaver,                              -- Recht: Weber
            Technologies.R_Construction,                        -- Recht: Konstruktion
            Technologies.R_Wall,                                -- Recht: Mauer
            Technologies.R_Pallisade,                           -- Recht: Palisade
            Technologies.R_Trail,                               -- Recht: Pfad
            Technologies.R_KnockDown,                           -- Recht: Abriss
            Technologies.R_Sermon,                              -- Recht: Predigt
            Technologies.R_SpecialEdition,                      -- Recht: Special Edition
            Technologies.R_SpecialEdition_Pavilion,             -- Recht: Pavilion AeK SE
        }
    }

    -- Landvogt ----------------------------------------------------------------

    NeedsAndRightsByKnightTitle[KnightTitles.Mayor] = {
        ActivateNeedForPlayer,
        {
            Needs.Clothes,                                      -- Bedürfnis: KLeidung
        },
        ActivateRightForPlayer, {
            Technologies.R_Hygiene,                             -- Recht: Hygiene
            Technologies.R_Soapmaker,                           -- Recht: Seifenmacher
            Technologies.R_BroomMaker,                          -- Recht: Besenmacher
            Technologies.R_Military,                            -- Recht: Militär
            Technologies.R_SwordSmith,                          -- Recht: Schwertschmied
            Technologies.R_Barracks,                            -- Recht: Schwertkämpferkaserne
            Technologies.R_Thieves,                             -- Recht: Diebe
            Technologies.R_SpecialEdition_StatueFamily,         -- Recht: Familienstatue Aek SE
        },
        StartKnightsPromotionCelebration                        -- Beförderungsfest aktivieren
    }

    -- Baron -------------------------------------------------------------------

    NeedsAndRightsByKnightTitle[KnightTitles.Baron] = {
        ActivateNeedForPlayer,
        {
            Needs.Hygiene,                                      -- Bedürfnis: Hygiene
        },
        ActivateRightForPlayer, {
            Technologies.R_Medicine,                            -- Recht: Medizin
            Technologies.R_BowMaker,                            -- Recht: Bogenmacher
            Technologies.R_BarracksArchers,                     -- Recht: Bogenschützenkaserne
            Technologies.R_Entertainment,                       -- Recht: Unterhaltung
            Technologies.R_Tavern,                              -- Recht: Taverne
            Technologies.R_Festival,                            -- Recht: Fest
            Technologies.R_Street,                              -- Recht: Straße
            Technologies.R_SpecialEdition_Column,               -- Recht: Säule AeK SE
        },
        StartKnightsPromotionCelebration                        -- Beförderungsfest aktivieren
    }

    -- Graf --------------------------------------------------------------------

    NeedsAndRightsByKnightTitle[KnightTitles.Earl] = {
        ActivateNeedForPlayer,
        {
            Needs.Entertainment,                                -- Bedürfnis: Unterhaltung
            Needs.Prosperity,                                   -- Bedürfnis: Reichtum
        },
        ActivateRightForPlayer, {
            Technologies.R_SiegeEngineWorkshop,                 -- Recht: Belagerungswaffenschmied
            Technologies.R_BatteringRam,                        -- Recht: Ramme
            Technologies.R_Baths,                               -- Recht: Badehaus
            Technologies.R_AmmunitionCart,                      -- Recht: Munitionswagen
            Technologies.R_Prosperity,                          -- Recht: Reichtum
            Technologies.R_Taxes,                               -- Recht: Steuern einstellen
            Technologies.R_Ballista,                            -- Recht: Mauerkatapult
            Technologies.R_SpecialEdition_StatueSettler,        -- Recht: Siedlerstatue AeK SE
        },
        StartKnightsPromotionCelebration                        -- Beförderungsfest aktivieren
    }

    -- Marquees ----------------------------------------------------------------

    NeedsAndRightsByKnightTitle[KnightTitles.Marquees] = {
        ActivateNeedForPlayer,
        {
            Needs.Wealth,                                       -- Bedürfnis: Verschönerung
        },
        ActivateRightForPlayer, {
            Technologies.R_Theater,                             -- Recht: Theater
            Technologies.R_Wealth,                              -- Recht: Schmuckgebäude
            Technologies.R_BannerMaker,                         -- Recht: Bannermacher
            Technologies.R_SiegeTower,                          -- Recht: Belagerungsturm
            Technologies.R_SpecialEdition_StatueProduction,     -- Recht: Produktionsstatue AeK SE
        },
        StartKnightsPromotionCelebration                        -- Beförderungsfest aktivieren
    }

    -- Herzog ------------------------------------------------------------------

    NeedsAndRightsByKnightTitle[KnightTitles.Duke] = {
        ActivateNeedForPlayer, nil,
        ActivateRightForPlayer, {
            Technologies.R_Catapult,                            -- Recht: Katapult
            Technologies.R_Carpenter,                           -- Recht: Tischler
            Technologies.R_CandleMaker,                         -- Recht: Kerzenmacher
            Technologies.R_Blacksmith,                          -- Recht: Schmied
            Technologies.R_SpecialEdition_StatueDario,          -- Recht: Dariostatue AeK SE
        },
        StartKnightsPromotionCelebration                        -- Beförderungsfest aktivieren
    }

    -- Erzherzog ---------------------------------------------------------------

    NeedsAndRightsByKnightTitle[KnightTitles.Archduke] = {
        ActivateNeedForPlayer,nil,
        ActivateRightForPlayer, {
            Technologies.R_Victory                              -- Sieg
        },
        -- VictroryBecauseOfTitle,                              -- Sieg wegen Titel
        StartKnightsPromotionCelebration                        -- Beförderungsfest aktivieren
    }



    -- Reich des Ostens --------------------------------------------------------

    if g_GameExtraNo &#x3E;= 1 then
        local TechnologiesTableIndex = 4;
        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Mayor][TechnologiesTableIndex],Technologies.R_Cistern);
        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Mayor][TechnologiesTableIndex],Technologies.R_Beautification_Brazier);
        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Mayor][TechnologiesTableIndex],Technologies.R_Beautification_Shrine);
        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Baron][TechnologiesTableIndex],Technologies.R_Beautification_Pillar);
        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Earl][TechnologiesTableIndex],Technologies.R_Beautification_StoneBench);
        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Earl][TechnologiesTableIndex],Technologies.R_Beautification_Vase);
        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Marquees][TechnologiesTableIndex],Technologies.R_Beautification_Sundial);
        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Archduke][TechnologiesTableIndex],Technologies.R_Beautification_TriumphalArch);
        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Duke][TechnologiesTableIndex],Technologies.R_Beautification_VictoryColumn);
    end



    -- ---------------------------------------------------------------------- --
    -- Bedingungen                                                            --
    -- ---------------------------------------------------------------------- --

    KnightTitleRequirements = {}

    -- Ritter ------------------------------------------------------------------

    KnightTitleRequirements[KnightTitles.Mayor] = {}
    KnightTitleRequirements[KnightTitles.Mayor].Headquarters = 1
    KnightTitleRequirements[KnightTitles.Mayor].Settlers = 10
    KnightTitleRequirements[KnightTitles.Mayor].Products = {
        {GoodCategories.GC_Clothes, 6},
    }

    -- Baron -------------------------------------------------------------------

    KnightTitleRequirements[KnightTitles.Baron] = {}
    KnightTitleRequirements[KnightTitles.Baron].Settlers = 30
    KnightTitleRequirements[KnightTitles.Baron].Headquarters = 1
    KnightTitleRequirements[KnightTitles.Baron].Storehouse = 1
    KnightTitleRequirements[KnightTitles.Baron].Cathedrals = 1
    KnightTitleRequirements[KnightTitles.Baron].Products = {
        {GoodCategories.GC_Hygiene, 12},
    }

    -- Graf --------------------------------------------------------------------

    KnightTitleRequirements[KnightTitles.Earl] = {}
    KnightTitleRequirements[KnightTitles.Earl].Settlers = 50
    KnightTitleRequirements[KnightTitles.Earl].Headquarters = 2
    KnightTitleRequirements[KnightTitles.Earl].Products = {
        {GoodCategories.GC_Entertainment, 18},
    }

    -- Marquess ----------------------------------------------------------------

    KnightTitleRequirements[KnightTitles.Marquees] = {}
    KnightTitleRequirements[KnightTitles.Marquees].Settlers = 70
    KnightTitleRequirements[KnightTitles.Marquees].Headquarters = 2
    KnightTitleRequirements[KnightTitles.Marquees].Storehouse = 2
    KnightTitleRequirements[KnightTitles.Marquees].Cathedrals = 2
    KnightTitleRequirements[KnightTitles.Marquees].RichBuildings = 20

    -- Herzog ------------------------------------------------------------------

    KnightTitleRequirements[KnightTitles.Duke] = {}
    KnightTitleRequirements[KnightTitles.Duke].Settlers = 90
    KnightTitleRequirements[KnightTitles.Duke].Storehouse = 2
    KnightTitleRequirements[KnightTitles.Duke].Cathedrals = 2
    KnightTitleRequirements[KnightTitles.Duke].Headquarters = 3
    KnightTitleRequirements[KnightTitles.Duke].DecoratedBuildings = {
        {Goods.G_Banner, 9 },
    }

    -- Erzherzog ---------------------------------------------------------------

    KnightTitleRequirements[KnightTitles.Archduke] = {}
    KnightTitleRequirements[KnightTitles.Archduke].Settlers = 150
    KnightTitleRequirements[KnightTitles.Archduke].Storehouse = 3
    KnightTitleRequirements[KnightTitles.Archduke].Cathedrals = 3
    KnightTitleRequirements[KnightTitles.Archduke].Headquarters = 3
    KnightTitleRequirements[KnightTitles.Archduke].RichBuildings = 30
    KnightTitleRequirements[KnightTitles.Archduke].FullDecoratedBuildings = 30

    -- Einstellungen Aktivieren
    CreateTechnologyKnightTitleTable()
end

</code></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundleminimapmarker.lua.html">
            <div class='doclink'>
                <div>BundleMinimapMarker</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><code>-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundleMinimapMarker                                          # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Ermöglocht das Anlegen von Markierungen auf der Minimap.
--
-- Mögliche Typen von Markierungen:
-- &#x3C;ul&#x3E;
-- &#x3C;li&#x3E;Signal: Eine flüchtige Markierung, die nach wenigen Sekunden wieder
-- verschwindet.&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;Marker: Eine statische Markierung, die dauerhaft verbleibt.&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;Pulse: Eine pulsierende Markierung, die dauerhaft verbleibt.&#x3C;/li&#x3E;
-- &#x3C;/ul&#x3E;
--
-- Die Farbe eines Markers kann auf 2 verschiedene Weisen bestimmt werden.
-- &#x3C;ol&#x3E;
-- &#x3C;li&#x3E;Durch die Spielerfarbe des "Besitzers" der Markierung.
-- &#x3C;pre&#x3E; API.CreateMinimapSignal(1, GetPosition("pos"));&#x3C;/pre&#x3E;
-- &#x3C;/li&#x3E;
-- &#x3C;li&#x3E;Durch Übergabe einer vordefinierten Farbe oder einer Farbtabelle
-- &#x3C;pre&#x3E;
-- API.CreateMinimapSignal(MarkerColor.Red, GetPosition("pos"));
-- API.CreateMinimapSignal({180, 180, 180}, GetPosition("pos"));&#x3C;/pre&#x3E;
-- &#x3C;/li&#x3E;
-- &#x3C;/ol&#x3E;
--
-- Durchsichtige Marker sind nicht vorgesehen!
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundleMinimapMarker = {};

API = API or {};
QSB = QSB or {};

---
-- Vordefinierte Farben für Minimap Marker.
-- @field Blue Königsblau
-- @field Red Blutrot
-- @field Yellow Sonnengelb
-- @field Green Blattgrün
--
-- @usage API.CreateMinimapSignal(MarkerColor.Red, GetPosition("pos"));
--
MarkerColor = {
    Blue    = { 17,   7, 216},
    Red     = {216,   7,   7},
    Yellow  = { 25, 185,   8},
    Green   = { 16, 194, 220},
}

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Erstellt eine flüchtige Markierung auf der Minimap.
--
-- &#x3C;b&#x3E;Hinweis&#x3C;/b&#x3E;: Die Farbe richtet sich nach der Spielerfarbe!
--
-- &#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: CreateMinimapSignal
--
-- @param _PlayerID PlayerID oder Farbtabelle (Spielernummer oder Farbtabelle)
-- @param _Position Position des Markers (Skriptname, ID oder Position)
-- @return[type=number] ID des Markers
-- @within Anwenderfunktionen
--
-- @usage API.CreateMinimapSignal(1, GetPosition("pos"));
--
function API.CreateMinimapSignal(_PlayerID, _Position)
    if GUI then
        fatal("API.CreateMinimapSignal: Can not be used in local script!");
        return;
    end

    local Position = _Position;
    if type(_Position) ~= "table" then
        Position = GetPosition(_Position);
    end

    if type(Position) ~= "table" or (not Position.X or not Position.X) then
        fatal("API.CreateMinimapSignal: Position is invalid!");
        return;
    end
    return BundleMinimapMarker.Global:CreateMinimapMarker(_PlayerID, Position.X, Position.Y, 7);
end
CreateMinimapSignal = API.CreateMinimapSignal;

---
-- Erstellt eine statische Markierung auf der Minimap.
--
-- &#x3C;b&#x3E;Hinweis&#x3C;/b&#x3E;: Die Farbe richtet sich nach der Spielerfarbe!
--
-- &#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: CreateMinimapMarker
--
-- @param _PlayerID PlayerID oder Farbtabelle (Spielernummer oder Farbtabelle)
-- @param _Position Position des Markers (Skriptname, ID oder Position)
-- @return[type=number] ID des Markers
-- @within Anwenderfunktionen
--
-- @usage API.CreateMinimapMarker(1, GetPosition("pos"));
--
function API.CreateMinimapMarker(_PlayerID, _Position)
    if GUI then
        fatal("API.CreateMinimapMarker: Can not be used in local script!");
        return;
    end

    local Position = _Position;
    if type(_Position) ~= "table" then
        Position = GetPosition(_Position);
    end

    if type(Position) ~= "table" or (not Position.X or not Position.X) then
        fatal("API.CreateMinimapMarker: Position is invalid!");
        return;
    end
    return BundleMinimapMarker.Global:CreateMinimapMarker(_PlayerID, Position.X, Position.Y, 6);
end
CreateMinimapMarker = API.CreateMinimapMarker;

---
-- Erstellt eine pulsierende Markierung auf der Minimap.
--
-- &#x3C;b&#x3E;Hinweis&#x3C;/b&#x3E;: Die Farbe richtet sich nach der Spielerfarbe!
--
-- &#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: CreateMinimapPulse
--
-- @param _PlayerID PlayerID oder Farbtabelle (Spielernummer oder Farbtabelle)
-- @param _Position Position des Markers (Skriptname, ID oder Position)
-- @return[type=number] ID des Markers
-- @within Anwenderfunktionen
--
-- @usage API.CreateMinimapPulse(1, GetPosition("pos"));
--
function API.CreateMinimapPulse(_PlayerID, _Position)
    if GUI then
        fatal("API.CreateMinimapPulse: Can not be used in local script!");
        return;
    end

    local Position = _Position;
    if type(_Position) ~= "table" then
        Position = GetPosition(_Position);
    end
    
    if type(Position) ~= "table" or (not Position.X or not Position.X) then
        fatal("API.CreateMinimapPulse: Position is invalid!");
        return;
    end
    return BundleMinimapMarker.Global:CreateMinimapMarker(_PlayerID, Position.X, Position.Y, 1);
end
CreateMinimapPulse = API.CreateMinimapPulse;

---
-- Zerstört eine Markierung auf der Minimap.
--
-- &#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: DestroyMinimapSignal
--
-- @param[type=number] _ID ID des Markers
-- @within Anwenderfunktionen
--
-- @usage API.DestroyMinimapSignal(SomeMarkerID);
--
function API.DestroyMinimapSignal(_ID)
    if GUI then
        fatal("API.DestroyMinimapSignal: Can not be used in local script!");
        return;
    end
    if type(_ID) ~= "number" then
        fatal("API.DestroyMinimapSignal: _ID must be a number!");
        return;
    end
    BundleMinimapMarker.Global:DestroyMinimapMarker(_ID);
end
DestroyMinimapMarker = API.DestroyMinimapSignal;

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

BundleMinimapMarker = {
    Global = {
        Data = {
            MarkerCounter = 1000000,
            CreatedMinimapMarkers = {},
        },
    },
    Local = {
        Data = {},
    }
};

-- Global Script ---------------------------------------------------------------

---
-- Initialisiert das Bundle im globalen Skript.
-- @within Internal
-- @local
--
function BundleMinimapMarker.Global:Install()
    API.AddSaveGameAction(self.OnSaveGameLoaded);
end

---
-- Erstellt eine neue Markierung auf der Minimap.
-- 
-- @param[type=number] _PlayerID ID des Besitzers
-- @param[type=number] _X X-Koordinate des Markers
-- @param[type=number] _Y Y-Koordinate des Makers
-- @param[type=number] _Type Typ des Markers
-- @return[type=number] ID des Markers
-- @within Internal
-- @local
--
function BundleMinimapMarker.Global:CreateMinimapMarker(_PlayerID, _X, _Y, _Type)
    self.Data.MarkerCounter = self.Data.MarkerCounter +1;
    -- Flüchtige Markierungen werden nicht gespeichert!
    self.Data.CreatedMinimapMarkers[self.Data.MarkerCounter] = {
        _PlayerID, _X, _Y, _Type
    };
    self:ShowMinimapMarker(self.Data.MarkerCounter);
    return self.Data.MarkerCounter;
end

---
-- Zerstort eine Markierung auf der Minimap.
-- 
-- @param[type=number] _ID ID des Markers
-- @within Internal
-- @local
--
function BundleMinimapMarker.Global:DestroyMinimapMarker(_ID)
    self.Data.CreatedMinimapMarkers[_ID] = nil;
    API.Bridge([[GUI.DestroyMinimapSignal(]] .._ID.. [[)]]);
end

---
-- Zeigt eine erstellte Markierung auf der Minimap an.
-- 
-- @param[type=number] _ID ID des Markers
-- @within Internal
-- @local
--
function BundleMinimapMarker.Global:ShowMinimapMarker(_ID)
    if not self.Data.CreatedMinimapMarkers[_ID] then
        return;
    end
    local Marker = self.Data.CreatedMinimapMarkers[_ID];

    local ColorOrPlayerID = Marker[1];
    if type(ColorOrPlayerID) == "table" then
        ColorOrPlayerID = API.ConvertTableToString(ColorOrPlayerID);
    end

    API.Bridge([[
        BundleMinimapMarker.Local:ShowMinimapMarker(
            ]] .._ID.. [[,]] ..ColorOrPlayerID.. [[,]] ..Marker[2].. [[,]] ..Marker[3].. [[, ]] ..Marker[4].. [[
        )
    ]]);
end

---
-- Stellt Markierungen auf der Minimap wieder her, wenn ein Spielstand
-- geladen wird.
-- 
-- @within Internal
-- @local
--
function BundleMinimapMarker.Global.OnSaveGameLoaded()
    for k, v in pairs(BundleMinimapMarker.Global.Data.CreatedMinimapMarkers) do
        if v and v[4] ~= 7 then
            BundleMinimapMarker.Global:ShowMinimapMarker(k);
        end
    end
end

-- Local Script ------------------------------------------------------------- --

---
-- Initialisiert das Bundle im globalen Skript.
-- @within Internal
-- @local
--
function BundleMinimapMarker.Local:Install()
end

---
-- Initialisiert das Bundle im globalen Skript.
--
-- @param[type=number] _PlayerID ID des Besitzers
-- @param[type=number] _X X-Koordinate des Markers
-- @param[type=number] _Y Y-Koordinate des Makers
-- @param[type=number] _Type Typ des Markers
-- @return[type=number] ID des Markers
-- @within Internal
-- @local
--
function BundleMinimapMarker.Local:ShowMinimapMarker(_ID, _PlayerID, _X, _Y, _Type)
    local R, G, B;
    if type(_PlayerID) == "number" then
        R, G, B = GUI.GetPlayerColor(_PlayerID);
    else
        R = _PlayerID[1];
        G = _PlayerID[2];
        B = _PlayerID[3];
    end
    GUI.CreateMinimapSignalRGBA(_ID, _X, _Y, R, G, B, 255, _Type);
end

-- -------------------------------------------------------------------------- --

Core:RegisterBundle("BundleMinimapMarker");

</code></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundlemusictools.lua.html">
            <div class='doclink'>
                <div>BundleMusicTools</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><code>-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundleMusicTools                                             # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Dieses Bundle bietet die Möglichkeit Musikstücke abzuspielen. Die
-- Musik kann als einzelne Titel oder als Playlist wiedergegeben werden.
--
-- &#x3C;p&#x3E;&#x3C;a href="#API.StartMusic"&#x3E;Musik abspielen&#x3C;/a&#x3E;&#x3C;/p&#x3E;
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundleMusicTools = {};

API = API or {};
QSB = QSB or {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Startet ein Musikstück als Stimme.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; StartSong&#x3C;/p&#x3E;
--
-- Es wird nicht als Musik behandelt, sondern als Sprache! Die Lautstäkre
-- sämtlicher Sprache wird beeinflusst, weshalb immer nur 1 Song gleichzeitig
-- gespielt werden kann! Alle als Sprache abgespielten Sounds werden die
-- gleiche Lautstärke haben, wie die Musik.
--
-- _Description hat folgendes Format:
-- &#x3C;ul&#x3E;
-- &#x3C;li&#x3E;File     - Path + Dateiname&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;Volume   - Lautstärke&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;length   - abgespielte Länge in Sekunden (nicht zwingend |Musikstück|)&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;Fadeout  - Ausblendzeit in Zehntels. (&#x3E;= 5 oder 0 für sofort)&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;MuteAtmo - Hintergrundgeräusche aus&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;MuteUI   - GUI-Sounds aus&#x3C;/li&#x3E;
-- &#x3C;/ul&#x3E;
--
-- @param[type=table] _Description Definition des Musikstück
-- @within Anwenderfunktionen
--
-- @usage
-- API.StartMusic({
--     File     = "music/s6_10_antagonist.mp3",
--     Volume   = 70,
--     Length   = 49,
--     Fadeout  = 20,
--     MuteAtmo = true;
--     MuteUI   = true,
-- });
--
function API.StartMusic(_Description)
    if GUI then
        API.Fatal("Could not execute API.StartMusic in local script!");
        return;
    end
    BundleMusicTools.Global:StartSong(_Description);
end
StartSong = API.StartMusic;

---
-- Vereinfachter einzeiliger Aufruf für StartSong.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; StartSongSimple&#x3C;/p&#x3E;
--
-- @param[type=string] _File Pfad zur Datei
-- @param[type=number] _Volume Lautstärke
-- @param[type=number] _Length Abspieldauer (&#x3C;= Dauer Musikstück)
-- @param[type=number] _FadeOut Ausblenden in Sekunden
-- @within Anwenderfunktionen
--
-- @usage
-- API.StartMusicSimple("music/s6_10_antagonist.mp3", 70, 49, 1)
--
function API.StartMusicSimple(_File, _Volume, _Length, _FadeOut)
    if GUI then
        API.Bridge("API.StartMusicSimple('" .._File.. "', " .._Volume.. ", " .._Length.. ", " .._FadeOut.. ")");
        return;
    end
    local Data = {
        File     = _File,
        Volume   = _Volume,
        Length   = _Length,
        Fadeout  = _FadeOut * 10,
        MuteAtmo = true;
        MuteUI   = true,
    };
    BundleMusicTools.Global:StartSong(Data);
end
StartSongSimple = API.StartMusicSimple;

---
-- Spielt eine Playlist ab.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; StartPlaylist&#x3C;/p&#x3E;
--
-- Eine im Skript definierte Playlist, nicht
-- eine XML! Die Playlist kann einmal abgearbeitet oder auf Wiederholung
-- gestellt werden. Alle Einträge haben das Format von StartSong!
-- Zusätzlich kann der Wahrheitswert Repeat gesetzt werden, damit
-- sich die Playlist endlos wiederholt.
--
-- @param[type=table] _Playlist Definition der Playlist
-- @within Anwenderfunktionen
--
-- @usage
-- local Playlist = {
--     {
--         File     = "music/s6_10_antagonist.mp3",
--         Volume   = 70,
--         Length   = 49,
--         Fadeout  = 20,
--         MuteAtmo = true;
--         MuteUI   = true,
--     },
--     {
--         File     = "music/s6_04_blaze.mp3",
--         Volume   = 70,
--         Length   = 65,
--         Fadeout  = 20,
--         MuteAtmo = false;
--         MuteUI   = true,
--     },
-- }
-- API.StartPlaylist(Playlist);
--
function API.StartPlaylist(_Playlist)
    if GUI then
        API.Fatal("Could not execute API.StartPlaylist in local script!");
        return;
    end
    BundleMusicTools.Global:StartPlaylist(_Playlist);
end
StartPlaylist = API.StartPlaylist;

---
-- Stoppt gerade gespielte Musik und startet die Playlist mit dem
-- angegebenen Titel. Es muss eine Playlist existieren! Nachdem der
-- Titel abgespielt ist, wird die Playlist normal weiter gespielt.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; StartPlaylistTitle&#x3C;/p&#x3E;
--
-- @param[type=number] _Title Index des Titels
-- @within Anwenderfunktionen
--
function API.StartPlaylistTitle(_Title)
    if GUI then
        API.Fatal("Could not execute API.StartPlaylistTitle in local script!");
        return;
    end
    BundleMusicTools.Global:StartPlaylistTitle(_Title);
end
StartPlaylistTitle = API.StartPlaylistTitle;

---
-- Stopt Musik und stellt die alte Soundkonfiguration wieder her.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; StopSong&#x3C;/p&#x3E;
--
-- @within Anwenderfunktionen
--
function API.StopSong()
    if GUI then
        API.Bridge("API.StopSong()");
        return;
    end
    BundleMusicTools.Global:StopSong();
end
StopSong = API.StopSong;

---
-- Stopt den gerade laufenden Song und leert sowohl die Songdaten
-- als auch die Playlist.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; AbortSongOrPlaylist&#x3C;/p&#x3E;
--
-- @within Anwenderfunktionen
--
function API.AbortMusic()
    if GUI then
        API.Bridge("API.AbortMusic()");
        return;
    end
    BundleMusicTools.Global:AbortMusic();
end
AbortSongOrPlaylist = API.AbortMusic;

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

BundleMusicTools = {
    Global = {
        Data = {
            StartSongData = {},
            StartSongPlaylist = {},
            StartSongQueue = {},
        }
    },
    Local = {
        Data = {
            SoundBackup = {},
        }
    },
}

-- Global Script ---------------------------------------------------------------

---
-- Initalisiert das Bundle im globalen Skript.
--
-- @within Internal
-- @local
--
function BundleMusicTools.Global:Install()

end

---
-- Startet ein Musikstück als Stimme.
--
-- @param[type=table] _Description Beschreibung des Musikstücks
-- @within Internal
-- @local
--
function BundleMusicTools.Global:StartSong(_Description)
    if self.Data.StartSongData.Running then
        table.insert(self.Data.StartSongQueue, _Description);
    else
        assert(type(_Description.File) == "string");
        assert(type(_Description.Volume) == "number");
        assert(type(_Description.Length) == "number");
        _Description.Length = _Description.Length * 10;
        assert(type(_Description.Fadeout) == "number");
        _Description.MuteAtmo = _Description.MuteAtmo == true;
        _Description.MuteUI = _Description.MuteUI == true;
        _Description.CurrentVolume = _Description.Volume;
        _Description.Time = 0;

        self.Data.StartSongData = _Description;
        self.Data.StartSongData.Running = true;

        Logic.ExecuteInLuaLocalState([[
            BundleMusicTools.Local:BackupSound(
                ]].. _Description.Volume ..[[,
                "]].. _Description.File ..[[",
                ]].. tostring(_Description.MuteAtmo) ..[[,
                ]].. tostring(_Description.MuteUI) ..[[
            )
        ]])

        if not self.Data.StartSongJob then
            self.Data.StartSongJob = StartSimpleHiResJob("StartSongControl");
        end
    end
end

---
-- Spielt eine Playlist ab.
--
-- @param[type=table] _Playlist Playlist
-- @within Internal
-- @local
--
function BundleMusicTools.Global:StartPlaylist(_Playlist)
    for i=1, #_Playlist, 1 do
        table.insert(self.Data.StartSongPlaylist, _Playlist[i]);
        self:StartSong(_Playlist[i]);
    end
    self.Data.StartSongPlaylist.Repeat = _Playlist.Repeat == true;
end

---
-- Stoppt gerade gespielte Musik und startet die Playlist mit dem
-- angegebenen Titel. Es muss eine Playlist existieren! Nachdem der
-- Titel abgespielt ist, wird die Playlist normal weiter gespielt.
--
-- @param[type=number] _Title Index des Titels
-- @within Internal
-- @local
--
function BundleMusicTools.Global:StartPlaylistTitle(_Title)
    local playlist = self.Data.StartSongPlaylist;
    local length = #length;
    if (length &#x3E;= _Title) then
        self.Data.StartSongData.Running = false;
        self.Data.StartSongQueue = {};
        self.Data.StartSongData = {};
        self:StopSong();
        EndJob(self.Data.StartSongJob);
        self.Data.StartSongJob = nil;
        for i=_Title, length, 1 do
            self:StartSong(playlist);
        end
    end
end

---
-- Stopt Musik und stellt die alte Soundkonfiguration wieder her.
--
-- @within Internal
-- @local
--
function BundleMusicTools.Global:StopSong()
    local Queue = #self.Data.StartSongQueue;
    local Data = self.Data.StartSongData;
    Logic.ExecuteInLuaLocalState([[
        BundleMusicTools.Local:ResetSound(
            "]].. ((Data.File ~= nil and Data.File) or "") ..[[",
            ]].. Queue ..[[
        )
    ]]);
end

---
-- Stopt den gerade laufenden Song und leert sowohl die Songdaten
-- als auch die Playlist.
--
-- @within Internal
-- @local
--
function BundleMusicTools.Global:AbortMusic()
    self.Data.StartSongPlaylist = {};
    self.Data.StartSongQueue = {};
    self:StopSong();
    self.Data.StartSongData = {};
    EndJob(self.Data.StartSongJob);
    self.Data.StartSongJob = nil;
end

---
-- Kontrolliert den Song / die Playlist. Wenn ein Song durch ist, wird
-- der nächste Song in der Warteschlange gestartet, sofern vorhanden.
-- Ist die Warteschlange leer, endet der Job. Existiert eine Playlist,
-- für die Repeat = true ist, dann wird die Playlist neu gestartet.
--
-- @within Internal
-- @local
--
function BundleMusicTools.Global.StartSongControl()
    if not BundleMusicTools.Global.Data.StartSongData.Running then
        BundleMusicTools.Global.Data.StartSongData = {};
        BundleMusicTools.Global.Data.StartSongJob = nil;
        if #BundleMusicTools.Global.Data.StartSongQueue &#x3E; 0 then
            local Description = table.remove(BundleMusicTools.Global.Data.StartSongQueue, 1);
            BundleMusicTools.Global:StartSong(Description);
        else
            if BundleMusicTools.Global.Data.StartSongPlaylist.Repeat then
                BundleMusicTools.Global:StartPlaylist(BundleMusicTools.Global.Data.StartSongPlaylist);
            end
        end
        return true;
    end

    local Data = BundleMusicTools.Global.Data.StartSongData;
    -- Zeit zählen
    BundleMusicTools.Global.Data.StartSongData.Time = Data.Time +1;

    if Data.Fadeout &#x3C; 5 then
        if Data.Time &#x3E;= Data.Length then
            BundleMusicTools.Global.Data.StartSongData.Running = false;
            BundleMusicTools.Global:StopSong();
        end
    else
        local FadeoutTime = Data.Length - Data.Fadeout+1;
        if Data.Time &#x3E;= FadeoutTime then
            if Data.Time &#x3E;= Data.Length then
                BundleMusicTools.Global.Data.StartSongData.Running = false;
                BundleMusicTools.Global:StopSong();
            else
                local VolumeStep = Data.Volume / Data.Fadeout;
                BundleMusicTools.Global.Data.StartSongData.CurrentVolume = Data.CurrentVolume - VolumeStep;
                Logic.ExecuteInLuaLocalState([[
                    Sound.SetSpeechVolume(]]..Data.CurrentVolume..[[)
                ]]);
            end
        end
    end
end
StartSongControl = BundleMusicTools.Global.StartSongControl;

-- Local Script ----------------------------------------------------------------

---
-- Initalisiert das Bundle im lokalen Skript.
--
-- @within Internal
-- @local
--
function BundleMusicTools.Local:Install()

end

---
-- Speichert die Soundeinstellungen.
--
-- @param[type=number]  _Volume Lautstärke
-- @param[type=string]  _Song Pfad zum Titel
-- @param[type=boolean] _MuteAtmo Atmosphäre stumm schalten
-- @param[type=boolean] _MuteUI UI stumm schalten
-- @within Internal
-- @local
--
function BundleMusicTools.Local:BackupSound(_Volume, _Song, _MuteAtmo, _MuteUI)
    if self.Data.SoundBackup.FXSP == nil then
        self.Data.SoundBackup.FXSP = Sound.GetFXSoundpointVolume();
        self.Data.SoundBackup.FXAtmo = Sound.GetFXAtmoVolume();
        self.Data.SoundBackup.FXVol = Sound.GetFXVolume();
        self.Data.SoundBackup.Sound = Sound.GetGlobalVolume();
        self.Data.SoundBackup.Music = Sound.GetMusicVolume();
        self.Data.SoundBackup.Voice = Sound.GetSpeechVolume();
        self.Data.SoundBackup.UI = Sound.Get2DFXVolume();
    end

    Sound.SetFXVolume(100);
    Sound.SetSpeechVolume(_Volume);
    if _MuteAtmo == true then
        Sound.SetFXSoundpointVolume(0);
        Sound.SetFXAtmoVolume(0);
    end
    if _MuteUI == true then
        Sound.Set2DFXVolume(0);
        Sound.SetFXVolume(0);
    end
    Sound.SetMusicVolume(0);
    Sound.PlayVoice("ImportantStuff", _Song);
end

---
-- Stellt die Soundeinstellungen wieder her.
--
-- @param[type=string] _File Pfad zur Datei
-- @param[type=number] _QueueLength Länge der Warteschlange
-- @within Internal
-- @local
--
function BundleMusicTools.Local:ResetSound(_File, _QueueLength)
    if _File ~= nil then
        Sound.StopVoice("ImportantStuff", _File)
    end
    if _QueueLength &#x3C;= 0 then
        if self.Data.SoundBackup.FXSP ~= nil then
            Sound.SetFXSoundpointVolume(self.Data.SoundBackup.FXSP)
            Sound.SetFXAtmoVolume(self.Data.SoundBackup.FXAtmo)
            Sound.SetFXVolume(self.Data.SoundBackup.FXVol)
            Sound.SetGlobalVolume(self.Data.SoundBackup.Sound)
            Sound.SetMusicVolume(self.Data.SoundBackup.Music)
            Sound.SetSpeechVolume(self.Data.SoundBackup.Voice)
            Sound.Set2DFXVolume(self.Data.SoundBackup.UI)
            self.Data.SoundBackup = {}
        end
    end
end

-- -------------------------------------------------------------------------- --

Core:RegisterBundle("BundleMusicTools");

</code></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundlenonplayercharacter.lua.html">
            <div class='doclink'>
                <div>BundleNonPlayerCharacter</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><code>-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundleNonPlayerCharacter                                     # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Mit diesem Bundle wird ein spezieller Modus für Nichtspieler-Charaktere
-- bereitgestellt. Die Helden eines Spielers können mit diesen NPCs sprechen.
-- Dazu muss der Held selektiert sein. Dann kann der Spieler ihm mit einem
-- Rechtsklick befehlen, den NPC anzusprechen. Dabei wird der Mauszeiger zu
-- einer Hand.
--
-- Ein NPC wird durch ein leichtes Glitzern auf der Spielwelt hervorgehoben.
--
-- &#x3C;a href="#API.NpcCompose"&#x3E;NPCs erzeugen und verwalten&#x3C;/a&#x3E;
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundleNonPlayerCharacter = {};

API = API or {};
QSB = QSB or {};

QSB.NonPlayerCharacterObjects = {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Erstellt einen neuen NPC für den angegebenen Siedler.
--
-- Der NPC wird sofort aktiviert und kann angesprochen werden. Er wird durch
-- eine glitzernde Aura hervorgehoben.
--
-- Mögliche Einstellungen für den NPC:
-- &#x3C;table border="1"&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;th&#x3E;&#x3C;b&#x3E;Eigenschaft&#x3C;/b&#x3E;&#x3C;/th&#x3E;
-- &#x3C;th&#x3E;&#x3C;b&#x3E;Beschreibung&#x3C;/b&#x3E;&#x3C;/th&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;Name&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Stringname des Siedlers, der zum NPC werden soll.&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;Hero&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Skriptname eines Helden, mit dem der NPC sprechen will.&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;WrongHeroMessage&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Eine optionale Nachricht, wenn der falsche Held angesprochen wird.&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;Callback&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Eine Funktion, die aufgerufen wird, wenn der NPC angesprochen wird.&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;/table&#x3E;
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; CreateNPC&#x3C;/p&#x3E;
--
-- @param[type=table] _Data Nichtspieler-Charakter
-- @return[type=table] NonPlayerCharacter Objekt
-- @within Anwenderfunktionen
--
-- @usage
-- API.NpcCompose {
--     Name     = "horst",
--     Callback = function(_Npc, _Hero)
--        -- Hier kann was passieren
--     end,
-- }
--
function API.NpcCompose(_Data)
    local WronHeroCallback = function(_Npc)
        if _Npc.WrongHeroMessage then
            API.Note(_Npc.WrongHeroMessage);
        end
    end

    local NPC = QSB.NonPlayerCharacter:New(_Data.Name);
    NPC:SetDialogPartner(_Data.Hero);
    NPC:SetWrongPartnerCallback(WronHeroCallback);
    NPC:SetCallback(_Data.Callback);
    return NPC:Activate();
end
CreateNPC = API.NpcCompose;

---
-- Entfernt den NPC komplett vom Entity. Das Entity bleibt dabei erhalten.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; DestroyNPC&#x3C;/p&#x3E;
--
-- @param _Entity Nichtspieler-Charakter (Skriptname oder ID)
-- @within Anwenderfunktionen
--
-- @usage
-- API.NpcDispose("horst")
--
function API.NpcDispose(_Entity)
    local ScriptName = Logic.GetEntityName(GetID(_Entity));
    local NPC = QSB.NonPlayerCharacter:GetInstance(ScriptName);
    if not NPC then
        return;
    end
    NPC:Dispose();
end
DestroyNPC = API.NpcDispose;

---
-- Aktiviert einen inaktiven NPC. Wenn ein NPC bereits gesprochen hat, muss
-- er zuvor zurückgesetzt werden.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; EnableNPC&#x3C;/P&#x3E;
--
-- @param _Entity Nichtspieler-Charakter (Skriptname oder ID)
-- @within Anwenderfunktionen
--
-- @usage
-- API.NpcActivate("horst")
--
function API.NpcActivate(_Entity)
    local ScriptName = Logic.GetEntityName(GetID(_Entity));
    local NPC = QSB.NonPlayerCharacter:GetInstance(ScriptName);
    if not NPC then
        return;
    end
    NPC:Activate();
end
EnableNPC = API.NpcActivate;

---
-- Deaktiviert einen NPC, sodass dieser nicht angesprochen werden kann.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; DisableNPC&#x3C;/P&#x3E;
--
-- @param _Entity Nichtspieler-Charakter (Skriptname oder ID)
-- @within Anwenderfunktionen
--
-- @usage
-- API.NpcDeactivate("horst")
--
function API.NpcDeactivate(_Entity)
    local ScriptName = Logic.GetEntityName(GetID(_Entity));
    local NPC = QSB.NonPlayerCharacter:GetInstance(ScriptName);
    if not NPC then
        return;
    end
    NPC:Deactivate();
end
DisableNPC = API.NpcDeactivate;

---
-- Setzt einen NPC zurück, sodass er nicht mehr als angesprochen gilt.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; ResetNPC&#x3C;p&#x3E;
--
-- @param _Entity Nichtspieler-Charakter (Skriptname oder ID)
-- @within Anwenderfunktionen
--
-- @usage
-- API.NpcReset("horst")
--
function API.NpcReset(_Entity)
    local ScriptName = Logic.GetEntityName(GetID(_Entity));
    local NPC = QSB.NonPlayerCharacter:GetInstance(ScriptName);
    if not NPC then
        return;
    end
    NPC:Reset();
end
ResetNPC = API.NpcReset;

---
-- Prüft, ob der NPC bereits angesprochen wurde. Wenn ein Ansprechpartner
-- vorgegeben ist, muss dieser den NPC ansprechen.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; TalkedToNPC&#x3C;/p&#x3E;
--
-- @param _Entity Nichtspieler-Charakter (Skriptname oder ID)
-- @return[type=boolean] NPC wurde angesprochen
-- @within Anwenderfunktionen
--
-- @usage
-- API.NpcHasSpoken("horst")
--
function API.NpcHasSpoken(_Entity)
    local ScriptName = Logic.GetEntityName(GetID(_Entity));
    local NPC = QSB.NonPlayerCharacter:GetInstance(ScriptName);
    if not NPC then
        return;
    end
    return NPC:HasTalkedTo();
end
TalkedToNPC = API.NpcHasSpoken;

-- -------------------------------------------------------------------------- --
-- Klassen                                                                    --
-- -------------------------------------------------------------------------- --

QSB.NonPlayerCharacter = {};

---
-- Konstruktor
-- @param[type=string] _ScriptName Skriptname des NPC
-- @within QSB.NonPlayerCharacter
-- @usage
-- -- Einen normalen NPC erzeugen:
-- QSB.NonPlayerCharacter:New("npc")
--     :SetDialogPartner("hero")                 -- Optional
--     :SetCallback(Briefing1)                   -- Optional
--     :Activate();
--
function QSB.NonPlayerCharacter:New(_ScriptName)
    assert(self == QSB.NonPlayerCharacter, 'Can not be used from instance!');
    local npc = API.InstanceTable(self);
    npc.m_NpcName  = _ScriptName;
    npc.m_NpcType  = BundleNonPlayerCharacter.Global.DefaultNpcType
    npc.m_Distance = 350;
    if Logic.IsKnight(GetID(_ScriptName)) then
        npc.m_Distance = 400;
    end
    QSB.NonPlayerCharacterObjects[_ScriptName] = npc;
    npc:CreateMarker();
    return npc;
end

---
-- Gibt das Objekt des NPC zurück, wenn denn eins für dieses Entity existiert.
--
-- Wurde noch kein NPC für diesen Skriptnamen erzeugt, wird nil zurückgegeben.
--
-- @param[type=string] _ScriptName Skriptname des NPC
-- @return[type=table] Interaktives Objekt
-- @within QSB.NonPlayerCharacter
-- @usage -- NPC ermitteln
-- local NPC = QSB.NonPlayerCharacter:GetInstance("horst");
-- -- Etwas mit dem NPC tun
-- NPC:SetDialogPartner("hilda");
--
function QSB.NonPlayerCharacter:GetInstance(_ScriptName)
    assert(self == QSB.NonPlayerCharacter, 'Can not be used from instance!');
    local EntityID = GetID(_ScriptName)
    local ScriptName = Logic.GetEntityName(EntityID);
    if Logic.IsEntityInCategory(EntityID, EntityCategories.Soldier) == 1 then
        local LeaderID = Logic.SoldierGetLeaderEntityID(EntityID);
        if IsExisting(LeaderID) then
            ScriptName = Logic.GetEntityName(LeaderID);
        end
    end
    return QSB.NonPlayerCharacterObjects[ScriptName];
end

---
-- Gibt die Entity ID des letzten angesprochenen NPC zurück.
--
-- @return[type=number] ID des letzten NPC
-- @within QSB.NonPlayerCharacter
--
function QSB.NonPlayerCharacter:GetNpcId()
    assert(self == QSB.NonPlayerCharacter, 'Can not be used from instance!');
    return BundleNonPlayerCharacter.Global.LastNpcEntityID;
end

---
-- Gibt die Entity ID des letzten Helden zurück, der einen NPC
-- angesprochen hat.
--
-- @return[type=number] ID des letzten Heden
-- @within QSB.NonPlayerCharacter
--
function QSB.NonPlayerCharacter:GetHeroId()
    assert(self == QSB.NonPlayerCharacter, 'Can not be used from instance!');
    return BundleNonPlayerCharacter.Global.LastHeroEntityID;
end

---
-- Gibt die Entity ID des NPC zurück. Ist der NPC ein Leader, wird
-- der erste Soldat zurückgegeben, wenn es einen gibt.
--
-- @return[type=number] ID des NPC
-- @within QSB.NonPlayerCharacter
--
function QSB.NonPlayerCharacter:GetID()
    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');
    local EntityID = GetID(self.m_NpcName);
    if Logic.IsEntityInCategory(EntityID, EntityCategories.Leader) == 1 then
        local Soldiers = {Logic.GetSoldiersAttachedToLeader(EntityID)};
        if Soldiers[1] &#x3E; 0 then
            return Soldiers[2];
        end
    end
    return EntityID
end

---
-- Löscht einen NPC.
--
-- @within QSB.NonPlayerCharacter
--
-- @usage -- NPC löschen
-- NPC:Dispose();
--
function QSB.NonPlayerCharacter:Dispose()
    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');
    self:Deactivate();
    self:DestroyMarker();
    QSB.NonPlayerCharacterObjects[self.m_NpcName] = nil;
end

---
-- Aktiviert einen inaktiven NPC, sodass er wieder angesprochen werden kann.
--
-- @param[type=number] _Type NPC-Typ [1-4]
-- @return[type=table] self
-- @within QSB.NonPlayerCharacter
-- @usage -- NPC aktivieren:
-- NPC:Activate();
--
function QSB.NonPlayerCharacter:Activate(_Type)
    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');
    if IsExisting(self.m_NpcName) then
        Logic.SetOnScreenInformation(self:GetID(), _Type or self.m_NpcType);
        self:ShowMarker();
    end
    return self;
end

---
-- Deaktiviert einen aktiven NPC, sodass er nicht angesprochen werden kann.
--
-- @return[type=table] self
-- @within QSB.NonPlayerCharacter
-- @usage -- NPC deaktivieren:
-- NPC:Deactivate();
--
function QSB.NonPlayerCharacter:Deactivate()
    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');
    if IsExisting(self.m_NpcName) then
        Logic.SetOnScreenInformation(self:GetID(), 0);
        self:HideMarker();
    end
    return self;
end

---
-- &#x3C;p&#x3E;Gibt true zurück, wenn der NPC aktiv ist.&#x3C;/p&#x3E;
--
-- @return[type=boolean] NPC ist aktiv
-- @within QSB.NonPlayerCharacter
--
function QSB.NonPlayerCharacter:IsActive()
    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');
    return Logic.GetEntityScriptingValue(self:GetID(), 6) &#x3E; 0;
end

---
-- Setzt den NPC zurück, sodass er erneut aktiviert werden kann.
--
-- @return[type=table] self
-- @within QSB.NonPlayerCharacter
--
function QSB.NonPlayerCharacter:Reset()
    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');
    if IsExisting(self.m_NpcName) then
        Logic.SetOnScreenInformation(self:GetID(), 0);
        self.m_TalkedTo = nil;
        self:HideMarker();
    end
    return self;
end

---
-- Gibt true zurück, wenn der NPC angesprochen wurde. Ist ein
-- spezieller Ansprechpartner definiert, wird nur dann true
-- zurückgegeben, wenn dieser Held mit dem NPC spricht.
--
-- @return[type=boolean] NPC wurde angesprochen
-- @within QSB.NonPlayerCharacter
--
function QSB.NonPlayerCharacter:HasTalkedTo()
    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');
    if self.m_HeroName then
        return self.m_TalkedTo == GetID(self.m_HeroName);
    end
    return self.m_TalkedTo ~= nil;
end

---
-- Gibt die Entity ID des letzten angesprochenen NPC zurück.
--
-- @param[type=number] _Type Typ des Npc
-- @return[type=number] ID des letzten NPC
-- @within QSB.NonPlayerCharacter
--
function QSB.NonPlayerCharacter:SetType(_Type)
    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');
    self.m_NpcType = _Type;
    if _Type &#x3E; 1 then
        self:HideMarker();
    end
    return self;
end

---
-- Setzt die Entfernung, die unterschritten werden muss, damit
-- ein NPC als angesprochen gilt.
--
-- @param[type=number] _Distance Aktivierungsdistanz
-- @within QSB.NonPlayerCharacter
--
function QSB.NonPlayerCharacter:SetTalkDistance(_Distance)
    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');
    self.m_Distance = _Distance or 350;
    return self;
end

---
-- Setzt den Ansprechpartner für diesen NPC.
--
-- @param[type=string] _HeroName Skriptname des Helden
-- @return[type=table] self
-- @within QSB.NonPlayerCharacter
--
function QSB.NonPlayerCharacter:SetDialogPartner(_HeroName)
    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');
    self.m_HeroName = _HeroName;
    return self;
end

---
-- Setzt das Callback für den Fall, dass ein falscher Held den
-- NPC anspricht.
--
-- @param[type=function] _Callback Callback
-- @return[type=table] self
-- @within QSB.NonPlayerCharacter
--
function QSB.NonPlayerCharacter:SetWrongPartnerCallback(_Callback)
    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');
    self.m_WrongHeroCallback = _Callback;
    return self;
end

---
-- Setzt das Callback des NPC, dass beim Ansprechen ausgeführt wird.
--
-- @param[type=function] _Callback Callback
-- @return[type=table] self
-- @within QSB.NonPlayerCharacter
--
function QSB.NonPlayerCharacter:SetCallback(_Callback)
    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');
    assert(type(_Callback) == "function", 'callback must be a function!');
    self.m_Callback = _Callback;
    return self;
end

---
-- Rotiert alle nahen Helden zum NPC und den NPC zu dem Helden,
-- der ihn angesprochen hat.
--
-- @within QSB.NonPlayerCharacter
-- @local
--
function QSB.NonPlayerCharacter:RotateActors()
    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');
    local PlayerID = Logic.EntityGetPlayer(BundleNonPlayerCharacter.Global.LastHeroEntityID);
    local PlayerKnights = {};
    Logic.GetKnights(PlayerID, PlayerKnights);
    for k, v in pairs(PlayerKnights) do
        -- Alle Helden stoppen, die sich zu NPC bewegen
        local SV = (QSB.HistoryEdition and 17) or 19;
        local x1 = math.floor(BundleNonPlayerCharacter.Global:IntegerToFloat(Logic.GetEntityScriptingValue(v, SV)));
        local SV = (QSB.HistoryEdition and 18) or 20;
        local y1 = math.floor(BundleNonPlayerCharacter.Global:IntegerToFloat(Logic.GetEntityScriptingValue(v, SV)));
        local x2, y2 = Logic.EntityGetPos(GetID(self.m_NpcName));
        if x1 == math.floor(x2) and y1 == math.floor(y2) then
            local x, y, z = Logic.EntityGetPos(v);
            Logic.MoveEntity(v, x, y);
            LookAt(v, self.m_NpcName);
        end
    end
    API.Confront(self.m_NpcName, BundleNonPlayerCharacter.Global.LastHeroEntityID)
end

---
-- Erzeugt das Entity des NPC-Markers.
--
-- @within QSB.NonPlayerCharacter
-- @local
--
function QSB.NonPlayerCharacter:CreateMarker()
    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');
    local x,y,z = Logic.EntityGetPos(self:GetID());
    local MarkerID = Logic.CreateEntity(Entities.XD_ScriptEntity, x, y, 0, 0);
    DestroyEntity(self.m_MarkerID);
    self.m_MarkerID = MarkerID;
    self:HideMarker();
    return self;
end

---
-- Entfernt das Entity des NPC-Markers.
--
-- @within QSB.NonPlayerCharacter
-- @local
--
function QSB.NonPlayerCharacter:DestroyMarker()
    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');
    if self.m_MarkerID then
        DestroyEntity(self.m_MarkerID);
        self.m_MarkerID = nil;
    end
    return self;
end

---
-- Zeigt den NPC-Marker des NPC an.
--
-- @within QSB.NonPlayerCharacter
-- @local
--
function QSB.NonPlayerCharacter:ShowMarker()
    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');
    if self.m_NpcType == 1 and IsExisting(self.m_MarkerID) then
        local SV = (QSB.HistoryEdition and -42) or -45;
        local EntityScale = Logic.GetEntityScriptingValue(self:GetID(), SV);
        Logic.SetEntityScriptingValue(self.m_MarkerID, SV, EntityScale);
        Logic.SetModel(self.m_MarkerID, Models.Effects_E_Wealth);
        Logic.SetVisible(self.m_MarkerID, true);
    end
    self.m_MarkerVisibility = true;
    return self;
end

---
-- Versteckt den NPC-Marker des NPC.
--
-- @within QSB.NonPlayerCharacter
-- @local
--
function QSB.NonPlayerCharacter:HideMarker()
    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');
    if IsExisting(self.m_MarkerID) then
        Logic.SetModel(self.m_MarkerID, Models.Effects_E_NullFX);
        Logic.SetVisible(self.m_MarkerID, false);
    end
    self.m_MarkerVisibility = false;
    return self;
end

---
-- Gibt true zurück, wenn der Marker des NPC sichtbar ist.
--
-- @return[type=boolen] Sichtbarkeit
-- @within QSB.NonPlayerCharacter
-- @local
--
function QSB.NonPlayerCharacter:IsMarkerVisible()
    assert(self ~= QSB.NonPlayerCharacter, 'Can not be used in static context!');
    return IsExisting(self.m_MarkerID) and self.m_MarkerVisibility == true;
end

---
-- Kontrolliert die Sichtbarkeit und die Position des NPC-Markers.
--
-- @within QSB.NonPlayerCharacter
-- @local
--
function QSB.NonPlayerCharacter:ControlMarker()
    -- Nur, wenn Standard-NPC
    if self.m_NpcType == 1 then
        if self:IsActive() and not self:HasTalkedTo() then
            -- Blinken
            if self:IsMarkerVisible() then
                self:HideMarker();
            else
                self:ShowMarker();
            end

            -- Repositionierung
            local x1,y1,z1 = Logic.EntityGetPos(self.m_MarkerID);
            local x2,y2,z2 = Logic.EntityGetPos(self:GetID());
            if math.abs(x1-x2) &#x3E; 20 or math.abs(y1-y2) &#x3E; 20 then
                Logic.DEBUG_SetPosition(self.m_MarkerID, x2, y2);
            end
        end
        -- Während Briefings immer verstecken
        if IsBriefingActive and IsBriefingActive() then
            self:HideMarker();
        end
    end
end

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

BundleNonPlayerCharacter = {
    Global = {
        LastNpcEntityID = 0,
        LastHeroEntityID = 0,
        DefaultNpcType = 1,
    },
    Local = {}
};

-- Global Script ---------------------------------------------------------------

---
-- Initialisiert das Bundle im globalen Skript.
-- @within Internal
-- @local
--
function BundleNonPlayerCharacter.Global:Install()
    -- NPC stuff --

    StartSimpleJob("BundleNonPlayerCharacter_ControlMarkerJob");
    StartSimpleHiResJob("BundleNonPlayerCharacter_DialogTriggerJob");

    GameCallback_OnNPCInteraction_Orig_QSB_NPC_Rewrite = GameCallback_OnNPCInteraction
    GameCallback_OnNPCInteraction = function(_EntityID, _PlayerID)
        GameCallback_OnNPCInteraction_Orig_QSB_NPC_Rewrite(_EntityID, _PlayerID)
        Quest_OnNPCInteraction(_EntityID, _PlayerID)
    end

    Quest_OnNPCInteraction = function(_EntityID, _PlayerID)
        local KnightIDs = {};
        Logic.GetKnights(_PlayerID, KnightIDs);

        local ClosestKnightID = 0;
        local ClosestKnightDistance = Logic.WorldGetSize();
        for i= 1, #KnightIDs, 1 do
            local DistanceBetween = Logic.GetDistanceBetweenEntities(KnightIDs[i], _EntityID);
            if DistanceBetween &#x3C; ClosestKnightDistance then
                ClosestKnightDistance = DistanceBetween;
                ClosestKnightID = KnightIDs[i];
            end
        end
        BundleNonPlayerCharacter.Global.LastHeroEntityID = ClosestKnightID;
        local NPC = QSB.NonPlayerCharacter:GetInstance(_EntityID);
        BundleNonPlayerCharacter.Global.LastNpcEntityID = NPC:GetID();

        if NPC then
            NPC:RotateActors();
            NPC.m_TalkedTo = ClosestKnightID;
            if NPC:HasTalkedTo() then
                NPC:Deactivate();
                if NPC.m_Callback then
                    NPC.m_Callback(NPC, ClosestKnightID);
                end
            else
                if NPC.m_WrongHeroCallback then
                    NPC.m_WrongHeroCallback(NPC, ClosestKnightID);
                end
            end
        end
    end

    -- Quest stuff --

    function QuestTemplate:RemoveQuestMarkers()
        for i=1, self.Objectives[0] do
            if self.Objectives[i].Type == Objective.Distance then
                if ((type(self.Objectives[i].Data[1]) == "number" and self.Objectives[i].Data[1] &#x3E; 0)
                or (type(self.Objectives[i].Data[1]) ~= "number")) and self.Objectives[i].Data[4] then
                    DestroyQuestMarker(self.Objectives[i].Data[2]);
                end
            end
        end
    end

    function QuestTemplate:ShowQuestMarkers()
        for i=1, self.Objectives[0] do
            if self.Objectives[i].Type == Objective.Distance then
                if ((type(self.Objectives[i].Data[1]) == "number" and self.Objectives[i].Data[1] &#x3E; 0)
                or (type(self.Objectives[i].Data[1]) ~= "number")) and self.Objectives[i].Data[4] then
                    ShowQuestMarker(self.Objectives[i].Data[2]);
                end
            end
        end
    end

    function QuestTemplate:RemoveNPCMarkers()
        for i=1, self.Objectives[0] do
            if type(self.Objectives[i].Data) == "table" then
                if self.Objectives[i].Data[1] == -65565 then
                    if type(self.Objectives[i].Data[4]) == "table" then
                        if self.Objectives[i].Data[4].NpcInstance then
                            self.Objectives[i].Data[4].NpcInstance:Dispose();
                            self.Objectives[i].Data[4].NpcInstance = nil;
                        end
                    end
                end
            end
        end
    end

    QuestTemplate.Interrupt_Orig_BundleNonPlayerCharacter = QuestTemplate.Interrupt;
    QuestTemplate.Interrupt = function(_quest, i)
        QuestTemplate.Interrupt_Orig_BundleNonPlayerCharacter(_quest, i);
        _quest:RemoveNPCMarkers();
    end

    QuestTemplate.IsObjectiveCompleted_Orig_BundleNonPlayerCharacter = QuestTemplate.IsObjectiveCompleted;
    QuestTemplate.IsObjectiveCompleted = function(self, objective)
        local objectiveType = objective.Type;
        local data = objective.Data;
        if objective.Completed ~= nil then
            return objective.Completed;
        end

        if objectiveType ~= Objective.Distance then
            return self:IsObjectiveCompleted_Orig_BundleNonPlayerCharacter(objective);
        else
            if data[1] == -65565 then
                if not IsExisting(data[3]) then
                    API.Fatal(data[3].. " is dead! :(");
                    objective.Completed = false;
                else
                    if not data[4].NpcInstance then
                        local NPC = QSB.NonPlayerCharacter:New(data[3]);
                        NPC:SetDialogPartner(data[2]);
                        data[4].NpcInstance = NPC;
                    end
                    if data[4].NpcInstance:HasTalkedTo(data[2]) then
                        objective.Completed = true;
                    end
                    if not objective.Completed then
                        if not data[4].NpcInstance:IsActive() then
                            data[4].NpcInstance:Activate();
                        end
                    end
                end
            else
                return self:IsObjectiveCompleted_Orig_BundleNonPlayerCharacter(objective);
            end
        end
    end
end

---
-- Setzt den Standardtypen des NPC. Der Typ gibt an, ob Glitter verwendet wird
-- oder auf die NPC-Marker zurückgegriffen wird.
--
-- @param[type=number] _Type Typ des NPC [1-4]
-- @within Internal
-- @local
--
function BundleNonPlayerCharacter.Global:SetDefaultNPCType(_Type)
    self.DefaultNpcType = _Type;
end

---
-- Gibt die ID des kontrollierenden Spielers zurück.
-- 
-- @return[type=number] Kontrollierender Spieler
-- @within Internal
-- @local
--
function BundleNonPlayerCharacter.Global:GetControllingPlayer()
    for i= 1, 8, 1 do
        if Logic.PlayerGetIsHumanFlag(i) == true then
            return i;
        end
    end
    return 0;
end

---
-- Konvertiert eine Ganzzahl in eine Gleitkommazahl.
-- @param[type=number] num Zahl zum Konvertieren
-- @return[type=number] Ganzzahl
-- @within Internal
-- @local
--
function BundleNonPlayerCharacter.Global:IntegerToFloat(num)
    if(num == 0) then 
        return 0;
    end
    local sign = 1
    if(num &#x3C; 0) then 
        num = 2147483648 + num; sign = -1;
    end
    local frac = (num - math.floor(num/8388608)*8388608);
    local headPart = (num-frac)/8388608
    local expNoSign = (headPart - math.floor(headPart/256)*256);
    local exp = expNoSign-127
    local fraction = 1
    local fp = 0.5
    local check = 4194304
    for i = 23, 0, -1 do
        if(frac - check) &#x3E; 0 then
            fraction = fraction + fp; frac = frac - check;
        end
        check = check / 2; fp = fp / 2
    end
    return fraction * math.pow(2, exp) * sign
end

---
-- Kontrolliert die "Glitter Marker" der NPCs.
--
-- @within Internal
-- @local
--
function BundleNonPlayerCharacter.Global.ControlMarker()
    for k, v in pairs(QSB.NonPlayerCharacterObjects) do
        if IsExisting(v:GetID()) then
            v:ControlMarker();
        end
    end
end
BundleNonPlayerCharacter_ControlMarkerJob = BundleNonPlayerCharacter.Global.ControlMarker;

---
-- Prüft, ob ein NPC durch die emulierte Aktivierungsdistanz angesprochen
-- wird. Die Bedingung wird für alle NPCs geprüft. Der erste NPC, der
-- die Bedingung erfüllt, wird aktiviert.
--
-- Der Job prüft nur NPCs, deren Aktivierungsdistanz 350 oder höher ist.
--
-- @within Internal
-- @local
--
function BundleNonPlayerCharacter.Global.DialogTriggerController()
    local PlayerID = BundleNonPlayerCharacter.Global:GetControllingPlayer();
    local PlayersKnights = {};
    Logic.GetKnights(PlayerID, PlayersKnights);
    for i= 1, #PlayersKnights, 1 do
        if Logic.GetCurrentTaskList(PlayersKnights[i]) == "TL_NPC_INTERACTION" then
            for k, v in pairs(QSB.NonPlayerCharacterObjects) do
                if v and v.m_TalkedTo == nil and v.m_Distance &#x3E;= 350 then
                    local SV = (QSB.HistoryEdition and 17) or 19;
                    local x1 = math.floor(BundleNonPlayerCharacter.Global:IntegerToFloat(Logic.GetEntityScriptingValue(PlayersKnights[i], SV)));
                    local SV = (QSB.HistoryEdition and 18) or 20;
                    local y1 = math.floor(BundleNonPlayerCharacter.Global:IntegerToFloat(Logic.GetEntityScriptingValue(PlayersKnights[i], SV)));
                    local x2, y2 = Logic.EntityGetPos(GetID(k));
                    if x1 == math.floor(x2) and y1 == math.floor(y2) then
                        if IsExisting(k) and IsNear(PlayersKnights[i], k, v.m_Distance) then
                            GameCallback_OnNPCInteraction(GetID(k), PlayerID);
                            return;
                        end
                    end
                end
            end
        end
    end
end
BundleNonPlayerCharacter_DialogTriggerJob = BundleNonPlayerCharacter.Global.DialogTriggerController;

-- Local Script ----------------------------------------------------------------

---
-- Initialisiert das Bundle im lokalen Skript.
-- @within Internal
-- @local
--
function BundleNonPlayerCharacter.Local:Install()
    g_CurrentDisplayedQuestID = 0;

    GUI_Interaction.DisplayQuestObjective_Orig_BundleNonPlayerCharacter = GUI_Interaction.DisplayQuestObjective
    GUI_Interaction.DisplayQuestObjective = function(_QuestIndex, _MessageKey)
        local lang = Network.GetDesiredLanguage();
        if lang ~= "de" then lang = "en" end

        local QuestIndexTemp = tonumber(_QuestIndex);
        if QuestIndexTemp then
            _QuestIndex = QuestIndexTemp;
        end

        local Quest, QuestType = GUI_Interaction.GetPotentialSubQuestAndType(_QuestIndex);
        local QuestObjectivesPath = "/InGame/Root/Normal/AlignBottomLeft/Message/QuestObjectives";
        XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomLeft/Message/QuestObjectives", 0);
        local QuestObjectiveContainer;
        local QuestTypeCaption;

        local ParentQuest = Quests[_QuestIndex];
        local ParentQuestIdentifier;
        if ParentQuest ~= nil
        and type(ParentQuest) == "table" then
            ParentQuestIdentifier = ParentQuest.Identifier;
        end
        local HookTable = {};

        g_CurrentDisplayedQuestID = _QuestIndex;

        if QuestType == Objective.Distance then
            QuestObjectiveContainer = QuestObjectivesPath .. "/List";
            QuestTypeCaption = Wrapped_GetStringTableText(_QuestIndex, "UI_Texts/QuestInteraction");
            local ObjectList = {};

            if Quest.Objectives[1].Data[1] == -65565 then
                QuestObjectiveContainer = QuestObjectivesPath .. "/Distance";
                QuestTypeCaption = Wrapped_GetStringTableText(_QuestIndex, "UI_Texts/QuestMoveHere");
                SetIcon(QuestObjectiveContainer .. "/QuestTypeIcon",{7,10});

                local MoverEntityID = GetEntityId(Quest.Objectives[1].Data[2]);
                local MoverEntityType = Logic.GetEntityType(MoverEntityID);
                local MoverIcon = g_TexturePositions.Entities[MoverEntityType];
                if not MoverIcon then
                    MoverIcon = {7, 9};
                end
                SetIcon(QuestObjectiveContainer .. "/IconMover", MoverIcon);

                local TargetEntityID = GetEntityId(Quest.Objectives[1].Data[3]);
                local TargetEntityType = Logic.GetEntityType(TargetEntityID);
                local TargetIcon = g_TexturePositions.Entities[TargetEntityType];
                if not TargetIcon then
                    TargetIcon = {14, 10};
                end

                local IconWidget = QuestObjectiveContainer .. "/IconTarget";
                local ColorWidget = QuestObjectiveContainer .. "/TargetPlayerColor";

                SetIcon(IconWidget, TargetIcon);
                XGUIEng.SetMaterialColor(ColorWidget, 0, 255, 255, 255, 0);

                SetIcon(QuestObjectiveContainer .. "/QuestTypeIcon",{16,12});
                local caption = {de = "Gespräch beginnen", en = "Start conversation"};
                QuestTypeCaption = caption[lang];

                XGUIEng.SetText(QuestObjectiveContainer.."/Caption","{center}"..QuestTypeCaption);
                XGUIEng.ShowWidget(QuestObjectiveContainer, 1);
            else
                GUI_Interaction.DisplayQuestObjective_Orig_BundleNonPlayerCharacter(_QuestIndex, _MessageKey);
            end
        else
            GUI_Interaction.DisplayQuestObjective_Orig_BundleNonPlayerCharacter(_QuestIndex, _MessageKey);
        end
    end

    GUI_Interaction.GetEntitiesOrTerritoryListForQuest_Orig_BundleNonPlayerCharacter = GUI_Interaction.GetEntitiesOrTerritoryListForQuest
    GUI_Interaction.GetEntitiesOrTerritoryListForQuest = function( _Quest, _QuestType )
        local EntityOrTerritoryList = {}
        local IsEntity = true

        if _QuestType == Objective.Distance then
            if _Quest.Objectives[1].Data[1] == -65565 then
                local Entity = GetEntityId(_Quest.Objectives[1].Data[3]);
                table.insert(EntityOrTerritoryList, Entity);
            else
                return GUI_Interaction.GetEntitiesOrTerritoryListForQuest_Orig_BundleNonPlayerCharacter( _Quest, _QuestType );
            end

        else
            return GUI_Interaction.GetEntitiesOrTerritoryListForQuest_Orig_BundleNonPlayerCharacter( _Quest, _QuestType );
        end
        return EntityOrTerritoryList, IsEntity
    end
end

Core:RegisterBundle("BundleNonPlayerCharacter");

-- -------------------------------------------------------------------------- --
-- Behavior                                                                   --
-- -------------------------------------------------------------------------- --

---
-- Der Held muss einen Nichtspielercharakter ansprechen.
--
-- Es wird automatisch ein NPC erzeugt und überwacht, sobald der Quest
-- aktiviert wurde. Ein NPC darf nicht auf geblocktem Gebiet stehen oder
-- seine Enity-ID verändern.
--
-- &#x3C;b&#x3E;Hinweis&#x3C;/b&#x3E;: Jeder Siedler kann zu jedem Zeitpunkt nur &#x3C;u&#x3E;einen&#x3C;/u&#x3E; NPC 
-- haben. Wird ein weiterer NPC zugewiesen, wird der alte überschrieben und
-- der verknüpfte Quest funktioniert nicht mehr!
--
-- @param[type=string] _NpcName  Skriptname des NPC
-- @param[type=string] _HeroName (optional) Skriptname des Helden
-- @within Goal
--
function Goal_NPC(...)
    return b_Goal_NPC:new(...);
end

b_Goal_NPC = {
    Name             = "Goal_NPC",
    Description     = {
        en = "Goal: The hero has to talk to a non-player character.",
        de = "Ziel: Der Held muss einen Nichtspielercharakter ansprechen.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "NPC",  de = "NPC" },
        { ParameterType.ScriptName, en = "Hero", de = "Held" },
    },
}

function b_Goal_NPC:GetGoalTable(_Quest)
    return {Objective.Distance, -65565, self.Hero, self.NPC, self}
end

function b_Goal_NPC:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.NPC = _Parameter
    elseif (_Index == 1) then
        self.Hero = _Parameter
        if self.Hero == "-" then
            self.Hero = nil
        end
   end
end

function b_Goal_NPC:GetIcon()
    return {14,10}
end

Core:RegisterBehavior(b_Goal_NPC);

</code></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundleplayerhelperfunctions.lua.html">
            <div class='doclink'>
                <div>BundlePlayerHelperFunctions</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><code>-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundlePlayerHelperFunctions                                   # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Mit diesem Bundle kommen einige Funktionalitäten zur Steuerung von
-- spielerbezogenen Features.
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundlePlayerHelperFunctions = {};

API = API or {};
QSB = QSB or {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Entfernt ein Territorium für den angegebenen Spieler aus der Liste
-- der entdeckten Territorien.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; UndiscoverTerritory&#x3C;/p&#x3E;
--
-- @param[type=number] _PlayerID    Spieler-ID
-- @param[type=number] _TerritoryID Territorium-ID
-- @within Anwenderfunktionen
--
function API.UndiscoverTerritory(_PlayerID, _TerritoryID)
    if GUI then
        API.Bridge("API.UndiscoverTerritory(" .._PlayerID.. ", ".._TerritoryID.. ")")
        return;
    end
    return BundlePlayerHelperFunctions.Global:UndiscoverTerritory(_PlayerID, _TerritoryID);
end
UndiscoverTerritory = API.UndiscoverTerritory;

---
-- Entfernt alle Territorien einer Partei aus der Liste der entdeckten
-- Territorien. Als Nebeneffekt gild die Partei als unentdeckt.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; UndiscoverTerritories&#x3C;/p&#x3E;
--
-- @param[type=number] _PlayerID    Spieler-ID
-- @param[type=number] _TargetPlayerID Anderer Spieler
-- @within Anwenderfunktionen
--
function API.UndiscoverTerritories(_PlayerID, _TargetPlayerID)
    if GUI then
        API.Bridge("API.UndiscoverTerritories(" .._PlayerID.. ", ".._TargetPlayerID.. ")")
        return;
    end
    return BundlePlayerHelperFunctions.Global:UndiscoverTerritories(_PlayerID, _TargetPlayerID);
end
UndiscoverTerritories = API.UndiscoverTerritories;

---
-- Setzt die Einnahmen für alle Stadtgebäude eines Spielers. Stadtgebäude
-- können nur Einnahmen zwischen 0 und 100 Talern haben.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; SetPlayerEarnings&#x3C;/p&#x3E;
--
-- @param[type=number] _PlayerID Partei oder nil für alle
-- @param[type=number] _Earnings Einnahmen [0 | 100]
-- @within Anwenderfunktionen
--
function API.SetEarningsOfPlayerCity(_PlayerID, _Earnings)
    if GUI then
        API.Bridge("API.SetEarningsOfPlayerCity(" .._PlayerID.. ", " .._Earnings.. ")");
        return;
    end
    if _PlayerID ~= -1 and Logic.GetStoreHouse(_PlayerID) == 0 then
        API.Fatal("API.SetEarningsOfPlayerCity: Player " .._PlayerID.. " is dead! :(");
        return;
    end
    if _Earnings == nil or (_Earnings &#x3C; 0 or _Earnings &#x3E; 100) then
        API.Fatal("API.SetEarningsOfPlayerCity: _Earnings must be between 0 and 100!");
        return;
    end
    return BundlePlayerHelperFunctions.Global:SetEarningsOfPlayerCity(_PlayerID, _Earnings);
end
SetPlayerEarnings = API.SetEarningsOfPlayerCity;

---
-- Setzt den Befriedigungsstatus eines Bedürfnisses für alle Gebäude
-- des angegebenen Spielers. Der Befriedigungsstatus ist eine Zahl
-- zwischen 0.0 und 1.0.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; SetNeedSatisfactionLevel&#x3C;/p&#x3E;
--
-- @param[type=number] _Need Bedürfnis
-- @param[type=number] _State Erfüllung des Bedürfnisses
-- @param[type=number] _PlayerID Partei oder -1 für alle
-- @within Anwenderfunktionen
--
function API.SetNeedSatisfaction(_Need, _State, _PlayerID)
    if GUI then
        API.Bridge("API.SetNeedSatisfaction(" .._Need.. ", " .._State.. ", " .._PlayerID.. ")")
        return;
    end
    if _PlayerID ~= -1 and Logic.GetStoreHouse(_PlayerID) == 0 then
        API.Fatal("API.SetNeedSatisfaction: Player " .._PlayerID.. " is dead! :(");
        return;
    end
    if _State &#x3C; 0 or _State &#x3E; 1 then
        API.Fatal("API.SetNeedSatisfaction: _State must be between 0 and 1!");
        return;
    end
    return BundlePlayerHelperFunctions.Global:SetNeedSatisfactionLevel(_Need, _State, _PlayerID);
end
SetNeedSatisfactionLevel = API.SetNeedSatisfaction;

---
-- Diese Funktion ermöglicht das sichere Entsperren eines gesperrten Titels.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; UnlockTitleForPlayer&#x3C;/p&#x3E;
--
-- @param[type=number] _PlayerID Zielpartei
-- @param[type=number] _KnightTitle Titel zum Entsperren
-- @within Anwenderfunktionen
--
function API.UnlockTitleForPlayer(_PlayerID, _KnightTitle)
    if GUI then
        API.Bridge("API.UnlockTitleForPlayer(" .._PlayerID.. ", " .._KnightTitle.. ")")
        return;
    end
    return BundlePlayerHelperFunctions.Global:UnlockTitleForPlayer(_PlayerID, _KnightTitle);
end
UnlockTitleForPlayer = API.UnlockTitleForPlayer;

---
-- Startet ein Fest für den Spieler. Ist dieser Typ von Fest für
-- den Spieler verboten, wird er automatisch erlaubt.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; StartNormalFestival&#x3C;/p&#x3E;
--
-- @param[type=number] _PlayerID Spieler
-- @within Anwenderfunktionen
--
function API.StartNormalFestival(_PlayerID)
    if GUI then
        API.Bridge("API.StartNormalFestival(".. _PlayerID ..")");
        return;
    end
    BundlePlayerHelperFunctions.Global:RestrictFestivalForPlayer(_PlayerID, 0, false);
    Logic.StartFestival(_PlayerID, 0);
end
StartNormalFestival = API.StartNormalFestival;

---
-- Startet ein Beförderungsfest für den Spieler. Ist dieser Typ
-- von Fest für den Spieler verboten, wird er automatisch erlaubt.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; StartCityUpgradeFestival&#x3C;/p&#x3E;
--
-- @param[type=number] _PlayerID Spieler
-- @within Anwenderfunktionen
--
function API.StartCityUpgradeFestival(_PlayerID)
    if GUI then
        API.Bridge("API.StartCityUpgradeFestival(".. _PlayerID ..")");
        return;
    end
    BundlePlayerHelperFunctions.Global:RestrictFestivalForPlayer(_PlayerID, 1, false);
    Logic.StartFestival(_PlayerID, 1);
end
StartCityUpgradeFestival = API.StartCityUpgradeFestival;

---
-- Verbietet ein normales Fest und sperrt die Technologie.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; ForbidFestival&#x3C;/p&#x3E;
--
-- @param[type=number] _PlayerID Spieler
-- @within Anwenderfunktionen
--
function API.ForbidFestival(_PlayerID)
    if GUI then
        API.Bridge("API.ForbidFestival(".. _PlayerID ..")");
        return;
    end

    local KnightTitle = Logic.GetKnightTitle(_PlayerID)
    local Technology = Technologies.R_Festival;
    local State = TechnologyStates.Locked;
    if KnightTitleNeededForTechnology[Technology] == nil or KnightTitle &#x3E;= KnightTitleNeededForTechnology[Technology] then
        State = TechnologyStates.Prohibited;
    end
    Logic.TechnologySetState(_PlayerID, Technology, State);
    BundlePlayerHelperFunctions.Global:RestrictFestivalForPlayer(_PlayerID, 0, true);
    API.Bridge("BundlePlayerHelperFunctions.Local.Data.NormalFestivalLockedForPlayer[" .._PlayerID.. "] = true");
end
ForbidFestival = API.ForbidFestival;

---
-- Erlaubt ein normales Fest und gibt die Technologie frei.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; AllowFestival&#x3C;/p&#x3E;
--
-- @param[type=number] _PlayerID Spieler
-- @within Anwenderfunktionen
--
function API.AllowFestival(_PlayerID)
    if GUI then
        API.Bridge("API.AllowFestival(".. _PlayerID ..")");
        return;
    end

    BundlePlayerHelperFunctions.Global:RestrictFestivalForPlayer(_PlayerID, 0, false);
    local KnightTitle = Logic.GetKnightTitle(_PlayerID)
    local Technology = Technologies.R_Festival;
    local State = TechnologyStates.Unlocked;
    if KnightTitleNeededForTechnology[Technology] == nil or KnightTitle &#x3E;= KnightTitleNeededForTechnology[Technology] then
        State = TechnologyStates.Researched;
    end
    Logic.TechnologySetState(_PlayerID, Technology, State);
    API.Bridge("BundlePlayerHelperFunctions.Local.Data.NormalFestivalLockedForPlayer[" .._PlayerID.. "] = false");
end
AllowFestival = API.AllowFestival;

---
-- Wechselt die Spieler ID des menschlichen Spielers. Die neue ID muss
-- einen Primärritter haben. Diese Funktion kann nicht im Multiplayer
-- Mode verwendet werden.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; PlayerSetPlayerID&#x3C;/p&#x3E;
--
-- @param[type=number]  _OldID Alte ID des menschlichen Spielers
-- @param[type=number]  _NewID Neue ID des menschlichen Spielers
-- @param[type=string]  _NewName Name in der Statistik
-- @param[type=boolean] _RetainKnight Ritter mitnehmen
-- @within Anwenderfunktionen
--
function API.SetControllingPlayer(_OldID, _NewID, _NewName, _RetainKnight)
    if GUI then
        API.Bridge("API.SetControllingPlayer(".. _OldID ..", ".. _NewID ..", '".. _NewName .."', ".. tostring(_RetainKnight) ..")");
        return;
    end
    return BundlePlayerHelperFunctions.Global:SetControllingPlayer(_OldID, _NewID, _NewName, _RetainKnight);
end
PlayerSetPlayerID = API.SetControllingPlayer;

---
-- Gibt die ID des kontrollierenden Spielers zurück. Der erste als menschlich
-- definierte Spieler wird als kontrollierender Spieler angenommen.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; PlayerGetPlayerID&#x3C;/p&#x3E;
--
-- @return[type=number] PlayerID
-- @within Anwenderfunktionen
--
function API.GetControllingPlayer()
    if not GUI then
        return BundlePlayerHelperFunctions.Global:GetControllingPlayer();
    else
        return GUI.GetPlayerID();
    end
end
PlayerGetPlayerID = API.GetControllingPlayer;

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

BundlePlayerHelperFunctions = {
    Global = {
        Data = {
            FestivalBlacklist = {},
            DiscoveredTerritories = {};
        }
    },
    Local = {
        Data = {
            NormalFestivalLockedForPlayer = {},
        }
    },
}

-- Global Script ---------------------------------------------------------------

---
-- Initalisiert das Bundle im globalen Skript.
--
-- @within Internal
-- @local
--
function BundlePlayerHelperFunctions.Global:Install()
    self:InitFestival();
    API.AddSaveGameAction(BundlePlayerHelperFunctions.Global.OnSaveGameLoaded);
end

---
-- Überschreibt Logic.StartFestival, sodass das Feierverhalten der KI gesteuert
-- werden kann.
--
-- @within Internal
-- @local
--
function BundlePlayerHelperFunctions.Global:InitFestival()
    Logic.StartFestival_Orig_NothingToCelebrate = Logic.StartFestival;
    Logic.StartFestival = function(_PlayerID, _Index)
        if BundlePlayerHelperFunctions.Global.Data.FestivalBlacklist[_PlayerID] then
            if BundlePlayerHelperFunctions.Global.Data.FestivalBlacklist[_PlayerID][_Index] then
                return;
            end
        end
        Logic.StartFestival_Orig_NothingToCelebrate(_PlayerID, _Index);
    end
end

---
-- Entfernt ein Territorium für den angegebenen Spieler aus der Liste
-- der entdeckten Territorien.
--
-- @param[type=number] _PlayerID    Spieler-ID
-- @param[type=number] _TerritoryID Territorium-ID
-- @within Internal
-- @local
--
function BundlePlayerHelperFunctions.Global:UndiscoverTerritory(_PlayerID, _TerritoryID)
    if self.Data.DiscoveredTerritories[_PlayerID] == nil then
        self.Data.DiscoveredTerritories[_PlayerID] = {};
    end
    for i=1, #self.Data.DiscoveredTerritories[_PlayerID], 1 do
        if self.Data.DiscoveredTerritories[_PlayerID][i] == _TerritoryID then
            table.remove(self.Data.DiscoveredTerritories[_PlayerID], i);
            break;
        end
    end
end

---
-- Entfernt alle Territorien einer Partei aus der Liste der entdeckten
-- Territorien. Als Nebeneffekt gild die Partei als unentdeckt-
--
-- @param[type=number] _PlayerID    Spieler-ID
-- @param[type=number] _TargetPlayerID Anderer Spieler
-- @within Internal
-- @local
--
function BundlePlayerHelperFunctions.Global:UndiscoverTerritories(_PlayerID, _TargetPlayerID)
    if self.Data.DiscoveredTerritories[_PlayerID] == nil then
        self.Data.DiscoveredTerritories[_PlayerID] = {};
    end
    local Discovered = {};
    for k, v in pairs(self.Data.DiscoveredTerritories[_PlayerID]) do
        local OwnerPlayerID = Logic.GetTerritoryPlayerID(v);
        if OwnerPlayerID ~= _TargetPlayerID then
            table.insert(Discovered, v);
            break;
        end
    end
    self.Data.DiscoveredTerritories[_PlayerID][i] = Discovered;
end

---
-- Setzt die Einnahmen für alle Stadtgebäude eines Spielers. Stadtgebäude
-- können nur Einnahmen zwischen 0 und 100 Talern haben.
--
-- &#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; SetPlayerEarnings
--
-- @param[type=number] _PlayerID Partei oder nil für alle
-- @param[type=number] _Earnings Einnahmen [0 | 100]
-- @within Internal
-- @local
--
function BundlePlayerHelperFunctions.Global:SetEarningsOfPlayerCity(_PlayerID, _Earnings)
    if _PlayerID == -1 then
        for i=1, 8, 1 do
            self:SetEarningsOfPlayerCity(i, _Earnings);
        end
    else
        local City = {Logic.GetPlayerEntitiesInCategory(_PlayerID, EntityCategories.CityBuilding)};
        for i=1, #City, 1 do
            Logic.SetBuildingEarnings(City[i], _Earnings);
        end
    end
end

---
-- Setzt den Befriedigungsstatus eines Bedürfnisses für alle Gebäude
-- des angegebenen Spielers. Der Befriedigungsstatus ist eine Zahl
-- zwischen 0.0 und 1.0.
--
-- @param[type=number] _Need Bedürfnis
-- @param[type=number] _State Erfüllung des Bedürfnisses
-- @param[type=number] _PlayerID Partei oder -1 für alle
-- @within Internal
-- @local
--
function BundlePlayerHelperFunctions.Global:SetNeedSatisfactionLevel(_Need, _State, _PlayerID)
    if _PlayerID == -1 then
        for i=1, 8, 1 do
            self:SetNeedSatisfactionLevel(_Need, _State, i);
        end
    else
        local City = {Logic.GetPlayerEntitiesInCategory(_PlayerID, EntityCategories.CityBuilding)};
        if _Need == Needs.Nutrition or _Need == Needs.Medicine then
            local Rim = {Logic.GetPlayerEntitiesInCategory(_PlayerID, EntityCategories.OuterRimBuilding)};
            City = Array_Append(City, Rim);
        end
        for j=1, #City, 1 do
            if Logic.IsNeedActive(City[j], _Need) then
                Logic.SetNeedState(City[j], _Need, _State);
            end
        end
    end
end

---
-- Entsperrt einen gesperrten Titel für den Spieler.
--
-- @param[type=number] _PlayerID Zielpartei
-- @param[type=number] _KnightTitle Titel zum Entsperren
-- @within Internal
-- @local
--
function BundlePlayerHelperFunctions.Global:UnlockTitleForPlayer(_PlayerID, _KnightTitle)
    if LockedKnightTitles[_PlayerID] == _KnightTitle
    then
        LockedKnightTitles[_PlayerID] = nil;
        for KnightTitle= _KnightTitle, #NeedsAndRightsByKnightTitle
        do
            local TechnologyTable = NeedsAndRightsByKnightTitle[KnightTitle][4];
            if TechnologyTable ~= nil
            then
                for i=1, #TechnologyTable
                do
                    local TechnologyType = TechnologyTable[i];
                    Logic.TechnologySetState(_PlayerID, TechnologyType, TechnologyStates.Unlocked);
                end
            end
        end
    end
end

---
-- Erlaubt oder verbietet ein Fest für den angegebenen Spieler.
--
-- @param[type=number]  _PlayerID ID des Spielers
-- @param[type=number]  _Index    Index des Fest
-- @param[type=boolean] _Flag     Erlauben/verbieten
-- @within Internal
-- @local
--
function BundlePlayerHelperFunctions.Global:RestrictFestivalForPlayer(_PlayerID, _Index, _Flag)
    self.Data.FestivalBlacklist[_PlayerID] = self.Data.FestivalBlacklist[_PlayerID] or {};
    self.Data.FestivalBlacklist[_PlayerID][_Index] = _Flag == true;
end

---
-- Wechselt die Spieler ID des menschlichen Spielers. Die neue ID muss
-- einen Primärritter haben. Diese Funktion kann nicht im Multiplayer
-- Mode verwendet werden.
--
-- @param[type=number] _oldPlayerID Alte ID des menschlichen Spielers
-- @param[type=number] _newPlayerID Neue ID des menschlichen Spielers
-- @param[type=string] _newNameForStatistics Name in der Statistik
-- @param[type=boolean] _retainPrimaryKnight Ritter mitnehmen
-- @within Internal
-- @local
--
function BundlePlayerHelperFunctions.Global:SetControllingPlayer(_oldPlayerID, _newPlayerID, _newNameForStatistics, _retainPrimaryKnight)
    assert(type(_oldPlayerID) == "number");
    assert(type(_newPlayerID) == "number");
    _newNameForStatistics = _newNameForStatistics or "";
    _retainPrimaryKnight = (_retainPrimaryKnight and true) or false;

    local eID,eName,eType;
    if _retainPrimaryKnight then
        eID   = Logic.GetKnightID(_oldPlayerID);
        eName = Logic.GetEntityName(eID);
        eType = Logic.GetEntityType(eID);
        Logic.ChangeEntityPlayerID(eID,_newPlayerID);
        Logic.SetPrimaryKnightID(_newPlayerID,GetID(eName));
    else
        eID   = Logic.GetKnightID(_newPlayerID);
        eName = Logic.GetEntityName(eID);
        eType = Logic.GetEntityType(eID);
    end

    Logic.PlayerSetIsHumanFlag(_oldPlayerID, 0);
    Logic.PlayerSetIsHumanFlag(_newPlayerID, 1);
    Logic.PlayerSetGameStateToPlaying(_newPlayerID);

    self.Data.HumanKnightType = eType;
    self.Data.HumanPlayerID = _newPlayerID;

    GameCallback_PlayerLost = function( _PlayerID )
        if _PlayerID == self:GetControllingPlayer() then
            QuestTemplate:TerminateEventsAndStuff()
            if MissionCallback_Player1Lost then
                MissionCallback_Player1Lost()
            end
        end
    end

    Logic.ExecuteInLuaLocalState([[
        GUI.ClearSelection()
        GUI.SetControlledPlayer(]].._newPlayerID..[[)

        for k,v in pairs(Buffs)do
            GUI_Buffs.UpdateBuffsInInterface(]].._newPlayerID..[[,v)
            GUI.ResetMiniMap()
        end

        if IsExisting(Logic.GetKnightID(GUI.GetPlayerID())) then
            local portrait = GetKnightActor(]]..eType..[[)
            g_PlayerPortrait[GUI.GetPlayerID()] = portrait
            LocalSetKnightPicture()
        end

        local newName = "]].._newNameForStatistics..[["
        if newName ~= "" then
            GUI_MissionStatistic.PlayerNames[GUI.GetPlayerID()] = newName
        end
        HideOtherMenus()

        function GUI_Knight.GetTitleNameByTitleID(_KnightType, _TitleIndex)
            local KeyName = "Title_" .. GetNameOfKeyInTable(KnightTitles, _TitleIndex) .. "_" .. KnightGender[]]..eType..[[]
            local String = XGUIEng.GetStringTableText("UI_ObjectNames/" .. KeyName)
            if String == nil or String == "" then
                String = "Knight not in Gender Table? (localscript.lua)"
            end
            return String
        end
    ]]);

    self.Data.HumanPlayerChangedOnce = true;
end

---
-- Gibt die ID des kontrollierenden Spielers zurück. Der erste als menschlich
-- definierte Spieler wird als kontrollierender Spieler angenommen.
--
-- @return[type=number] PlayerID
-- @within Internal
-- @local
--
function BundlePlayerHelperFunctions.Global:GetControllingPlayer()
    local pID = 1;
    for i=1,8 do
        if Logic.PlayerGetIsHumanFlag(i) == true then
            pID = i;
            break;
        end
    end
    return pID;
end

---
-- Stellt nicht-persistente Änderungen nach dem laden wieder her.
--
-- @within Internal
-- @local
--
function BundlePlayerHelperFunctions.Global.OnSaveGameLoaded()
    -- Feste sperren --
    Logic.StartFestival_Orig_NothingToCelebrate = nil;
    BundlePlayerHelperFunctions.Global:InitFestival();

    -- Menschlichen Spieler ändern --
    if BundlePlayerHelperFunctions.Global.Data.HumanPlayerChangedOnce then
        Logic.ExecuteInLuaLocalState([[
            GUI.SetControlledPlayer(]]..BundlePlayerHelperFunctions.Global.Data.HumanPlayerID..[[)
            for k,v in pairs(Buffs)do
                GUI_Buffs.UpdateBuffsInInterface(]]..BundlePlayerHelperFunctions.Global.Data.HumanPlayerID..[[,v)
                GUI.ResetMiniMap()
            end
            if IsExisting(Logic.GetKnightID(GUI.GetPlayerID())) then
                local portrait = GetKnightActor(]]..BundlePlayerHelperFunctions.Global.Data.HumanKnightType..[[)
                g_PlayerPortrait[]]..BundlePlayerHelperFunctions.Global.Data.HumanPlayerID..[[] = portrait
                LocalSetKnightPicture()
            end
        ]]);
    end
end

-- Local Script ------------------------------------------------------------- --

function BundlePlayerHelperFunctions.Local:Install()
    self:InitForbidFestival();
    self:OverrideQuestLogPlayerIcon();
    self:OverrideQuestPlayerIcon();
end

---
-- Überschreibt den Button zum Start eines Festes, sodass er nicht angezeigt
-- wird, wenn Feste verboten sind.
--
-- @within Internal
-- @local
--
function BundlePlayerHelperFunctions.Local:InitForbidFestival()
    NewStartFestivalUpdate = function()
        local WidgetID = XGUIEng.GetCurrentWidgetID();
        local PlayerID = GUI.GetPlayerID();
        if BundlePlayerHelperFunctions.Local.Data.NormalFestivalLockedForPlayer[PlayerID] then
            XGUIEng.ShowWidget(WidgetID, 0);
            return true;
        end
    end
    Core:StackFunction("GUI_BuildingButtons.StartFestivalUpdate", NewStartFestivalUpdate);
end

---
-- Überschreibt das Quest Icon für Spieler, die keinem Typen zugeordnet sind.
--
-- @within Internal
-- @local
--
function BundlePlayerHelperFunctions.Local:OverrideQuestPlayerIcon()
    GUI_Interaction.SetPlayerIcon_Orig_BundlePlayerHelperFunctions = GUI_Interaction.SetPlayerIcon;
    GUI_Interaction.SetPlayerIcon = function(_PlayerIconContainer, _PlayerID)
        if _PlayerID == GUI.GetPlayerID() then
            GUI_Interaction.SetPlayerIcon_Orig_BundlePlayerHelperFunctions(_PlayerIconContainer, _PlayerID);
            return;
        end

        -- Icon
        local PlayerIcon;
        local LogoWidget = _PlayerIconContainer .. "/Logo";
        local PatternWidget = _PlayerIconContainer .. "/Pattern";
        local PlayerCategory = GetPlayerCategoryType(_PlayerID);
        local PlayerIcon = g_TexturePositions.PlayerCategories[PlayerCategory];
        if Mission_Callback_OverridePlayerIconForQuest then
            PlayerIcon = Mission_Callback_OverridePlayerIconForQuest(_PlayerID) or PlayerIcon;
        end
        if PlayerIcon == nil then
            PlayerIcon = {13, 7};
        end
        SetIcon(LogoWidget, PlayerIcon);

        -- Background
        SetIcon(PatternWidget, {14, 1});
        local R, G, B = GUI.GetPlayerColor(_PlayerID);
        if PlayerCategory == PlayerCategories.Harbour then
            R, G, B = 255, 255, 255;
        end
        XGUIEng.SetMaterialColor(PatternWidget, 0, R, G, B, 255);
    end
end

---
-- Überschreibt das Quest log Icon für Spieler, die keinem Typen zugeordnet sind.
--
-- @within Internal
-- @local
--
function BundlePlayerHelperFunctions.Local:OverrideQuestLogPlayerIcon()
    QuestLog.PushQuestGiverLogo_Orig_BundlePlayerHelperFunctions = QuestLog.PushQuestGiverLogo;
    QuestLog.PushQuestGiverLogo = function(_widgetlist, _PlayerID)
        local Frame = "Icons.png";
        local IconSize = 44;
        local PlayerCategory = GetPlayerCategoryType(_PlayerID);
        local Coordinates = g_TexturePositions.PlayerCategories[PlayerCategory];
        
        if Coordinates ~= nil or Mission_Callback_OverridePlayerIconForQuest then
            QuestLog.PushQuestGiverLogo_Orig_BundlePlayerHelperFunctions(_widgetlist, _PlayerID);
            return;
        end
        Coordinates = {13, 7};

        local u0 = (Coordinates[1] - 1) * IconSize;
        local v0 = (Coordinates[2] - 1) * IconSize;
        local u1 = Coordinates[1] * IconSize;
        local v1 = Coordinates[2] * IconSize;

        if Coordinates[3] and Coordinates[3] == 1 then
            Frame = "Icons2.png";
        end
        XGUIEng.ListBoxPushItemEx(_widgetlist, "", Frame, nil, u0, v0, u1, v1);
    end
end

-- -------------------------------------------------------------------------- --

Core:RegisterBundle("BundlePlayerHelperFunctions");

</code></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundlequestgeneration.lua.html">
            <div class='doclink'>
                <div>BundleQuestGeneration</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><code>-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundleQuestGeneration                                        # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Mit diesem Bundle können Aufträge per Skript erstellt werden.
--
-- Normaler Weise werden Aufträge im Questassistenten erzeugt. Dies ist aber
-- statisch und das Kopieren von Aufträgen ist nicht möglich. Wenn Aufträge
-- im Skript erzeugt werden, verschwinden alle diese Nachteile. Aufträge
-- können im Skript kopiert und angepasst werden. Es ist ebenfalls machbar,
-- die Aufträge in Sequenzen zu erzeugen.
--
-- &#x3C;p&#x3E;&#x3C;a href="#API.CreateQuest"&#x3E;Quests erzeugen&#x3C;/a&#x3E;&#x3C;/p&#x3E;
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundleQuestGeneration = {};

API = API or {};
QSB = QSB or {};

QSB.GeneratedQuestDialogs = {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Erstellt einen Quest.
--
-- Ein Quest braucht immer wenigstens ein Goal und einen Trigger. Hat ein Quest
-- keinen Namen, erhält er automatisch einen mit fortlaufender Nummerierung.
--
-- Ein Quest besteht aus verschiedenen Eigenschaften und Behavior, die nicht
-- alle zwingend gesetzt werden müssen. Behavior werden einfach nach den
-- Eigenschaften nacheinander angegeben.
-- &#x3C;p&#x3E;&#x3C;u&#x3E;Eigenschaften:&#x3C;/u&#x3E;&#x3C;/p&#x3E;
-- &#x3C;ul&#x3E;
-- &#x3C;li&#x3E;Name: Der eindeutige Name des Quests&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;Sender: PlayerID des Auftraggeber (Default 1)&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;Receiver: PlayerID des Auftragnehmer (Default 1)&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;Suggestion: Vorschlagnachricht des Quests&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;Success: Erfolgsnachricht des Quest&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;Failure: Fehlschlagnachricht des Quest&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;Description: Aufgabenbeschreibung (Nur bei Custom)&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;Time: Zeit bis zu, Fehlschlag/Abschluss&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;Loop: Funktion, die während der Laufzeit des Quests aufgerufen wird&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;Callback: Funktion, die nach Abschluss aufgerufen wird&#x3C;/li&#x3E;
-- &#x3C;/ul&#x3E;
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; AddQuest&#x3C;/p&#x3E;
--
-- @param[type=table] _Data Questdefinition
-- @return[type=string] Name des Quests
-- @return[type=number] Gesamtzahl Quests
-- @within Anwenderfunktionen
--
-- @usage
-- AddQuest {
--     Name        = "ExampleQuest",
--     Suggestion  = "Wir müssen das Kloster finden.",
--     Success     = "Dies sind die berümten Heilermönche.",
--
--     Goal_DiscoverPlayer(4),
--     Reward_Diplomacy(1, 4, "EstablishedContact"),
--     Trigger_Time(0),
-- }
--
function API.CreateQuest(_Data)
    if GUI then
        API.Fatal("API.CreateQuest: Could not execute in local script!");
        return;
    end
    return BundleQuestGeneration.Global:QuestCreateNewQuest(_Data);
end
AddQuest = API.CreateQuest;

---
-- Erzeugt eine Nachricht im Questfenster.
--
-- Der Quest wird immer nach Ablauf der Wartezeit nach
-- Abschluss des Ancestor Quest gestartet bzw. unmittelbar, wenn es keinen
-- Ancestor Quest gibt. Das Callback ist eine Funktion, die zur Anzeigezeit
-- des Quests ausgeführt wird.
--
-- Alle Paramater sind optional und können von rechts nach links weggelassen
-- oder mit nil aufgefüllt werden.
--
-- &#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: QuestMessage
--
-- @param[type=string]   _Text        Anzeigetext der Nachricht
-- @param[type=number]   _Sender      Sender der Nachricht
-- @param[type=number]   _Receiver    Receiver der Nachricht
-- @param[type=number]   _AncestorWt  Wartezeit
-- @param[type=function] _Callback    Callback
-- @param[type=string]   _Ancestor    Vorgänger-Quest
-- @return[type=string] QuestName
-- @within Anwenderfunktionen
--
-- @usage
-- API.CreateQuestMessage("Das ist ein Text", 4, 1);
--
function API.CreateQuestMessage(_Text, _Sender, _Receiver, _AncestorWt, _Callback, _Ancestor)
    if GUI then
        API.Fatal("API.CreateQuestMessage: Could not execute in local script!");
        return;
    end
    return BundleQuestGeneration.Global:QuestMessage(_Text, _Sender, _Receiver, _AncestorWt, _Callback, _Ancestor);
end
QuestMessage = API.CreateQuestMessage;

---
-- Erzeugt aus einer Table mit Daten eine Reihe von Nachrichten, die nach
-- einander angezeigt werden.
--
-- Dabei sind die eingestellten Wartezeiten in Echtzeit gemessen. Somit ist es
-- egal, wie hoch die Spielgeschwindigkeit ist. Die Dialoge warten alle
-- automatisch 12 Sekunden, wenn nichts anderes eingestellt wird.
--
-- Ein Dialog kann als Nachfolge auf einen Quest oder einen anderen Dialog
-- erzeugt werden, indem Ancestor gleich dem Questnamen gesetzt wird. Die
-- Wartezeit ist automatisch 0 Sekunden. Will man eine andere Wartezeit,
-- so muss Delay gesetzt werden.
--
-- Diese Funktion ist geeignet um längere Quest-Dialoge zu konfigurieren!
--
-- &#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: QuestDialog
--
-- Einzelne Parameter pro Eintrag:
-- &#x3C;ul&#x3E;
-- &#x3C;li&#x3E;Anzeigetext der Nachricht&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;PlayerID des Sender der Nachricht&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;PlayerID des Empfängers der Nachricht&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;Wartezeit zur vorangegangenen Nachricht&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;Action-Funktion der Nachricht&#x3C;/li&#x3E;
-- &#x3C;/ul&#x3E;
--
-- @param[type=table] _Messages Liste der anzuzeigenden Nachrichten
-- @return[type=string] Name des letzten Quest
-- @return[type=table] Namensliste der Quests
-- @within Anwenderfunktionen
--
-- @usage
-- API.CreateQuestDialog{
--     Name = "DialogName",
--     Ancestor = "SomeQuestName",
--     Delay = 12,
--
--     {"Hallo, wie geht es dir?", 4, 1, 8},
--     {"Mir geht es gut, wie immer!", 1, 1, 8, SomeCallbackFunction},
--     {"Das ist doch schön.", 4, 1, 8},
-- };
--
function API.CreateQuestDialog(_Messages)
    if GUI then
        API.Fatal("API.CreateQuestDialog: Could not execute in local script!");
        return;
    end

    table.insert(_Messages, {"KEY(NO_MESSAGE)", 1, 1});

    local QuestName;
    local GeneratedQuests = {};
    for i= 1, #_Messages, 1 do
        _Messages[i][4] = _Messages[i][4] or 12;
        if i &#x3E; 1 then
            _Messages[i][6] = _Messages[i][6] or QuestName;
        else
            _Messages[i][6] = _Messages[i][6] or _Messages.Ancestor;
            _Messages[i][4] = _Messages.Delay or 0;
        end
        if i == #_Messages and #_Messages[i-1] then
            _Messages[i][7] = _Messages.Name;
            _Messages[i][4] = _Messages[i-1][4];
        end
        QuestName = BundleQuestGeneration.Global:QuestMessage(unpack(_Messages[i]));
        table.insert(GeneratedQuests, QuestName);
    end

    -- Benannte Dialoge für spätere Zugriffe speichern.
    if _Messages.Name then
        QSB.GeneratedQuestDialogs[_Messages.Name] = GeneratedQuests;
    end
    return GeneratedQuests[#GeneratedQuests], GeneratedQuests;
end
QuestDialog = API.CreateQuestDialog;

---
-- Unterbricht einen laufenden oder noch nicht gestarteten Quest-Dialog.
--
-- Die Funktion kann entweder anhand eines Dialognamen den Dialog zurücksetzen
-- oder direkt die Table der erzeugten Quests annehmen.
--
-- &#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: QuestDialogInterrupt
--
-- @param[type=string] _Dialog Dialog der abgebrochen wird
-- @within Anwenderfunktionen
--
function API.InterruptQuestDialog(_Dialog)
    if GUI then
        API.Fatal("API.InterruptQuestDialog: Could not execute in local script!");
        return;
    end

    local QuestDialog = _Dialog;
    if type(QuestDialog) == "string" then
        QuestDialog = QSB.GeneratedQuestDialogs[QuestDialog];
    end
    if QuestDialog == nil then
        API.Fatal("API.InterruptQuestDialog: Dialog is invalid!");
        return;
    end
    for i= 1, #QuestDialog-1, 1 do
        API.StopQuest(QuestDialog[i], true);
    end
    API.WinQuest(QuestDialog[#QuestDialog], true);
end
QuestDialogInterrupt = API.InterruptQuestDialog;

---
-- Setzt einen Quest-Dialog zurück sodass er erneut gestartet werden kann.
--
-- Die Funktion kann entweder anhand eines Dialognamen den Dialog zurücksetzen
-- oder direkt die Table der erzeugten Quests annehmen.
--
-- &#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: QuestDialogRestart
--
-- @param[type=string] _Dialog Dialog der neu gestartet wird
-- @within Anwenderfunktionen
--
function API.RestartQuestDialog(_Dialog)
    if GUI then
        API.Fatal("API.ResetQuestDialog: Could not execute in local script!");
        return;
    end

    local QuestDialog = _Dialog;
    if type(QuestDialog) == "string" then
        QuestDialog = QSB.GeneratedQuestDialogs[QuestDialog];
    end
    if QuestDialog == nil then
        API.Fatal("API.ResetQuestDialog: Dialog is invalid!");
        return;
    end
    for i= 1, #QuestDialog, 1 do
        Quests[GetQuestID(QuestDialog[i])].Triggers[1][2][1].WaitTimeTimer = nil;
        API.RestartQuest(QuestDialog[i], true);
    end
    Quests[GetQuestID(QuestDialog[1])]:Trigger();
end
QuestDialogRestart = API.RestartQuestDialog;

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

BundleQuestGeneration = {
    Global = {
        Data = {
            QuestMessageID = 0,
        }
    },
};

-- Global Script ---------------------------------------------------------------

---
-- Initalisiert das Bundle im globalen Skript.
--
-- @within Internal
-- @local
--
function BundleQuestGeneration.Global:Install()
end

---
-- Erzeugt eine Nachricht im Questfenster.
--
-- Der erzeugte Quest wird immer fehlschlagen. Der angezeigte Test ist die
-- Failure Message. Der Quest wird immer nach Ablauf der Wartezeit nach
-- Abschluss des Ancestor Quest gestartet bzw. unmittelbar, wenn es keinen
-- Ancestor Quest gibt. Das Callback ist eine Funktion, die zur Anzeigezeit
-- des Quests ausgeführt wird.
--
-- Alle Paramater sind optional und können von rechts nach links weggelassen
-- oder mit nil aufgefüllt werden.
--
-- @param[type=string]   _Text        Anzeigetext der Nachricht
-- @param[type=number]   _Sender      Sender der Nachricht
-- @param[type=number]   _Receiver    Receiver der Nachricht
-- @param[type=number]   _AncestorWt  Wartezeit
-- @param[type=function] _Callback    Callback
-- @param[type=string]   _Ancestor    Vorgänger-Quest
-- @param[type=string]   _QuestName   Questname überschreiben
-- @return[type=string] QuestName
--
-- @within Internal
-- @local
--
function BundleQuestGeneration.Global:QuestMessage(_Text, _Sender, _Receiver, _AncestorWt, _Callback, _Ancestor, _QuestName)
    self.Data.QuestMessageID = self.Data.QuestMessageID +1;

    -- Trigger-Nachbau
    local OnQuestOver = {
        Triggers.Custom2, {
            {QuestName = _Ancestor, WaitTime = _AncestorWt or 1,},
                function(_Data)
                local QuestID = GetQuestID(_Data.QuestName);
                if not _Data.QuestName then
                    return true;
                end
                if (Quests[QuestID] and Quests[QuestID].State == QuestState.Over and Quests[QuestID].Result ~= QuestResult.Interrupted) then
                    _Data.WaitTimeTimer = _Data.WaitTimeTimer or API.RealTimeGetSecondsPassedSinceGameStart();
                    if API.RealTimeGetSecondsPassedSinceGameStart() &#x3E;= _Data.WaitTimeTimer + _Data.WaitTime then
                        return true;
                    end
                end
                return false;
            end
        }
    };

    -- Lokalisierung
    local Language = (Network.GetDesiredLanguage() == "de" and "de") or "en";
    if type(_Text) == "table" then
        _Text = _Text[Language];
    end

    -- Quest erzeugen
    local _, CreatedQuest = QuestTemplate:New(
        (_QuestName ~= nil and _QuestName) or "QSB_QuestMessage_" ..self.Data.QuestMessageID,
        (_Sender or 1),
        (_Receiver or 1),
        { {Objective.Dummy} },
        { OnQuestOver },
        0, nil, nil, _Callback, nil, false, (_Text ~= nil), nil, nil, _Text, nil
    );
    return CreatedQuest.Identifier;
end

---
-- Erzeugt einen Quest.
--
-- @param[type=table] _Data Daten des Quest.
-- @return[type=string] Name des erzeugten Quests
-- @within Internal
-- @local
--
function BundleQuestGeneration.Global:QuestCreateNewQuest(_Data)
    if not _Data.Name then
        QSB.AutomaticQuestNameCounter = (QSB.AutomaticQuestNameCounter or 0) +1;
        _Data.Name = string.format("AutoNamed_Quest_d", QSB.AutomaticQuestNameCounter);
    end
    if not Core:CheckQuestName(_Data.Name) then
        fatal("Quest '"..tostring(_Data.Name).."': invalid questname! Contains forbidden characters!");
        return;
    end

    local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";

    -- Questdaten erzeugen
    local QuestData = {
        _Data.Name,
        (_Data.Sender ~= nil and _Data.Sender) or 1,
        (_Data.Receiver ~= nil and _Data.Receiver) or 1,
        {},
        {},
        (_Data.Time ~= nil and _Data.Time) or 0,
        {},
        {},
        _Data.Callback,
        _Data.Loop,
        _Data.Visible == true or _Data.Suggestion ~= nil,
        _Data.EndMessage == true or (_Data.Failure ~= nil or _Data.Success ~= nil),
        (type(_Data.Description) == "table" and _Data.Description[lang]) or _Data.Description,
        (type(_Data.Suggestion) == "table" and _Data.Suggestion[lang]) or _Data.Suggestion,
        (type(_Data.Success) == "table" and _Data.Success[lang]) or _Data.Success,
        (type(_Data.Failure) == "table" and _Data.Failure[lang]) or _Data.Failure
    };

    -- Daten validieren
    if not self:QuestValidateQuestData(QuestData) then
        API.Fatal("AddQuest: Error while creating quest. Table has been copied to log.");
        API.DumpTable(QuestData, "Quest");
        return;
    end

    -- Behaviour
    for k,v in pairs(_Data) do
        if tonumber(k) ~= nil then
            if type(v) == "table" then
                if v.GetGoalTable then
                    table.insert(QuestData[4], v:GetGoalTable());

                    local Idx = #QuestData[4];
                    QuestData[4][Idx].Context            = v;
                    QuestData[4][Idx].FuncOverrideIcon   = QuestData[4][Idx].Context.GetIcon;
                    QuestData[4][Idx].FuncOverrideMsgKey = QuestData[4][Idx].Context.GetMsgKey;
                elseif v.GetReprisalTable then
                    table.insert(QuestData[8], v:GetReprisalTable());
                elseif v.GetRewardTable then
                    table.insert(QuestData[7], v:GetRewardTable());
                else
                    table.insert(QuestData[5], v:GetTriggerTable());
                end
            end
        end
    end

    -- Quest erzeugen
    local QuestID, Quest = QuestTemplate:New(unpack(QuestData, 1, 16));
    Quest.MsgTableOverride = _Data.MSGKeyOverwrite;
    Quest.IconOverride = _Data.IconOverwrite;
    return _Data.Name, Quests[0];
end

---
-- Validiert die Felder eines Quests.
--
-- @param[type=table] _Data Daten des Quest.
-- @return[type=boolean] Quest OK
-- @within Internal
-- @local
--
function BundleQuestGeneration.Global:QuestValidateQuestData(_Data)
    return (
        (type(_Data[1]) == "string" and self:QuestValidateQuestName(_Data[1])) and
        (type(_Data[2]) == "number" and _Data[2] &#x3E;= 1 and _Data[2] &#x3C;= 8) and
        (type(_Data[3]) == "number" and _Data[3] &#x3E;= 1 and _Data[3] &#x3C;= 8) and
        (type(_Data[6]) == "number" and _Data[6] &#x3E;= 0) and
        ((_Data[9] ~= nil and type(_Data[9]) == "function") or (_Data[9] == nil)) and
        ((_Data[10] ~= nil and type(_Data[10]) == "function") or (_Data[10] == nil)) and
        (type(_Data[11]) == "boolean") and
        (type(_Data[12]) == "boolean") and
        ((_Data[13] ~= nil and type(_Data[13]) == "string") or (_Data[13] == nil)) and
        ((_Data[14] ~= nil and type(_Data[14]) == "string") or (_Data[14] == nil)) and
        ((_Data[15] ~= nil and type(_Data[15]) == "string") or (_Data[15] == nil)) and
        ((_Data[16] ~= nil and type(_Data[16]) == "string") or (_Data[16] == nil))
    );
end

---
-- Validiert den Namen eines Quests.
--
-- @param[type=string] _Name Name des Quest.
-- @return[type=boolean] Name OK
-- @within Internal
-- @local
--
function BundleQuestGeneration.Global:QuestValidateQuestName(_Name)
    return string.find(_Name, "^[A-Za-z0-9_]+$") ~= nil;
end

Core:RegisterBundle("BundleQuestGeneration");

</code></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundlesymfoniabehaviors.lua.html">
            <div class='doclink'>
                <div>BundleSymfoniaBehaviors</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><code>-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundleSymfoniaBehaviors                                      # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Dieses Bundle enthält einige weitere nützliche Behavior, welche es so nicht
-- in der ursprünglichen QSB gab.
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundleSymfoniaBehaviors = {};

API = API or {};
QSB = QSB or {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

-- Hier gibt es keine Funktionen!

-- -------------------------------------------------------------------------- --
-- Goals                                                                      --
-- -------------------------------------------------------------------------- --

---
-- Ein Entity muss sich zu einem Ziel bewegen und eine Distanz unterschreiten.
--
-- Optional kann das Ziel mit einem Marker markiert werden.
--
-- @param _ScriptName Skriptname des Entity
-- @param _Target     Skriptname des Ziels
-- @param _Distance   Entfernung
-- @param _UseMarker  Ziel markieren
--
-- @within Goal
--
function Goal_MoveToPosition(...)
    return b_Goal_MoveToPosition:new(...);
end

b_Goal_MoveToPosition = {
    Name = "Goal_MoveToPosition",
    Description = {
        en = "Goal: A entity have to moved as close as the distance to another entity. The target can be marked with a static marker.",
        de = "Ziel: Eine Entity muss sich einer anderen bis auf eine bestimmte Distanz nähern. Die Lupe wird angezeigt, das Ziel kann markiert werden.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Entity",   de = "Entity" },
        { ParameterType.ScriptName, en = "Target",   de = "Ziel" },
        { ParameterType.Number,     en = "Distance", de = "Entfernung" },
        { ParameterType.Custom,     en = "Marker",   de = "Ziel markieren" },
    },
}

function b_Goal_MoveToPosition:GetGoalTable()
    return {Objective.Distance, self.Entity, self.Target, self.Distance, self.Marker}
end

function b_Goal_MoveToPosition:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Entity = _Parameter
    elseif (_Index == 1) then
        self.Target = _Parameter
    elseif (_Index == 2) then
        self.Distance = _Parameter * 1
    elseif (_Index == 3) then
        self.Marker = AcceptAlternativeBoolean(_Parameter)
    end
end

function b_Goal_MoveToPosition:GetCustomData( _Index )
    local Data = {};
    if _Index == 3 then
        Data = {"true", "false"}
    end
    return Data
end

Core:RegisterBehavior(b_Goal_MoveToPosition);

-- -------------------------------------------------------------------------- --

---
-- Der Spieler muss einen bestimmten Quest abschließen.
--
-- @param _QuestName Name des Quest
--
-- @within Goal
--
function Goal_WinQuest(...)
    return b_Goal_WinQuest:new(...);
end

b_Goal_WinQuest = {
    Name = "Goal_WinQuest",
    Description = {
        en = "Goal: The player has to win a given quest",
        de = "Ziel: Der Spieler muss eine angegebene Quest erfolgreich abschliessen.",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest Name",      de = "Questname" },
    },
}

function b_Goal_WinQuest:GetGoalTable()
    return {Objective.Custom2, {self, self.CustomFunction}};
end

function b_Goal_WinQuest:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Quest = _Parameter;
    end
end

function b_Goal_WinQuest:CustomFunction(_Quest)
    local quest = Quests[GetQuestID(self.Quest)];
    if quest then
        if quest.Result == QuestResult.Failure then
            return false;
        end
        if quest.Result == QuestResult.Success then
            return true;
        end
    end
    return nil;
end

function b_Goal_WinQuest:Debug(_Quest)
    if Quests[GetQuestID(self.Quest)] == nil then
        fatal(_Quest.Identifier .. ": " .. self.Name .. ": Quest '"..self.Quest.."' does not exist!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Goal_WinQuest);

-- -------------------------------------------------------------------------- --

---
-- Der Spieler muss eine bestimmte Menge Gold mit Dieben stehlen.
--
-- Dabei ist es egal von welchem Spieler. Diebe können Gold nur aus
-- Stadtgebäude stehlen und nur von feindlichen Spielern.
--
-- &#x3C;b&#x3E;Hinweis&#x3C;/b&#x3E;:Das Behavior cheatet allen Zielspielern Einnahmen in den
-- Gebäuden, damit der Quest stets erfüllbar bleibt. Dies gilt auch, wenn
-- der menschliche Spieler das Ziel ist!
--
-- @param _Amount       Menge an Gold
-- @param _ShowProgress Fortschritt ausgeben
--
-- @within Goal
--
function Goal_StealGold(...)
    return b_Goal_StealGold:new(...)
end

b_Goal_StealGold = {
    Name = "Goal_StealGold",
    Description = {
        en = "Goal: Steal an explicit amount of gold from a players or any players city buildings.",
        de = "Ziel: Diebe sollen eine bestimmte Menge Gold aus feindlichen Stadtgebäuden stehlen.",
    },
    Parameter = {
        { ParameterType.Number,   en = "Amount on Gold", de = "Zu stehlende Menge" },
        { ParameterType.Custom,   en = "Target player",  de = "Spieler von dem gestohlen wird" },
        { ParameterType.Custom,   en = "Print progress", de = "Fortschritt ausgeben" },
    },
}

function b_Goal_StealGold:GetGoalTable()
    return {Objective.Custom2, {self, self.CustomFunction}};
end

function b_Goal_StealGold:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Amount = _Parameter * 1;
    elseif (_Index == 1) then
        local PlayerID = tonumber(_Paramater) or -1;
        self.Target = PlayerID * 1;
    elseif (_Index == 2) then
        _Parameter = _Parameter or "true"
        self.Printout = AcceptAlternativeBoolean(_Parameter);
    end
    self.StohlenGold = 0;
end

function b_Goal_StealGold:GetCustomData(_Index)
    if _Index == 1 then
        return { "-", 1, 2, 3, 4, 5, 6, 7, 8 };
    elseif _Index == 2 then
        return { "true", "false" };
    end
end

function b_Goal_StealGold:SetDescriptionOverwrite(_Quest)
    local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";
    local TargetPlayerName = (lang == "de" and " anderen Spielern ") or " different parties";
    if self.Target ~= -1 then
        TargetPlayerName = GetPlayerName(self.Target);
        if TargetPlayerName == nil or TargetPlayerName == "" then
            TargetPlayerName = " PLAYER_NAME_MISSING ";
        end
    end

    -- Cheat earnings
    local PlayerIDs = {self.Target};
    if self.Target == -1 then
        PlayerIDs = {1, 2, 3, 4, 5, 6, 7, 8};
    end
    for i= 1, #PlayerIDs, 1 do
        if i ~= _Quest.ReceivingPlayer and Logic.GetStoreHouse(i) ~= 0 then
            local CityBuildings = {Logic.GetPlayerEntitiesInCategory(i, EntityCategories.CityBuilding)};
            for j= 1, #CityBuildings, 1 do
                local CurrentEarnings = Logic.GetBuildingProductEarnings(CityBuildings[j]);
                if CurrentEarnings &#x3C; 45 and Logic.GetTime()  5 == 0 then
                    Logic.SetBuildingEarnings(CityBuildings[j], CurrentEarnings +1);
                end
            end
        end
    end

    local amount = self.Amount-self.StohlenGold;
    amount = (amount &#x3E; 0 and amount) or 0;
    local text = {
        de = "Gold von s stehlen {cr}{cr}Aus Stadtgebäuden zu stehlende Goldmenge: d",
        en = "Steal gold from s {cr}{cr}Amount on gold to steal from city buildings: d",
    };
    return "{center}" ..string.format(text[lang], TargetPlayerName, amount);
end

function b_Goal_StealGold:CustomFunction(_Quest)
    Core:ChangeCustomQuestCaptionText(self:SetDescriptionOverwrite(_Quest), _Quest);

    if self.StohlenGold &#x3E;= self.Amount then
        return true;
    end
    return nil;
end

function b_Goal_StealGold:GetIcon()
    return {5,13};
end

function b_Goal_StealGold:Debug(_Quest)
    if tonumber(self.Amount) == nil and self.Amount &#x3C; 0 then
        fatal(_Quest.Identifier .. ": " .. self.Name .. ": amount can not be negative!");
        return true;
    end
    return false;
end

function b_Goal_StealGold:Reset()
    self.StohlenGold = 0;
end

Core:RegisterBehavior(b_Goal_StealGold)

-- -------------------------------------------------------------------------- --

---
-- Der Spieler muss ein bestimmtes Stadtgebäude bestehlen.
--
-- Eine Kirche wird immer Sabotiert. Ein Lagerhaus verhält sich ähnlich zu
-- einer Burg.
--
-- &#x3C;b&#x3E;Hinweis&#x3C;/b&#x3E;: Das Behavior cheatet in dem Zielgebäude Einnahmen, damit
-- ein Dieb entsandt werden kann.
--
-- @param _ScriptName Skriptname des Gebäudes
--
-- @within Goal
--
function Goal_StealBuilding(...)
    return b_Goal_StealBuilding:new(...)
end

b_Goal_StealBuilding = {
    Name = "Goal_StealBuilding",
    Description = {
        en = "Goal: The player has to steal from a building. Not a castle and not a village storehouse!",
        de = "Ziel: Der Spieler muss ein bestimmtes Gebäude bestehlen. Dies darf keine Burg und kein Dorflagerhaus sein!",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Building", de = "Gebäude" },
    },
}

function b_Goal_StealBuilding:GetGoalTable()
    return {Objective.Custom2, {self, self.CustomFunction}};
end

function b_Goal_StealBuilding:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Building = _Parameter
    end
    self.RobberList = {};
end

function b_Goal_StealBuilding:GetCustomData(_Index)
    if _Index == 1 then
        return { "true", "false" };
    end
end

function b_Goal_StealBuilding:SetDescriptionOverwrite(_Quest)
    local isCathedral = Logic.IsEntityInCategory(GetID(self.Building), EntityCategories.Cathedrals) == 1;
    local isWarehouse = Logic.GetEntityType(GetID(self.Building)) == Entities.B_StoreHouse;
    local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";
    local text;

    if isCathedral then
        text = {
            de = "Sabotage {cr}{cr} Sabotiert die mit Pfeil markierte Kirche.",
            en = "Sabotage {cr}{cr} Sabotage the Church of the opponent.",
        };
    elseif isWarehouse then
        text = {
            de = "Lagerhaus bestehlen {cr}{cr} Sendet einen Dieb in das markierte Lagerhaus.",
            en = "Steal from storehouse {cr}{cr} Steal from the marked storehouse.",
        };
    else
        text = {
            de = "Gebäude bestehlen {cr}{cr} Bestehlt das durch einen Pfeil markierte Gebäude.",
            en = "Steal from building {cr}{cr} Steal from the building marked by an arrow.",
        };
    end
    return "{center}" .. text[lang];
end

function b_Goal_StealBuilding:CustomFunction(_Quest)
    if not IsExisting(self.Building) then
        if self.Marker then
            Logic.DestroyEffect(self.Marker);
        end
        return false;
    end

    if not self.Marker then
        local pos = GetPosition(self.Building);
        self.Marker = Logic.CreateEffect(EGL_Effects.E_Questmarker, pos.X, pos.Y, 0);
    end

    -- Cheat earnings
    local BuildingID = GetID(self.Building);
    if  Logic.IsEntityInCategory(BuildingID, EntityCategories.CityBuilding) == 1
    and Logic.GetBuildingEarnings(BuildingID) &#x3C; 10 then
        Logic.SetBuildingEarnings(BuildingID, 10);
    end

    if self.SuccessfullyStohlen then
        Logic.DestroyEffect(self.Marker);
        return true;
    end
    return nil;
end

function b_Goal_StealBuilding:GetIcon()
    return {5,13};
end

function b_Goal_StealBuilding:Debug(_Quest)
    local eTypeName = Logic.GetEntityTypeName(Logic.GetEntityType(GetID(self.Building)));
    local IsHeadquarter = Logic.IsEntityInCategory(GetID(self.Building), EntityCategories.Headquarters) == 1;
    if Logic.IsBuilding(GetID(self.Building)) == 0 then
        fatal(_Quest.Identifier .. ": " .. self.Name .. ": target is not a building");
        return true;
    elseif not IsExisting(self.Building) then
        fatal(_Quest.Identifier .. ": " .. self.Name .. ": target is destroyed :(");
        return true;
    elseif string.find(eTypeName, "B_NPC_BanditsHQ") or string.find(eTypeName, "B_NPC_Cloister") or string.find(eTypeName, "B_NPC_StoreHouse") then
        fatal(_Quest.Identifier .. ": " .. self.Name .. ": village storehouses are not allowed!");
        return true;
    elseif IsHeadquarter then
        fatal(_Quest.Identifier .. ": " .. self.Name .. ": use Goal_StealInformation for headquarters!");
        return true;
    end
    return false;
end

function b_Goal_StealBuilding:Reset()
    self.SuccessfullyStohlen = false;
    self.RobberList = {};
    self.Marker = nil;
end

function b_Goal_StealBuilding:Interrupt(_Quest)
    Logic.DestroyEffect(self.Marker);
end

Core:RegisterBehavior(b_Goal_StealBuilding)

-- -------------------------------------------------------------------------- --

---
-- Der Spieler muss ein Gebäude mit einem Dieb ausspoinieren.
--
-- Der Quest ist erfolgreich, sobald der Dieb in das Gebäude eindringt. Es
-- muss sich um ein Gebäude handeln, das bestohlen werden kann (Burg, Lager,
-- Kirche, Stadtgebäude mit Einnahmen)!
--
-- Optional kann der Dieb nach Abschluss gelöscht werden. Diese Option macht
-- es einfacher ihn durch z.B. einen Abfahrenden U_ThiefCart zu "ersetzen".
--
-- &#x3C;b&#x3E;Hinweis&#x3C;/b&#x3E;:Das Behavior cheatet in dem Zielgebäude Einnahmen, damit
-- ein Dieb entsandt werden kann.
--
-- @param _ScriptName  Skriptname des Gebäudes
-- @param _DeleteThief Dieb nach Abschluss löschen
--
-- @within Goal
--
function Goal_SpyBuilding(...)
    return b_Goal_SpyBuilding:new(...)
end

b_Goal_SpyBuilding = {
    Name = "Goal_SpyBuilding",
    IconOverwrite = {5,13},
    Description = {
        en = "Goal: Infiltrate a building with a thief. A thief must be able to steal from the target building.",
        de = "Ziel: Infiltriere ein Gebäude mit einem Dieb. Nur mit Gebaueden möglich, die bestohlen werden koennen.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Target Building", de = "Zielgebäude" },
        { ParameterType.Custom,     en = "Destroy Thief", de = "Dieb löschen" },
    },
}

function b_Goal_SpyBuilding:GetGoalTable()
    return {Objective.Custom2, {self, self.CustomFunction}};
end

function b_Goal_SpyBuilding:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Building = _Parameter
    elseif (_Index == 1) then
        _Parameter = _Parameter or "true"
        self.Delete = AcceptAlternativeBoolean(_Parameter)
    end
end

function b_Goal_SpyBuilding:GetCustomData(_Index)
    if _Index == 1 then
        return { "true", "false" };
    end
end

function b_Goal_SpyBuilding:SetDescriptionOverwrite(_Quest)
    if not _Quest.QuestDescription then
        local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";
        local text = {
            de = "Gebäude infriltrieren {cr}{cr}Spioniere das markierte Gebäude mit einem Dieb aus!",
            en = "Infiltrate building {cr}{cr}Spy on the highlighted buildings with a thief!",
        };
        return text[lang];
    else
        return _Quest.QuestDescription;
    end
end

function b_Goal_SpyBuilding:CustomFunction(_Quest)
    if not IsExisting(self.Building) then
        if self.Marker then
            Logic.DestroyEffect(self.Marker);
        end
        return false;
    end

    if not self.Marker then
        local pos = GetPosition(self.Building);
        self.Marker = Logic.CreateEffect(EGL_Effects.E_Questmarker, pos.X, pos.Y, 0);
    end

    -- Cheat earnings
    local BuildingID = GetID(self.Building);
    if  Logic.IsEntityInCategory(BuildingID, EntityCategories.CityBuilding) == 1
    and Logic.GetBuildingEarnings(BuildingID) &#x3C; 10 then
        Logic.SetBuildingEarnings(BuildingID, 10);
    end

    if self.Infiltrated then
        Logic.DestroyEffect(self.Marker);
        return true;
    end
    return nil;
end

function b_Goal_SpyBuilding:GetIcon()
    return self.IconOverwrite;
end

function b_Goal_SpyBuilding:Debug(_Quest)
    if Logic.IsBuilding(GetID(self.Building)) == 0 then
        fatal(_Quest.Identifier .. ": " .. self.Name .. ": target is not a building");
        return true;
    elseif not IsExisting(self.Building) then
        fatal(_Quest.Identifier .. ": " .. self.Name .. ": target is destroyed :(");
        return true;
    end
    return false;
end

function b_Goal_SpyBuilding:Reset()
    self.Infiltrated = false;
    self.Marker = nil;
end

function b_Goal_SpyBuilding:Interrupt(_Quest)
    Logic.DestroyEffect(self.Marker);
end

Core:RegisterBehavior(b_Goal_SpyBuilding);

-- -------------------------------------------------------------------------- --

---
-- Es muss eine Menge an Munition in der Kriegsmaschine erreicht werden.
--
-- &#x3C;u&#x3E;Relationen&#x3C;/u&#x3E;
-- &#x3C;ul&#x3E;
-- &#x3C;li&#x3E;&#x3E;= - Anzahl als Mindestmenge&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;&#x3C; - Weniger als Anzahl&#x3C;/li&#x3E;
-- &#x3C;/ul&#x3E;
--
-- @param _ScriptName  Name des Kriegsgerät
-- @param _Relation    Mengenrelation
-- @param _Amount      Menge an Munition
--
-- @within Goal
--
function Goal_AmmunitionAmount(...)
    return b_Goal_AmmunitionAmount:new(...);
end

b_Goal_AmmunitionAmount = {
    Name = "Goal_AmmunitionAmount",
    Description = {
        en = "Goal: Reach a smaller or bigger value than the given amount of ammunition in a war machine.",
        de = "Ziel: Ueber- oder unterschreite die angegebene Anzahl Munition in einem Kriegsgerät.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script name", de = "Skriptname" },
        { ParameterType.Custom, en = "Relation", de = "Relation" },
        { ParameterType.Number, en = "Amount", de = "Menge" },
    },
}

function b_Goal_AmmunitionAmount:GetGoalTable()
    return { Objective.Custom2, {self, self.CustomFunction} }
end

function b_Goal_AmmunitionAmount:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Scriptname = _Parameter
    elseif (_Index == 1) then
        self.bRelSmallerThan = tostring(_Parameter) == "true" or _Parameter == "&#x3C;"
    elseif (_Index == 2) then
        self.Amount = _Parameter * 1
    end
end

function b_Goal_AmmunitionAmount:CustomFunction()
    local EntityID = GetID(self.Scriptname);
    if not IsExisting(EntityID) then
        return false;
    end
    local HaveAmount = Logic.GetAmmunitionAmount(EntityID);
    if ( self.bRelSmallerThan and HaveAmount &#x3C; self.Amount ) or ( not self.bRelSmallerThan and HaveAmount &#x3E;= self.Amount ) then
        return true;
    end
    return nil;
end

function b_Goal_AmmunitionAmount:Debug(_Quest)
    if self.Amount &#x3C; 0 then
        fatal(_Quest.Identifier .. ": Error in " .. self.Name .. ": Amount is negative");
        return true
    end
end

function b_Goal_AmmunitionAmount:GetCustomData( _Index )
    if _Index == 1 then
        return {"&#x3C;", "&#x3E;="};
    end
end

Core:RegisterBehavior(b_Goal_AmmunitionAmount)

-- -------------------------------------------------------------------------- --

---
-- Eine Menge an Entities des angegebenen Spawnpoint muss zerstört werden.
--
-- Wenn die angegebene Anzahl zu Beginn des Quest nicht mit der Anzahl an
-- bereits gespawnten Entities übereinstimmt, wird dies automatisch korrigiert.
-- (Neue Entities gespawnt bzw. überschüssige gelöscht)
--
-- @param              _SpawnPoint Spawnpoint oder Liste von Spawnpoints
-- @param[type=number] _Amount     Menge zu zerstörender Entities
--
-- @within Goal
--
function Goal_DestroySpawnedEntities(...)
    return b_Goal_DestroySpawnedEntities:new(...);
end

b_Goal_DestroySpawnedEntities = {
    Name = "Goal_DestroySpawnedEntities",
    Description = {
        en = "Goal: Destroy all entities spawned at the spawnpoint.",
        de = "Ziel: Zerstöre alle Entitäten, die bei dem Spawnpoint erzeugt wurde.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Spawnpoint", de = "Spawnpoint" },
        { ParameterType.Number,     en = "Amount",     de = "Menge" },
    },
};

function b_Goal_DestroySpawnedEntities:GetGoalTable()
    return {Objective.DestroyEntities, 3, self.SpawnPoint, self.Amount};
end

function b_Goal_DestroySpawnedEntities:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        if type(_Parameter) ~= "table" then
            _Parameter = {_Parameter};
        end
        self.SpawnPoint = _Parameter;
    elseif (_Index == 1) then
        self.Amount = _Parameter * 1;
    end
end

function b_Goal_DestroySpawnedEntities:GetMsgKey()
    return "Quest_DestroyEntities";
end

Core:RegisterBehavior(b_Goal_DestroySpawnedEntities);

-- -------------------------------------------------------------------------- --

---
-- Der Spieler muss mindestens den angegebenen Ruf erreichen. Der Ruf muss
-- in Prozent angegeben werden (ohne -Zeichen).
--
-- @param[type=number] _Reputation Benötigter Ruf
--
-- @within Goal
--
function Goal_CityReputation(...)
    return b_Goal_CityReputation:new(...);
end

b_Goal_CityReputation = {
    Name = "Goal_CityReputation",
    Description = {
        en = "Goal: Der Ruf der Stadt des Empfängers muss mindestens so hoch sein, wie angegeben.",
        de = "Ziel: The reputation of the quest receivers city must at least reach the desired hight.",
    },
    Parameter = {
        { ParameterType.Number, en = "City reputation", de = "Ruf der Stadt" },
    },
    Text = {
        de = "RUF DER STADT{cr}{cr}Hebe den Ruf der Stadt durch weise Herrschaft an!{cr}Benötigter Ruf: d",
        en = "CITY REPUTATION{cr}{cr}Raise your reputation by fair rulership!{cr}Needed reputation: d",
    }
}

function b_Goal_CityReputation:GetGoalTable()
    return {Objective.Custom2, {self, self.CustomFunction}};
end

function b_Goal_CityReputation:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Reputation = _Parameter * 1;
    end
end

function b_Goal_CityReputation:CustomFunction(_Quest)
    self:SetCaption(_Quest);
    local CityReputation = Logic.GetCityReputation(_Quest.ReceivingPlayer) * 100;
    if CityReputation &#x3E;= self.Reputation then
        return true;
    end
end

function b_Goal_CityReputation:SetCaption(_Quest)
    if not _Quest.QuestDescription or _Quest.QuestDescription == "" then
    local Language = (Network.GetDesiredLanguage() == "de" and "de") or "en";
        local Text = string.format(self.Text[Language], self.Reputation);
        Core:ChangeCustomQuestCaptionText(Text, _Quest);
    end
end

function b_Goal_CityReputation:Debug(_Quest)
    if type(self.Reputation) ~= "number" or self.Reputation &#x3C; 0 or self.Reputation &#x3E; 100 then
        API.Fatal(_Quest.Identifier.. " " ..self.Name.. ": Reputation must be between 0 and 100!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Goal_CityReputation);

-- -------------------------------------------------------------------------- --
-- Reprisals                                                                  --
-- -------------------------------------------------------------------------- --

---
-- Ändert die Position eines Siedlers oder eines Gebäudes.
--
-- Optional kann das Entity in einem bestimmten Abstand zum Ziel platziert
-- werden und das Ziel anschauen. Die Entfernung darf nicht kleiner sein
-- als 50!
--
-- @param _ScriptName Skriptname des Entity
-- @param _Target     Skriptname des Ziels
-- @param _LookAt     Gegenüberstellen
-- @param _Distance   Relative Entfernung (nur mit _LookAt)
--
-- @within Reprisal
--
function Reprisal_SetPosition(...)
    return b_Reprisal_SetPosition:new(...);
end

b_Reprisal_SetPosition = {
    Name = "Reprisal_SetPosition",
    Description = {
        en = "Reprisal: Places an entity relative to the position of another. The entity can look the target.",
        de = "Vergeltung: Setzt eine Entity relativ zur Position einer anderen. Die Entity kann zum Ziel ausgerichtet werden.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Entity",             de = "Entity", },
        { ParameterType.ScriptName, en = "Target position", de = "Zielposition", },
        { ParameterType.Custom,     en = "Face to face",     de = "Ziel ansehen", },
        { ParameterType.Number,     en = "Distance",         de = "Zielentfernung", },
    },
}

function b_Reprisal_SetPosition:GetReprisalTable()
    return { Reprisal.Custom, { self, self.CustomFunction } }
end

function b_Reprisal_SetPosition:AddParameter( _Index, _Parameter )
    if (_Index == 0) then
        self.Entity = _Parameter;
    elseif (_Index == 1) then
        self.Target = _Parameter;
    elseif (_Index == 2) then
        self.FaceToFace = AcceptAlternativeBoolean(_Parameter)
    elseif (_Index == 3) then
        self.Distance = (_Parameter ~= nil and tonumber(_Parameter)) or 100;
    end
end

function b_Reprisal_SetPosition:CustomFunction(_Quest)
    if not IsExisting(self.Entity) or not IsExisting(self.Target) then
        return;
    end

    local entity = GetID(self.Entity);
    local target = GetID(self.Target);
    local x,y,z = Logic.EntityGetPos(target);
    if Logic.IsBuilding(target) == 1 then
        x,y = Logic.GetBuildingApproachPosition(target);
    end
    local ori = Logic.GetEntityOrientation(target)+90;

    if self.FaceToFace then
        x = x + self.Distance * math.cos( math.rad(ori) );
        y = y + self.Distance * math.sin( math.rad(ori) );
        Logic.DEBUG_SetSettlerPosition(entity, x, y);
        LookAt(self.Entity, self.Target);
    else
        if Logic.IsBuilding(target) == 1 then
            x,y = Logic.GetBuildingApproachPosition(target);
        end
        Logic.DEBUG_SetSettlerPosition(entity, x, y);
    end
end

function b_Reprisal_SetPosition:GetCustomData(_Index)
    if _Index == 2 then
        return { "true", "false" }
    end
end

function b_Reprisal_SetPosition:Debug(_Quest)
    if self.FaceToFace then
        if tonumber(self.Distance) == nil or self.Distance &#x3C; 50 then
            fatal(_Quest.Identifier.. " " ..self.Name.. ": Distance is nil or to short!");
            return true;
        end
    end
    if not IsExisting(self.Entity) or not IsExisting(self.Target) then
        fatal(_Quest.Identifier.. " " ..self.Name.. ": Mover entity or target entity does not exist!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Reprisal_SetPosition);

-- -------------------------------------------------------------------------- --

---
-- Ändert den Eigentümer des Entity oder des Battalions.
--
-- @param _ScriptName Skriptname des Entity
-- @param _NewOwner   PlayerID des Eigentümers
--
-- @within Reprisal
--
function Reprisal_ChangePlayer(...)
    return b_Reprisal_ChangePlayer:new(...)
end

b_Reprisal_ChangePlayer = {
    Name = "Reprisal_ChangePlayer",
    Description = {
        en = "Reprisal: Changes the owner of the entity or a battalion.",
        de = "Vergeltung: Aendert den Besitzer einer Entity oder eines Battalions.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Entity",     de = "Entity", },
        { ParameterType.Custom,     en = "Player",     de = "Spieler", },
    },
}

function b_Reprisal_ChangePlayer:GetReprisalTable()
    return { Reprisal.Custom, { self, self.CustomFunction } }
end

function b_Reprisal_ChangePlayer:AddParameter( _Index, _Parameter )
    if (_Index == 0) then
        self.Entity = _Parameter;
    elseif (_Index == 1) then
        self.Player = tostring(_Parameter);
    end
end

function b_Reprisal_ChangePlayer:CustomFunction(_Quest)
    if not IsExisting(self.Entity) then
        return;
    end
    local eID = GetID(self.Entity);
    if Logic.IsLeader(eID) == 1 then
        Logic.ChangeSettlerPlayerID(eID, self.Player);
    else
        Logic.ChangeEntityPlayerID(eID, self.Player);
    end
end

function b_Reprisal_ChangePlayer:GetCustomData(_Index)
    if _Index == 1 then
        return {"0", "1", "2", "3", "4", "5", "6", "7", "8"}
    end
end

function b_Reprisal_ChangePlayer:Debug(_Quest)
    if not IsExisting(self.Entity) then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": entity '"..  self.Entity .. "' does not exist!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Reprisal_ChangePlayer);

-- -------------------------------------------------------------------------- --

---
-- Ändert die Sichtbarkeit eines Entity.
--
-- @param _ScriptName Skriptname des Entity
-- @param _Visible    Sichtbarkeit an/aus
--
-- @within Reprisal
--
function Reprisal_SetVisible(...)
    return b_Reprisal_SetVisible:new(...)
end

b_Reprisal_SetVisible = {
    Name = "Reprisal_SetVisible",
    Description = {
        en = "Reprisal: Changes the visibility of an entity. If the entity is a spawner the spawned entities will be affected.",
        de = "Strafe: Setzt die Sichtbarkeit einer Entity. Handelt es sich um einen Spawner werden auch die gespawnten Entities beeinflusst.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Entity",     de = "Entity", },
        { ParameterType.Custom,     en = "Visible",     de = "Sichtbar", },
    },
}

function b_Reprisal_SetVisible:GetReprisalTable()
    return { Reprisal.Custom, { self, self.CustomFunction } }
end

function b_Reprisal_SetVisible:AddParameter( _Index, _Parameter )
    if (_Index == 0) then
        self.Entity = _Parameter;
    elseif (_Index == 1) then
        self.Visible = AcceptAlternativeBoolean(_Parameter)
    end
end

function b_Reprisal_SetVisible:CustomFunction(_Quest)
    if not IsExisting(self.Entity) then
        return;
    end

    local eID = GetID(self.Entity);
    local pID = Logic.EntityGetPlayer(eID);
    local eType = Logic.GetEntityType(eID);
    local tName = Logic.GetEntityTypeName(eType);

    if string.find(tName, "S_") or string.find(tName, "B_NPC_Bandits")
    or string.find(tName, "B_NPC_Barracks") then
        local spawned = {Logic.GetSpawnedEntities(eID)};
        for i=1, #spawned do
            if Logic.IsLeader(spawned[i]) == 1 then
                local soldiers = {Logic.GetSoldiersAttachedToLeader(spawned[i])};
                for j=2, #soldiers do
                    Logic.SetVisible(soldiers[j], self.Visible);
                end
            else
                Logic.SetVisible(spawned[i], self.Visible);
            end
        end
    else
        if Logic.IsLeader(eID) == 1 then
            local soldiers = {Logic.GetSoldiersAttachedToLeader(eID)};
            for j=2, #soldiers do
                Logic.SetVisible(soldiers[j], self.Visible);
            end
        else
            Logic.SetVisible(eID, self.Visible);
        end
    end
end

function b_Reprisal_SetVisible:GetCustomData(_Index)
    if _Index == 1 then
        return { "true", "false" }
    end
end

function b_Reprisal_SetVisible:Debug(_Quest)
    if not IsExisting(self.Entity) then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": entity '"..  self.Entity .. "' does not exist!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Reprisal_SetVisible);

-- -------------------------------------------------------------------------- --

---
-- Macht das Entity verwundbar oder unverwundbar.
--
-- Bei einem Battalion wirkt sich das Behavior auf alle Soldaten und den
-- (unsichtbaren) Leader aus. Wird das Behavior auf ein Spawner Entity 
-- angewendet, werden die gespawnten Entities genommen.
--
-- @param _ScriptName Skriptname des Entity
-- @param _Vulnerable Verwundbarkeit an/aus
--
-- @within Reprisal
--
function Reprisal_SetVulnerability(...)
    return b_Reprisal_SetVulnerability:new(...);
end

b_Reprisal_SetVulnerability = {
    Name = "Reprisal_SetVulnerability",
    Description = {
        en = "Reprisal: Changes the vulnerability of the entity. If the entity is a spawner the spawned entities will be affected.",
        de = "Vergeltung: Macht eine Entity verwundbar oder unverwundbar. Handelt es sich um einen Spawner, sind die gespawnten Entities betroffen",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Entity",              de = "Entity", },
        { ParameterType.Custom,     en = "Vulnerability",      de = "Verwundbar", },
    },
}

function b_Reprisal_SetVulnerability:GetReprisalTable()
    return { Reprisal.Custom, { self, self.CustomFunction } }
end

function b_Reprisal_SetVulnerability:AddParameter( _Index, _Parameter )
    if (_Index == 0) then
        self.Entity = _Parameter;
    elseif (_Index == 1) then
        self.Vulnerability = AcceptAlternativeBoolean(_Parameter)
    end
end

function b_Reprisal_SetVulnerability:CustomFunction(_Quest)
    if not IsExisting(self.Entity) then
        return;
    end
    local eID = GetID(self.Entity);
    local eType = Logic.GetEntityType(eID);
    local tName = Logic.GetEntityTypeName(eType);
    local EntitiesToCheck = {eID};
    if string.find(tName, "S_") or string.find(tName, "B_NPC_Bandits")
    or string.find(tName, "B_NPC_Barracks") then
        EntitiesToCheck = {Logic.GetSpawnedEntities(eID)};
    end
    local MethodToUse = "MakeInvulnerable";
    if self.Vulnerability then
        MethodToUse = "MakeVulnerable";
    end
    for i= 1, #EntitiesToCheck, 1 do
        if Logic.IsLeader(EntitiesToCheck[i]) == 1 then
            local Soldiers = {Logic.GetSoldiersAttachedToLeader(EntitiesToCheck[i])};
            for j=2, #Soldiers, 1 do
                _G[MethodToUse](Soldiers[j]);
            end
        end
        _G[MethodToUse](EntitiesToCheck[i]);
    end
end

function b_Reprisal_SetVulnerability:GetCustomData(_Index)
    if _Index == 1 then
        return { "true", "false" }
    end
end

function b_Reprisal_SetVulnerability:Debug(_Quest)
    if not IsExisting(self.Entity) then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": entity '"..  self.Entity .. "' does not exist!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Reprisal_SetVulnerability);

-- -------------------------------------------------------------------------- --

---
-- Ändert das Model eines Entity.
--
-- In Verbindung mit Reward_SetVisible oder Reprisal_SetVisible können
-- Script Entites ein neues Model erhalten und sichtbar gemacht werden.
-- Das hat den Vorteil, das Script Entities nicht überbaut werden können.
--
-- @param _ScriptName Skriptname des Entity
-- @param _Model      Neues Model
--
-- @within Reprisal
--
function Reprisal_SetModel(...)
    return b_Reprisal_SetModel:new(...);
end

b_Reprisal_SetModel = {
    Name = "Reprisal_SetModel",
    Description = {
        en = "Reprisal: Changes the model of the entity. Be careful, some models crash the game.",
        de = "Vergeltung: Aendert das Model einer Entity. Achtung: Einige Modelle fuehren zum Absturz.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Entity",     de = "Entity", },
        { ParameterType.Custom,     en = "Model",     de = "Model", },
    },
}

function b_Reprisal_SetModel:GetReprisalTable()
    return { Reprisal.Custom, { self, self.CustomFunction } }
end

function b_Reprisal_SetModel:AddParameter( _Index, _Parameter )
    if (_Index == 0) then
        self.Entity = _Parameter;
    elseif (_Index == 1) then
        self.Model = _Parameter;
    end
end

function b_Reprisal_SetModel:CustomFunction(_Quest)
    if not IsExisting(self.Entity) then
        return;
    end
    local eID = GetID(self.Entity);
    Logic.SetModel(eID, Models[self.Model]);
end

function b_Reprisal_SetModel:GetCustomData(_Index)
    if _Index == 1 then
        local Data = {};
        for k,v in pairs(Models) do
            if  not string.find(k,"Animals_") and not string.find(k,"Banners_") and not string.find(k,"Goods_") and not string.find(k,"goods_")
            and not string.find(k,"Heads_") and not string.find(k,"MissionMap_") and not string.find(k,"R_Fish") and not string.find(k,"Units_")
            and not string.find(k,"XD_") and not string.find(k,"XS_") and not string.find(k,"XT_") and not string.find(k,"Z_") then
                table.insert(Data,k);
            end
        end
        return Data;
    end
end

function b_Reprisal_SetModel:Debug(_Quest)
    if not IsExisting(self.Entity) then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": entity '"..  self.Entity .. "' does not exist!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Reprisal_SetModel);

-- -------------------------------------------------------------------------- --
-- Rewards                                                                    --
-- -------------------------------------------------------------------------- --

---
-- Ändert die Position eines Siedlers oder eines Gebäudes.
--
-- Optional kann das Entity in einem bestimmten Abstand zum Ziel platziert
-- werden und das Ziel anschauen. Die Entfernung darf nicht kleiner sein
-- als 50!
--
-- @param _ScriptName Skriptname des Entity
-- @param _Target     Skriptname des Ziels
-- @param _LookAt     Gegenüberstellen
-- @param _Distance   Relative Entfernung (nur mit _LookAt)
--
-- @within Reward
--
function Reward_SetPosition(...)
    return b_Reward_SetPosition:new(...);
end

b_Reward_SetPosition = API.InstanceTable(b_Reprisal_SetPosition);
b_Reward_SetPosition.Name = "Reward_SetPosition";
b_Reward_SetPosition.Description.en = "Reward: Places an entity relative to the position of another. The entity can look the target.";
b_Reward_SetPosition.Description.de = "Lohn: Setzt eine Entity relativ zur Position einer anderen. Die Entity kann zum Ziel ausgerichtet werden.";
b_Reward_SetPosition.GetReprisalTable = nil;

b_Reward_SetPosition.GetRewardTable = function(self, _Quest)
    return { Reward.Custom, { self, self.CustomFunction } };
end

Core:RegisterBehavior(b_Reward_SetPosition);

-- -------------------------------------------------------------------------- --

---
-- Ändert den Eigentümer des Entity oder des Battalions.
--
-- @param _ScriptName Skriptname des Entity
-- @param _NewOwner   PlayerID des Eigentümers
--
-- @within Reward
--
function Reward_ChangePlayer(...)
    return b_Reward_ChangePlayer:new(...);
end

b_Reward_ChangePlayer = API.InstanceTable(b_Reprisal_ChangePlayer);
b_Reward_ChangePlayer.Name = "Reward_ChangePlayer";
b_Reward_ChangePlayer.Description.en = "Reward: Changes the owner of the entity or a battalion.";
b_Reward_ChangePlayer.Description.de = "Lohn: Aendert den Besitzer einer Entity oder eines Battalions.";
b_Reward_ChangePlayer.GetReprisalTable = nil;

b_Reward_ChangePlayer.GetRewardTable = function(self, _Quest)
    return { Reward.Custom, { self, self.CustomFunction } };
end

Core:RegisterBehavior(b_Reward_ChangePlayer);

-- -------------------------------------------------------------------------- --

---
-- Bewegt einen Siedler relativ zu einem Zielpunkt.
--
-- Der Siedler wird sich zum Ziel ausrichten und in der angegeben Distanz
-- und dem angegebenen Winkel Position beziehen.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Hinweis:&#x3C;/b&#x3E; Funktioniert ähnlich wie MoveEntityToPositionToAnotherOne.
-- &#x3C;/p&#x3E;
--
-- @param _ScriptName  Skriptname des Entity
-- @param _Destination Skriptname des Ziels
-- @param _Distance    Entfernung
-- @param _Angle       Winkel
--
-- @within Reward
--
function Reward_MoveToPosition(...)
    return b_Reward_MoveToPosition:new(...);
end

b_Reward_MoveToPosition = {
    Name = "Reward_MoveToPosition",
    Description = {
        en = "Reward: Moves an entity relative to another entity. If angle is zero the entities will be standing directly face to face.",
        de = "Lohn: Bewegt eine Entity relativ zur Position einer anderen. Wenn Winkel 0 ist, stehen sich die Entities direkt gegen�ber.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Settler", de = "Siedler" },
        { ParameterType.ScriptName, en = "Destination", de = "Ziel" },
        { ParameterType.Number,     en = "Distance", de = "Entfernung" },
        { ParameterType.Number,     en = "Angle", de = "Winkel" },
    },
}

function b_Reward_MoveToPosition:GetRewardTable()
    return { Reward.Custom, {self, self.CustomFunction} }
end

function b_Reward_MoveToPosition:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Entity = _Parameter;
    elseif (_Index == 1) then
        self.Target = _Parameter;
    elseif (_Index == 2) then
        self.Distance = _Parameter * 1;
    elseif (_Index == 3) then
        self.Angle = _Parameter * 1;
    end
end

function b_Reward_MoveToPosition:CustomFunction(_Quest)
    if not IsExisting(self.Entity) or not IsExisting(self.Target) then
        return;
    end
    self.Angle = self.Angle or 0;

    local entity = GetID(self.Entity);
    local target = GetID(self.Target);
    local orientation = Logic.GetEntityOrientation(target);
    local x,y,z = Logic.EntityGetPos(target);
    if Logic.IsBuilding(target) == 1 then
        x, y = Logic.GetBuildingApproachPosition(target);
        orientation = orientation -90;
    end
    x = x + self.Distance * math.cos( math.rad(orientation+self.Angle) );
    y = y + self.Distance * math.sin( math.rad(orientation+self.Angle) );
    Logic.MoveSettler(entity, x, y);
    StartSimpleJobEx( function(_entityID, _targetID)
        if Logic.IsEntityMoving(_entityID) == false then
            LookAt(_entityID, _targetID);
            return true;
        end
    end, entity, target);
end

function b_Reward_MoveToPosition:Debug(_Quest)
    if tonumber(self.Distance) == nil or self.Distance &#x3C; 50 then
        fatal(_Quest.Identifier.. " " ..self.Name.. ": Distance is nil or to short!");
        return true;
    elseif not IsExisting(self.Entity) or not IsExisting(self.Target) then
        fatal(_Quest.Identifier.. " " ..self.Name.. ": Mover entity or target entity does not exist!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Reward_MoveToPosition);

-- -------------------------------------------------------------------------- --

---
-- Der Spieler gewinnt das Spiel mit einem animierten Siegesfest.
--
-- Es ist nicht möglich weiterzuspielen!
--
-- @within Reward
--
function Reward_VictoryWithParty()
    return b_Reward_VictoryWithParty:new();
end

b_Reward_VictoryWithParty = {
    Name = "Reward_VictoryWithParty",
    Description = {
        en = "Reward: The player wins the game with an animated festival on the market.",
        de = "Lohn: Der Spieler gewinnt das Spiel mit einer animierten Siegesfeier.",
    },
    Parameter =    {}
};

function b_Reward_VictoryWithParty:GetRewardTable()
    return {Reward.Custom, {self, self.CustomFunction}};
end

function b_Reward_VictoryWithParty:AddParameter(_Index, _Parameter)
end

function b_Reward_VictoryWithParty:CustomFunction(_Quest)
    Victory(g_VictoryAndDefeatType.VictoryMissionComplete);
    local pID = _Quest.ReceivingPlayer;

    local market = Logic.GetMarketplace(pID);
    if IsExisting(market) then
        local pos = GetPosition(market)
        Logic.CreateEffect(EGL_Effects.FXFireworks01,pos.X,pos.Y,0);
        Logic.CreateEffect(EGL_Effects.FXFireworks02,pos.X,pos.Y,0);

        local PossibleSettlerTypes = {
            Entities.U_SmokeHouseWorker,
            Entities.U_Butcher,
            Entities.U_Carpenter,
            Entities.U_Tanner,
            Entities.U_Blacksmith,
            Entities.U_CandleMaker,
            Entities.U_Baker,
            Entities.U_DairyWorker,

            Entities.U_SpouseS01,
            Entities.U_SpouseS02,
            Entities.U_SpouseS02,
            Entities.U_SpouseS03,
            Entities.U_SpouseF01,
            Entities.U_SpouseF01,
            Entities.U_SpouseF02,
            Entities.U_SpouseF03,
        };
        VictoryGenerateFestivalAtPlayer(pID, PossibleSettlerTypes);

        Logic.ExecuteInLuaLocalState([[
            if IsExisting(]]..market..[[) then
                CameraAnimation.AllowAbort = false
                CameraAnimation.QueueAnimation(CameraAnimation.SetCameraToEntity, ]]..market..[[)
                CameraAnimation.QueueAnimation(CameraAnimation.StartCameraRotation, 5)
                CameraAnimation.QueueAnimation(CameraAnimation.Stay ,9999)
            end
            XGUIEng.ShowWidget("/InGame/InGame/MissionEndScreen/ContinuePlaying", 0);
        ]]);
    end
end

function b_Reward_VictoryWithParty:Debug(_Quest)
    return false;
end

Core:RegisterBehavior(b_Reward_VictoryWithParty)

-- -------------------------------------------------------------------------- --

---
-- Ändert die Sichtbarkeit eines Entity.
--
-- @param _ScriptName Skriptname des Entity
-- @param _Visible    Sichtbarkeit an/aus
--
-- @within Reprisal
--
function Reward_SetVisible(...)
    return b_Reward_SetVisible:new(...)
end

b_Reward_SetVisible = API.InstanceTable(b_Reprisal_SetVisible);
b_Reward_SetVisible.Name = "Reward_SetVisible";
b_Reward_SetVisible.Description.en = "Reward: Changes the visibility of an entity. If the entity is a spawner the spawned entities will be affected.";
b_Reward_SetVisible.Description.de = "Lohn: Setzt die Sichtbarkeit einer Entity. Handelt es sich um einen Spawner werden auch die gespawnten Entities beeinflusst.";
b_Reward_SetVisible.GetReprisalTable = nil;

b_Reward_SetVisible.GetRewardTable = function(self, _Quest)
    return { Reward.Custom, { self, self.CustomFunction } }
end

Core:RegisterBehavior(b_Reward_SetVisible);

-- -------------------------------------------------------------------------- --

---
-- Gibt oder entzieht einem KI-Spieler die Kontrolle über ein Entity.
--
-- @param _ScriptName Skriptname des Entity
-- @param _Controlled Durch KI kontrollieren an/aus
--
-- @within Reward
--
function Reward_AI_SetEntityControlled(...)
    return b_Reward_AI_SetEntityControlled:new(...);
end

b_Reward_AI_SetEntityControlled = {
    Name = "Reward_AI_SetEntityControlled",
    Description = {
        en = "Reward: Bind or Unbind an entity or a battalion to/from an AI player. The AI player must be activated!",
        de = "Lohn: Die KI kontrolliert die Entity oder der KI die Kontrolle entziehen. Die KI muss aktiv sein!",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Entity",               de = "Entity", },
        { ParameterType.Custom,     en = "AI control entity", de = "KI kontrolliert Entity", },
    },
}

function b_Reward_AI_SetEntityControlled:GetRewardTable()
    return { Reward.Custom, { self, self.CustomFunction } }
end

function b_Reward_AI_SetEntityControlled:AddParameter( _Index, _Parameter )
    if (_Index == 0) then
        self.Entity = _Parameter;
    elseif (_Index == 1) then
        self.Hidden = AcceptAlternativeBoolean(_Parameter)
    end
end

function b_Reward_AI_SetEntityControlled:CustomFunction(_Quest)
    if not IsExisting(self.Entity) then
        return;
    end
    local eID = GetID(self.Entity);
    local pID = Logic.EntityGetPlayer(eID);
    local eType = Logic.GetEntityType(eID);
    local tName = Logic.GetEntityTypeName(eType);
    if string.find(tName, "S_") or string.find(tName, "B_NPC_Bandits")
    or string.find(tName, "B_NPC_Barracks") then
        local spawned = {Logic.GetSpawnedEntities(eID)};
        for i=1, #spawned do
            if Logic.IsLeader(spawned[i]) == 1 then
                AICore.HideEntityFromAI(pID, spawned[i], not self.Hidden);
            end
        end
    else
        AICore.HideEntityFromAI(pID, eID, not self.Hidden);
    end
end

function b_Reward_AI_SetEntityControlled:GetCustomData(_Index)
    if _Index == 1 then
        return { "false", "true" }
    end
end

function b_Reward_AI_SetEntityControlled:Debug(_Quest)
    if not IsExisting(self.Entity) then
        fatal(_Quest.Identifier .. " " .. self.Name .. ": entity '"..  self.Entity .. "' does not exist!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Reward_AI_SetEntityControlled);

-- -------------------------------------------------------------------------- --

---
-- Macht das Entity verwundbar oder unverwundbar.
--
-- Bei einem Battalion wirkt sich das Behavior auf alle Soldaten und den
-- (unsichtbaren) Leader aus. Wird das Behavior auf ein Spawner Entity 
-- angewendet, werden die gespawnten Entities genommen.
--
-- @param _ScriptName Skriptname des Entity
-- @param _Vulnerable Verwundbarkeit an/aus
--
-- @within Reward
--
function Reward_SetVulnerability(...)
    return b_Reward_SetVulnerability:new(...);
end

b_Reward_SetVulnerability = API.InstanceTable(b_Reprisal_SetVulnerability);
b_Reward_SetVulnerability.Name = "Reward_SetVulnerability";
b_Reward_SetVulnerability.Description.en = "Reward: Changes the vulnerability of the entity. If the entity is a spawner the spawned entities will be affected.";
b_Reward_SetVulnerability.Description.de = "Lohn: Macht eine Entity verwundbar oder unverwundbar. Handelt es sich um einen Spawner, sind die gespawnten Entities betroffen.";
b_Reward_SetVulnerability.GetReprisalTable = nil;

b_Reward_SetVulnerability.GetRewardTable = function(self, _Quest)
    return { Reward.Custom, { self, self.CustomFunction } }
end

Core:RegisterBehavior(b_Reward_SetVulnerability);

-- -------------------------------------------------------------------------- --

---
-- Ändert das Model eines Entity.
--
-- In Verbindung mit Reward_SetVisible oder Reprisal_SetVisible können
-- Script Entites ein neues Model erhalten und sichtbar gemacht werden.
-- Das hat den Vorteil, das Script Entities nicht überbaut werden können.
--
-- @param _ScriptName Skriptname des Entity
-- @param _Model      Neues Model
--
-- @within Reward
--
function Reward_SetModel(...)
    return b_Reward_SetModel:new(...);
end

b_Reward_SetModel = API.InstanceTable(b_Reprisal_SetModel);
b_Reward_SetModel.Name = "Reward_SetModel";
b_Reward_SetModel.Description.en = "Reward: Changes the model of the entity. Be careful, some models crash the game.";
b_Reward_SetModel.Description.de = "Lohn: Aendert das Model einer Entity. Achtung: Einige Modelle fuehren zum Absturz.";
b_Reward_SetModel.GetReprisalTable = nil;

b_Reward_SetModel.GetRewardTable = function(self, _Quest)
    return { Reward.Custom, { self, self.CustomFunction } }
end

Core:RegisterBehavior(b_Reward_SetModel);

-- -------------------------------------------------------------------------- --

---
-- Füllt die Munition in der Kriegsmaschine vollständig auf.
--
-- @param _ScriptName Skriptname des Entity
--
-- @within Reward
--
function Reward_RefillAmmunition(...)
    return b_Reward_RefillAmmunition:new(...);
end

b_Reward_RefillAmmunition = {
    Name = "Reward_RefillAmmunition",
    Description = {
        en = "Reward: Refills completely the ammunition of the entity.",
        de = "Lohn: Fuellt die Munition der Entity vollständig auf.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script name", de = "Skriptname" },
    },
}

function b_Reward_RefillAmmunition:GetRewardTable()
    return { Reward.Custom, {self, self.CustomFunction} }
end

function b_Reward_RefillAmmunition:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Scriptname = _Parameter
    end
end

function b_Reward_RefillAmmunition:CustomFunction()
    local EntityID = GetID(self.Scriptname);
    if not IsExisting(EntityID) then
        return;
    end

    local Ammunition = Logic.GetAmmunitionAmount(EntityID);
    while (Ammunition &#x3C; 10)
    do
        Logic.RefillAmmunitions(EntityID);
        Ammunition = Logic.GetAmmunitionAmount(EntityID);
    end
end

function b_Reward_RefillAmmunition:Debug(_Quest)
    if not IsExisting(self.Scriptname) then
        fatal(_Quest.Identifier .. ": Error in " .. self.Name .. ": '"..self.Scriptname.."' is destroyed!");
        return true
    end
    return false;
end

Core:RegisterBehavior(b_Reward_RefillAmmunition)

-- -------------------------------------------------------------------------- --
-- Trigger                                                                    --
-- -------------------------------------------------------------------------- --

---
-- Startet den Quest, sobald mindestens X von Y Quests fehlgeschlagen sind.
--
-- @param _MinAmount Mindestens zu verlieren (max. 5)
-- @param _QuestAmount Anzahl geprüfter Quests (max. 5 und &#x3E;= _MinAmount)
-- @param _Quest1      Name des 1. Quest
-- @param _Quest2      Name des 2. Quest
-- @param _Quest3      Name des 3. Quest
-- @param _Quest4      Name des 4. Quest
-- @param _Quest5      Name des 5. Quest
--
-- @within Trigger
--
function Trigger_OnAtLeastXOfYQuestsFailed(...)
    return b_Trigger_OnAtLeastXOfYQuestsFailed:new(...);
end

b_Trigger_OnAtLeastXOfYQuestsFailed = {
    Name = "Trigger_OnAtLeastXOfYQuestsFailed",
    Description = {
        en = "Trigger: if at least X of Y given quests has been finished successfully.",
        de = "Ausloeser: wenn X von Y angegebener Quests fehlgeschlagen sind.",
    },
    Parameter = {
        { ParameterType.Custom, en = "Least Amount", de = "Mindest Anzahl" },
        { ParameterType.Custom, en = "Quest Amount", de = "Quest Anzahl" },
        { ParameterType.QuestName, en = "Quest name 1", de = "Questname 1" },
        { ParameterType.QuestName, en = "Quest name 2", de = "Questname 2" },
        { ParameterType.QuestName, en = "Quest name 3", de = "Questname 3" },
        { ParameterType.QuestName, en = "Quest name 4", de = "Questname 4" },
        { ParameterType.QuestName, en = "Quest name 5", de = "Questname 5" },
    },
}

function b_Trigger_OnAtLeastXOfYQuestsFailed:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function b_Trigger_OnAtLeastXOfYQuestsFailed:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.LeastAmount = tonumber(_Parameter)
    elseif (_Index == 1) then
        self.QuestAmount = tonumber(_Parameter)
    elseif (_Index == 2) then
        self.QuestName1 = _Parameter
    elseif (_Index == 3) then
        self.QuestName2 = _Parameter
    elseif (_Index == 4) then
        self.QuestName3 = _Parameter
    elseif (_Index == 5) then
        self.QuestName4 = _Parameter
    elseif (_Index == 6) then
        self.QuestName5 = _Parameter
    end
end

function b_Trigger_OnAtLeastXOfYQuestsFailed:CustomFunction()
    local least = 0
    for i = 1, self.QuestAmount do
		local QuestID = GetQuestID(self["QuestName"..i]);
        if IsValidQuest(QuestID) then
			if (Quests[QuestID].Result == QuestResult.Failure) then
				least = least + 1
				if least &#x3E;= self.LeastAmount then
					return true
				end
			end
        end
    end
    return false
end

function b_Trigger_OnAtLeastXOfYQuestsFailed:Debug(_Quest)
    local leastAmount = self.LeastAmount
    local questAmount = self.QuestAmount
    if leastAmount &#x3C;= 0 or leastAmount &#x3E;5 then
        fatal(_Quest.Identifier .. ": Error in " .. self.Name .. ": LeastAmount is wrong")
        return true
    elseif questAmount &#x3C;= 0 or questAmount &#x3E; 5 then
        fatal(_Quest.Identifier .. ": Error in " .. self.Name .. ": QuestAmount is wrong")
        return true
    elseif leastAmount &#x3E; questAmount then
        fatal(_Quest.Identifier .. ": Error in " .. self.Name .. ": LeastAmount is greater than QuestAmount")
        return true
    end
    for i = 1, questAmount do
        if not IsValidQuest(self["QuestName"..i]) then
            fatal(_Quest.Identifier .. ": Error in " .. self.Name .. ": Quest ".. self["QuestName"..i] .. " not found")
            return true
        end
    end
    return false
end

function b_Trigger_OnAtLeastXOfYQuestsFailed:GetCustomData(_Index)
    if (_Index == 0) or (_Index == 1) then
        return {"1", "2", "3", "4", "5"}
    end
end

Core:RegisterBehavior(b_Trigger_OnAtLeastXOfYQuestsFailed)

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest, sobald die Munition in der Kriegsmaschine erschöpft ist.
--
-- @param _ScriptName Skriptname des Entity
--
-- @within Trigger
--
function Trigger_AmmunitionDepleted(...)
    return b_Trigger_AmmunitionDepleted:new(...);
end

b_Trigger_AmmunitionDepleted = {
    Name = "Trigger_AmmunitionDepleted",
    Description = {
        en = "Trigger: if the ammunition of the entity is depleted.",
        de = "Ausloeser: wenn die Munition der Entity aufgebraucht ist.",
    },
    Parameter = {
        { ParameterType.Scriptname, en = "Script name", de = "Skriptname" },
    },
}

function b_Trigger_AmmunitionDepleted:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function b_Trigger_AmmunitionDepleted:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Scriptname = _Parameter
    end
end

function b_Trigger_AmmunitionDepleted:CustomFunction()
    if not IsExisting(self.Scriptname) then
        return false;
    end

    local EntityID = GetID(self.Scriptname);
    if Logic.GetAmmunitionAmount(EntityID) &#x3E; 0 then
        return false;
    end

    return true;
end

function b_Trigger_AmmunitionDepleted:Debug(_Quest)
    if not IsExisting(self.Scriptname) then
        fatal(_Quest.Identifier .. ": Error in " .. self.Name .. ": '"..self.Scriptname.."' is destroyed!");
        return true
    end
    return false
end

Core:RegisterBehavior(b_Trigger_AmmunitionDepleted)

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest, wenn exakt einer von beiden Quests erfolgreich ist.
--
-- @param _QuestName1 Name des ersten Quest
-- @param _QuestName2 Name des zweiten Quest
--
-- @within Trigger
--
function Trigger_OnExactOneQuestIsWon(...)
    return b_Trigger_OnExactOneQuestIsWon:new(...);
end

b_Trigger_OnExactOneQuestIsWon = {
    Name = "Trigger_OnExactOneQuestIsWon",
    Description = {
        en = "Trigger: if one of two given quests has been finished successfully, but NOT both.",
        de = "Ausloeser: wenn eine von zwei angegebenen Quests (aber NICHT beide) erfolgreich abgeschlossen wurde.",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest Name 1", de = "Questname 1" },
        { ParameterType.QuestName, en = "Quest Name 2", de = "Questname 2" },
    },
}

function b_Trigger_OnExactOneQuestIsWon:GetTriggerTable()
    return {Triggers.Custom2, {self, self.CustomFunction}};
end

function b_Trigger_OnExactOneQuestIsWon:AddParameter(_Index, _Parameter)
    self.QuestTable = {};

    if (_Index == 0) then
        self.Quest1 = _Parameter;
    elseif (_Index == 1) then
        self.Quest2 = _Parameter;
    end
end

function b_Trigger_OnExactOneQuestIsWon:CustomFunction(_Quest)
    local Quest1 = Quests[GetQuestID(self.Quest1)];
    local Quest2 = Quests[GetQuestID(self.Quest2)];
    if Quest2 and Quest1 then
        local Quest1Succeed = (Quest1.State == QuestState.Over and Quest1.Result == QuestResult.Success);
        local Quest2Succeed = (Quest2.State == QuestState.Over and Quest2.Result == QuestResult.Success);
        if (Quest1Succeed and not Quest2Succeed) or (not Quest1Succeed and Quest2Succeed) then
            return true;
        end
    end
    return false;
end

function b_Trigger_OnExactOneQuestIsWon:Debug(_Quest)
    if self.Quest1 == self.Quest2 then
        fatal(_Quest.Identifier..": "..self.Name..": Both quests are identical!");
        return true;
    elseif not IsValidQuest(self.Quest1) then
        fatal(_Quest.Identifier..": "..self.Name..": Quest '"..self.Quest1.."' does not exist!");
        return true;
    elseif not IsValidQuest(self.Quest2) then
        fatal(_Quest.Identifier..": "..self.Name..": Quest '"..self.Quest2.."' does not exist!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Trigger_OnExactOneQuestIsWon);

-- -------------------------------------------------------------------------- --

---
-- Startet den Quest, wenn exakt einer von beiden Quests fehlgeschlagen ist.
--
-- @param _QuestName1 Name des ersten Quest
-- @param _QuestName2 Name des zweiten Quest
--
-- @within Trigger
--
function Trigger_OnExactOneQuestIsLost(...)
    return b_Trigger_OnExactOneQuestIsLost:new(...);
end

b_Trigger_OnExactOneQuestIsLost = {
    Name = "Trigger_OnExactOneQuestIsLost",
    Description = {
        en = "Trigger: If one of two given quests has been lost, but NOT both.",
        de = "Ausloeser: Wenn einer von zwei angegebenen Quests (aber NICHT beide) fehlschlägt.",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest Name 1", de = "Questname 1" },
        { ParameterType.QuestName, en = "Quest Name 2", de = "Questname 2" },
    },
}

function b_Trigger_OnExactOneQuestIsLost:GetTriggerTable()
    return {Triggers.Custom2, {self, self.CustomFunction}};
end

function b_Trigger_OnExactOneQuestIsLost:AddParameter(_Index, _Parameter)
    self.QuestTable = {};

    if (_Index == 0) then
        self.Quest1 = _Parameter;
    elseif (_Index == 1) then
        self.Quest2 = _Parameter;
    end
end

function b_Trigger_OnExactOneQuestIsLost:CustomFunction(_Quest)
    local Quest1 = Quests[GetQuestID(self.Quest1)];
    local Quest2 = Quests[GetQuestID(self.Quest2)];
    if Quest2 and Quest1 then
        local Quest1Succeed = (Quest1.State == QuestState.Over and Quest1.Result == QuestResult.Failure);
        local Quest2Succeed = (Quest2.State == QuestState.Over and Quest2.Result == QuestResult.Failure);
        if (Quest1Succeed and not Quest2Succeed) or (not Quest1Succeed and Quest2Succeed) then
            return true;
        end
    end
    return false;
end

function b_Trigger_OnExactOneQuestIsLost:Debug(_Quest)
    if self.Quest1 == self.Quest2 then
        fatal(_Quest.Identifier..": "..self.Name..": Both quests are identical!");
        return true;
    elseif not IsValidQuest(self.Quest1) then
        fatal(_Quest.Identifier..": "..self.Name..": Quest '"..self.Quest1.."' does not exist!");
        return true;
    elseif not IsValidQuest(self.Quest2) then
        fatal(_Quest.Identifier..": "..self.Name..": Quest '"..self.Quest2.."' does not exist!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Trigger_OnExactOneQuestIsLost);

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

BundleSymfoniaBehaviors = {
    Global = {},
    Local = {}
};

-- Global Script ---------------------------------------------------------------

---
-- Initialisiert das Bundle im globalen Skript.
-- @within Internal
-- @local
--
function BundleSymfoniaBehaviors.Global:Install()
    --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    -- Theif observation
    --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    GameCallback_OnThiefDeliverEarnings_Orig_QSB_SymfoniaBehaviors = GameCallback_OnThiefDeliverEarnings;
    GameCallback_OnThiefDeliverEarnings = function(_ThiefPlayerID, _ThiefID, _BuildingID, _GoodAmount)
        GameCallback_OnThiefDeliverEarnings_Orig_QSB_SymfoniaBehaviors(_ThiefPlayerID, _ThiefID, _BuildingID, _GoodAmount);

        for i=1, Quests[0] do
            if Quests[i] and Quests[i].State == QuestState.Active then
                for j=1, Quests[i].Objectives[0] do
                    if Quests[i].Objectives[j].Type == Objective.Custom2 then
                        if Quests[i].Objectives[j].Data[1].Name == "Goal_StealBuilding" then
                            local found;
                            for k=1, #Quests[i].Objectives[j].Data[1].RobberList do
                                local stohlen = Quests[i].Objectives[j].Data[1].RobberList[k];
                                if stohlen[1] == GetID(Quests[i].Objectives[j].Data[1].Building) and stohlen[2] == _ThiefID then
                                    found = true;
                                    break;
                                end
                            end
                            if found then
                                Quests[i].Objectives[j].Data[1].SuccessfullyStohlen = true;
                            end

                        elseif Quests[i].Objectives[j].Data[1].Name == "Goal_StealGold" then
                            local CurrentObjective = Quests[i].Objectives[j].Data[1];
                            local TargetPlayerID = Logic.EntityGetPlayer(_BuildingID);

                            if CurrentObjective.Target ~= -1 and CurrentObjective.Target ~= TargetPlayerID then
                                return;
                            end
                            Quests[i].Objectives[j].Data[1].StohlenGold = Quests[i].Objectives[j].Data[1].StohlenGold + _GoodAmount;
                            if CurrentObjective.Printout then
                                local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";
                                local msg  = {de = "Talern gestohlen",en = "gold stolen",};
                                local curr = CurrentObjective.StohlenGold;
                                local need = CurrentObjective.Amount;
                                API.Note(string.format("d/d s", curr, need, msg[lang]));
                            end
                        end
                    end
                end
            end
        end
    end

    GameCallback_OnThiefStealBuilding_Orig_QSB_SymfoniaBehaviors = GameCallback_OnThiefStealBuilding;
    GameCallback_OnThiefStealBuilding = function(_ThiefID, _ThiefPlayerID, _BuildingID, _BuildingPlayerID)
        GameCallback_OnThiefStealBuilding_Orig_QSB_SymfoniaBehaviors(_ThiefID, _ThiefPlayerID, _BuildingID, _BuildingPlayerID);

        for i=1, Quests[0] do
            if Quests[i] and Quests[i].State == QuestState.Active then
                for j=1, Quests[i].Objectives[0] do
                    if Quests[i].Objectives[j].Type == Objective.Custom2 then
                        if Quests[i].Objectives[j].Data[1].Name == "Goal_SpyBuilding" then
                            if  GetID(Quests[i].Objectives[j].Data[1].Building) == _BuildingID and Quests[i].ReceivingPlayer == _ThiefPlayerID then
                                Quests[i].Objectives[j].Data[1].Infiltrated = true;
                                if Quests[i].Objectives[j].Data[1].Delete then
                                    DestroyEntity(_ThiefID);
                                end
                            end

                        elseif Quests[i].Objectives[j].Data[1].Name == "Goal_StealBuilding" then
                            local found;
                            local isCathedral = Logic.IsEntityInCategory(_BuildingID, EntityCategories.Cathedrals) == 1;
                            local isWarehouse = Logic.GetEntityType(_BuildingID) == Entities.B_StoreHouse;
                            if isWarehouse or isCathedral then
                                Quests[i].Objectives[j].Data[1].SuccessfullyStohlen = true;
                            else
                                for k=1, #Quests[i].Objectives[j].Data[1].RobberList do
                                    local stohlen = Quests[i].Objectives[j].Data[1].RobberList[k];
                                    if stohlen[1] == _BuildingID and stohlen[2] == _ThiefID then
                                        found = true;
                                        break;
                                    end
                                end
                            end
                            if not found then
                                table.insert(Quests[i].Objectives[j].Data[1].RobberList, {_BuildingID, _ThiefID});
                            end
                        end
                    end
                end
            end
        end
    end

    --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    -- Objectives
    --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    QuestTemplate.IsObjectiveCompleted_Orig_QSB_SymfoniaBehaviors = QuestTemplate.IsObjectiveCompleted;
    QuestTemplate.IsObjectiveCompleted = function(self, objective)
        local objectiveType = objective.Type;
        if objective.Completed ~= nil then
            return objective.Completed;
        end

        if objectiveType == Objective.Distance then
            objective.Completed = BundleSymfoniaBehaviors.Global:IsQuestPositionReached(self, objective);
        elseif objectiveType == Objective.DestroyEntities then
            if objective.Data[1] == 3 then
                objective.Completed = BundleSymfoniaBehaviors.Global:AreQuestEntitiesDestroyed(self, objective);
            else
                return self:IsObjectiveCompleted_Orig_QSB_SymfoniaBehaviors(objective);
            end
        else
            return self:IsObjectiveCompleted_Orig_QSB_SymfoniaBehaviors(objective);
        end
    end

    --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    -- Questmarkers
    --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    function QuestTemplate:RemoveQuestMarkers()
        for i=1, self.Objectives[0] do
            if self.Objectives[i].Type == Objective.Distance then
                if self.Objectives[i].Data[4] then
                    DestroyQuestMarker(self.Objectives[i].Data[2]);
                end
            end
        end
    end

    function QuestTemplate:ShowQuestMarkers()
        for i=1, self.Objectives[0] do
            if self.Objectives[i].Type == Objective.Distance then
                if self.Objectives[i].Data[4] then
                    ShowQuestMarker(self.Objectives[i].Data[2]);
                end
            end
        end
    end

    function ShowQuestMarker(_Entity)
        local eID = GetID(_Entity);
        local x,y = Logic.GetEntityPosition(eID);
        local Marker = EGL_Effects.E_Questmarker_low;
        if Logic.IsBuilding(eID) == 1 then
            Marker = EGL_Effects.E_Questmarker;
        end
        Questmarkers[eID] = Logic.CreateEffect(Marker, x,y,0);
    end

    function DestroyQuestMarker(_Entity)
        local eID = GetID(_Entity);
        if Questmarkers[eID] ~= nil then
            Logic.DestroyEffect(Questmarkers[eID]);
            Questmarkers[eID] = nil;
        end
    end
end

---
-- Prüft, ob das Entity das Ziel erreicht hat.
-- @param[type=table] _Quest     Quest Data
-- @param[type=table] _Objective Behavior Data
-- @return[type=boolean] Ziel wurde erreicht
-- @within Internal
-- @local
--
function BundleSymfoniaBehaviors.Global:IsQuestPositionReached(_Quest, _Objective)
    local IDdata2 = GetID(_Objective.Data[1]);
    local IDdata3 = GetID(_Objective.Data[2]);
    _Objective.Data[3] = _Objective.Data[3] or 2500;
    if not (Logic.IsEntityDestroyed(IDdata2) or Logic.IsEntityDestroyed(IDdata3)) then
        if Logic.GetDistanceBetweenEntities(IDdata2,IDdata3) &#x3C;= _Objective.Data[3] then
            DestroyQuestMarker(IDdata3);
            return true;
        end
    else
        DestroyQuestMarker(IDdata3);
        return false;
    end
end

---
-- Prüft, ob alle gespawnten Entities zerstört wurden.
-- @param[type=table] _Quest     Quest Data
-- @param[type=table] _Objective Behavior Data
-- @return[type=boolean] Resultat des Behavior
-- @within Internal
-- @local
--
function BundleSymfoniaBehaviors.Global:AreQuestEntitiesDestroyed(_Quest, _Objective)
    if _Objective.Data[1] == 3 then
        -- Initial wird die Anzahl an Entities sichergestellt.
        if not _Objective.Data[4] then
            local FirstEntityID;
            local SpawnAmount = _Objective.Data[3];
            for k, v in pairs(_Objective.Data[2]) do
                local EntityID        = GetID(v);
                local SpawnedEntities = {Logic.GetSpawnedEntities(EntityID)};
                if #SpawnedEntities &#x3C; SpawnAmount then
                    repeat
                        Logic.RespawnResourceEntity_Spawn(EntityID);
                        SpawnedEntities = {Logic.GetSpawnedEntities(EntityID)};
                    until (#SpawnedEntities == SpawnAmount);
                elseif #SpawnedEntities &#x3E; SpawnAmount then
                    repeat
                        DestroyEntity(SpawnedEntities[1]);
                        SpawnedEntities = {Logic.GetSpawnedEntities(EntityID)};
                    until (#SpawnedEntities == SpawnAmount);
                end
                if not FirstEntityID then
                    FirstEntityID = SpawnedEntities[1];
                end
            end
            -- Icon setzen
            if not _Objective.Data[5] then
                _Objective.Data[5] = {7, 12};
                if Logic.IsEntityInCategory(FirstEntityID, EntityCategories.AttackableAnimal) == 1 then
                    _Objective.Data[5] = {13, 8};
                end
            end
            _Objective.Data[4] = true;
        end

        -- Gibt es keine gespawnten Entities mehr, ist das Ziel erreicht.
        local AllSpawnedEntities = {};
        for k, v in pairs(_Objective.Data[2]) do
            AllSpawnedEntities = Array_Append(AllSpawnedEntities, {Logic.GetSpawnedEntities(v)});
        end
        if #AllSpawnedEntities == 0 then
            return true;
        end
    end
end

-- Local Script ----------------------------------------------------------------

---
-- Initialisiert das Bundle im lokalen Skript.
-- @within Internal
-- @local
--
function BundleSymfoniaBehaviors.Local:Install()
    Core:StackFunction("GUI_Interaction.GetEntitiesOrTerritoryListForQuest", self.GetEntitiesOrTerritoryList);
    Core:StackFunction("GUI_Interaction.SaveQuestEntityTypes", self.SaveQuestEntityTypes);
    Core:StackFunction("GUI_Interaction.DisplayQuestObjective", self.DisplayQuestObjective);
end

---
-- Erweitert die Funktion, welche das Auftragsziel darstellt. Das richtige
-- Icon für Spawned Entities wird angezeigt.
-- @within Internal
-- @local
--
function BundleSymfoniaBehaviors.Local.DisplayQuestObjective(_QuestIndex, _MessageKey)
    local QuestIndexTemp = tonumber(_QuestIndex);
    if QuestIndexTemp then
        _QuestIndex = QuestIndexTemp;
    end
    local Quest, QuestType = GUI_Interaction.GetPotentialSubQuestAndType(_QuestIndex);
    local QuestObjectivesPath = "/InGame/Root/Normal/AlignBottomLeft/Message/QuestObjectives";
    XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomLeft/Message/QuestObjectives", 0);
    if QuestType == Objective.DestroyEntities and Quest.Objectives[1].Data[1] == 3 then
        local QuestObjectiveContainer = QuestObjectivesPath .. "/GroupEntityType";
        local QuestTypeCaption = Wrapped_GetStringTableText(_QuestIndex, "UI_Texts/QuestDestroy");
        local EntitiesList = GUI_Interaction.GetEntitiesOrTerritoryListForQuest( Quest, QuestType );
        local EntitiesAmount = #EntitiesList;
        if not Quest.Objectives[1].Data[4] and #EntitiesList == 0 then
            EntitiesAmount = #Quest.Objectives[1].Data[2] * Quest.Objectives[1].Data[3];
        end

        XGUIEng.ShowWidget(QuestObjectiveContainer .. "/AdditionalCaption", 0);
        XGUIEng.ShowWidget(QuestObjectiveContainer .. "/AdditionalCondition", 0);
        SetIcon(QuestObjectiveContainer .. "/Icon", Quest.Objectives[1].Data[5]);
        XGUIEng.SetText(QuestObjectiveContainer .. "/Number", "{center}" .. EntitiesAmount);

        XGUIEng.SetText(QuestObjectiveContainer .. "/Caption", "{center}" .. QuestTypeCaption);
        XGUIEng.ShowWidget(QuestObjectiveContainer, 1);
        GUI_Interaction.SetQuestTypeIcon(QuestObjectiveContainer .. "/QuestTypeIcon", _QuestIndex);
        if Quest.State == QuestState.Over then
            if Quest.Result == QuestResult.Success then
                XGUIEng.ShowWidget(QuestObjectivesPath .. "/QuestOverSuccess", 1);
            elseif Quest.Result == QuestResult.Failure then
                XGUIEng.ShowWidget(QuestObjectivesPath .. "/QuestOverFailure", 1);
            end
        end
        return true;
    end

    --end if dummy quest
    if QuestObjectiveContainer == nil then
        return
    end
end

---
-- Erweitert die Funktion zur Ermittlung der Sprungziele für die Lupe.
-- Alle gespawnten Entities werden durch die Lupe angezeigt.
-- @param[type=table]  _Quest     Quest Table
-- @param[type=number] _QuestType Typ des Quest
-- @within Internal
-- @local
--
function BundleSymfoniaBehaviors.Local.GetEntitiesOrTerritoryList(_Quest, _QuestType)
    local IsEntity = true;
    local EntityOrTerritoryList = {};
    if _QuestType == Objective.DestroyEntities then
        if _Quest.Objectives[1].Data and _Quest.Objectives[1].Data[1] == 3 then
            for k, v in pairs(_Quest.Objectives[1].Data[2]) do
                EntityOrTerritoryList = Array_Append(EntityOrTerritoryList, {Logic.GetSpawnedEntities(GetID(v))});
            end
            return EntityOrTerritoryList, IsEntity;
        end
    end
end

---
-- Erweitert die Funktion zur Speicherung der Quest Entities. Es wird der
-- neue Typ 3 für Objective.DestroyEntities implementiert.
-- @param[type=number] _QuestIndex Index des Quest
-- @within Internal
-- @local
--
function BundleSymfoniaBehaviors.Local.SaveQuestEntityTypes(_QuestIndex)
    if g_Interaction.SavedQuestEntityTypes[_QuestIndex] ~= nil then
        return;
    end
    local Quest, QuestType = GUI_Interaction.GetPotentialSubQuestAndType(_QuestIndex);
    local EntitiesList;
    if QuestType ~= Objective.DestroyEntities or Quest.Objectives[1].Data[1] == 2 then
        return;
    end
    EntitiesList = GUI_Interaction.GetEntitiesOrTerritoryListForQuest(Quest, QuestType);
    EntitiesList[0] = #EntitiesList;
    if EntitiesList ~= nil then
        g_Interaction.SavedQuestEntityTypes[_QuestIndex] = {};
        for i = 1, EntitiesList[0], 1 do
            if Logic.IsEntityAlive(EntitiesList[i]) then
                local EntityType = Logic.GetEntityType(GetEntityId(EntitiesList[i]));
                table.insert(g_Interaction.SavedQuestEntityTypes[_QuestIndex], i, EntityType);
            end
        end
        return true;
    end
end

Core:RegisterBundle("BundleSymfoniaBehaviors");

</code></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundlethirdpersoncamera.lua.html">
            <div class='doclink'>
                <div>BundleThirdPersonCamera</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><code>-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundleThirdPersonCamera                                      # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Dieses Bundle bietet einen Kameramodus an, mit dem ein Entity aus der
-- Schulterperspektive verfolgt werden kann.
--
-- &#x3C;a href="#API.ThirdPersonActivate"&#x3E;Schulterblick aktivieren&#x3C;/a&#x3E;&#x3C;br&#x3E;
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundleThirdPersonCamera = {};

API = API or {};
QSB = QSB or {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Aktiviert die Heldenkamera und setzt den verfolgten Helden. Der
-- Held kann 0 sein, dann wird entweder der letzte Held verwendet
-- oder über den GUI-Spieler ermittelt.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; HeroCameraActivate&#x3C;/p&#x3E;
--
-- @param _Hero [string|number] Skriptname/Entity-ID des Helden
-- @param _MaxZoom [number] Maximaler Zoomfaktor
-- @within Anwenderfunktionen
--
function API.ThirdPersonActivate(_Hero, _MaxZoom)
    if GUI then
        local Target = (type(_Hero) == "string" and "'".._Hero.."'") or _Hero;
        API.Bridge("API.ThirdPersonActivate(".. Target ..", ".. _MaxZoom ..")");
        return;
    end
    return BundleThirdPersonCamera.Global:ThirdPersonActivate(_Hero, _MaxZoom);
end
HeroCameraActivate = API.ThirdPersonActivate;

---
-- Deaktiviert die Heldenkamera.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; HeroCameraDeactivate&#x3C;/p&#x3E;
--
-- @within Anwenderfunktionen
--
function API.ThirdPersonDeactivate()
    if GUI then
        API.Bridge("API.ThirdPersonDeactivate()");
        return;
    end
    return BundleThirdPersonCamera.Global:ThirdPersonDeactivate();
end
HeroCameraDeactivate = API.ThirdPersonDeactivate;

---
-- Prüft, ob die Heldenkamera aktiv ist.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; HeroCameraIsRuning&#x3C;/p&#x3E;
--
-- @return [boolean] Kamera aktiv
-- @within Anwenderfunktionen
--
function API.ThirdPersonIsRuning()
    if not GUI then
        return BundleThirdPersonCamera.Global:ThirdPersonIsRuning();
    else
        return BundleThirdPersonCamera.Local:ThirdPersonIsRuning();
    end
end
HeroCameraIsRuning = API.ThirdPersonIsRuning;

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

BundleThirdPersonCamera = {
    Global = {
        Data = {
            ThirdPersonIsActive = false,
        }
    },
    Local = {
        Data = {
            ThirdPersonIsActive = false,
            ThirdPersonLastHero = nil,
            ThirdPersonLastZoom = nil,
        }
    },
}

-- Global Script ---------------------------------------------------------------

---
-- Initalisiert das Bundle im globalen Skript.
--
-- @within Internal
-- @local
--
function BundleThirdPersonCamera.Global:Install()
    API.AddSaveGameAction(BundleThirdPersonCamera.Global.OnSaveGameLoaded);
end

-- -------------------------------------------------------------------------- --

---
-- Aktiviert die Heldenkamera und setzt den verfolgten Helden. Der
-- Held kann 0 sein, dann wird entweder der letzte Held verwendet
-- oder über den GUI-Spieler ermittelt.
--
-- @param _Hero [string|number] Skriptname/Entity-ID des Helden
-- @param _MaxZoom [number] Maximaler Zoomfaktor
-- @within Internal
-- @local
--
function BundleThirdPersonCamera.Global:ThirdPersonActivate(_Hero, _MaxZoom)
    if BriefingSystem then
        BundleThirdPersonCamera.Global:ThirdPersonOverwriteStartAndEndBriefing();
    end

    local Hero = GetID(_Hero);
    BundleThirdPersonCamera.Global.Data.ThirdPersonIsActive = true;
    Logic.ExecuteInLuaLocalState([[
        BundleThirdPersonCamera.Local:ThirdPersonActivate(]]..tostring(Hero)..[[, ]].. tostring(_MaxZoom) ..[[);
    ]]);
end

---
-- Deaktiviert die Heldenkamera.
-- @within Internal
-- @local
--
function BundleThirdPersonCamera.Global:ThirdPersonDeactivate()
    BundleThirdPersonCamera.Global.Data.ThirdPersonIsActive = false;
    Logic.ExecuteInLuaLocalState([[
        BundleThirdPersonCamera.Local:ThirdPersonDeactivate();
    ]]);
end

---
-- Prüft, ob die Heldenkamera aktiv ist.
--
-- @return [boolean] Kamera aktiv
-- @within Internal
-- @local
--
function BundleThirdPersonCamera.Global:ThirdPersonIsRuning()
    return self.Data.ThirdPersonIsActive;
end

---
-- Überschreibt StartBriefing und EndBriefing des Briefing System,
-- wenn es vorhanden ist.
-- @within Internal
-- @local
--
function BundleThirdPersonCamera.Global:ThirdPersonOverwriteStartAndEndBriefing()
    if BriefingSystem then
        if not BriefingSystem.StartBriefing_Orig_HeroCamera then
            BriefingSystem.StartBriefing_Orig_HeroCamera = BriefingSystem.StartBriefing;
            BriefingSystem.StartBriefing = function(_Briefing, _CutsceneMode)
                if BundleThirdPersonCamera.Global:ThirdPersonIsRuning() then
                    BundleThirdPersonCamera.Global:ThirdPersonDeactivate();
                    BundleThirdPersonCamera.Global.Data.ThirdPersonStoppedByCode = true;
                end
                BriefingSystem.StartBriefing_Orig_HeroCamera(_Briefing, _CutsceneMode);
            end
            StartBriefing = BriefingSystem.StartBriefing;
        end

        if not BriefingSystem.EndBriefing_Orig_HeroCamera then
            BriefingSystem.EndBriefing_Orig_HeroCamera = BriefingSystem.EndBriefing;
            BriefingSystem.EndBriefing = function(_Briefing, _CutsceneMode)
                BriefingSystem.EndBriefing_Orig_HeroCamera();
                if BundleThirdPersonCamera.Global.Data.ThirdPersonStoppedByCode then
                    BundleThirdPersonCamera.Global:ThirdPersonActivate(0);
                    BundleThirdPersonCamera.Global.Data.ThirdPersonStoppedByCode = false;
                end
            end
        end
    end
end

-- -------------------------------------------------------------------------- --

---
-- Stellt nicht-persistente Änderungen nach dem laden wieder her.
--
-- @within Internal
-- @local
--
function BundleThirdPersonCamera.Global.OnSaveGameLoaded()
    
end

-- Local Script ----------------------------------------------------------------

---
-- Aktiviert die Heldenkamera und setzt den verfolgten Helden. Der
-- Held kann 0 sein, dann wird entweder der letzte Held verwendet
-- oder über den GUI-Spieler ermittelt.
--
-- @param _Hero [string|number] Skriptname/Entity-ID des Helden
-- @param _MaxZoom [number] Maximaler Zoomfaktor
-- @within Internal
-- @local
--
function BundleThirdPersonCamera.Local:ThirdPersonActivate(_Hero, _MaxZoom)
    _Hero = (_Hero ~= 0 and _Hero) or self.Data.ThirdPersonLastHero or Logic.GetKnightID(GUI.GetPlayerID());
    _MaxZoom = _MaxZoom or self.Data.ThirdPersonLastZoom or 0.5;
    if not _Hero then
        return;
    end

    if not GameCallback_Camera_GetBorderscrollFactor_Orig_HeroCamera then
        self:ThirdPersonOverwriteGetBorderScrollFactor();
    end

    self.Data.ThirdPersonLastHero = _Hero;
    self.Data.ThirdPersonLastZoom = _MaxZoom;
    self.Data.ThirdPersonIsActive = true;

    local Orientation = Logic.GetEntityOrientation(_Hero);
    Camera.RTS_FollowEntity(_Hero);
    Camera.RTS_SetRotationAngle(Orientation-90);
    Camera.RTS_SetZoomFactor(_MaxZoom);
    Camera.RTS_SetZoomFactorMax(_MaxZoom + 0.0001);
end

---
-- Deaktiviert die Heldenkamera.
--
-- @within Internal
-- @local
--
function BundleThirdPersonCamera.Local:ThirdPersonDeactivate()
    self.Data.ThirdPersonIsActive = false;
    Camera.RTS_SetZoomFactorMax(0.5);
    Camera.RTS_SetZoomFactor(0.5);
    Camera.RTS_FollowEntity(0);
end

---
-- Prüft, ob die Heldenkamera aktiv ist.
--
-- @return [boolean] Kamera aktiv
-- @within Internal
-- @local
--
function BundleThirdPersonCamera.Local:ThirdPersonIsRuning()
    return self.Data.ThirdPersonIsActive;
end

---
-- Überschreibt GameCallback_GetBorderScrollFactor und wandelt den
-- Bildlauf am Bildschirmrand in Bildrotation um. Dabei wird die
-- Kamera um links oder rechts gedreht, abhänig von der Position
-- der Mouse.
--
-- @within Internal
-- @local
--
function BundleThirdPersonCamera.Local:ThirdPersonOverwriteGetBorderScrollFactor()
    GameCallback_Camera_GetBorderscrollFactor_Orig_HeroCamera = GameCallback_Camera_GetBorderscrollFactor
    GameCallback_Camera_GetBorderscrollFactor = function()
        if not BundleThirdPersonCamera.Local.Data.ThirdPersonIsActive then
            return GameCallback_Camera_GetBorderscrollFactor_Orig_HeroCamera();
        end

        local CameraRotation = Camera.RTS_GetRotationAngle();
        local xS, yS = GUI.GetScreenSize();
        local xM, yM = GUI.GetMousePosition();
        local xR = xM / xS;

        if xR &#x3C;= 0.02 then
            CameraRotation = CameraRotation + 0.3;
        elseif xR &#x3E;= 0.98 then
            CameraRotation = CameraRotation - 0.3;
        else
            return 0;
        end
        if CameraRotation &#x3E;= 360 then
            CameraRotation = 0;
        end
        Camera.RTS_SetRotationAngle(CameraRotation);
        return 0;
    end
end

-- -------------------------------------------------------------------------- --

Core:RegisterBundle("BundleThirdPersonCamera");

</code></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundletimeline.lua.html">
            <div class='doclink'>
                <div>BundleTimeLine</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><code>-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundleTimeLine                                               # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Dieses Bundle ermöglicht es Aktionen in einer zeitlichen Abfolge zu
-- gliedern.
--
-- Die Bezeichnung "Time Line" (Zeitstrahl) wird z.B. in der Filmindustrie
-- verwendet und beschreibt einen Ablauf von aufeinander folgenden Ereignissen.
-- Diese Ereignisse sind zeitlich gegliedert.
--
-- Du kannst mit der Implementation eines solchen Zeitstrahls Lua-Funktionen
-- im Abstand einer oder mehrerer Sekunden ausführen lassen. Ein solcher
-- Zeitstrahl verfügt über eine ID, mit der er angesprochen werden kann. So
-- kann er abgebrochen, pausiert, fortgesetzt und neu gestartet werden.
--
-- &#x3C;a href="#API.TimeLineStart"&#x3E;Zeitstrahl erstellen&#x3C;/a&#x3E;&#x3C;br&#x3E;Eine Abfolge von
-- Aktionen definieren, die zu gewissen Zeitpunkten ausgelöst werden.
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundleTimeLine = {};

API = API or {};
QSB = QSB or {};

QSB.TimeLine = {
    Data = {
        TimeLineUniqueJobID = 1,
        TimeLineJobs = {},
    }
};

-- -------------------------------------------------------------------------- --
-- TimeLine Klasse                                                            --
-- -------------------------------------------------------------------------- --

---
-- Startet einen Zeitstrahl. Ein Zeitstrahl hat Stationen,
-- an denen eine Aktion ausgeführt wird. Jede Station muss mindestens eine
-- Sekunde nach der vorherigen liegen.
--
-- Jede Aktion eines Zeitstrahls erhält die Table des aktuellen Ereignisses
-- als Argument. So können Parameter an die Funktion übergeben werden.
--
-- @param[type=table] _Description Beschreibung
-- @return[type=number] ID des Zeitstrahls
-- @within Anwenderfunktionen
--
-- @usage MyTimeLine = QSB.TimeLine:Start {
--     {Time = 5, Action = MyFirstAction},
--     -- MySecondAction erhält "BOCKWURST" als Parameter
--     {Time = 15, Action = MySecondAction, "BOCKWURST"},
--     -- Inline-Funktion
--     {Time = 30, Action = function() end},
-- }
--
function QSB.TimeLine:Start(_description)
    local JobID = QSB.TimeLine.Data.TimeLineUniqueJobID;
    QSB.TimeLine.Data.TimeLineUniqueJobID = JobID +1;

    _description.Running = true;
    _description.StartTime = Logic.GetTime();
    _description.Iterator = 1;

    -- Check auf sinnvolle Zeitabstände
    local Last = 0;
    for i=1, #_description, 1 do
        if _description[i].Time &#x3C; Last then
            _description[i].Time = Last+1;
            Last = _description[i].Time;
        end
    end

    QSB.TimeLine.Data.TimeLineJobs[JobID] = _description;
    if not QSB.TimeLine.Data.ControlerID then
        local Controler = StartSimpleJobEx(QSB.TimeLine.TimeLineControler);
        QSB.TimeLine.Data.ControlerID = Controler;
    end
    return JobID;
end
function API.TimeLineStart(_ID)
    return QSB.TimeLine:Start(_ID);
end

---
-- Startet einen Zeitstrahl erneut. Ist der Zeitstrahl noch nicht
-- beendet, beginnt er dennoch von vorn.
--
-- @param[type=number] _ID ID des Zeitstrahl
-- @within Anwenderfunktionen
--
-- @usage QSB.TimeLine:Restart(MyTimeLine);
--
function QSB.TimeLine:Restart(_ID)
    if not QSB.TimeLine.Data.TimeLineJobs[_ID] then
        return;
    end
    QSB.TimeLine.Data.TimeLineJobs[_ID].Running = true;
    QSB.TimeLine.Data.TimeLineJobs[_ID].StartTime = Logic.GetTime();
    QSB.TimeLine.Data.TimeLineJobs[_ID].Iterator = 1;
end
function API.TimeLineRestart(_ID)
    QSB.TimeLine:Restart(_ID);
end

---
-- Prüft, ob der Zeitstrahl noch nicht durchgelaufen ist.
--
-- @param[type=number] _ID ID des Zeitstrahl
-- @return[type=boolean] Zeitstrahl ist aktiv
-- @within Anwenderfunktionen
--
-- @usage local IsRunning = QSB.TimeLine:IsRunning(MyTimeLine);
--
function QSB.TimeLine:IsRunning(_ID)
    if QSB.TimeLine.Data.TimeLineJobs[_ID] then
        return QSB.TimeLine.Data.TimeLineJobs[_ID].Running == true;
    end
    return false;
end
function API.TimeLineIsRunning(_ID)
    QSB.TimeLine:IsRunning(_ID);
end

---
-- Hält einen Zeitstrahl an.
--
-- @param[type=number] _ID ID des Zeitstrahl
-- @within Anwenderfunktionen
--
-- @usage QSB.TimeLine:Yield(MyTimeLine);
--
function QSB.TimeLine:Yield(_ID)
    if not QSB.TimeLine.Data.TimeLineJobs[_ID] then
        return;
    end
    QSB.TimeLine.Data.TimeLineJobs[_ID].YieldTime = Logic.GetTime();
    QSB.TimeLine.Data.TimeLineJobs[_ID].Running = false;
end
function API.TimeLineYield(_ID)
    QSB.TimeLine:Yield(_ID);
end

---
-- Stößt einen angehaltenen Zeitstrahl wieder an.
--
-- @param[type=number] _ID ID des Zeitstrahl
-- @within Anwenderfunktionen
--
-- @usage QSB.TimeLine:Resume(MyTimeLine);
--
function QSB.TimeLine:Resume(_ID)
    if not QSB.TimeLine.Data.TimeLineJobs[_ID] then
        return;
    end
    if QSB.TimeLine.Data.TimeLineJobs[_ID].YieldTime then
        local OldStartTime = QSB.TimeLine.Data.TimeLineJobs[_ID].StartTime;
        local TimeYielded = Logic.GetTime() - QSB.TimeLine.Data.TimeLineJobs[_ID].YieldTime;
        QSB.TimeLine.Data.TimeLineJobs[_ID].StartTime = OldStartTime + TimeYielded;
        QSB.TimeLine.Data.TimeLineJobs[_ID].YieldTime = nil;
    end
    QSB.TimeLine.Data.TimeLineJobs[_ID].Running = true;
end
function API.TimeLineResume(_ID)
    QSB.TimeLine:Resume(_ID);
end

---
-- Steuert alle Zeitstrahlen.
-- @within QSB.TimeLine
-- @local
--
function QSB.TimeLine.TimeLineControler()
    for k,v in pairs(QSB.TimeLine.Data.TimeLineJobs) do
        if v.Iterator &#x3E; #v then
            QSB.TimeLine.Data.TimeLineJobs[k].Running = false;
        end

        if v.Running then
            if (v[v.Iterator].Time + v.StartTime) &#x3C;= Logic.GetTime() then
                v[v.Iterator].Action(unpack(v[v.Iterator]));
                QSB.TimeLine.Data.TimeLineJobs[k].Iterator = v.Iterator +1;
            end
        end
    end
end

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

BundleTimeLine = {
    Global = {
        Data = {}
    },
    Local = {
        Data = {}
    },
}

-- Global Script ---------------------------------------------------------------

---
-- Initalisiert das Bundle im globalen Skript.
--
-- @within Internal
-- @local
--
function BundleTimeLine.Global:Install()
    TimeLine = QSB.TimeLine;
end

-- Local Script ----------------------------------------------------------------

---
-- Initalisiert das Bundle im lokalen Skript.
--
-- @within Internal
-- @local
--
function BundleTimeLine.Local:Install()
    TimeLine = QSB.TimeLine;
end

-- -------------------------------------------------------------------------- --

Core:RegisterBundle("BundleTimeLine");

</code></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundletradinganalysis.lua.html">
            <div class='doclink'>
                <div>BundleTradingAnalysis</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><code>-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundleTradingAnalysis                                        # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Dieses Bundle bietet einige Funktionen zum untersuchen und
-- zur Manipulation von Handelsangeboten. Die bekannten Funktionen, wie z.B.
-- AddOffer, werden erweitert, sodass sie Angebote für einen Spieler mit einer
-- anderen ID als 1 erstellen können. Ein kann Händler nicht mehr
-- mehrere Angebote des gleichen Typs anbieten. Außerdem werden einige
-- Preise und Erneuerungsraten hinzugefügt.
--
-- Das wichtigste auf einen Blick:
-- &#x3C;ul&#x3E;
-- &#x3C;li&#x3E;&#x3C;a href="#API.GetOfferCount"&#x3E;Angebote zählen&#x3C;/a&#x3E;&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;&#x3C;a href="#API.IsGoodOrUnitOffered"&#x3E;Angebote prüfen&#x3C;/a&#x3E;&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;&#x3C;a href="#API.RemoveTradeOffer"&#x3E;Angebote einzeln löschen&#x3C;/a&#x3E;&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;&#x3C;a href="#API.ModifyTradeOffer"&#x3E;Angebote modifizieren&#x3C;/a&#x3E;&#x3C;/li&#x3E;
-- &#x3C;/ul&#x3E;
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundleTradingAnalysis = {};

API = API or {};
QSB = QSB or {};

QSB.TraderTypes = {
    GoodTrader        = 0,
    MercenaryTrader   = 1,
    EntertainerTrader = 2,
    Unknown           = 3,
};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Gibt die Handelsinformationen des Spielers aus. In dem Objekt stehen
-- ID des Spielers, ID des Lagerhaus, Menge an Angeboten insgesamt und
-- alle Angebote der Händlertypen.
--
-- @param[type=number] _PlayerID Player ID
-- @return[type=table] Angebotsinformationen
-- @within Anwenderfunktionen
--
-- @usage local Info = API.GetOfferInformation(2);
--
-- -- Info enthält:
-- -- Info = {
-- --      Player = 2,
-- --      Storehouse = 26796.
-- --      OfferCount = 2,
-- --      {
-- --          Händler-ID, Angebots-ID, Angebotstyp, Wagenladung, Angebotsmenge
-- --          {0, 0, Goods.G_Gems, 9, 2},
-- --          {0, 1, Goods.G_Milk, 9, 4},
-- --      },
-- -- };
--
function API.GetOfferInformation(_PlayerID)
    if GUI then
        API.Fatal("Can not execute API.GetOfferInformation in local script!");
        return;
    end
    return BundleTradingAnalysis.Global:GetStorehouseInformation(_PlayerID);
end

---
-- Gibt die Menge an Angeboten im Lagerhaus des Spielers zurück. Wenn
-- der Spieler kein Lagerhaus hat, wird 0 zurückgegeben.
--
-- @param[type=number] _PlayerID Player ID
-- @return[type=number] Anzahl angebote
-- @within Anwenderfunktionen
--
-- @usage -- Angebote von Spieler 5 zählen
-- local Count = API.GetOfferCount(5);
--
function API.GetOfferCount(_PlayerID)
    if GUI then
        API.Fatal("Can not execute API.GetOfferCount in local script!");
        return;
    end
    return BundleTradingAnalysis.Global:GetOfferCount(_PlayerID);
end

---
-- Gibt zurück, ob das Angebot vom angegebenen Spieler im Lagerhaus zum
-- Verkauf angeboten wird.
--
-- @param[type=number] _PlayerID Player ID
-- @param[type=number] _GoodOrEntityType Warentyp oder Entitytyp
-- @return[type=boolean] Ware wird angeboten
-- @within Anwenderfunktionen
--
-- @usage -- Wird die Ware angeboten?
-- if API.IsGoodOrUnitOffered(4, Goods.G_Bread) then
--     API.Note("Brot wird von Spieler 4 angeboten.");
-- end
--
function API.IsGoodOrUnitOffered(_PlayerID, _GoodOrEntityType)
    if GUI then
        API.Fatal("Can not execute API.IsGoodOrUnitOffered in local script!");
        return;
    end
    local OfferID, TraderID = BundleTradingAnalysis.Global:GetOfferAndTrader(_PlayerID, _GoodOrEntityType);
    return OfferID ~= 1 and TraderID ~= 1;
end

---
-- Entfernt das Angebot vom Lagerhaus des Spielers, wenn es vorhanden
-- ist. Es wird immer nur das erste Angebot des Typs entfernt.
--
-- @param[type=number] _PlayerID Player ID
-- @param[type=number] _GoodOrEntityType Warentyp oder Entitytyp
-- @within Anwenderfunktionen
--
-- @usage -- Keinen Käse mehr verkaufen
-- API.RemoveTradeOffer(7, Goods.G_Cheese);
--
function API.RemoveTradeOffer(_PlayerID, _GoodOrEntityType)
    if GUI then
        API.Bridge("API.RemoveTradeOffer(" .._PlayerID.. ", " .._GoodOrEntityType.. ")");
        return;
    end
    return BundleTradingAnalysis.Global:RemoveTradeOffer(_PlayerID, _GoodOrEntityType);
end

---
-- Ändert die aktuelle Menge des Angebots im Händelrgebäude.
--
-- Es kann ein beliebiger positiver Wert gesetzt werden. Es gibt keine
-- Beschränkungen.
--
-- &#x3C;b&#x3E;Hinweis&#x3C;/b&#x3E;: Wird eine höherer Wert gesetzt, als das ursprüngliche
-- Maximum, regenerieren sich die zusätzlichen Angebote nicht.
--
-- @param[type=number] _PlayerID Player ID
-- @param[type=number] _GoodOrEntityType ID des Händlers im Gebäude
-- @param[type=number] _NewAmount Neue Menge an Angeboten
-- @within Anwenderfunktionen
--
-- @usage -- Angebote voll auffüllen
-- API.ModifyTradeOffer(7, Goods.G_Cheese, -1);
-- API.ModifyTradeOffer(7, Goods.U_MilitarySword);
-- -- 2 Angebote auffüllen
-- API.ModifyTradeOffer(7, Goods.G_Dye, 2);
--
function API.ModifyTradeOffer(_PlayerID, _GoodOrEntityType, _NewAmount)
    if GUI then
        API.Bridge("API.ModifyTradeOffer(" .._PlayerID.. ", " .._GoodOrEntityType.. ", " .._NewAmount.. ")");
        return;
    end
    return BundleTradingAnalysis.Global:ModifyTradeOffer(_PlayerID, _GoodOrEntityType, _NewAmount);
end

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

BundleTradingAnalysis = {
    Global = {
        Data = {
            PlayerOffersAmount = {
                [1] = {}, [2] = {}, [3] = {}, [4] = {}, [5] = {}, [6] = {}, [7] = {}, [8] = {},
            };
        },
    },
};

-- Global Script ---------------------------------------------------------------

---
-- Initialisiert das Bundle im globalen Skript.
-- @within Internal
-- @local
--
function BundleTradingAnalysis.Global:Install()
    self.OverwriteOfferFunctions();
    self.OverwriteBasePricesAndRefreshRates();
end

---
-- Überschreibt die Funktionen für Standardangebote.
--
-- @within Internal
-- @local
--
function BundleTradingAnalysis.Global:OverwriteOfferFunctions()
    ---
    -- Erzeugt ein Handelsangebot für Waren und gibt die ID zurück.
    --
    -- &#x3C;b&#x3E;Hinweis&#x3C;/b&#x3E;: Jeder Angebotstyp kann nur 1 Mal pro Lagerhaus
    -- angeboten werden.
    --
    -- @param[type=number] _Merchant  Handelsgebäude
    -- @param[type=number] _NumberOfOffers Anzahl an Angeboten
    -- @param[type=number] _GoodType Warentyp
    -- @param[type=number] _RefreshRate Erneuerungsrate
    -- @param[type=number] _optionalPlayersPlayerID Optionale Spieler-ID
    -- @return[type=number] Offer ID
    -- @within Originalfunktionen
    --
    AddOffer = function(_Merchant, _NumberOfOffers, _GoodType, _RefreshRate, _optionalPlayersPlayerID)
        local MerchantID = GetID(_Merchant);
        if type(_GoodType) == "string" then
            _GoodType = Goods[_GoodType];
        else
            _GoodType = _GoodType;
        end

        local PlayerID = Logic.EntityGetPlayer(MerchantID);
        local OfferID, TraderID = BundleTradingAnalysis.Global:GetOfferAndTrader(PlayerID, _GoodType);
        if OfferID ~= -1 and TraderID ~= -1 then
            API.Warn("Good offer for good type " .._GoodType.. " already exists for player " ..PlayerID.. "!");
            return;
        end


        AddGoodToTradeBlackList(PlayerID, _GoodType);
        local MarketerType = Entities.U_Marketer;
        if _GoodType == Goods.G_Medicine then
            MarketerType = Entities.U_Medicus;
        end
        if _RefreshRate == nil then
            _RefreshRate = MerchantSystem.RefreshRates[_GoodType];
            if _RefreshRate == nil then
                _RefreshRate = 0;
            end
        end
        if _optionalPlayersPlayerID == nil then
            _optionalPlayersPlayerID = 1;
        end
        local offerAmount = 9;

        BundleTradingAnalysis.Global.Data.PlayerOffersAmount[PlayerID][_GoodType] = _NumberOfOffers;
        return Logic.AddGoodTraderOffer(MerchantID,_NumberOfOffers,Goods.G_Gold,0,_GoodType,offerAmount,_optionalPlayersPlayerID,_RefreshRate,MarketerType,Entities.U_ResourceMerchant);
    end

    ---
    -- Erzeugt ein Handelsangebot für Söldner und gibt die ID zurück.
    --
    -- &#x3C;b&#x3E;Hinweis&#x3C;/b&#x3E;: Jeder Angebotstyp kann nur 1 Mal pro Lagerhaus
    -- angeboten werden.
    --
    -- @param[type=number] _Mercenary Handelsgebäude
    -- @param[type=number] _Amount Anzahl an Angeboten
    -- @param[type=number] _Type Soldatentyp
    -- @param[type=number] _RefreshRate Erneuerungsrate
    -- @param[type=number] _optionalPlayersPlayerID Optionale Spieler-ID
    -- @return[type=number] Offer ID
    -- @within Originalfunktionen
    --
    AddMercenaryOffer = function(_Mercenary, _Amount, _Type, _RefreshRate, _optionalPlayersPlayerID)
        local MercenaryID = GetID(_Mercenary);
        if _Type == nil then
            _Type = Entities.U_MilitaryBandit_Melee_ME;
        end
        if _RefreshRate == nil then
            _RefreshRate = MerchantSystem.RefreshRates[_Type];
            if _RefreshRate == nil then
                _RefreshRate = 0;
            end
        end

        local PlayerID = Logic.EntityGetPlayer(MercenaryID);
        local OfferID, TraderID = BundleTradingAnalysis.Global:GetOfferAndTrader(PlayerID, _Type);
        if OfferID ~= -1 and TraderID ~= -1 then
            API.Warn("Mercenary offer for type " .._Type.. " already exists for player " ..PlayerID.. "!");
            return;
        end

        local amount = 3;
        local typeName = Logic.GetEntityTypeName(_Type);
        if string.find(typeName,"MilitaryBow") or string.find(typeName,"MilitarySword") then
            amount = 6;
        elseif string.find(typeName,"Cart") then
            amount = 0;
        end
        if _optionalPlayersPlayerID == nil then
            _optionalPlayersPlayerID = 1;
        end

        BundleTradingAnalysis.Global.Data.PlayerOffersAmount[PlayerID][_Type] = _Amount;
        return Logic.AddMercenaryTraderOffer(MercenaryID, _Amount, Goods.G_Gold, 3, _Type ,amount,_optionalPlayersPlayerID,_RefreshRate);
    end

    ---
    -- Erzeugt ein Handelsangebot für Entertainer und gibt die
    -- ID zurück.
    --
    -- &#x3C;b&#x3E;Hinweis&#x3C;/b&#x3E;: Jeder Angebotstyp kann nur 1 Mal pro Lagerhaus
    -- angeboten werden.
    --
    -- @param[type=number] _Merchant Handelsgebäude
    -- @param[type=number] _EntertainerType Typ des Entertainer
    -- @param[type=number] _optionalPlayersPlayerID Optionale Spieler-ID
    -- @return[type=number] Offer ID
    -- @within Originalfunktionen
    --
    AddEntertainerOffer = function(_Merchant, _EntertainerType, _optionalPlayersPlayerID)
        local MerchantID = GetID(_Merchant);
        local NumberOfOffers = 1;

        local PlayerID = Logic.EntityGetPlayer(MerchantID);
        local OfferID, TraderID = BundleTradingAnalysis.Global:GetOfferAndTrader(PlayerID, _EntertainerType);
        if OfferID ~= -1 and TraderID ~= -1 then
            API.Warn("Entertainer offer for type " .._EntertainerType.. " already exists for player " ..PlayerID.. "!");
            return;
        end

        if _EntertainerType == nil then
            _EntertainerType = Entities.U_Entertainer_NA_FireEater;
        end
        if _optionalPlayersPlayerID == nil then
            _optionalPlayersPlayerID = 1;
        end

        BundleTradingAnalysis.Global.Data.PlayerOffersAmount[PlayerID][_EntertainerType] = 1;
        return Logic.AddEntertainerTraderOffer(MerchantID,NumberOfOffers,Goods.G_Gold,0,_EntertainerType, _optionalPlayersPlayerID,0);
    end
end

---
-- Fügt fehlende Einträge für Militäreinheiten bei den Basispreisen
-- und Erneuerungsraten hinzu, damit diese gehandelt werden können.
-- @within Internal
-- @local
--
function BundleTradingAnalysis.Global:OverwriteBasePricesAndRefreshRates()
    MerchantSystem.BasePrices[Entities.U_CatapultCart] = MerchantSystem.BasePrices[Entities.U_CatapultCart] or 1000;
    MerchantSystem.BasePrices[Entities.U_BatteringRamCart] = MerchantSystem.BasePrices[Entities.U_BatteringRamCart] or 450;
    MerchantSystem.BasePrices[Entities.U_SiegeTowerCart] = MerchantSystem.BasePrices[Entities.U_SiegeTowerCart] or 600;
    MerchantSystem.BasePrices[Entities.U_AmmunitionCart] = MerchantSystem.BasePrices[Entities.U_AmmunitionCart] or 180;
    MerchantSystem.BasePrices[Entities.U_MilitarySword_RedPrince] = MerchantSystem.BasePrices[Entities.U_MilitarySword_RedPrince] or 150;
    MerchantSystem.BasePrices[Entities.U_MilitarySword] = MerchantSystem.BasePrices[Entities.U_MilitarySword] or 150;
    MerchantSystem.BasePrices[Entities.U_MilitaryBow_RedPrince] = MerchantSystem.BasePrices[Entities.U_MilitaryBow_RedPrince] or 220;
    MerchantSystem.BasePrices[Entities.U_MilitaryBow] = MerchantSystem.BasePrices[Entities.U_MilitaryBow] or 220;

    MerchantSystem.RefreshRates[Entities.U_CatapultCart] = MerchantSystem.RefreshRates[Entities.U_CatapultCart] or 270;
    MerchantSystem.RefreshRates[Entities.U_BatteringRamCart] = MerchantSystem.RefreshRates[Entities.U_BatteringRamCart] or 190;
    MerchantSystem.RefreshRates[Entities.U_SiegeTowerCart] = MerchantSystem.RefreshRates[Entities.U_SiegeTowerCart] or 220;
    MerchantSystem.RefreshRates[Entities.U_AmmunitionCart] = MerchantSystem.RefreshRates[Entities.U_AmmunitionCart] or 150;
    MerchantSystem.RefreshRates[Entities.U_MilitaryBow_RedPrince] = MerchantSystem.RefreshRates[Entities.U_MilitarySword_RedPrince] or 150;
    MerchantSystem.RefreshRates[Entities.U_MilitarySword] = MerchantSystem.RefreshRates[Entities.U_MilitarySword] or 150;
    MerchantSystem.RefreshRates[Entities.U_MilitaryBow_RedPrince] = MerchantSystem.RefreshRates[Entities.U_MilitaryBow_RedPrince] or 150;
    MerchantSystem.RefreshRates[Entities.U_MilitaryBow] = MerchantSystem.RefreshRates[Entities.U_MilitaryBow] or 150;

    if g_GameExtraNo &#x3E;= 1 then
        MerchantSystem.BasePrices[Entities.U_MilitaryBow_Khana] = MerchantSystem.BasePrices[Entities.U_MilitaryBow_Khana] or 220;
        MerchantSystem.RefreshRates[Entities.U_MilitaryBow_Khana] = MerchantSystem.RefreshRates[Entities.U_MilitaryBow_Khana] or 150;
        MerchantSystem.BasePrices[Entities.U_MilitarySword_Khana] = MerchantSystem.BasePrices[Entities.U_MilitarySword_Khana] or 150;
        MerchantSystem.RefreshRates[Entities.U_MilitaryBow_Khana] = MerchantSystem.RefreshRates[Entities.U_MilitarySword_Khana] or 150;
    end
end

---
-- Gibt die Handelsinformationen des Spielers aus. In dem Objekt stehen
-- ID des Spielers, ID des Lagerhaus, Menge an Angeboten insgesamt und
-- alle Angebote der Händlertypen.
--
-- @param[type=number] _PlayerID Player ID
-- @return[type=table] Angebotsinformationen
-- @within Internal
-- @local
--
-- @usage BundleTradingAnalysis.Global:GetStorehouseInformation(2);
--
-- -- Ausgabe:
-- -- Info = {
-- --      Player = 2,
-- --      Storehouse = 26796.
-- --      OfferCount = 2,
-- --      {
-- --          Händler-ID, Angebots-ID, Angebotstyp, Wagenladung, Angebotsmenge
-- --          {0, 0, Goods.G_Gems, 9, 2},
-- --          {0, 1, Goods.G_Milk, 9, 4},
-- --      },
-- -- }
--
function BundleTradingAnalysis.Global:GetStorehouseInformation(_PlayerID)
    local BuildingID = Logic.GetStoreHouse(_PlayerID);

    local StorehouseData = {
        Player      = _PlayerID,
        Storehouse  = BuildingID,
        OfferCount  = 0,
        {},
    };

    local NumberOfMerchants = Logic.GetNumberOfMerchants(Logic.GetStoreHouse(2));
    local AmountOfOffers = 0;

    if BuildingID ~= 0 then
        for Index = 0, NumberOfMerchants, 1 do
            local Offers = {Logic.GetMerchantOfferIDs(BuildingID, Index, _PlayerID)};
            for i= 1, #Offers, 1 do
                local type, goodAmount, offerAmount, prices = 0, 0, 0, 0;
                if Logic.IsGoodTrader(BuildingID, Index) then
                    type, goodAmount, offerAmount, prices = Logic.GetGoodTraderOffer(BuildingID, Offers[i], _PlayerID);
                    if type == Goods.G_Sheep or type == Goods.G_Cow then
                        goodAmount = 5;
                    end
                elseif Logic.IsMercenaryTrader(BuildingID, Index) then
                    type, goodAmount, offerAmount, prices = Logic.GetMercenaryOffer(BuildingID, Offers[i], _PlayerID);
                elseif Logic.IsEntertainerTrader(BuildingID, Index) then
                    type, goodAmount, offerAmount, prices = Logic.GetEntertainerTraderOffer(BuildingID, Offers[i], _PlayerID);
                end

                AmountOfOffers = AmountOfOffers +1;
                local OfferData = {Index, Offers[i], type, goodAmount, offerAmount};
                table.insert(StorehouseData[1], OfferData);
            end
        end
    end

    StorehouseData.OfferCount = AmountOfOffers;
    return StorehouseData;
end

---
-- Gibt die Menge an Angeboten im Lagerhaus des Spielers zurück. Wenn
-- der Spieler kein Lagerhaus hat, wird 0 zurückgegeben.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @return[type=number] Menge an Angeboten
-- @within Internal
-- @local
--
function BundleTradingAnalysis.Global:GetOfferCount(_PlayerID)
    local Offers = self:GetStorehouseInformation(_PlayerID);
    if Info then
        return Offers.OfferCount;
    end
    return 0;
end

---
-- Gibt Offer ID und Trader ID und ID des Lagerhaus des Angebots für
-- den Spieler zurück. Es wird immer das erste Angebot zurückgegeben.
--
-- @param[type=number] _PlayerID Player ID
-- @param[type=number] _GoodOrEntityType Warentyp oder Entitytyp
-- @return[type=number] Offer ID
-- @return[type=number] Trader ID
-- @return[type=number] Storehouse ID
-- @within Internal
-- @local
--
function BundleTradingAnalysis.Global:GetOfferAndTrader(_PlayerID, _GoodOrEntityType)
    local Info = self:GetStorehouseInformation(_PlayerID);
    if Info then
        for j=1, #Info[1], 1 do
            if Info[1][j][3] == _GoodOrEntityType then
                return Info[1][j][2], Info[1][j][1], Info.Storehouse;
            end
        end
    end
    return -1, -1, -1;
end

---
-- Gibt den Typ des Händlers mit der ID im Gebäude zurück.
--
-- @param[type=number] _BuildingID Building ID
-- @param[type=number] _TraderID Trader ID
-- @return[type=number] Händlertyp
-- @within Internal
-- @local
--
function BundleTradingAnalysis.Global:GetTraderType(_BuildingID, _TraderID)
    if Logic.IsGoodTrader(BuildingID, _TraderID) == true then
        return QSB.TraderTypes.GoodTrader;
    elseif Logic.IsMercenaryTrader(BuildingID, _TraderID) == true then
        return QSB.TraderTypes.MercenaryTrader;
    elseif Logic.IsEntertainerTrader(BuildingID, _TraderID) == true then
        return QSB.TraderTypes.EntertainerTrader;
    else
        return QSB.TraderTypes.Unknown;
    end
end

---
-- Entfernt das Angebot vom Lagerhaus des Spielers, wenn es vorhanden ist.
-- Es wird immer nur das erste Angebot des Typs entfernt.
--
-- @param[type=number] _PlayerID Player ID
-- @param[type=number] _GoodOrEntityType Warentyp oder Entitytyp
-- @within Internal
-- @local
--
function BundleTradingAnalysis.Global:RemoveTradeOffer(_PlayerID, _GoodOrEntityType)
    local OfferID, TraderID, BuildingID = self:GetOfferAndTrader(_PlayerID, _GoodOrEntityType);
    if not IsExisting(BuildingID) then
        return;
    end
    -- Wird benötigt, weil bei RemoveOffer die Trader-IDs vertauscht sind.
    local MappedTraderID = (TraderID == 1 and 2) or (TraderID == 2 and 1) or 0;
    Logic.RemoveOffer(BuildingID, MappedTraderID, OfferID);
end

---
-- Ändert die aktuelle Menge des Angebots im Händelrgebäude.
--
-- Der eingetragene Wert darf die maximale Menge an Angeboten des Typs im
-- Lagerhaus nicht überschreiten.
--
-- &#x3C;b&#x3E;Hinweis&#x3C;/b&#x3E;: Wird eine höherer Wert gesetzt, als das ursprüngliche
-- Maximum, regenerieren sich die zusätzlichen Angebote nicht.
--
-- @param[type=number] _PlayerID	     Händlergebäude
-- @param[type=number] _GoodOrEntityType ID des Händlers im Gebäude
-- @param[type=number] _NewAmount        Neue Menge an Angeboten
-- @within Internal
-- @local
--
function BundleTradingAnalysis.Global:ModifyTradeOffer(_PlayerID, _GoodOrEntityType, _NewAmount)
    local OfferID, TraderID, BuildingID = self:GetOfferAndTrader(_PlayerID, _GoodOrEntityType);
    if not IsExisting(BuildingID) then
        return;
    end

    -- Menge == -1 oder Menge == nil bedeutet Maximum
    if _NewAmount == nil or _NewAmount == -1 then
        _NewAmount = self.Data.PlayerOffersAmount[_PlayerID][_GoodOrEntityType];
    end
    -- Werte größer als das Maximum werden nicht erneuert!
    if self.Data.PlayerOffersAmount[_PlayerID][_GoodOrEntityType] and self.Data.PlayerOffersAmount[_PlayerID][_GoodOrEntityType] &#x3C; _NewAmount then
        _NewAmount = self.Data.PlayerOffersAmount[_PlayerID][_GoodOrEntityType];
    end
    Logic.ModifyTraderOffer(BuildingID, OfferID, _NewAmount, TraderID);
end

-- -------------------------------------------------------------------------- --

Core:RegisterBundle("BundleTradingAnalysis");

</code></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundletravelingsalesman.lua.html">
            <div class='doclink'>
                <div>BundleTravelingSalesman</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><code>-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundleTravelingSalesman                                       # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Mit diesem Bundle wird ein Fahrender Händler angeboten der periodisch den
-- Hafen mit einem Schiff anfährt. Dabei kann der Fahrtweg frei mit Wegpunkten
-- bestimmt werden. Es können auch mehrere Spieler zu Händlern gemacht werden.
--
-- &#x3C;p&#x3E;&#x3C;a href="#API.TravelingSalesmanActivate"&#x3E;Schiffshändler aktivieren&#x3C;/a&#x3E;&#x3C;/p&#x3E;
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundleTravelingSalesman = {};

API = API or {};
QSB = QSB or {};

QSB.TravelingSalesman = {
	Harbors = {}
};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Erstellt einen fahrender Händler mit zufälligen Angeboten.
--
-- Soll immer das selbe angeboten werden, darf nur ein Angebotsblock
-- definiert werden.
-- Es kann mehr als einen fahrender Händler auf der Map geben.
--
-- &#x3C;h5&#x3E;Angebote&#x3C;/h5&#x3E;
-- Es sind maximal 4 Angebote pro Angebotsblock erlaubt. Es können Waren,
-- Soldaten oder Entertainer angeboten werden. Es wird immer automatisch 1
-- Block selektiert und die Angebote gesetzt.
--
-- &#x3C;h5&#x3E;Routen&#x3C;/h5&#x3E;
-- Über Waypoints wird der Weg bestimmt, den das Handelsschiff nehmen wird.
-- Die Umkehrung der Route ist standardmäßig als Rückweg festgelegt. Will
-- man einen anderen Rückweg, muss dieser als Reversed angegeben werden.
--
-- &#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: TravelingSalesmanActivate
--
-- @param[type=table]  _Description Definition des Händlers
-- @within Anwenderfunktionen
--
-- @usage local TraderDescription = {
--     PlayerID = 2,
--     Waypoints = {"WP1", "WP2", "WP3", "WP4"},
--     Offers = {
--         {
--             {"G_Gems", 5,},
--             {"G_Iron", 5,},
--             {"G_Beer", 2,},
--         },
--         {
--             {"G_Stone", 5,},
--             {"G_Sheep", 1,},
--             {"G_Cheese", 2,},
--             {"G_Milk", 5,},
--         },
--         {
--             {"G_Grain", 5,},
--             {"G_Broom", 2,},
--             {"G_Sheep", 1,},
--         },
--         {
--             {"U_CatapultCart", 1,},
--             {"U_MilitarySword", 3,},
--             {"U_MilitaryBow", 3,},
--         },
--     },
-- };
-- API.TravelingSalesmanActivate(TraderDescription);
--
function API.TravelingSalesmanCreate(_TraderDescription)
    if GUI then
        API.Fatal("Can not execute API.TravelingSalesmanActivate in local script!");
        return;
    end
    return QSB.TravelingSalesman:New(_TraderDescription.PlayerID)
        :SetOffers(_TraderDescription.Offers)
        :SetApproachRoute(_TraderDescription.Waypoints)
        :SetReturnRouteRoute(_TraderDescription.Reversed)
        :SetApperance(_TraderDescription.Appearance)
        :UseOfferRotation(_TraderDescription.Flag or true)
        :Activate();
end
TravelingSalesmanActivate = API.TravelingSalesmanCreate;

---
-- Entfernt den fahrenden Händler von dem Spieler. Der Spieler bleibt
-- erhalten wird aber nicht mal als fahrender Händler fungieren.
--
-- &#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: TravelingSalesmanDeactivate
--
-- @param[type=number] _PlayerID Spieler-ID des Händlers
-- @within Anwenderfunktionen
--
-- @usage API.TravelingSalesmanDispose(2);
--
function API.TravelingSalesmanDispose(_PlayerID)
    if GUI then
        API.Bridge("API.TravelingSalesmanDispose(" .._PlayerID.. ")");
        return;
    end
    QSB.TravelingSalesman:GetInstance(_PlayerID):Dispose();
end
TravelingSalesmanDeactivate = API.TravelingSalesmanDispose;

---
-- Aktiviert einen fahrenden Händler, der zuvor deaktiviert wurde.
--
-- &#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: TravelingSalesmanResume
--
-- @param[type=number] _PlayerID Spieler-ID des Händlers
-- @within Anwenderfunktionen
--
-- @usage API.TravelingSalesmanActivate(2);
--
function API.TravelingSalesmanActivate(_PlayerID)
    if GUI then
        API.Bridge("API.TravelingSalesmanDeactivate(" .._PlayerID.. ")");
        return;
    end
    QSB.TravelingSalesman:GetInstance(_PlayerID):Aktivate();
end
TravelingSalesmanResume = API.TravelingSalesmanActivate;

---
-- Deaktiviert einen fahrenden Händler. Der aktuelle Zyklus wird noch beendet,
-- aber danach kommt der Händler nicht mehr wieder.
--
-- &#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: TravelingSalesmanYield
--
-- @param[type=number] _PlayerID Spieler-ID des Händlers
-- @within Anwenderfunktionen
--
-- @usage API.TravelingSalesmanDeactivate(2);
--
function API.TravelingSalesmanDeactivate(_PlayerID)
    if GUI then
        API.Bridge("API.TravelingSalesmanDeactivate(" .._PlayerID.. ")");
        return;
    end
    QSB.TravelingSalesman:GetInstance(_PlayerID):Deaktivate();
end
TravelingSalesmanYield = API.TravelingSalesmanDeactivate;

---
-- Legt fest, ob die diplomatischen Beziehungen zwischen dem Spieler und dem
-- Hafen überschrieben werden.
--
-- Die diplomatischen Beziehungen werden überschrieben, wenn sich ein Schiff
-- im Hafen befindet und wenn es abreist. Der Hafen ist "Handelspartner", wenn
-- ein Schiff angelegt hat, sonst "Bekannt".
--
-- Bei diplomatischen Beziehungen geringer als "Bekannt", kann es zu Fehlern
-- kommen. Dann werden Handelsangebote angezeigt, konnen aber nicht durch
-- den Spieler erworben werden.
--
-- &#x3C;b&#x3E;Hinweis&#x3C;/b&#x3E;: Überschreiben der Beziehungen ist Standardmäßig als aktiv
-- voreingestellt.
--
-- &#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: TravelingSalesmanDiplomacyOverride
--
-- @param[type=number]  _PlayerID Spieler-ID des Händlers
-- @param[type=boolean] _Flag Diplomatie überschreiben
-- @within Anwenderfunktionen
--
-- @usage API.TravelingSalesmanDiplomacyOverride(2, false);
--
function API.TravelingSalesmanDiplomacyOverride(_PlayerID, _Flag)
    if GUI then
        API.Bridge("API.TravelingSalesmanDiplomacyOverride(" .._PlayerID.. ", " ..tostring(_Flag).. ")");
        return;
    end
    QSB.TravelingSalesman:GetInstance(_PlayerID):UseChangeDiplomacy(_Flag);
end
TravelingSalesmanDiplomacyOverride = API.TravelingSalesmanDiplomacyOverride;

---
-- Legt fest, ob die Angebote der Reihe nach durchgegangen werden (beginnt von
-- vorn, wenn am Ende angelangt) oder zufällig ausgesucht werden.
--
-- &#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: TravelingSalesmanRotationMode
--
-- @param[type=number]  _PlayerID Spieler-ID des Händlers
-- @param[type=boolean] _Flag Angebotsrotation einschalten
-- @within Anwenderfunktionen
--
-- @usage API.TravelingSalesmanRotationMode(2, true);
--
function API.TravelingSalesmanRotationMode(_PlayerID, _Flag)
    if GUI then
        API.Bridge("API.TravelingSalesmanRotationMode(" .._PlayerID.. ", " ..tostring(_Flag).. ")");
        return;
    end
    QSB.TravelingSalesman:GetInstance(_PlayerID):UseOfferRotation(_Flag);
end
TravelingSalesmanRotationMode = API.TravelingSalesmanRotationMode;

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

BundleTravelingSalesman = {
    Global = {
        Data = {},
    },
};

-- Global Script ---------------------------------------------------------------

---
-- Initialisiert das Bundle im globalen Skript.
-- @within Internal
-- @local
--
function BundleTravelingSalesman.Global:Install()
    StartSimpleJobEx(BundleTravelingSalesman.Global.TravelingSalesmanController);
end

---
-- Ruft die Loop-Funktion aller Fahrenden Händler auf.
-- @within Internal
-- @local
--
function BundleTravelingSalesman.Global.TravelingSalesmanController()
    for i= 1, 8, 1 do
        if QSB.TravelingSalesman:GetInstance(i) then
            QSB.TravelingSalesman:GetInstance(i):Loop();
        end
    end
end

-- Klassen ------------------------------------------------------------------ --

QSB.TravelingSalesmanInstances = {};

QSB.TravelingSalesman = {}

---
-- Konstruktor
-- @param[type=number] _PlayerID Player-ID des Händlers
-- @within QSB.TravelingSalesman
-- @local
--
function QSB.TravelingSalesman:New(_PlayerID)
    local salesman = API.InstanceTable(self);
    salesman.m_PlayerID = _PlayerID;
    salesman.m_Offers = {};
    salesman.m_Appearance = {{3, 5}, {7, 9}};
    salesman.m_Waypoints = nil;
    salesman.m_Reversed = nil;
    salesman.m_ChangeDiplomacy = true;
    salesman.m_OfferRotation = false;
    salesman.m_LastOffer = 0;
    salesman.m_Status = 0;
    QSB.TravelingSalesmanInstances[_PlayerID] = salesman;
    return salesman;
end

---
-- Gibt die Instanz des Fahrenden Händlers für die Player-ID zurück.
--
-- Sollte keine Instanz für den Spieler existieren, wird eine Null-Instanz
-- erzeugt und zurückgegeben.
--
-- @param[type=number] _PlayerID Player-ID des Händlers
-- @return[type=table] Instanz
-- @within QSB.TravelingSalesman
-- @local
--
function QSB.TravelingSalesman:GetInstance(_PlayerID)
    if QSB.TravelingSalesmanInstances[_PlayerID] then
        return QSB.TravelingSalesmanInstances[_PlayerID];
    end
    local NullInstance = QSB.TravelingSalesman:New(_PlayerID);
    NullInstance.SymfoniaDebugValue_NullInstance = true;
    return NullInstance;
end

---
-- Startet einen initialisierten Händler.
-- @return[type=table] Instanz
-- @within QSB.TravelingSalesman
-- @local
--
function QSB.TravelingSalesman:Activate()
    self.m_Active = true;
    if type(self.m_Waypoints) ~= "table" or type(self.m_Reversed) ~= "table" then
        fatal("QSB.TravelingSalesman:Activate: trader "..self.m_PlayerID.." must have a approach and a return route!");
        return;
    end
    return self;
end

---
-- Stoppt einen aktiven Händler, sodass der nächste Zyklus nicht mehr startet.
-- @return[type=table] Instanz
-- @within QSB.TravelingSalesman
-- @local
--
function QSB.TravelingSalesman:Deactivate()
    self.m_Active = false;
    return self;
end

---
-- Gibt die ID des ersten aktiven menschlichen Spielers zurück.
-- @return[type=number] Player-ID
-- @within QSB.TravelingSalesman
-- @local
--
function QSB.TravelingSalesman:GetHumanPlayer()
    for i= 1, 8, 1 do
        if Logic.PlayerGetIsHumanFlag(1) == true then
            return i;
        end
    end
    return 0;
end

---
-- Entfernt alle Angebotsblöcke des Fahrenden Händlers.
-- @return[type=table] self
-- @within QSB.TravelingSalesman
-- @local
--
function QSB.TravelingSalesman:ClearOffers()
    return self:SetOffers({});
end

---
-- Setzt eine Liste von Angebotsblöcken für den Fahrenden Händler.
-- @param[type=table] _Offers Definierte Angebotsblöcke
-- @return[type=table] self
-- @within QSB.TravelingSalesman
-- @local
--
function QSB.TravelingSalesman:SetOffers(_Offers)
    self.m_Offers = _Offers;
    return self;
end

---
-- Fügt dem Fahrenden Händler einen Angebotsblock hinzu. Es wird zuerst der
-- Warentyp als String und danach die Anzahl angegeben.
-- @return[type=table] self
-- @within QSB.TravelingSalesman
-- @local
--
function QSB.TravelingSalesman:AddOffer(...)
    local Offer = {};
    for i= 1, #arg, 2 do
        table.insert(Offer, {arg[i], arg[i+1]});
    end
    table.insert(self.m_Offers, Offer);
    return self;
end

---
-- Löscht die Aufenthaltszeitspanne des Fahrenden Händlers.
-- @return[type=table] self
-- @within QSB.TravelingSalesman
-- @local
--
function QSB.TravelingSalesman:ClearApperance()
    return self:SetApperance({});
end

---
-- Fügt einen Zeitraum zur Aufenthalt des Fliegenden Händlers hinzu. Ein
-- Zeitraum besteht aus Startmonat und Endmonat.
-- @return[type=table] self
-- @within QSB.TravelingSalesman
-- @local
--
function QSB.TravelingSalesman:AddApperance(_Start, _End)
    table.insert(self.m_Appearance, {_Start, _End});
    return self;
end

---
-- Setzt die Aufenthaltszeitspanne des Fliegenden Händlers
-- @param[type=table] _Apperance Aufenthaltszeitspanne
-- @return[type=table] self
-- @within QSB.TravelingSalesman
-- @local
--
function QSB.TravelingSalesman:SetApperance(_Apperance)
    self.m_Appearance = _Apperance or self.m_Appearance;
    return self;
end

---
-- Setzt die Route für die Ankunft des Fahrenden Händlers.
-- @param[type=table] _List Liste der Wegpunkte
-- @return[type=table] self
-- @within QSB.TravelingSalesman
-- @local
--
function QSB.TravelingSalesman:SetApproachRoute(_List)
    self.m_Waypoints = API.InstanceTable(_List);
    self.m_SpawnPos = self.m_Waypoints[1];
    self.m_Destination = self.m_Waypoints[#_List];
    return self;
end

---
-- Setzt die Wegpunkte für die Abfahrt des Fliegenden Händlers. Ist die Liste
-- nil, werden die Wegpunkte für die Anfahrt invertiert.
-- @param[type=table] _List Liste der Wegpunkte
-- @return[type=table] self
-- @within QSB.TravelingSalesman
-- @local
--
function QSB.TravelingSalesman:SetReturnRouteRoute(_List)
    local Reversed = _List;
    if type(Reversed) ~= "table" then
        Reversed = {};
        for i= #self.m_Waypoints, 1, -1 do
            table.insert(Reversed, self.m_Waypoints[i]);
        end
    end
    self.m_Reversed = API.InstanceTable(Reversed);
    return self;
end

---
-- Aktiviert oder deaktiviert die sequentielle Abarbeitung der Angebote dieses
-- Fliegenden Händlers.
-- @param[type=boolean] _Flag Angebote sequenziell durchlaufen
-- @return[type=table] self
-- @within QSB.TravelingSalesman
-- @local
--
function QSB.TravelingSalesman:UseOfferRotation(_Flag)
    self.m_OfferRotation = _Flag == true;
    return self;
end

---
-- Aktiviert oder deaktiviert die automatische Anpasung der Diplomatie.
-- @param[type=boolean] _Flag Diplomatie wird überschrieben
-- @return[type=table] self
-- @within QSB.TravelingSalesman
-- @local
--
function QSB.TravelingSalesman:UseChangeDiplomacy(_Flag)
    self.m_ChangeDiplomacy = _Flag == true;
    return self;
end

---
-- Invalidiert die Instanz dieses Fliegenden Händlers.
-- @within QSB.TravelingSalesman
-- @local
--
function QSB.TravelingSalesman:Dispose()
    Logic.RemoveAllOffers(Logic.GetStoreHouse(self.m_PlayerID));
    DestroyEntity("TravelingSalesmanShip_Player" ..self.m_PlayerID);
    QSB.TravelingSalesmanInstances[self.m_PlayerID] = nil;
end

---
-- Gibt einen Block Angebote für diesen Fahrenden Händler zurück.
-- @return[type=table] Angebote
-- @within QSB.TravelingSalesman
-- @local
--
function QSB.TravelingSalesman:NextOffer()
    local NextOffer;
    if self.m_OfferRotation then
        self.m_LastOffer = self.m_LastOffer +1;
        if self.m_LastOffer &#x3E; #self.m_Offers then
            self.m_LastOffer = 1;
        end
        NextOffer = self.m_Offers[self.m_LastOffer];
    else
        local RandomIndex = 1;
        if #self.m_Offers &#x3E; 1 then
            repeat
                RandomIndex = math.random(1,#self.m_Offers);
            until (RandomIndex ~= self.m_LastOffer);
        end
        self.m_LastOffer = RandomIndex;
        NextOffer = self.m_Offers[self.m_LastOffer];
    end
    return NextOffer;
end

---
-- Zeigt die Info-Nachricht an, wenn ein Schiff im Hafen anlegt.
-- @return[type=table] self
-- @within QSB.TravelingSalesman
-- @local
--
function QSB.TravelingSalesman:DisplayInfoMessage()
    if ((IsBriefingActive and not IsBriefingActive()) or true) then
        local InfoQuest = Quests[GetQuestID("TravelingSalesman_Info_P" ..self.m_PlayerID)];
        if InfoQuest then
            API.RestartQuest("TravelingSalesman_Info_P" ..self.m_PlayerID, true);
            InfoQuest:SetMsgKeyOverride();
            InfoQuest:SetIconOverride();
            InfoQuest:Trigger();
            return self;
        end

        local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";
        local Text = { de = "Ein Schiff hat angelegt. Es bringt Güter von weit her.",
                       en = "A ship is at the pier. It delivers goods from far away."};
        QuestTemplate:New(
            "TravelingSalesman_Info_P" ..self.m_PlayerID,
            self.m_PlayerID,
            self:GetHumanPlayer(),
            {{ Objective.Dummy,}},
            {{ Triggers.Time, 0 }},
            0,
            nil, nil, nil, nil, false, true,
            nil, nil,
            Text[lang],
            nil
        );
    end
    return self;
end

---
-- Fügt dem Fahrenden Händler ein neues Angebot hinzu.
-- @return[type=table] self
-- @within QSB.TravelingSalesman
-- @local
--
function QSB.TravelingSalesman:IntroduceNewOffer()
    MerchantSystem.TradeBlackList[self.m_PlayerID] = {};
    MerchantSystem.TradeBlackList[self.m_PlayerID][0] = #MerchantSystem.TradeBlackList[3];

    local traderId = Logic.GetStoreHouse(self.m_PlayerID);
    local offer = self:NextOffer();
    Logic.RemoveAllOffers(traderId);

    if #offer &#x3E; 0 then
        for i=1,#offer,1 do
            local offerType = offer[i][1];
            local isGoodType = false;
            for k,v in pairs(Goods)do
                if k == offerType then
                    isGoodType = true;
                end
            end

            if isGoodType then
                local amount = offer[i][2];
                AddOffer(traderId,amount,Goods[offerType], 9999);
            else
                if Logic.IsEntityTypeInCategory(Entities[offerType],EntityCategories.Military)== 0 then
                    AddEntertainerOffer(traderId,Entities[offerType]);
                else
                    local amount = offer[i][2];
                    AddMercenaryOffer(traderId,amount,Entities[offerType], 9999);
                end
            end
        end
    end
    if self.m_ChangeDiplomacy then
        SetDiplomacyState(self:GetHumanPlayer(), self.m_PlayerID, DiplomacyStates.TradeContact);
    end
    Logic.SetTraderPlayerState(Logic.GetStoreHouse(self.m_PlayerID), self:GetHumanPlayer(), 1);
    return self;
end

---
-- Steuert den Ablauf des fliegenden Händlers.
-- @return[type=table] self
-- @within QSB.TravelingSalesman
-- @local
--
function QSB.TravelingSalesman:Loop()
    if not self.SymfoniaDebugValue_NullInstance and Logic.PlayerGetIsHumanFlag(self.m_PlayerID) == false then
        if self.m_Status == 0 and self.m_Active == true then
            local month = Logic.GetCurrentMonth();
            local start = false;
            for i=1, #self.m_Appearance,1 do
                if month == self.m_Appearance[i][1] then
                    start = true;
                end
            end
            if start then
                local orientation = Logic.GetEntityOrientation(GetID(self.m_SpawnPos))
                local ID = CreateEntity(0, Entities.D_X_TradeShip, GetPosition(self.m_SpawnPos), "TravelingSalesmanShip_Player" ..self.m_PlayerID, orientation);
                Path:new(ID,self.m_Waypoints, nil, nil, nil, nil, true, nil, nil, 300);
                self.m_Status = 1;
            end

        elseif self.m_Status == 1 then
            if IsNear("TravelingSalesmanShip_Player" ..self.m_PlayerID, self.m_Destination, 400) then
                self:IntroduceNewOffer():DisplayInfoMessage();
                self.m_Status = 2;
            end
            
        elseif self.m_Status == 2 then
            local month = Logic.GetCurrentMonth();
            local stop = false;
            for i=1, #self.m_Appearance,1 do
                if month == self.m_Appearance[i][2] then
                    stop = true;
                end
            end

            if stop then
                if self.m_ChangeDiplomacy then
                    SetDiplomacyState(self:GetHumanPlayer(), self.m_PlayerID, DiplomacyStates.EstablishedContact);
                end
                Path:new(GetID("TravelingSalesmanShip_Player" ..self.m_PlayerID), self.m_Reversed, nil, nil, nil, nil, true, nil, nil, 300);
                Logic.RemoveAllOffers(Logic.GetStoreHouse(self.m_PlayerID));
                self.m_Status = 3;
            end

        elseif self.m_Status == 3 then
            if IsNear("TravelingSalesmanShip_Player" ..self.m_PlayerID, self.m_Reversed[#self.m_Reversed], 400) then
                DestroyEntity("TravelingSalesmanShip_Player" ..self.m_PlayerID);
                self.m_Status = 0;
            end
        end
    end
    return self;
end

-- -------------------------------------------------------------------------- --

Core:RegisterBundle("BundleTravelingSalesman");

</code></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/bundleweathermanipulation.lua.html">
            <div class='doclink'>
                <div>BundleWeatherManipulation</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><code>-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia BundleWeatherManipulation                                    # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Mit diesem Modul können Wetterevents und Wetteranimationen kombiniert
-- gestartet werden.
--
-- @within Modulbeschreibung
-- @set sort=true
--
BundleWeatherManipulation = {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Erzeugt ein neues Wetterevent und gibt es zurück.
-- @param[type=string]  _GFX Verwendetes Display Set
-- @param[type=boolean] _Rain Niederschlag aktivieren
-- @param[type=boolean] _Snow Niederschlag ist Schnee
-- @param[type=boolean] _Ice Wasser gefriert
-- @param[type=boolean] _Monsoon Blockendes Monsunwasser aktivieren
-- @param[type=number]  _Temp Temperatur während des Events
-- @param[type=table]   _NotGrowing Liste der nicht nachwachsenden Güter
-- @return[type=table] Neues Wetterevent
-- @within WeatherEvent
--
function API.WeatherEventCreate(_GFX, _Rain, _Snow, _Ice, _Monsoon, _Temp, _NotGrowing)
    if GUI then
        fatal("API.WeatherEventCreate: Events must be created in the global script!");
        return;
    end
    
    local Event = WeatherEvent:New();
    Event.GFX = _GFX or Event.GFX;
    Event.Rain = _Rain or Event.Rain;
    Event.Snow = _Snow or Event.Snow;
    Event.Ice = _Ice or Event.Ice;
    Event.Monsoon = _Monsoon or Event.Monsoon;
    Event.Temperature = _Temp or Event.Temperature;
    Event.NotGrowing = NotGrowing or Event.NotGrowing;
    return Event;
end

---
-- Registiert ein Event für eine bestimmte Dauer. Das Event wird auf der
-- "Wartebank" eingereiht.
-- @param[type=table]  _Event     Event-Instanz
-- @param[type=string] _Name      Name des Events
-- @param[type=number] _Duration  Name des Events
-- @within WeatherEvent
--
function API.WeatherEventRegister(_Event, _Name, _Duration)
    if GUI then
        fatal("API.WeatherEventStart: Events must be started in the global script!");
        return;
    end
    if type(_Event) ~= "table" or not _Event.GFX then
        fatal("API.WeatherEventStart: Invalid weather event!");
        return;
    end
    BundleWeatherManipulation.Global:AddEvent(_Event, _Name, _Duration);
end

---
-- Registiert ein Event als Endlosschleife. Das Event wird immer wieder neu
-- starten, kurz bevor es eigentlich endet. Es darf keine anderen Events auf
-- der "Wartebank" geben.
-- @param[type=table]  _Event Event-Instanz
-- @param[type=string] _Name  Name des Events
-- @within WeatherEvent
--
function API.WeatherEventRegisterLoop(_Event, _Name)
    if GUI then
        fatal("API.WeatherEventStartLoop: Events must be started in the global script!");
        return;
    end
    if type(_Event) ~= "table" or not _Event.GFX then
        fatal("API.WeatherEventStartLoop: Invalid weather event!");
        return;
    end
    
    _Event.Loop = function(_Data)
        if _Data.Duration &#x3C;= 36 then
            BundleWeatherManipulation.Global:AddEvent(_Event, _Data.Name, 120);
            BundleWeatherManipulation.Global:StopEvent();
            BundleWeatherManipulation.Global:ActivateEvent();
        end
    end
    BundleWeatherManipulation.Global:AddEvent(_Event, _Name, 120);
end

---
-- Startet das nächste Wetterevent auf der "Wartebank". Wenn bereits ein Event
-- aktiv ist, wird dieses gestoppt. Allerdings bleibt die Animation erhalten.
-- @within WeatherEvent
--
function API.WeatherEventNext()
    BundleWeatherManipulation.Global:StopEvent();
    BundleWeatherManipulation.Global:ActivateEvent();
end

---
-- Bricht das aktuelle Event inklusive der Animation sofort ab.
-- @within WeatherEvent
--
function API.WeatherEventAbort()
    API.Bridge("Display.StopAllEnvironmentSettingsSequences()");
    BundleWeatherManipulation.Global:StopEvent();
end

---
-- Bricht das aktuelle Event ab und löscht alle eingereihten Events.
-- @within WeatherEvent
--
function API.WeatherEventPurge()
    BundleWeatherManipulation.Global:PurgeAllEvents();
    API.Bridge("Display.StopAllEnvironmentSettingsSequences()");
    BundleWeatherManipulation.Global:StopEvent();
end

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

BundleWeatherManipulation = {
    Global = {
        Data = {
            EventQueue = {},
            ActiveEvent = nil,
        },
    },
    Local = {
        Data = {
            ActiveEvent = nil,
        },
    },
}

-- Global Script ------------------------------------------------------------ --

---
-- Installiert das Bundle im globalen Skript.
-- @within WeatherEvent
-- @local
--
function BundleWeatherManipulation.Global:Install()
    API.AddSaveGameAction(self.OnSaveGameLoaded);
    StartSimpleJobEx(self.EventController);
end

---
-- Fügt ein Event zur Event Queue hinzu.
-- @param[type=table]  _Event    Wetterevent
-- @param[type=string] _Name     Name des Events
-- @param[type=string] _Duration Dauer des Ereignisses
-- @within WeatherEvent
-- @local
--
function BundleWeatherManipulation.Global:AddEvent(_Event, _Name, _Duration)
    local Event = API.InstanceTable(_Event);
    Event.Duration = _Duration;
    Event.Name = _Name;
    table.insert(self.Data.EventQueue, Event);
    -- self:NextEvent();
end

---
-- Entfernt alle Events aus der Event Queue, die den gleichen Namen haben.
-- @param[type=string] _EventName Name des Events
-- @within WeatherEvent
-- @local
--
function BundleWeatherManipulation.Global:PurgeEvent(_EventName)
    if #self.Data.EventQueue &#x3E; 0 then
        for i= #self.Data.EventQueue, 1 -1 do
            if self.Data.EventQueue[i].Name == _EventName then
                self.Data.EventQueue:remove(i);
            end
        end
    end
end

---
-- Leer die Event Queue komplett.
-- @within WeatherEvent
-- @local
--
function BundleWeatherManipulation.Global:PurgeAllEvents()
    if #self.Data.EventQueue &#x3E; 0 then
        for i= #self.Data.EventQueue, 1 -1 do
            self.Data.EventQueue:remove(i);
        end
    end
end

---
-- Startet das nächste Wetterevent in der Wetterwarteschlange, aber nur, wenn
-- kein Event aktiv ist.
-- @within WeatherEvent
-- @local
--
function BundleWeatherManipulation.Global:NextEvent()
    if not self:IsEventActive() then
        if #self.Data.EventQueue &#x3E; 0 then
            self:ActivateEvent();
        end
    end
end

---
-- Startet das nächste Wetterevent in der Wetterwarteschlange.
-- @within WeatherEvent
-- @local
--
function BundleWeatherManipulation.Global:ActivateEvent()
    if #self.Data.EventQueue == 0 then
        return;
    end

    local Event = table.remove(self.Data.EventQueue, 1);
    self.Data.ActiveEvent = Event;
    API.Bridge([[
        BundleWeatherManipulation.Local.Data.ActiveEvent = ]] ..API.ConvertTableToString(Event).. [[
        BundleWeatherManipulation.Local:DisplayEvent()
    ]]);
    API.Note("Debug: Event activated")

    Logic.WeatherEventClearGoodTypesNotGrowing();
    for i= 1, #Event.NotGrowing, 1 do
        Logic.WeatherEventAddGoodTypeNotGrowing(Event.NotGrowing[i]);
    end
    if Event.Rain then
        Logic.WeatherEventSetPrecipitationFalling(true);
        Logic.WeatherEventSetPrecipitationHeaviness(1);
        Logic.WeatherEventSetWaterRegenerationFactor(1);
        if Event.Snow then
            Logic.WeatherEventSetPrecipitationIsSnow(true);
        end
    end
    if Event.Ice then
        Logic.WeatherEventSetWaterFreezes(true);
    end
    if Event.Monsoon then
        Logic.WeatherEventSetShallowWaterFloods(true);
    end
    Logic.WeatherEventSetTemperature(Event.Temperature);
    Logic.ActivateWeatherEvent();
end

---
-- Stoppt das aktuelle Wettervent und die Wetteranimation.
-- @within WeatherEvent
-- @local
--
function BundleWeatherManipulation.Global:StopEvent()
    API.Bridge("BundleWeatherManipulation.Local.Data.ActiveEvent = nil");
    BundleWeatherManipulation.Global.Data.ActiveEvent = nil;
    Logic.DeactivateWeatherEvent();
end

---
-- Gibt die verbleibende Dauer des aktuellen Wetterevnts zurück. Ist kein
-- Event aktiv, wird 0 zurückgegeben.
-- @return[type=number] Übrige Dauer des Events
-- @within WeatherEvent
-- @local
--
function BundleWeatherManipulation.Global:GetEventRemainingTime()
    if not self:IsEventActive() then
        return 0;
    end
    return self.Data.ActiveEvent.Duration;
end

---
-- Prüft, ob ein Wetterevent aktiv ist.
-- @return[type=boolean] Event ist aktiv
-- @within WeatherEvent
-- @local
--
function BundleWeatherManipulation.Global:IsEventActive()
    return self.Data.ActiveEvent ~= nil;
end

---
-- Startet nach dem Laden eines Spielstandes die Wetteranimation neu mit
-- der verbleibenden Zeit des Events.
-- @within WeatherEvent
-- @local
--
function BundleWeatherManipulation.Global.OnSaveGameLoaded()
    if BundleWeatherManipulation.Global:IsEventActive() then
        API.Bridge([[
            Display.StopAllEnvironmentSettingsSequences()
            BundleWeatherManipulation.Local:DisplayEvent(]] ..BundleWeatherManipulation.Global:GetEventRemainingTime().. [[)
        ]]);
    end
end

---
-- Steuert die Event Queue und startet das jeweils nächste Event.
-- @within WeatherEvent
-- @local
--
function BundleWeatherManipulation.Global.EventController()
    if BundleWeatherManipulation.Global:IsEventActive() then
        BundleWeatherManipulation.Global.Data.ActiveEvent.Duration = BundleWeatherManipulation.Global.Data.ActiveEvent.Duration -1;
        if BundleWeatherManipulation.Global.Data.ActiveEvent.Loop then
            BundleWeatherManipulation.Global.Data.ActiveEvent:Loop();
        end
        
        if BundleWeatherManipulation.Global.Data.ActiveEvent.Duration == 0 then
            BundleWeatherManipulation.Global:StopEvent();
            BundleWeatherManipulation.Global:NextEvent();
        end
    end
end

-- Local Script ------------------------------------------------------------- --

---
-- Installiert das Bundle im globalen Skript.
-- @within WeatherEvent
-- @local
--
function BundleWeatherManipulation.Local:Install()
end

---
-- Startet die Wetteranimation mit der Duration des Events. Optional kann
-- eine andere Duration angegeben werden.
-- @param[type=number] Optionale Dauer der Animation
-- @within WeatherEvent
-- @local
--
function BundleWeatherManipulation.Local:DisplayEvent(_Duration)
    if self:IsEventActive() then
        local SequenceID = Display.AddEnvironmentSettingsSequence(self.Data.ActiveEvent.GFX);
        Display.PlayEnvironmentSettingsSequence(SequenceID, _Duration or self.Data.ActiveEvent.Duration);
    end
end

---
-- Prüft, ob ein Wetterevent aktiv ist.
-- @return[type=boolean] Event ist aktiv
-- @within WeatherEvent
-- @local
--
function BundleWeatherManipulation.Local:IsEventActive()
    return self.Data.ActiveEvent ~= nil;
end

--------------------------------------------------------------------------------

WeatherEvent = {
    GFX = "ne_winter_sequence.xml",
    NotGrowing = {},
    Rain = false,
    Snow = false,
    Ice = false,
    Monsoon = false,
    Temperature = 10,
}

---
-- Erstellt ein neues Wetterevent.
--
-- Ein Wetterevent ist standardmäßig eingestellt. Es gibt keinen Niederschlag,
-- und keinen Monsun, alle Güter wachsen, die Temperatur ist 10°C und als
-- GFX wird ne_winter_sequence.xml verwendet.
--
-- Um Werte anzupassen muss auf die Felder in einem neuen Wetterevent
-- zugegriffen werden. Ein Beispiel:
-- &#x3C;pre&#x3E;MyEvent.GFX = "as_winter_sequence.xml"&#x3C;/pre&#x3E;
--
-- Um Güter, die nicht nachwachsen sollen, hinzuzufügen, muss auf das Table
-- NotGrowing zugegriffen werden. Ein Beispiel:
-- &#x3C;pre&#x3E;MyEvent.NotGrowing:insert(Goods.G_Grain)&#x3C;/pre&#x3E;
--
-- Ein einmal erstelltes Event kann immer wieder verwendet werden! Speichere
-- es also in einer globalen Variable.
--
-- Ein Event hat folgende Felder:
-- &#x3C;table border="1"&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;&#x3C;b&#x3E;Feld&#x3C;/b&#x3E;&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;&#x3C;b&#x3E;Erklärung&#x3C;/b&#x3E;&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;GFX&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;String: Die verwendete Display-Animation. Hierbei muss es sich im eine
-- dynamische Display-Animation handeln.&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;NotGrowing&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Table: Liste aller nicht nachwachsender Güter während des Events.&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;Rain&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Boolean: Niederschlag fällt während des Events.&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;Snow&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Boolean: Der Niederschlag fällt als Schnee.&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;Ice&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Boolean: Wasser gefriert während des Events.&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;Monsoon&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Boolean: Monsunwasser ist während des Events aktiv.&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;Temperature&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Number: Die Temperatur während des Events in °C.&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;/table&#x3E;
--
-- @within WeatherEvent
-- @local
-- @usage MyEvent = WeatherEvent:New();
--
function WeatherEvent:New()
    return API.InstanceTable(self);
end

--------------------------------------------------------------------------------

Core:RegisterBundle("BundleWeatherManipulation");

</code></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/addoncastlestore.lua.html">
            <div class='doclink'>
                <div>AddOnCastleStore</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><code>-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia AddOnCastleStore                                             # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Dieses Bundle stellt ein Burglager zur Verfügung, das sich ähnlich wie das
-- normale Lager verhält. Das Burglager ist von der Ausbaustufe der Burg
-- abhängig. Je weiter die Burg ausgebaut wird, desto höher ist das Limit.
-- Eine Ware wird dann im Burglager eingelagert, wenn das eingestellte Limit
-- der Ware im Lagerhaus erreicht wird.
--
-- Der Spieler kann das allgemeine Verhalten des Lagers für alle Waren wählen
-- und zusätzlich für einzelne Waren andere Verhalten bestimmen. Waren können
-- eingelagert und ausgelagert werden. Eingelagerte Waren können zusätzlich
-- gesperrt werden. Eine gesperrte Ware wird nicht wieder ausgelagert, auch
-- wenn Platz im Lager frei wird.
--
-- Muss ein Spieler einen Tribut aus dem lagerhaus begleichen, eine bestimmte
-- Menge an Waren erreichen oder die Kosten Zur aktivierung eines interaktien
-- Objektes bezahlen, werden die Güter im Burglager automatisch mit einbezogen,
-- wenn sie nicht gesperrt wurden.
--
-- Das wichtigste Auf einen Blick:
-- &#x3C;ul&#x3E;
-- &#x3C;li&#x3E;
-- &#x3C;a href="#API.CastleStoreCreate"&#x3E;Burglager in der Burg anlegen&#x3C;/a&#x3E;
-- &#x3C;/li&#x3E;
-- &#x3C;li&#x3E;
-- &#x3C;a href="#API.CastleStoreCountGood"&#x3E;Warenmenge in der Burg abfragen&#x3C;/a&#x3E;
-- &#x3C;/li&#x3E;
-- &#x3C;li&#x3E;
-- &#x3C;a href="#API.CastleStoreAddGood"&#x3E;Waren dem Burglager hinzufügen&#x3C;/a&#x3E;
-- &#x3C;/li&#x3E;
-- &#x3C;li&#x3E;
-- &#x3C;a href="#API.CastleStoreRemoveGood"&#x3E;Waren aus der Burg entfernen&#x3C;/a&#x3E;
-- &#x3C;/li&#x3E;
-- &#x3C;/ul&#x3E;
--
-- @within Modulbeschreibung
-- @set sort=true
--
AddOnCastleStore = {};

API = API or {};
QSB = QSB or {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Erstellt ein Burglager für den angegebenen Spieler.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @return[type=table] Burglager-Instanz
-- @within Anwenderfunktionen
-- @usage
-- API.CastleStoreCreate(1);
--
function API.CastleStoreCreate(_PlayerID)
    if GUI then
        API.Bridge("API.CastleStoreCreate(" .._PlayerID.. ")");
        return;
    end
    return QSB.CastleStore:New(_PlayerID);
end

---
-- Zerstört das Burglager des angegebenen Spielers.
--
-- Alle Waren im Burglager werden dabei unwiederuflich gelöscht!
--
-- @param[type=number] _PlayerID ID des Spielers
-- @within Anwenderfunktionen
-- @usage
-- API.CastleStoreDestroy(1)
--
function API.CastleStoreDestroy(_PlayerID)
    if GUI then
        API.Bridge("API.CastleStoreCreate(" .._PlayerID.. ")");
        return;
    end
    local Store = QSB.CastleStore:GetInstance(_PlayerID);
    if Store then
        Store:Dispose();
    end
end

---
-- Fügt dem Burglager des Spielers eine Menga an Waren hinzu.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _Good Typ der Ware
-- @param[type=number] _Amount Menge der Ware
-- @within Anwenderfunktionen
-- @usage
-- API.CastleStoreAddGood(1, Goods.G_Wood, 50);
--
function API.CastleStoreAddGood(_PlayerID, _Good, _Amount)
    if GUI then
        API.Bridge("API.CastleStoreAddGood(" .._PlayerID.. "," .._Good.. "," .._Amount.. ")");
        return;
    end
    local Store = QSB.CastleStore:GetInstance(_PlayerID);
    if Store then
        Store:Add(_Good, _Amount);
    end
end

---
-- Entfernt eine Menge von Waren aus dem Burglager des Spielers.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _Good Typ der Ware
-- @param[type=number] _Amount Menge der Ware
-- @within Anwenderfunktionen
-- @usage
-- API.CastleStoreRemoveGood(1, Goods.G_Iron, 15);
--
function API.CastleStoreRemoveGood(_PlayerID, _Good, _Amount)
    if GUI then
        API.Bridge("API.CastleStoreRemoveGood(" .._PlayerID.. "," .._Good.. "," .._Amount.. ")");
        return;
    end
    local Store = QSB.CastleStore:GetInstance(_PlayerID);
    if Store then
        Store:Remove(_Good, _Amount);
    end
end

---
-- Gibt die Menge an Waren des Typs im Burglager des Spielers zurück.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _Good Typ der Ware
-- @return[type=number] Menge an Waren
-- @within Anwenderfunktionen
-- @usage
-- local Amount = API.CastleStoreCountGood(1, Goods.G_Milk);
--
function API.CastleStoreGetGoodAmount(_PlayerID, _Good)
    if GUI then
        return QSB.CastleStore:GetAmount(_PlayerID, _Good);
    end
    local Store = QSB.CastleStore:GetInstance(_PlayerID);
    if Store then
        return Store:GetAmount(_Good);
    end
    return 0;
end

---
-- Gibt die Gesamtmenge aller Waren im Burglager zurück.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @return[type=number] Menge an Waren
-- @within Anwenderfunktionen
-- @usage
-- local Amount = API.CastleStoreTotalAmount(1);
--
function API.CastleStoreGetTotalAmount(_PlayerID)
    if GUI then
        return QSB.CastleStore:GetTotalAmount(_PlayerID);
    end
    local Store = QSB.CastleStore:GetInstance(_PlayerID);
    if Store then
        return Store:GetTotalAmount();
    end
    return 0;
end

---
-- Gibt die maximale Kapazität des Burglagers zurück.
-- @param[type=number] _PlayerID ID des Spielers
-- @return[type=number] Große des Lagers
-- @within Anwenderfunktionen
-- @usage
-- local Size = API.CastleStoreGetSize(1);
--
function API.CastleStoreGetSize(_PlayerID)
    if GUI then
        return QSB.CastleStore:GetLimit(_PlayerID);
    end
    local Store = QSB.CastleStore:GetInstance(_PlayerID);
    if Store then
        return Store:GetLimit();
    end
    return 0;
end

---
-- Setzt die Basiskapazität des Burglagers.
--
-- Die Basiskapazität ist das Limit der ersten Stufe der Burg. Mit jedem
-- Ausbau wird dieser Wert verdoppelt.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _Capacity Basisgröße des Lagers
-- @within Anwenderfunktionen
-- @usage
-- -- -&#x3E; [150, 300, 600, 1200]
-- API.CastleStoreSetBaseCapacity(1, 150);
--
function API.CastleStoreSetBaseCapacity(_PlayerID, _Capacity)
    if GUI then
        API.Bridge("API.CastleStoreSetBaseCapacity(" .._PlayerID.. "," .._Capacity.. ")");
        return;
    end
    local Store = QSB.CastleStore:GetInstance(_PlayerID);
    if Store then
        Store:SetStorageLimit(_Capacity);
    end
end

---
-- Setzt die Obergrenze ab der ins Burglager ausgelagert wird.
--
-- @param[type=number] _PlayerID ID des Spielers
-- @param[type=number] _Good     Warentyp
-- @param[type=number] _Limit    Obergrenze
-- @within Anwenderfunktionen
-- @usage
-- API.CastleStoreSetOutsourceBoundary(1, Goods.G_Milk, 50);
--
function API.CastleStoreSetOutsourceBoundary(_PlayerID, _Good, _Limit)
    if GUI then
        API.Bridge("API.CastleStoreOutsourceBoundary(" .._PlayerID.. "," .._Good.. "," .._Limit.. ")");
        return;
    end
    local Store = QSB.CastleStore:GetInstance(_PlayerID);
    if Store then
        Stores:SetUperLimitInStorehouseForGoodType(_Good, _Limit)
    end
end

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

AddOnCastleStore = {
    Global = {
        Data = {
            UpdateCastleStore = false,
            CastleStoreObjects = {},
        },
        CastleStore = {
            Data = {
                CapacityBase = 75,
                Goods = {
                    -- [Ware] = {Menge, Einlager-Flag, Gesperrt-Flag, Untergrenze}
                    [Goods.G_Wood]      = {0, true, false, 35},
                    [Goods.G_Stone]     = {0, true, false, 35},
                    [Goods.G_Iron]      = {0, true, false, 35},
                    [Goods.G_Carcass]   = {0, true, false, 15},
                    [Goods.G_Grain]     = {0, true, false, 15},
                    [Goods.G_RawFish]   = {0, true, false, 15},
                    [Goods.G_Milk]      = {0, true, false, 15},
                    [Goods.G_Herb]      = {0, true, false, 15},
                    [Goods.G_Wool]      = {0, true, false, 15},
                    [Goods.G_Honeycomb] = {0, true, false, 15},
                }
            },
        },
    },
    Local = {
        Data = {},

        CastleStore = {
            Data = {}
        },

        Description = {
            ShowCastle = {
                Text = {
                    de = "Finanzansicht",
                    en = "Financial view",
                },
            },

            ShowCastleStore = {
                Text = {
                    de = "Lageransicht",
                    en = "Storeage view",
                },
            },

            GoodButtonDisabled = {
                Text = {
                    de = "Diese Ware wird nicht angenommen.",
                    en = "This good will not be stored.",
                },
            },

            CityTab = {
                Title = {
                    de = "Güter verwaren",
                    en = "Keep goods",
                },
                Text = {
                    de = "[UMSCHALT + N]{cr}- Lagert Waren im Burglager ein {cr}- Waren verbleiben auch im Lager, wenn Platz vorhanden ist",
                    en = "[SHIFT + N]{cr}- Stores goods inside the vault {cr}- Goods also remain in the warehouse when space is available",
                },
            },

            StorehouseTab = {
                Title = {
                    de = "Güter zwischenlagern",
                    en = "Store in vault",
                },
                Text = {
                    de = "[UMSCHALT + B]{cr}- Lagert Waren im Burglager ein {cr}- Lagert waren wieder aus, sobald Platz frei wird",
                    en = "[SHIFT + B]{cr}- Stores goods inside the vault {cr}- Allows to extrac goods as soon as space becomes available",
                },
            },

            MultiTab = {
                Title = {
                    de = "Lager räumen",
                    en = "Clear store",
                },
                Text = {
                    de = "[UMSCHALT + M]{cr}- Lagert alle Waren aus {cr}- Benötigt Platz im Lagerhaus",
                    en = "[Shift + M]{cr}- Removes all goods {cr}- Requires space in the storehouse",
                },
            },
        },
    },
}

-- Global Script ---------------------------------------------------------------

---
-- Initalisiert das Bundle im globalen Skript.
--
-- @within Internal
-- @local
--
function AddOnCastleStore.Global:Install()
    QSB.CastleStore = self.CastleStore;
    self:OverwriteGameFunctions()
    API.AddSaveGameAction(self.OnSaveGameLoaded);
end

---
-- Erzeugt ein neues Burglager-Objekt und gibt es zurück.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: QSB.CastleStore:New&#x3C;/p&#x3E;
--
-- @param _PlayerID [number] PlayerID des Spielers
-- @return [table] QSB.CastleStore Instanz
-- @within QSB.CastleStore
-- @local
--
-- @usage
-- -- Erstellt ein Burglager für Spieler 1
-- local Store = QSB.CastleStore:new(1);
--
function AddOnCastleStore.Global.CastleStore:New(_PlayerID)
    assert(self == AddOnCastleStore.Global.CastleStore, "Can not be used from instance!");
    local Store = API.InstanceTable(self);
    Store.Data.PlayerID = _PlayerID;
    AddOnCastleStore.Global.Data.CastleStoreObjects[_PlayerID] = Store;

    if not self.Data.UpdateCastleStore then
        self.Data.UpdateCastleStore = true;
        StartSimpleHiResJobEx(AddOnCastleStore.Global.CastleStore.UpdateStores);
    end
    Logic.ExecuteInLuaLocalState([[
        QSB.CastleStore:CreateStore(]] ..Store.Data.PlayerID.. [[);
    ]])
    return Store;
end

---
-- Gibt die Burglagerinstanz für den Spieler zurück.
--
-- Wurde kein Burglager für den Spieler erstellt, wird nil zurückgegeben.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: QSB.CastleStore:GetInstance&#x3C;/p&#x3E;
--
-- @param _PlayerID [number] PlayerID des Spielers
-- @return [table] QSB.CastleStore Instanz
-- @within QSB.CastleStore
-- @local
--
-- @usage
-- -- Ermittelt das Burglager von Spieler 1
-- local Store = QSB.CastleStore:GetInstance(1);
--
function AddOnCastleStore.Global.CastleStore:GetInstance(_PlayerID)
    assert(self == AddOnCastleStore.Global.CastleStore, "Can not be used from instance!");
    return AddOnCastleStore.Global.Data.CastleStoreObjects[_PlayerID];
end

---
-- Gibt die Menge an Waren des Spielers zurück, eingeschlossen
-- der Waren im Burglager. Hat der Spieler kein Burglager, wird
-- nur die Menge im Lagerhaus zurückgegeben.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: QSB.CastleStore:GetGoodAmountWithCastleStore&#x3C;/p&#x3E;
--
-- @param _Good [number] Warentyp
-- @param _PlayerIDvID des Spielers
-- @return [number] Warenmenge mit Menge in Burglager
-- @within QSB.CastleStore
-- @local
--
-- @usage
-- -- Menge an Holz in beiden Lagern
-- local WoodAmount = QSB.CastleStore:GetGoodAmountWithCastleStore(Goods.G_Wood, 1);
--
function AddOnCastleStore.Global.CastleStore:GetGoodAmountWithCastleStore(_Good, _PlayerID)
    assert(self == AddOnCastleStore.Global.CastleStore, "Can not be used from instance!");
    local CastleStore = self:GetInstance(_PlayerID);
    local Amount = GetPlayerGoodsInSettlement(_Good, _PlayerID, true);

    if CastleStore ~= nil and _Good ~= Goods.G_Gold and Logic.GetGoodCategoryForGoodType(_Good) == GoodCategories.GC_Resource then
        Amount = Amount + CastleStore:GetAmount(_Good);
    end
    return Amount;
end

---
-- Zerstört das Burglager.
--
-- Die Burg wird dabei natürlich nicht zerstört.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: QSB.CastleStore:Dispose&#x3C;/p&#x3E;
--
-- @within QSB.CastleStore
-- @local
--
-- @usage
-- -- Löschen des Burglagers von Spieler 1 ohne Referenz
-- QSB.CastleStore:GetInstance(1):Dispose();
-- -- Loschen mit Referenzvariable (z.B. Store)
-- Store:Dispose();
--
function AddOnCastleStore.Global.CastleStore:Dispose()
    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");
    Logic.ExecuteInLuaLocalState([[
        QSB.CastleStore:DeleteStore(]] ..self.Data.PlayerID.. [[);
    ]])
    AddOnCastleStore.Global.Data.CastleStoreObjects[self.Data.PlayerID] = nil;
end

---
-- Setzt die Obergrenze für eine Ware, ab der ins Burglager
-- ausgelagert wird.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: QSB.CastleStore:SetUperLimitInStorehouseForGoodType&#x3C;/p&#x3E;
--
-- @param _Good [number] Warentyp
-- @param _Limit [number] Obergrenze
-- @return self
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Global.CastleStore:SetUperLimitInStorehouseForGoodType(_Good, _Limit)
    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");
    self.Data.Goods[_Good][4] = _Limit;
    Logic.ExecuteInLuaLocalState([[
        AddOnCastleStore.Local.CastleStore.Data[]] ..self.Data.PlayerID.. [[].Goods[]] .._Good.. [[][4] = ]] .._Limit.. [[
    ]])
    return self;
end

---
-- Setzt den Basiswert für die maximale Kapazität des Burglagers.
--
-- Der Basiswert dient zur Berechnung der Kapazität für die Ausbaustufen und
-- muss durch 2 teilbar sein.
--
-- Ist also der Basiswert 150, ergibt sich daraus:
-- &#x3C;code&#x3E;
-- 150, 300, 600, 1200
-- &#x3C;/code&#x3E;
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: QSB.CastleStore:SetStorageLimit&#x3C;/p&#x3E;
--
-- @param _Limit [number] Maximale Kapazität
-- @return self
-- @within QSB.CastleStore
-- @local
--
-- @usage
-- -- Basiswert auf 100 setzen.
-- -- -&#x3E; [100, 200, 400, 800]
-- QSB.CastleStore:GetInstance(1):SetStorageLimit(100);
--
function AddOnCastleStore.Global.CastleStore:SetStorageLimit(_Limit)
    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");
    self.Data.CapacityBase = math.floor(_Limit/2);
    Logic.ExecuteInLuaLocalState([[
        AddOnCastleStore.Local.CastleStore.Data[]] ..self.Data.PlayerID.. [[].CapacityBase = ]] ..math.floor(_Limit/2).. [[
    ]])
    return self;
end

---
-- Gibt die Menge an Waren des Typs im Burglager zurück.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: QSB.CastleStore:GetAmount&#x3C;/p&#x3E;
--
-- @param _Good [number] Warentyp
-- @return [number] Menge an Waren im Burglager
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Global.CastleStore:GetAmount(_Good)
    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");
    if self.Data.Goods[_Good] then
        return self.Data.Goods[_Good][1];
    end
    return 0;
end

---
-- Gibt die Gesamtmenge aller Waren im Burglager zurück.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: QSB.CastleStore:GetTotalAmount&#x3C;/p&#x3E;
--
-- @return [number] Gesamtmenge aller Waren
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Global.CastleStore:GetTotalAmount()
    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");
    local TotalAmount = 0;
    for k, v in pairs(self.Data.Goods) do
        TotalAmount = TotalAmount + v[1];
    end
    return TotalAmount;
end

---
-- Gibt das aktuelle Lagerlimit zurück.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: QSB.CastleStore:GetLimit&#x3C;/p&#x3E;
--
-- @return [number] Lagerlimt in der Burg
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Global.CastleStore:GetLimit()
    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");
    local Level = 0;
    local Headquarters = Logic.GetHeadquarters(self.Data.PlayerID);
    if Headquarters ~= 0 then
        Level = Logic.GetUpgradeLevel(Headquarters);
    end

    local Capacity = self.Data.CapacityBase;
    for i= 1, (Level+1), 1 do
        Capacity = Capacity * 2;
    end
    return Capacity;
end

---
-- Gibt zurück, ob die Ware akzeptiert wird.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: QSB.CastleStore:IsGoodAccepted&#x3C;/p&#x3E;
--
-- @param _Good [number] Warentyp
-- @return [boolean] Ware wird akzeptiert
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Global.CastleStore:IsGoodAccepted(_Good)
    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");
    return self.Data.Goods[_Good][2] == true;
end

---
-- Setzt, ob die Ware akzeptiert wird.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: QSB.CastleStore:SetGoodAccepted&#x3C;/p&#x3E;
--
-- @param _Good [number] Watentyp
-- @param _Flag [boolean] Akzeptanz-Flag
-- @return self
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Global.CastleStore:SetGoodAccepted(_Good, _Flag)
    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");
    self.Data.Goods[_Good][2] = _Flag == true;
    Logic.ExecuteInLuaLocalState([[
        QSB.CastleStore:SetAccepted(
            ]] ..self.Data.PlayerID.. [[, ]] .._Good.. [[, ]] ..tostring(_Flag == true).. [[
        )
    ]])
    return self;
end

---
-- Gibt zurück, ob die Ware gesperrt ist.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: QSB.CastleStore:IsGoodLocked&#x3C;/p&#x3E;
--
-- @param _Good [number] Warentyp
-- @return [boolean] Ware ist gesperrt
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Global.CastleStore:IsGoodLocked(_Good)
    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");
    return self.Data.Goods[_Good][3] == true;
end

---
-- Setzt ob die Ware gesperrt ist, also nicht ausgelagert wird.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: QSB.CastleStore:SetGoodLocked&#x3C;/p&#x3E;
--
-- @param _Good [number] Watentyp
-- @param _Flag [boolean] Akzeptanz-Flag
-- @return self
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Global.CastleStore:SetGoodLocked(_Good, _Flag)
    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");
    self.Data.Goods[_Good][3] = _Flag == true;
    Logic.ExecuteInLuaLocalState([[
        QSB.CastleStore:SetLocked(
            ]] ..self.Data.PlayerID.. [[, ]] .._Good.. [[, ]] ..tostring(_Flag == true).. [[
        )
    ]])
    return self;
end

---
-- Setzt den Modus "Zwischenlagerung", als ob der Tab geklickt wird.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: QSB.CastleStore:ActivateTemporaryMode&#x3C;/p&#x3E;
--
-- @return self
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Global.CastleStore:ActivateTemporaryMode()
    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");
    Logic.ExecuteInLocalLuaState([[
        QSB.CastleStore.OnStorehouseTabClicked(QSB.CastleStore, ]] ..self.Data.PlayerID.. [[)
    ]])
    return self;
end

---
-- Setzt den Modus "Verwahrung", als ob der Tab geklickt wird.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: QSB.CastleStore:ActivateStockMode&#x3C;/p&#x3E;
--
-- @return self
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Global.CastleStore:ActivateStockMode()
    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");
    Logic.ExecuteInLocalLuaState([[
        QSB.CastleStore.OnCityTabClicked(QSB.CastleStore, ]] ..self.Data.PlayerID.. [[)
    ]])
    return self;
end

---
-- Setzt den Modus "Auslagerung", als ob der Tab geklickt wird.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: QSB.CastleStore:ActivateOutsourceMode&#x3C;/p&#x3E;
--
-- @return self
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Global.CastleStore:ActivateOutsourceMode()
    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");
    Logic.ExecuteInLocalLuaState([[
        QSB.CastleStore.OnMultiTabClicked(QSB.CastleStore, ]] ..self.Data.PlayerID.. [[)
    ]])
    return self;
end

---
-- Lagert eine Menge von Waren im Burglager ein.
-- &#x3C;p&#x3E;Die Ware wird eingelagert wenn die Ware angenommen wird und noch
-- Platz im Burglager vorhanden ist.&#x3C;/p&#x3E;
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: QSB.CastleStore:Store&#x3C;/p&#x3E;
--
-- @param _Good [number] Watentyp
-- @param _Amount [number] Menge
-- @return self
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Global.CastleStore:Store(_Good, _Amount)
    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");
    if self:IsGoodAccepted(_Good) then
        if self:GetLimit() &#x3E;= self:GetTotalAmount() + _Amount then
            local Level = Logic.GetUpgradeLevel(Logic.GetHeadquarters(self.Data.PlayerID));
            if GetPlayerResources(_Good, self.Data.PlayerID) &#x3E; (self.Data.Goods[_Good][4] * (Level+1)) then
                AddGood(_Good, _Amount * (-1), self.Data.PlayerID);
                self.Data.Goods[_Good][1] = self.Data.Goods[_Good][1] + _Amount;
                Logic.ExecuteInLuaLocalState([[
                    QSB.CastleStore:SetAmount(
                        ]] ..self.Data.PlayerID.. [[, ]] .._Good.. [[, ]] ..self.Data.Goods[_Good][1].. [[
                    )
                ]]);
            end
        end
    end
    return self;
end

---
-- Lagert eine Menge von Waren aus dem Burglager aus.
-- &#x3C;p&#x3E;Die Ware wird ausgelagert wenn noch Platz im Lagerhaus vorhanden ist.&#x3C;/p&#x3E;
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: QSB.CastleStore:Outsource&#x3C;/p&#x3E;
--
-- @param _Good [number] Watentyp
-- @param _Amount [number] Menge
-- @return self
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Global.CastleStore:Outsource(_Good, _Amount)
    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");
    local Level = Logic.GetUpgradeLevel(Logic.GetHeadquarters(self.Data.PlayerID));
    if Logic.GetPlayerUnreservedStorehouseSpace(self.Data.PlayerID) &#x3E;= _Amount then
        if self:GetAmount(_Good) &#x3E;= _Amount then
            AddGood(_Good, _Amount, self.Data.PlayerID);
            self.Data.Goods[_Good][1] = self.Data.Goods[_Good][1] - _Amount;
            Logic.ExecuteInLuaLocalState([[
                QSB.CastleStore:SetAmount(
                    ]] ..self.Data.PlayerID.. [[, ]] .._Good.. [[, ]] ..self.Data.Goods[_Good][1].. [[
                )
            ]]);
        end
    end
    return self;
end

---
-- Fügt eine Menge an Waren dem Burglager hinzu, solange noch
-- Platz vorhanden ist.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: QSB.CastleStore:Add&#x3C;/p&#x3E;
--
-- @param _Good [number] Watentyp
-- @param _Amount [number] Menge
-- @return self
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Global.CastleStore:Add(_Good, _Amount)
    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");
    for i= 1, _Amount, 1 do
        if self:GetLimit() &#x3E; self:GetTotalAmount() then
            self.Data.Goods[_Good][1] = self.Data.Goods[_Good][1] + 1;
        end
    end
    Logic.ExecuteInLuaLocalState([[
        QSB.CastleStore:SetAmount(
            ]] ..self.Data.PlayerID.. [[, ]] .._Good.. [[, ]] ..self.Data.Goods[_Good][1].. [[
        )
    ]]);
    return self;
end

---
-- Entfernt eine Menge an Waren aus dem Burglager ohne sie ins
-- Lagerhaus zu legen.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: QSB.CastleStore:Remove&#x3C;/p&#x3E;
--
-- @param _Good [number] Watentyp
-- @param _Amount [number] Menge
-- @return self
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Global.CastleStore:Remove(_Good, _Amount)
    assert(self ~= AddOnCastleStore.Global.CastleStore, "Can not be used in static context!");
    if self:GetAmount(_Good) &#x3E; 0 then
        local ToRemove = (_Amount &#x3C;= self:GetAmount(_Good) and _Amount) or self:GetAmount(_Good);
        self.Data.Goods[_Good][1] = self.Data.Goods[_Good][1] - ToRemove;
        Logic.ExecuteInLuaLocalState([[
            QSB.CastleStore:SetAmount(
                ]] ..self.Data.PlayerID.. [[, ]] .._Good.. [[, ]] ..self.Data.Goods[_Good][1].. [[
            )
        ]]);
    end
    return self;
end

---
-- Aktualisiert die Waren im Lager und im Burglager.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: QSB.CastleStore.UpdateStores&#x3C;/p&#x3E;
--
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Global.CastleStore.UpdateStores()
    assert(self == nil, "This method is only procedural!");
    for k, v in pairs(AddOnCastleStore.Global.Data.CastleStoreObjects) do
        if v ~= nil and Logic.GetStoreHouse(k) ~= 0 then
            local Level = Logic.GetUpgradeLevel(Logic.GetHeadquarters(v.Data.PlayerID));
            for kk, vv in pairs(v.Data.Goods) do
                if vv ~= nil then
                    -- Ware wird angenommen
                    if vv[2] == true then
                        local AmountInStore  = GetPlayerResources(kk, v.Data.PlayerID)
                        local AmountInCastle = v:GetAmount(kk)
                        -- Auslagern, wenn möglich
                        if AmountInStore &#x3C; (v.Data.Goods[kk][4] * (Level+1)) then
                            if vv[3] == false then
                                v:Outsource(kk, 1);
                            end
                        -- Einlagern, falls möglich
                        else
                            v:Store(kk, 1);
                        end
                    -- Ware ist gebannt
                    else
                        v:Outsource(kk, 1);
                    end
                end
            end
        end
    end
end

---
-- Wirt ausgeführt, nachdem ein Spielstand geladen wurde. Diese Funktion Stellt
-- alle nicht persistenten Änderungen wieder her.
--
-- @within Internal
-- @local
--
function AddOnCastleStore.Global.OnSaveGameLoaded()
    API.Bridge("AddOnCastleStore.Local:OverwriteGetStringTableText()")
    API.Bridge("AddOnCastleStore.Local.CastleStore:ActivateHotkeys()")
end

---
-- Überschreibt die globalen Spielfunktionen, die mit dem Burglager in
-- Konfilckt stehen.
--
-- @within Internal
-- @local
--
function AddOnCastleStore.Global:OverwriteGameFunctions()
    QuestTemplate.IsObjectiveCompleted_Orig_QSB_CastleStore = QuestTemplate.IsObjectiveCompleted;
    QuestTemplate.IsObjectiveCompleted = function(self, objective)
        local objectiveType = objective.Type;
        local data = objective.Data;

        if objective.Completed ~= nil then
            return objective.Completed;
        end

        if objectiveType == Objective.Produce then
            local GoodAmount = GetPlayerGoodsInSettlement(data[1], self.ReceivingPlayer, true);
            local CastleStore = QSB.CastleStore:GetInstance(self.ReceivingPlayer);
            if CastleStore and Logic.GetGoodCategoryForGoodType(data[1]) == GoodCategories.GC_Resource then
                GoodAmount = GoodAmount + CastleStore:GetAmount(data[1]);
            end
            if (not data[3] and GoodAmount &#x3E;= data[2]) or (data[3] and GoodAmount &#x3C; data[2]) then
                objective.Completed = true;
            end
        else
            return QuestTemplate.IsObjectiveCompleted_Orig_QSB_CastleStore(self, objective);
        end
    end

    QuestTemplate.SendGoods = function(self)
        for i=1, self.Objectives[0] do
            if self.Objectives[i].Type == Objective.Deliver then
                if self.Objectives[i].Data[3] == nil then
                    local goodType = self.Objectives[i].Data[1]
                    local goodQuantity = self.Objectives[i].Data[2]

                    local amount = QSB.CastleStore:GetGoodAmountWithCastleStore(goodType, self.ReceivingPlayer, true);
                    if amount &#x3E;= goodQuantity then
                        local Sender = self.ReceivingPlayer
                        local Target = self.Objectives[i].Data[6] and self.Objectives[i].Data[6] or self.SendingPlayer

                        local expectedMerchant = {}
                        expectedMerchant.Good = goodType
                        expectedMerchant.Amount = goodQuantity
                        expectedMerchant.PlayerID = Target
                        expectedMerchant.ID = nil
                        self.Objectives[i].Data[5] = expectedMerchant
                        self.Objectives[i].Data[3] = 1
                        QuestMerchants[#QuestMerchants+1] = expectedMerchant

                        if goodType == Goods.G_Gold then
                            local BuildingID = Logic.GetHeadquarters(Sender)
                            if BuildingID == 0 then
                                BuildingID = Logic.GetStoreHouse(Sender)
                            end
                            self.Objectives[i].Data[3] = Logic.CreateEntityAtBuilding(Entities.U_GoldCart, BuildingID, 0, Target)
                            Logic.HireMerchant(self.Objectives[i].Data[3], Target, goodType, goodQuantity, self.ReceivingPlayer)
                            Logic.RemoveGoodFromStock(BuildingID,goodType,goodQuantity)
                            if MapCallback_DeliverCartSpawned then
                                MapCallback_DeliverCartSpawned( self, self.Objectives[i].Data[3], goodType )
                            end

                        elseif goodType == Goods.G_Water then
                            local BuildingID = Logic.GetMarketplace(Sender)

                            self.Objectives[i].Data[3] = Logic.CreateEntityAtBuilding(Entities.U_Marketer, BuildingID, 0, Target)
                            Logic.HireMerchant(self.Objectives[i].Data[3], Target, goodType, goodQuantity, self.ReceivingPlayer)
                            Logic.RemoveGoodFromStock(BuildingID,goodType,goodQuantity)
                            if MapCallback_DeliverCartSpawned then
                                MapCallback_DeliverCartSpawned( self, self.Objectives[i].Data[3], goodType )
                            end

                        else
                            if Logic.GetGoodCategoryForGoodType(goodType) == GoodCategories.GC_Resource then
                                local StorehouseID = Logic.GetStoreHouse(Target)
                                local NumberOfGoodTypes = Logic.GetNumberOfGoodTypesOnOutStock(StorehouseID)
                                if NumberOfGoodTypes ~= nil then
                                    for j = 0, NumberOfGoodTypes-1 do
                                        local StoreHouseGoodType = Logic.GetGoodTypeOnOutStockByIndex(StorehouseID,j)
                                        local Amount = Logic.GetAmountOnOutStockByIndex(StorehouseID, j)
                                        if Amount &#x3E;= goodQuantity then
                                            Logic.RemoveGoodFromStock(StorehouseID, StoreHouseGoodType, goodQuantity, false)
                                        end
                                    end
                                end

                                local SenderStorehouse = Logic.GetStoreHouse(Sender);
                                local AmountInStorehouse = GetPlayerResources(goodType, Sender);
                                if AmountInStorehouse &#x3C; goodQuantity then
                                    -- Entferne aus Lager
                                    local AmountDifference = goodQuantity - AmountInStorehouse;
                                    AddGood(goodType, AmountInStorehouse * (-1), Sender);
                                    -- Entferne aus Burg
                                    local StoreInstance = QSB.CastleStore:GetInstance(self.ReceivingPlayer);
                                    if StoreInstance then
                                        StoreInstance:Remove(goodType, AmountDifference);
                                    end
                                else
                                    -- Entferne aus Lager
                                    AddGood(goodType, goodQuantity * (-1), Sender);
                                end
                                self.Objectives[i].Data[3] = Logic.CreateEntityAtBuilding(Entities.U_ResourceMerchant, SenderStorehouse, 0, Target);
                                Logic.HireMerchant(self.Objectives[i].Data[3], Target, goodType, goodQuantity, self.ReceivingPlayer);
                            else
                                Logic.StartTradeGoodGathering(Sender, Target, goodType, goodQuantity, 0)
                            end
                        end
                    end
                end
            end
        end
    end
end

-- Local Script ----------------------------------------------------------------

---
-- Initalisiert das Bundle im lokalen Skript.
--
-- @within Internal
-- @local
--
function AddOnCastleStore.Local:Install()
    QSB.CastleStore = self.CastleStore;
    self:OverwriteGameFunctions();
    self:OverwriteGetStringTableText();
    -- self:OverwriteInteractiveObject();
end

---
-- Erzeugt eine neue lokale Referenz zum Burglager des Spielers.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: QSB.CastleStore:CreateStore&#x3C;/p&#x3E;
--
-- @param _PlayerID [number] ID des Spielers
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Local.CastleStore:CreateStore(_PlayerID)
    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");
    local Store = {
        StoreMode = 1,
        CapacityBase = 75,
        Goods = {
            [Goods.G_Wood]      = {0, true, false, 35},
            [Goods.G_Stone]     = {0, true, false, 35},
            [Goods.G_Iron]      = {0, true, false, 35},
            [Goods.G_Carcass]   = {0, true, false, 15},
            [Goods.G_Grain]     = {0, true, false, 15},
            [Goods.G_RawFish]   = {0, true, false, 15},
            [Goods.G_Milk]      = {0, true, false, 15},
            [Goods.G_Herb]      = {0, true, false, 15},
            [Goods.G_Wool]      = {0, true, false, 15},
            [Goods.G_Honeycomb] = {0, true, false, 15},
        }
    }
    self.Data[_PlayerID] = Store;
    
    self:ActivateHotkeys();
    self:DescribeHotkeys();
end

---
-- Entfernt eine lokale Referenz auf ein Burglager des Spielers.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: QSB.CastleStore:DeleteStore&#x3C;/p&#x3E;
--
-- @param _PlayerID [number] ID des Spielers
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Local.CastleStore:DeleteStore(_PlayerID)
    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");
    self.Data[_PlayerID] = nil;
end

---
-- Gibt die Menge an Waren des Typs zurück.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: QSB.CastleStore:GetAmount&#x3C;/p&#x3E;
--
-- @param _PlayerID [number] ID des Spielers
-- @param _Good [number] Warentyp
-- @return [number] Menge an Waren
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Local.CastleStore:GetAmount(_PlayerID, _Good)
    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");
    if not self:HasCastleStore(_PlayerID) or not self.Data[_PlayerID].Goods[_Good] then
        return 0;
    end
    return self.Data[_PlayerID].Goods[_Good][1];
end

---
-- Gibt die Menge an Waren des Spielers zurück, eingeschlossen
-- der Waren im Burglager. Hat der Spieler kein Burglager, wird
-- nur die Menge im Lagerhaus zurückgegeben.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: QSB.CastleStore:GetGoodAmountWithCastleStore&#x3C;/p&#x3E;
--
-- @param _Good [number] Warentyp
-- @param _PlayerID [number] ID des Spielers
-- @return [number] Menge an Waren
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Local.CastleStore:GetGoodAmountWithCastleStore(_Good, _PlayerID)
    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");
    local Amount = GetPlayerGoodsInSettlement(_Good, _PlayerID, true);
    if self:HasCastleStore(_PlayerID) then
        if _Good ~= Goods.G_Gold and Logic.GetGoodCategoryForGoodType(_Good) == GoodCategories.GC_Resource then
            Amount = Amount + self:GetAmount(_PlayerID, _Good);
        end
    end
    return Amount;
end

---
-- Gibt die Gesamtmenge aller Waren im Burglager zurück.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: QSB.CastleStore:GetTotalAmount&#x3C;/p&#x3E;
--
-- @param _PlayerID [number] ID des Spielers
-- @return [number] Absolute Menge im Burglager
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Local.CastleStore:GetTotalAmount(_PlayerID)
    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");
    if not self:HasCastleStore(_PlayerID) then
        return 0;
    end
    local TotalAmount = 0;
    for k, v in pairs(self.Data[_PlayerID].Goods) do
        TotalAmount = TotalAmount + v[1];
    end
    return TotalAmount;
end

---
-- Ändert die Menge an Waren des Typs.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: QSB.CastleStore:SetAmount&#x3C;/p&#x3E;
--
-- @param _PlayerID [number] ID des Spielers
-- @param _Good [number] Warentyp
-- @param _Amount [number] Warenmenge
-- @return self
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Local.CastleStore:SetAmount(_PlayerID, _Good, _Amount)
    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");
    if not self:HasCastleStore(_PlayerID) or not self.Data[_PlayerID].Goods[_Good] then
        return;
    end
    self.Data[_PlayerID].Goods[_Good][1] = _Amount;
    return self;
end

---
-- Gibt zurück, ob die Ware des Typs akzeptiert wird.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: QSB.CastleStore:IsAccepted&#x3C;/p&#x3E;
--
-- @param _PlayerID [number] ID des Spielers
-- @param _Good [number] Warentyp
-- @return [boolean] Ware wird angenommen
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Local.CastleStore:IsAccepted(_PlayerID, _Good)
    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");
    if not self:HasCastleStore(_PlayerID) or not self.Data[_PlayerID].Goods[_Good] then
        return false;
    end
    return self.Data[_PlayerID].Goods[_Good][2] == true;
end

---
-- Setzt eine Ware als akzeptiert.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: QSB.CastleStore:SetAccepted&#x3C;/p&#x3E;
--
-- @param _PlayerIDvID des Spielers
-- @param _Good [number] Warentyp
-- @param _Flag [boolean] Akzeptanz-Flag
-- @return self
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Local.CastleStore:SetAccepted(_PlayerID, _Good, _Flag)
    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");
    if self:HasCastleStore(_PlayerID) and self.Data[_PlayerID].Goods[_Good] then
        self.Data[_PlayerID].Goods[_Good][2] = _Flag == true;
    end
    return self;
end

---
-- Gibt zurück, ob die Ware des Typs gesperrt ist.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: QSB.CastleStore:IsLocked&#x3C;/p&#x3E;
--
-- @param _PlayerID [number] ID des Spielers
-- @param _Good [number] Warentyp
-- @return [boolean] Ware ist gesperrt
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Local.CastleStore:IsLocked(_PlayerID, _Good)
    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");
    if not self:HasCastleStore(_PlayerID) or not self.Data[_PlayerID].Goods[_Good] then
        return true;
    end
    return self.Data[_PlayerID].Goods[_Good][3] == true;
end

---
-- Setzt eine Ware als gesperrt.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: QSB.CastleStore:SetLocked&#x3C;/p&#x3E;
--
-- @param _PlayerID [number] ID des Spielers
-- @param _Good [number] Warentyp
-- @param _Flag [boolean] Akzeptanz-Flag
-- @return self
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Local.CastleStore:SetLocked(_PlayerID, _Good, _Flag)
    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");
    if self:HasCastleStore(_PlayerID) and self.Data[_PlayerID].Goods[_Good] then
        self.Data[_PlayerID].Goods[_Good][3] = _Flag == true;
    end
    return self;
end

---
-- Gibt zurück, ob der Spieler ein Burglager hat.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: QSB.CastleStore:HasCastleStore&#x3C;/p&#x3E;
--
-- @param _PlayerID [number] ID des Spielers
-- @return [boolean] Spieler hat ein Burglager
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Local.CastleStore:HasCastleStore(_PlayerID)
    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");
    return self.Data[_PlayerID] ~= nil;
end

---
-- Gibt die Referenz des Burglagers des Spielers zurück.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: QSB.CastleStore:GetStore&#x3C;/p&#x3E;
--
-- @param _PlayerID [number] ID des Spielers
-- @return [table] Instanz des Burglagers
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Local.CastleStore:GetStore(_PlayerID)
    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");
    return self.Data[_PlayerID];
end

---
-- Gibt das aktuelle Lagerlimit des Burglagers zurück.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: QSB.CastleStore:GetLimit&#x3C;/p&#x3E;
--
-- @param _PlayerID [number] ID des Spielers
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Local.CastleStore:GetLimit(_PlayerID)
    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");
    local Level = 0;
    local Headquarters = Logic.GetHeadquarters(_PlayerID);
    if Headquarters ~= 0 then
        Level = Logic.GetUpgradeLevel(Headquarters);
    end

    local Capacity = self.Data[_PlayerID].CapacityBase;
    for i= 1, (Level+1), 1 do
        Capacity = Capacity * 2;
    end
    return Capacity;
end

---
-- "Waren einlagern" wurde geklickt.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: QSB.CastleStore:OnStorehouseTabClicked&#x3C;/p&#x3E;
--
-- @param _PlayerID [number] ID des Spielers
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Local.CastleStore:OnStorehouseTabClicked(_PlayerID)
    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");
    self.Data[_PlayerID].StoreMode = 1;
    self:UpdateBehaviorTabs(_PlayerID);
    GUI.SendScriptCommand([[
        local Store = QSB.CastleStore:GetInstance(]] .._PlayerID.. [[);
        for k, v in pairs(Store.Data.Goods) do
            Store:SetGoodAccepted(k, true);
            Store:SetGoodLocked(k, false);
        end
    ]]);
end

---
-- "Waren verwahren" wurde gedrückt.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: QSB.CastleStore:OnCityTabClicked&#x3C;/p&#x3E;
--
-- @param _PlayerID [number] ID des Spielers
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Local.CastleStore:OnCityTabClicked(_PlayerID)
    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");
    self.Data[_PlayerID].StoreMode = 2;
    self:UpdateBehaviorTabs(_PlayerID);
    GUI.SendScriptCommand([[
        local Store = QSB.CastleStore:GetInstance(]] .._PlayerID.. [[);
        for k, v in pairs(Store.Data.Goods) do
            Store:SetGoodAccepted(k, true);
            Store:SetGoodLocked(k, true);
        end
    ]]);
end

---
-- "Lager räumen" wurde gedrückt.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: QSB.CastleStore:OnMultiTabClicked&#x3C;/p&#x3E;
--
-- @param _PlayerID [number] ID des Spielers
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Local.CastleStore:OnMultiTabClicked(_PlayerID)
    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");
    self.Data[_PlayerID].StoreMode = 3;
    self:UpdateBehaviorTabs(_PlayerID);
    GUI.SendScriptCommand([[
        local Store = QSB.CastleStore:GetInstance(]] .._PlayerID.. [[);
        for k, v in pairs(Store.Data.Goods) do
            Store:SetGoodLocked(k, false);
            Store:SetGoodAccepted(k, false);
        end
    ]]);
end

---
-- Ein GoodType-Button wurde geklickt.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: QSB.CastleStore:GoodClicked&#x3C;/p&#x3E;
--
-- @param _PlayerID [number] ID des Spielers
-- @param _GoodType [number] Warentyp
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Local.CastleStore:GoodClicked(_PlayerID, _GoodType)
    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");
    if self:HasCastleStore(_PlayerID) then
        local CurrentWirgetID = XGUIEng.GetCurrentWidgetID();
        GUI.SendScriptCommand([[
            local Store = QSB.CastleStore:GetInstance(]] .._PlayerID.. [[);
            local Accepted = Store:IsGoodAccepted(]] .._GoodType.. [[)
            local Locked   = Store:IsGoodLocked(]] .._GoodType.. [[)
            
            if Accepted and not Locked then
                Store:SetGoodLocked(]] .._GoodType.. [[, true);
                Store:SetGoodAccepted(]] .._GoodType.. [[, true);
            elseif Accepted and Locked then
                Store:SetGoodLocked(]] .._GoodType.. [[, false);
                Store:SetGoodAccepted(]] .._GoodType.. [[, false);
            elseif not Accepted and not Locked then
                Store:SetGoodAccepted(]] .._GoodType.. [[, true);
            else
                Store:SetGoodLocked(]] .._GoodType.. [[, false);
                Store:SetGoodAccepted(]] .._GoodType.. [[, true);
            end
        ]]);
    end
end

---
-- Der Spieler wechselt zwischen den Ansichten in der Burg.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: QSB.CastleStore:DestroyGoodsClicked&#x3C;/p&#x3E;
--
-- @param _PlayerID [number] ID des Spielers
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Local.CastleStore:DestroyGoodsClicked(_PlayerID)
    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");
    if self:HasCastleStore(_PlayerID) then
        QSB.CastleStore.ToggleStore();
    end
end

---
-- Aktualisiert das Burgmenü, sobald sich die Selektion ändert.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: QSB.CastleStore:SelectionChanged&#x3C;/p&#x3E;
--
-- @param _PlayerID [number] ID des Spielers
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Local.CastleStore:SelectionChanged(_PlayerID)
    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");
    if self:HasCastleStore(_PlayerID) then
        local SelectedID = GUI.GetSelectedEntity();
        if Logic.GetHeadquarters(_PlayerID) == SelectedID then
            self:ShowCastleMenu();
        else
            self:RestoreStorehouseMenu();
        end
    end
end

---
-- Aktualisiert die Burglager-Tabs.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: QSB.CastleStore:UpdateBehaviorTabs&#x3C;/p&#x3E;
--
-- @param _PlayerID [number] ID des Spielers
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Local.CastleStore:UpdateBehaviorTabs(_PlayerID)
    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");
    if not QSB.CastleStore:HasCastleStore(GUI.GetPlayerID()) then
        return;
    end
    XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/TabButtons", 0);
    if self.Data[_PlayerID].StoreMode == 1 then
        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/TabButtons/StorehouseTabButtonUp", 1);
        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/TabButtons/CityTabButtonDown", 1);
        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/TabButtons/Tab03Down", 1);
    elseif self.Data[_PlayerID].StoreMode == 2 then
        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/TabButtons/StorehouseTabButtonDown", 1);
        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/TabButtons/CityTabButtonUp", 1);
        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/TabButtons/Tab03Down", 1);
    else
        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/TabButtons/StorehouseTabButtonDown", 1);
        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/TabButtons/CityTabButtonDown", 1);
        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/TabButtons/Tab03Up", 1);
    end
end

---
-- Aktualisiert die Mengenanzeige der Waren im Burglager.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: QSB.CastleStore:UpdateGoodsDisplay&#x3C;/p&#x3E;
--
-- @param _PlayerID [number] ID des Spielers
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Local.CastleStore:UpdateGoodsDisplay(_PlayerID)
    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");
    if not self:HasCastleStore(_PlayerID) then
        return;
    end

    local MotherContainer  = "/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/InStorehouse/Goods";
    local WarningColor = "";
    if self:GetLimit(_PlayerID) == self:GetTotalAmount(_PlayerID) then
        WarningColor = "{@color:255,32,32,255}";
    end
    for k, v in pairs(self.Data[_PlayerID].Goods) do
        local GoodTypeName = Logic.GetGoodTypeName(k);
        local AmountWidget = MotherContainer.. "/" ..GoodTypeName.. "/Amount";
        local ButtonWidget = MotherContainer.. "/" ..GoodTypeName.. "/Button";
        local BGWidget = MotherContainer.. "/" ..GoodTypeName.. "/BG";
        XGUIEng.SetText(AmountWidget, "{center}" .. WarningColor .. v[1]);
        XGUIEng.DisableButton(ButtonWidget, 0)

        -- Ware ist gesperrt
        if self:IsAccepted(_PlayerID, k) and self:IsLocked(_PlayerID, k) then
            XGUIEng.SetMaterialColor(ButtonWidget, 0, 230, 180, 120, 255);
            XGUIEng.SetMaterialColor(ButtonWidget, 1, 230, 180, 120, 255);
            XGUIEng.SetMaterialColor(ButtonWidget, 7, 230, 180, 120, 255);
        -- Ware wird nicht angenommen
        elseif not self:IsAccepted(_PlayerID, k) and not self:IsLocked(_PlayerID, k) then
            XGUIEng.SetMaterialColor(ButtonWidget, 0, 190, 90, 90, 255);
            XGUIEng.SetMaterialColor(ButtonWidget, 1, 190, 90, 90, 255);
            XGUIEng.SetMaterialColor(ButtonWidget, 7, 190, 90, 90, 255);
        -- Ware wird eingelagert
        else
            XGUIEng.SetMaterialColor(ButtonWidget, 0, 255, 255, 255, 255);
            XGUIEng.SetMaterialColor(ButtonWidget, 1, 255, 255, 255, 255);
            XGUIEng.SetMaterialColor(ButtonWidget, 7, 255, 255, 255, 255);
        end
    end
end

---
-- Aktualisiert die Lagerauslastungsanzeige des Burglagers.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: QSB.CastleStore:UpdateStorageLimit&#x3C;/p&#x3E;
--
-- @param _PlayerID [number] ID des Spielers
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Local.CastleStore:UpdateStorageLimit(_PlayerID)
    assert(self == AddOnCastleStore.Local.CastleStore, "Can not be used from instance!");
    if not self:HasCastleStore(_PlayerID) then
        return;
    end
    local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();
    local PlayerID = GUI.GetPlayerID();
    local StorageUsed = QSB.CastleStore:GetTotalAmount(PlayerID);
    local StorageLimit = QSB.CastleStore:GetLimit(PlayerID);
    local StorageLimitText = XGUIEng.GetStringTableText("UI_Texts/StorageLimit_colon");
    local Text = "{center}" ..StorageLimitText.. " " ..StorageUsed.. "/" ..StorageLimit;
    XGUIEng.SetText(CurrentWidgetID, Text);
end

---
-- Wechselt zwischen der Finanzansicht und dem Burglager.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: QSB.CastleStore:ToggleStore&#x3C;/p&#x3E;
--
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Local.CastleStore:ToggleStore()
    assert(self == nil, "This function is procedural!");
    if QSB.CastleStore:HasCastleStore(GUI.GetPlayerID()) then
        if Logic.GetHeadquarters(GUI.GetPlayerID()) == GUI.GetSelectedEntity() then
            if XGUIEng.IsWidgetShown("/InGame/Root/Normal/AlignBottomRight/Selection/Castle") == 1 then
                QSB.CastleStore.ShowCastleStoreMenu(QSB.CastleStore);
            else
                QSB.CastleStore.ShowCastleMenu(QSB.CastleStore);
            end
        end
    end
end

---
-- Stellt das normale Lagerhausmenü wieder her.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: QSB.CastleStore:RestoreStorehouseMenu&#x3C;/p&#x3E;
--
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Local.CastleStore:RestoreStorehouseMenu()
    XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/TabButtons", 1);
    XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/InCity/Goods", 1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/InCity", 0);
    SetIcon("/InGame/Root/Normal/AlignBottomRight/DialogButtons/PlayerButtons/DestroyGoods", {16, 8});

    local MotherPath = "/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/TabButtons/";
    SetIcon(MotherPath.. "StorehouseTabButtonUp/up/B_StoreHouse", {3, 13});
    SetIcon(MotherPath.. "StorehouseTabButtonDown/down/B_StoreHouse", {3, 13});
    SetIcon(MotherPath.. "CityTabButtonUp/up/CityBuildingsNumber", {8, 1});
    SetIcon(MotherPath.. "TabButtons/CityTabButtonDown/down/CityBuildingsNumber", {8, 1});
    SetIcon(MotherPath.. "TabButtons/Tab03Up/up/B_Castle_ME", {3, 14});
    SetIcon(MotherPath.. "Tab03Down/down/B_Castle_ME", {3, 14});

    for k, v in ipairs {"G_Carcass", "G_Grain", "G_Milk", "G_RawFish", "G_Iron","G_Wood", "G_Stone", "G_Honeycomb", "G_Herb", "G_Wool"} do
        local MotherPath = "/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/InStorehouse/Goods/";
        XGUIEng.SetMaterialColor(MotherPath.. v.. "/Button", 0, 255, 255, 255, 255);
        XGUIEng.SetMaterialColor(MotherPath.. v.. "/Button", 1, 255, 255, 255, 255);
        XGUIEng.SetMaterialColor(MotherPath.. v.. "/Button", 7, 255, 255, 255, 255);
    end
end

---
-- Das normale Burgmenü wird angezeigt.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: QSB.CastleStore:ShowCastleMenu&#x3C;/p&#x3E;
--
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Local.CastleStore:ShowCastleMenu()
    local MotherPath = "/InGame/Root/Normal/AlignBottomRight/";
    XGUIEng.ShowWidget(MotherPath.. "Selection/BGBig", 0)
    XGUIEng.ShowWidget(MotherPath.. "Selection/Storehouse", 0)
    XGUIEng.ShowWidget(MotherPath.. "Selection/BGSmall", 1)
    XGUIEng.ShowWidget(MotherPath.. "Selection/Castle", 1)

    if g_HideSoldierPayment ~= nil then
        XGUIEng.ShowWidget(MotherPath.. "Selection/Castle/Treasury/Payment", 0)
        XGUIEng.ShowWidget(MotherPath.. "Selection/Castle/LimitSoldiers", 0)
    end
    GUI_BuildingInfo.PaymentLevelSliderUpdate()
    GUI_BuildingInfo.TaxationLevelSliderUpdate()
    GUI_Trade.StorehouseSelected()
    local AnchorInfoForSmallX, AnchorInfoForSmallY = XGUIEng.GetWidgetLocalPosition(MotherPath.. "Selection/AnchorInfoForSmall")
    XGUIEng.SetWidgetLocalPosition(MotherPath.. "Selection/Info", AnchorInfoForSmallX, AnchorInfoForSmallY)

    XGUIEng.ShowWidget(MotherPath.. "DialogButtons/PlayerButtons", 1)
    XGUIEng.ShowWidget(MotherPath.. "DialogButtons/PlayerButtons/DestroyGoods", 1)
    XGUIEng.DisableButton(MotherPath.. "DialogButtons/PlayerButtons/DestroyGoods", 0)
    SetIcon(MotherPath.. "DialogButtons/PlayerButtons/DestroyGoods", {10, 9})
end

---
-- Das Burglager wird angezeigt.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: QSB.CastleStore:ShowCastleStoreMenu&#x3C;/p&#x3E;
--
-- @within QSB.CastleStore
-- @local
--
function AddOnCastleStore.Local.CastleStore:ShowCastleStoreMenu()
    local MotherPath = "/InGame/Root/Normal/AlignBottomRight/";
    XGUIEng.ShowWidget(MotherPath.. "Selection/Selection/BGSmall", 0);
    XGUIEng.ShowWidget(MotherPath.. "Selection/Castle", 0);
    XGUIEng.ShowWidget(MotherPath.. "Selection/BGSmall", 0);
    XGUIEng.ShowWidget(MotherPath.. "Selection/BGBig", 1);
    XGUIEng.ShowWidget(MotherPath.. "Selection/Storehouse", 1);
    XGUIEng.ShowWidget(MotherPath.. "Selection/Storehouse/AmountContainer", 0);
    XGUIEng.ShowAllSubWidgets(MotherPath.. "Selection/Storehouse/TabButtons", 1);

    GUI_Trade.StorehouseSelected()
    local AnchorInfoForBigX, AnchorInfoForBigY = XGUIEng.GetWidgetLocalPosition(MotherPath.. "Selection/AnchorInfoForBig")
    XGUIEng.SetWidgetLocalPosition(MotherPath.. "Selection/Info", AnchorInfoForBigX, AnchorInfoForBigY)

    XGUIEng.ShowWidget(MotherPath.. "DialogButtons/PlayerButtons", 1)
    XGUIEng.ShowWidget(MotherPath.. "DialogButtons/PlayerButtons/DestroyGoods", 1)
    XGUIEng.ShowWidget(MotherPath.. "Selection/Storehouse/InStorehouse", 1)
    XGUIEng.ShowWidget(MotherPath.. "Selection/Storehouse/InMulti", 0)
    XGUIEng.ShowWidget(MotherPath.. "Selection/Storehouse/InCity", 1)
    XGUIEng.ShowAllSubWidgets(MotherPath.. "Selection/Storehouse/InCity/Goods", 0);
    XGUIEng.ShowWidget(MotherPath.. "Selection/Storehouse/InCity/Goods/G_Beer", 1)
    XGUIEng.DisableButton(MotherPath.. "DialogButtons/PlayerButtons/DestroyGoods", 0)

    local MotherPathDialog = MotherPath.. "DialogButtons/PlayerButtons/";
    local MotherPathTabs = MotherPath.. "Selection/Storehouse/TabButtons/";
    SetIcon(MotherPathDialog.. "DestroyGoods", {3, 14});
    SetIcon(MotherPathTabs.. "StorehouseTabButtonUp/up/B_StoreHouse", {10, 9});
    SetIcon(MotherPathTabs.. "StorehouseTabButtonDown/down/B_StoreHouse", {10, 9});
    SetIcon(MotherPathTabs.. "CityTabButtonUp/up/CityBuildingsNumber", {15, 6});
    SetIcon(MotherPathTabs.. "CityTabButtonDown/down/CityBuildingsNumber", {15, 6});
    SetIcon(MotherPathTabs.. "Tab03Up/up/B_Castle_ME", {7, 1});
    SetIcon(MotherPathTabs.. "Tab03Down/down/B_Castle_ME", {7, 1});

    self:UpdateBehaviorTabs(GUI.GetPlayerID());
end

---
-- Überschreibt den Bezahlvorgang der Kosten eines interaktiven Objektes.
--
-- @within Internal
-- @local
--
function AddOnCastleStore.Local:OverwriteInteractiveObject()
    BundleInteractiveObjects.Local.OnObjectClicked = function(self, _IO)
        if not self:OnObjectClicked_DoesRewardFitInStorehouse(_IO) then
            return;
        end
        if not self:OnObjectClicked_CanPlayerPayCosts(_IO) then
            return;
        end
        if not self:OnObjectClicked_IsConditionFulfulled(_IO) then
            return;
        end
    
        local PlayerID = GUI.GetPlayerID();
        local EntityID = GetID(_IO.Name);
        if _IO.Costs[1] ~= nil then
            self:BuyObject(PlayerID, _IO.Costs[1], _IO.Costs[2]);
        end
        if _IO.Costs[3] ~= nil then
            self:BuyObject(PlayerID, _IO.Costs[3], _IO.Costs[4]);
        end
        if _IO.Reward[1] ~= nil then
            GUI.SendScriptCommand("GameCallback_ExecuteCustomObjectReward("..PlayerID..",'".._IO.Name.."',".._IO.Reward[1]..",".._IO.Reward[2]..")");
        end
        Play2DSound(pID, _IO.ActivationSound or "menu_left_prestige");
        GUI.SendScriptCommand("GameCallback_OnObjectInteraction("..EntityID..","..PlayerID..")");
    end
    
    BundleInteractiveObjects.Local.CanBeBought = function(self, _PlayerID, _Good, _Amount)
        local AmountOfGoods = GetPlayerGoodsInSettlement(_Good, _PlayerID, true);
        if AddOnCastleStore.Local.CastleStore:HasCastleStore(_PlayerID) then
            if Logic.GetGoodCategoryForGoodType(_Good) == GoodCategories.GC_Resource and _Good ~= Goods.G_Gold then
                local AmountInCastle = AddOnCastleStore.Local.CastleStore:GetAmount(_PlayerID, _Good);
                AmountOfGoods = AmountOfGoods + AmountInCastle;
            end
        end
        if AmountOfGoods &#x3C; _Amount then
            return false;
        end
        return true;
    end

    BundleInteractiveObjects.Local.BuyObject = function(self, _PlayerID, _Good, _Amount)
        if Logic.GetGoodCategoryForGoodType(_Good) ~= GoodCategories.GC_Resource and _Good ~= Goods.G_Gold then
            local buildings = GetPlayerEntities(_PlayerID,0);
            local goodAmount = _Amount;
            for i=1,#buildings do
                if Logic.IsBuilding(buildings[i]) == 1 and goodAmount &#x3E; 0 then
                    if Logic.GetBuildingProduct(buildings[i]) == _Good then
                        local goodAmountInBuilding = Logic.GetAmountOnOutStockByIndex(buildings[i],0);
                        for j=1,goodAmountInBuilding do
                            API.Bridge("Logic.RemoveGoodFromStock("..buildings[i]..",".._Good..",1)");
                            goodAmount = goodAmount -1;
                        end
                    end
                end
            end
        else
            local AmountInStore = GetPlayerGoodsInSettlement(_Good, _PlayerID, true);
            local GoodsToRemove = ((AmountInStore - _Amount) &#x3E;= 0 and _Amount) or AmountInStore;
            API.Bridge("AddGood(".._Good..", "..(GoodsToRemove*(-1))..", ".._PlayerID..")");

            if AddOnCastleStore.Local.CastleStore:HasCastleStore(_PlayerID) then
                _Amount = _Amount - GoodsToRemove;
                if _Amount &#x3E; 0 then
                    API.Bridge("QSB.CastleStore:GetInstance(" .._PlayerID.. "):Remove(" .._Good.. ", " .._Amount.. ")");
                end
            end
        end
    end
end

---
-- Hotkey-Callback für den Modus "Waren einlagern".
--
-- @within Internal
-- @local
--
function AddOnCastleStore.Local.CastleStore:HotkeyStoreGoods()
    local PlayerID = GUI.GetPlayerID();
    if AddOnCastleStore.Local.CastleStore:HasCastleStore(PlayerID) == false then 
        return;
    end
    AddOnCastleStore.Local.CastleStore:OnStorehouseTabClicked(PlayerID);
end

---
-- Hotkey-Callback für den Modus "Waren sperren".
--
-- @within Internal
-- @local
--
function AddOnCastleStore.Local.CastleStore:HotkeyLockGoods()
    local PlayerID = GUI.GetPlayerID();
    if AddOnCastleStore.Local.CastleStore:HasCastleStore(PlayerID) == false then 
        return;
    end
    AddOnCastleStore.Local.CastleStore:OnCityTabClicked(PlayerID);
end

---
-- Hotkey-Callback für den Modus "Lager räumen".
--
-- @within Internal
-- @local
--
function AddOnCastleStore.Local.CastleStore:HotkeyEmptyStore()
    local PlayerID = GUI.GetPlayerID();
    if AddOnCastleStore.Local.CastleStore:HasCastleStore(PlayerID) == false then 
        return;
    end
    AddOnCastleStore.Local.CastleStore:OnMultiTabClicked(PlayerID);
end

---
-- Versieht die Hotkeys des Burglagers mit ihren Funktionen.
--
-- @within Internal
-- @local
--
function AddOnCastleStore.Local.CastleStore:ActivateHotkeys()
    -- Waren einlagern
    Input.KeyBindDown(
        Keys.ModifierShift + Keys.B,
        "AddOnCastleStore.Local.CastleStore:HotkeyStoreGoods()",
        2,
        false
    );

    -- Waren verwahren
    Input.KeyBindDown(
        Keys.ModifierShift + Keys.N,
        "AddOnCastleStore.Local.CastleStore:HotkeyLockGoods()",
        2,
        false
    );
    
    -- Lager räumen
    Input.KeyBindDown(
        Keys.ModifierShift + Keys.M,
        "AddOnCastleStore.Local.CastleStore:HotkeyEmptyStore()",
        2,
        false
    );
end

---
-- Fügt die Beschreibung der Hotkeys der Hotkey-Tabelle hinzu.
--
-- @within Internal
-- @local
--
function AddOnCastleStore.Local.CastleStore:DescribeHotkeys()
    if not self.HotkeysAddToList then
        API.AddHotKey("Umschalt + B", {de = "Burglager: Waren einlagern", en = "Vault: Store goods"});
        API.AddHotKey("Umschalt + N", {de = "Burglager: Waren sperren", en = "Vault: Lock goods"});
        API.AddHotKey("Umschalt + M", {de = "Burglager: Lager räumen", en = "Vault: Empty store"});
        AddOnCastleStore.Local:OverwriteInteractiveObject();
        self.HotkeysAddToList = true;
    end
end

---
-- Überschreibt die Textausgabe mit den eigenen Texten.
--
-- @within Internal
-- @local
--
function AddOnCastleStore.Local:OverwriteGetStringTableText()
    GetStringTableText_Orig_QSB_CatsleStore = XGUIEng.GetStringTableText;
    XGUIEng.GetStringTableText = function(_key)
        local lang = (Network.GetDesiredLanguage() == "de" and "de") or "en";
        local SelectedID = GUI.GetSelectedEntity();
        local PlayerID = GUI.GetPlayerID();
        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();

        if _key == "UI_ObjectNames/DestroyGoods" then
            if Logic.GetHeadquarters(PlayerID) == SelectedID then
                if XGUIEng.IsWidgetShown("/InGame/Root/Normal/AlignBottomRight/Selection/Castle") == 1 then
                    return AddOnCastleStore.Local.Description.ShowCastleStore.Text[lang];
                else
                    return AddOnCastleStore.Local.Description.ShowCastle.Text[lang];
                end
            end
        end
        if _key == "UI_ObjectDescription/DestroyGoods" then
            return "";
        end

        if _key == "UI_ObjectNames/CityBuildingsNumber" then
            if Logic.GetHeadquarters(PlayerID) == SelectedID then
                return AddOnCastleStore.Local.Description.CityTab.Title[lang];
            end
        end
        if _key == "UI_ObjectDescription/CityBuildingsNumber" then
            if Logic.GetHeadquarters(PlayerID) == SelectedID then
                return AddOnCastleStore.Local.Description.CityTab.Text[lang];
            end
        end

        if _key == "UI_ObjectNames/B_StoreHouse" then
            if Logic.GetHeadquarters(PlayerID) == SelectedID then
                return AddOnCastleStore.Local.Description.StorehouseTab.Title[lang];
            end
        end
        if _key == "UI_ObjectDescription/B_StoreHouse" then
            if Logic.GetHeadquarters(PlayerID) == SelectedID then
                return AddOnCastleStore.Local.Description.StorehouseTab.Text[lang];
            end
        end

        if _key == "UI_ObjectNames/B_Castle_ME" then
            local WidgetMotherName = "/InGame/Root/Normal/AlignBottomRight/Selection/Storehouse/TabButtons/";
            local WidgetDownButton = WidgetMotherName.. "Tab03Down/down/B_Castle_ME";
            local WidgetUpButton = WidgetMotherName.. "Tab03Up/up/B_Castle_ME";
            if XGUIEng.GetWidgetPathByID(CurrentWidgetID) == WidgetDownButton or XGUIEng.GetWidgetPathByID(CurrentWidgetID) == WidgetUpButton then
                if Logic.GetHeadquarters(PlayerID) == SelectedID then
                    return AddOnCastleStore.Local.Description.MultiTab.Title[lang];
                end
            end
        end
        if _key == "UI_ObjectDescription/B_Castle_ME" then
            if Logic.GetHeadquarters(PlayerID) == SelectedID then
                return AddOnCastleStore.Local.Description.MultiTab.Text[lang];
            end
        end

        if _key == "UI_ButtonDisabled/NotEnoughGoods" then
            if Logic.GetHeadquarters(PlayerID) == SelectedID then
                return AddOnCastleStore.Local.Description.GoodButtonDisabled.Text[lang];
            end
        end

        return GetStringTableText_Orig_QSB_CatsleStore(_key);
    end
end

---
-- Überschreibt die lokalen Spielfunktionen, die benötigt werden, damit das
-- Burglager funktioniert.
--
-- @within Internal
-- @local
--
function AddOnCastleStore.Local:OverwriteGameFunctions()
    GameCallback_GUI_SelectionChanged_Orig_QSB_CastleStore = GameCallback_GUI_SelectionChanged;
    GameCallback_GUI_SelectionChanged = function(_Source)
        GameCallback_GUI_SelectionChanged_Orig_QSB_CastleStore(_Source);
        QSB.CastleStore:SelectionChanged(GUI.GetPlayerID());
    end

    GUI_Trade.GoodClicked_Orig_QSB_CastleStore = GUI_Trade.GoodClicked;
    GUI_Trade.GoodClicked = function()
        local GoodType = Goods[XGUIEng.GetWidgetNameByID(XGUIEng.GetWidgetsMotherID(XGUIEng.GetCurrentWidgetID()))];
        local SelectedID = GUI.GetSelectedEntity();
        local PlayerID   = GUI.GetPlayerID();

        if Logic.IsEntityInCategory(SelectedID, EntityCategories.Storehouse) == 1 then
            GUI_Trade.GoodClicked_Orig_QSB_CastleStore();
            return;
        end
        QSB.CastleStore:GoodClicked(PlayerID, GoodType);
    end

    GUI_Trade.DestroyGoodsClicked_Orig_QSB_CastleStore = GUI_Trade.DestroyGoodsClicked;
    GUI_Trade.DestroyGoodsClicked = function()
        local SelectedID = GUI.GetSelectedEntity();
        local PlayerID   = GUI.GetPlayerID();

        if Logic.IsEntityInCategory(SelectedID, EntityCategories.Storehouse) == 1 then
            GUI_Trade.DestroyGoodsClicked_Orig_QSB_CastleStore();
            return;
        end
        QSB.CastleStore:DestroyGoodsClicked(PlayerID);
    end

    GUI_Trade.SellUpdate_Orig_QSB_CastleStore = GUI_Trade.SellUpdate;
    GUI_Trade.SellUpdate = function()
        local SelectedID = GUI.GetSelectedEntity();
        local PlayerID   = GUI.GetPlayerID();

        if Logic.IsEntityInCategory(SelectedID, EntityCategories.Storehouse) == 1 then
            GUI_Trade.SellUpdate_Orig_QSB_CastleStore();
            return;
        end
        QSB.CastleStore:UpdateGoodsDisplay(PlayerID);
    end

    GUI_Trade.CityTabButtonClicked_Orig_QSB_CastleStore = GUI_Trade.CityTabButtonClicked;
    GUI_Trade.CityTabButtonClicked = function()
        local SelectedID = GUI.GetSelectedEntity();
        local PlayerID   = GUI.GetPlayerID();

        if Logic.IsEntityInCategory(SelectedID, EntityCategories.Storehouse) == 1 then
            GUI_Trade.CityTabButtonClicked_Orig_QSB_CastleStore();
            return;
        end
        QSB.CastleStore:OnCityTabClicked(PlayerID);
    end

    GUI_Trade.StorehouseTabButtonClicked_Orig_QSB_CastleStore = GUI_Trade.StorehouseTabButtonClicked;
    GUI_Trade.StorehouseTabButtonClicked = function()
        local SelectedID = GUI.GetSelectedEntity();
        local PlayerID   = GUI.GetPlayerID();

        if Logic.IsEntityInCategory(SelectedID, EntityCategories.Storehouse) == 1 then
            GUI_Trade.StorehouseTabButtonClicked_Orig_QSB_CastleStore();
            return;
        end
        QSB.CastleStore:OnStorehouseTabClicked(PlayerID);
    end

    GUI_Trade.MultiTabButtonClicked_Orig_QSB_CastleStore = GUI_Trade.MultiTabButtonClicked;
    GUI_Trade.MultiTabButtonClicked = function()
        local SelectedID = GUI.GetSelectedEntity();
        local PlayerID   = GUI.GetPlayerID();

        if Logic.IsEntityInCategory(SelectedID, EntityCategories.Storehouse) == 1 then
            GUI_Trade.MultiTabButtonClicked_Orig_QSB_CastleStore();
            return;
        end
        QSB.CastleStore:OnMultiTabClicked(PlayerID);
    end

    GUI_BuildingInfo.StorageLimitUpdate_Orig_QSB_CastleStore = GUI_BuildingInfo.StorageLimitUpdate;
    GUI_BuildingInfo.StorageLimitUpdate = function()
        local SelectedID = GUI.GetSelectedEntity();
        local PlayerID   = GUI.GetPlayerID();

        if Logic.IsEntityInCategory(SelectedID, EntityCategories.Storehouse) == 1 then
            GUI_BuildingInfo.StorageLimitUpdate_Orig_QSB_CastleStore();
            return;
        end
        QSB.CastleStore:UpdateStorageLimit(PlayerID);
    end

    -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    GUI_Interaction.SendGoodsClicked = function()
        local Quest, QuestType = GUI_Interaction.GetPotentialSubQuestAndType(g_Interaction.CurrentMessageQuestIndex);
        if not Quest then
            return;
        end
        local QuestIndex = GUI_Interaction.GetPotentialSubQuestIndex(g_Interaction.CurrentMessageQuestIndex);
        local GoodType = Quest.Objectives[1].Data[1];
        local GoodAmount = Quest.Objectives[1].Data[2];
        local Costs = {GoodType, GoodAmount};
        local CanBuyBoolean, CanNotBuyString = AreCostsAffordable(Costs, true);

        local PlayerID = GUI.GetPlayerID();
        if Logic.GetGoodCategoryForGoodType(GoodType) == GoodCategories.GC_Resource then
            CanNotBuyString = XGUIEng.GetStringTableText("Feedback_TextLines/TextLine_NotEnough_Resources");
            CanBuyBoolean = false;
            if QSB.CastleStore:IsLocked(PlayerID, GoodType) then
                CanBuyBoolean = GetPlayerResources(GoodType, PlayerID) &#x3E;= GoodAmount;
            else
                CanBuyBoolean = (GetPlayerResources(GoodType, PlayerID) + QSB.CastleStore:GetAmount(PlayerID, GoodType)) &#x3E;= GoodAmount;
            end
        end

        local TargetPlayerID = Quest.Objectives[1].Data[6] and Quest.Objectives[1].Data[6] or Quest.SendingPlayer;
        local PlayerSectorType = PlayerSectorTypes.Thief;
        local IsReachable = CanEntityReachTarget(TargetPlayerID, Logic.GetStoreHouse(GUI.GetPlayerID()), Logic.GetStoreHouse(TargetPlayerID), nil, PlayerSectorType);
        if IsReachable == false then
            local MessageText = XGUIEng.GetStringTableText("Feedback_TextLines/TextLine_GenericUnreachable");
            Message(MessageText);
            return
        end

        if CanBuyBoolean == true then
            Sound.FXPlay2DSound( "ui\\menu_click");
            GUI.QuestTemplate_SendGoods(QuestIndex);
            GUI_FeedbackSpeech.Add("SpeechOnly_CartsSent", g_FeedbackSpeech.Categories.CartsUnderway, nil, nil);
        else
            Message(CanNotBuyString);
        end
    end

    GUI_Tooltip.SetCosts = function(_TooltipCostsContainer, _Costs, _GoodsInSettlementBoolean)
        local TooltipCostsContainerPath = XGUIEng.GetWidgetPathByID(_TooltipCostsContainer);
        local Good1ContainerPath = TooltipCostsContainerPath .. "/1Good";
        local Goods2ContainerPath = TooltipCostsContainerPath .. "/2Goods";
        local NumberOfValidAmounts = 0;
        local Good1Path;
        local Good2Path;

        for i = 2, #_Costs, 2 do
            if _Costs[i] ~= 0 then
                NumberOfValidAmounts = NumberOfValidAmounts + 1;
            end
        end
        if NumberOfValidAmounts == 0 then
            XGUIEng.ShowWidget(Good1ContainerPath, 0);
            XGUIEng.ShowWidget(Goods2ContainerPath, 0);
            return
        elseif NumberOfValidAmounts == 1 then
            XGUIEng.ShowWidget(Good1ContainerPath, 1);
            XGUIEng.ShowWidget(Goods2ContainerPath, 0);
            Good1Path = Good1ContainerPath .. "/Good1Of1";
        elseif NumberOfValidAmounts == 2 then
            XGUIEng.ShowWidget(Good1ContainerPath, 0);
            XGUIEng.ShowWidget(Goods2ContainerPath, 1);
            Good1Path = Goods2ContainerPath .. "/Good1Of2";
            Good2Path = Goods2ContainerPath .. "/Good2Of2";
        elseif NumberOfValidAmounts &#x3E; 2 then
            GUI.AddNote("Debug: Invalid Costs table. Not more than 2 GoodTypes allowed.");
        end

        local ContainerIndex = 1;
        for i = 1, #_Costs, 2 do
            if _Costs[i + 1] ~= 0 then
                local CostsGoodType = _Costs[i];
                local CostsGoodAmount = _Costs[i + 1];
                local IconWidget;
                local AmountWidget;
                if ContainerIndex == 1 then
                    IconWidget = Good1Path .. "/Icon";
                    AmountWidget = Good1Path .. "/Amount";
                else
                    IconWidget = Good2Path .. "/Icon";
                    AmountWidget = Good2Path .. "/Amount";
                end
                SetIcon(IconWidget, g_TexturePositions.Goods[CostsGoodType], 44);
                local PlayerID = GUI.GetPlayerID();
                local PlayersGoodAmount = GetPlayerGoodsInSettlement(CostsGoodType, PlayerID, _GoodsInSettlementBoolean);
                if Logic.GetGoodCategoryForGoodType(CostsGoodType) == GoodCategories.GC_Resource and CostsGoodType ~= Goods.G_Gold then
                    if not QSB.CastleStore:IsLocked(PlayerID, CostsGoodType) then
                        PlayersGoodAmount = PlayersGoodAmount + QSB.CastleStore:GetAmount(PlayerID, CostsGoodType);
                    end
                end
                local Color = "";
                if PlayersGoodAmount &#x3C; CostsGoodAmount then
                    Color = "{@script:ColorRed}";
                end
                if CostsGoodAmount &#x3E; 0 then
                    XGUIEng.SetText(AmountWidget, "{center}" .. Color .. CostsGoodAmount);
                else
                    XGUIEng.SetText(AmountWidget, "");
                end
                ContainerIndex = ContainerIndex + 1;
            end
        end
    end
end

-- -------------------------------------------------------------------------- --

Core:RegisterBundle("AddOnCastleStore");

</code></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/addoninteractiveobjecttemplates.lua.html">
            <div class='doclink'>
                <div>AddOnInteractiveObjectTemplates</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><code>-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia AddOnInteractiveObjectTemplates                              # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Dieses Bundle bietet fertige Schablonen für interaktive Objekte. Mit diesen
-- Schablonen können komplexere interaktive Objekte einfach erstellt und durch
-- den Mapper genutzt werden.
--
-- &#x3C;p&#x3E;
-- &#x3C;b&#x3E;Interaktive Baustellen:&#x3C;/b&#x3E;&#x3C;br&#x3E;
-- Ermöglicht es den Spieler auf einem beliebigen Territorium einer Partei
-- ein Gebäude bauen zu lassen.
-- &#x3C;br&#x3E;Die Baustelle muss durch den Helden aktiviert
-- werden. Ein Siedler wird aus dem Lagerhaus kommen und das Gebäude bauen.
-- &#x3C;br&#x3E;&#x3C;a href="#API.CreateIOBuildingSite"&#x3E;Eine Baustelle anlegen&#x3C;/a&#x3E;
-- &#x3C;/p&#x3E;
-- &#x3C;p&#x3E;
-- &#x3C;b&#x3E;Interaktive Schatztruhen:&#x3C;/b&#x3E;&#x3C;br&#x3E;
-- Es werden Schatztruhen mit zufälligem Inhalt erzeugt. Diese Truhen werden
-- aktiviert und der Inhalt wird in einem Karren abtransportiert.
-- &#x3C;br&#x3E;&#x3C;a href="#API.CreateRandomChest"&#x3E;Eine Schatztruhe anlegen&#x3C;/a&#x3E;
-- &#x3C;/p&#x3E;
-- &#x3C;p&#x3E;
-- &#x3C;b&#x3E;Interaktive Minen:&#x3C;/b&#x3E;&#x3C;br&#x3E;
-- Der Spieler kann eine Stein- oder Eisenmine erzeugen, die zuerst durch
-- Begleichen der Kosten aufgebaut werden muss, bevor sie genutzt werden kann.
-- &#x3C;br&#x3E;Optional kann die Mine einstürzen, wenn sie erschöpft wurde.
-- &#x3C;br&#x3E;&#x3C;a href="#API.CreateIOMine"&#x3E;Eine Mine anlegen&#x3C;/a&#x3E;
-- &#x3C;/p&#x3E;
-- &#x3C;p&#x3E;
-- &#x3C;b&#x3E;Trebuchet-Baustellen:&#x3C;/b&#x3E;&#x3C;br&#x3E;
-- Der Spieler kann Trebuchet mieten. Das Trebuchet fährt als Karren vor,
-- wird aufgebaut und kann anschließend benutzt werden.&#x3C;br&#x3E; Das Trebuchet fährt
-- ab, wenn die Munition alle ist oder der Spieler das Trebuchet abbaut.&#x3C;br&#x3E;
-- Sobald ein Trebuchet zerstört wird oder sein Karren wieder am Lagerhaus
-- ankommt, wird die Baustelle wieder freigegeben.
-- &#x3C;br&#x3E;&#x3C;a href="#API.CreateTrebuchetConstructionSite"&#x3E;Eine Baustelle anlegen&#x3C;/a&#x3E;
-- &#x3C;/p&#x3E;
--
-- @within Modulbeschreibung
-- @set sort=true
--
AddOnInteractiveObjectTemplates = {};

API = API or {};
QSB = QSB or {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Erstelle eine verschüttete Mine eines bestimmten Typs. Es können zudem eine
-- Bedingung und zwei verschiedene Callbacks vereinbart werden.
--
-- Minen können als "nicht auffüllbar" markiert werden. In diesem Fall werden
-- sie zusammenstützen, sobald die Rohstoffe verbraucht sind.
--
-- Verschüttete Minen können durch einen Helden in normale Minen umgewandelt
-- werden. FÜr diese Umwandlung können Kosten anfallen, müssen aber nicht. Es
-- dürfen immer maximal 2 Waren als Kosten verwendet werden.
--
-- Es können weitere Funktionen hinzugefügt werden, um die Mine anzupassen:
-- &#x3C;ul&#x3E;
-- &#x3C;li&#x3E;&#x3C;u&#x3E;Bedingung:&#x3C;/u&#x3E; Eine Funktion, die true oder false zurückgeben muss.
-- Mit dieser Funktion wird bestimmt, ob die Mine gebaut werden darf.&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;&#x3C;u&#x3E;Callback Aktivierung:&#x3C;/u&#x3E; Eine Funktion, die ausgeführt wird, wenn
-- die Mine erfolgreich aktiviert wurde (evtl. Kosten bezahlt und/oder
-- Bedingung erfüllt).&#x3C;/li&#x3E;
-- &#x3C;li&#x3E;&#x3C;u&#x3E;Callback Erschöpft:&#x3C;/u&#x3E; Eine Funktion, die ausgeführt wird, sobald
-- die Rohstoffe der Mine erschöpft sind.&#x3C;/li&#x3E;
-- &#x3C;/ul&#x3E;
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: CreateIOMine&#x3C;/p&#x3E;
--
-- @param[type=string]   _Position         Script Entity, die mit Mine ersetzt wird
-- @param[type=number]   _Type             Typ der Mine
-- @param[type=table]    _Costs            (optional) Kostentabelle
-- @param[type=boolean]  _NotRefillable    (optional) Die Mine wird weiterhin überwacht
-- @param[type=function] _Condition        (optional) Bedingungsfunktion
-- @param[type=function] _CreationCallback (optional) Funktion nach Kauf ausführen
-- @param[type=function] _CallbackDepleted (optional) Funktion nach Ausbeutung ausführen
-- @within Anwenderfunktionen
--
-- @usage
-- -- Beispiel für eine Mine
-- API.CreateIOMine("mine", Entities.B_IronMine, {Goods.G_Wood, 20}, true)
-- -- Die Mine kann für 20 Holz erschlossen werden. Sobald die Rohstoffe
-- -- erschöpft sind, stürzt die Mine zusammen.
--
function API.CreateIOMine(_Position, _Type, _Costs, _NotRefillable, _Condition, _CreationCallback, _CallbackDepleted)
    if GUI then
        API.Fatal("API.CreateIOMine: Can not be used from local script!");
        return;
    end
    AddOnInteractiveObjectTemplates.Global:CreateIOMine(_Position, _Type, _Costs, _NotRefillable, _Condition, _CreationCallback, _CallbackDepleted);
end
CreateIOMine = API.CreateIOMine;

---
-- Erstelle eine verschüttete Eisenmine.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: CreateIOIronMine&#x3C;/p&#x3E;
--
-- @param[type=string]  _Position      Script Entity, die mit Mine ersetzt wird
-- @param[type=number]  _Cost1Type     (optional) Kostenware 1
-- @param[type=number]  _Cost1Amount   (optional) Kostenmenge 1
-- @param[type=number]  _Cost2Type     (optional) Kostenware 2
-- @param[type=number]  _Cost2Amount   (optional) Kostenmenge 2
-- @param[type=boolean] _NotRefillable (optional) Mine wird nach Ausbeutung zerstört
-- @within Anwenderfunktionen
-- @see API.CreateIOMine
--
-- @usage
-- -- Beispiel für eine Mine
-- API.CreateIOMine("mine", Goods.G_Wood, 20)
--
function API.CreateIOIronMine(_Position, _Cost1Type, _Cost1Amount, _Cost2Type, _Cost2Amount, _NotRefillable)
    if GUI then
        API.Fatal("API.CreateIOIronMine: Can not be used from local script!");
        return;
    end
    AddOnInteractiveObjectTemplates.Global:CreateIOIronMine(_Position, _Cost1Type, _Cost1Amount, _Cost2Type, _Cost2Amount, _NotRefillable);
end
CreateIOIronMine = API.CreateIOIronMine;

---
-- Erstelle eine verschüttete Steinmine.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: CreateIOStoneMine&#x3C;/p&#x3E;
--
-- @param[type=string]  _Position      Script Entity, die mit Mine ersetzt wird
-- @param[type=number]  _Cost1Type     (optional) Kostenware 1
-- @param[type=number]  _Cost1Amount   (optional) Kostenmenge 1
-- @param[type=number]  _Cost2Type     (optional) Kostenware 2
-- @param[type=number]  _Cost2Amount   (optional) Kostenmenge 2
-- @param[type=boolean] _NotRefillable (optional) Mine wird nach Ausbeutung zerstört
-- @within Anwenderfunktionen
-- @see API.CreateIOMine
--
-- @usage
-- -- Beispiel für eine Mine
-- API.CreateIOMine("mine", Goods.G_Wood, 20)
--
function API.CreateIOStoneMine(_Position, _Cost1Type, _Cost1Amount, _Cost2Type, _Cost2Amount, _NotRefillable)
    if GUI then
        API.Fatal("API.CreateIOStoneMine: Can not be used from local script!");
        return;
    end
    AddOnInteractiveObjectTemplates.Global:CreateIOStoneMine(_Position, _Cost1Type, _Cost1Amount, _Cost2Type, _Cost2Amount, _NotRefillable);
end
CreateIOStoneMine = API.CreateIOStoneMine;

---
-- Erzeugt eine Baustelle eines beliebigen Gebäudetyps an der Position.
--
-- Diese Baustelle kann durch einen Helden aktiviert werden. Dann wird ein
-- Siedler zur Baustelle eilen und das Gebäude aufbauen. Es ist egal, ob es
-- sich um ein Territorium des Spielers oder einer KI handelt.
--
-- Es ist dabei zu beachten, dass der Spieler, dem die Baustelle zugeordnet
-- wird, das Territorium besitzt, auf dem er bauen soll. Des weiteren muss
-- er über ein Lagerhaus/Hauptzelt verfügen.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Hinweis:&#x3C;/b&#x3E; Es kann vorkommen, dass das Model der Baustelle nicht
-- geladen wird. Dann ist der Boden der Baustelle schwarz. Sobald wenigstens
-- ein reguläres Gebäude gebaut wurde, sollte die Textur jedoch vorhanden sein.
-- &#x3C;/p&#x3E;
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: CreateIOBuildingSite&#x3C;/p&#x3E;
--
-- @param[type=string]   _Position Zielpunkt
-- @param[type=number]   _PlayerID Besitzer des Gebäudes
-- @param[type=number]   _Type Typ des Gebäudes
-- @param[type=table]    _Costs (optional) Eigene Gebäudekosten
-- @param[type=number]   _Distance (optional) Aktivierungsentfernung
-- @param[type=table]    _Icon (optional) Icon des Schalters
-- @param[type=string]   _Title (optional) Titel der Beschreibung
-- @param[type=string]   _Text(optional) Text der Beschreibung
-- @param[type=function] _Callback (optional) Funktion nach Fertigstellung
-- @within Anwenderfunktionen
--
-- @usage
-- -- Erzeugt eine Baustelle ohne besondere Einstellungen
-- API.CreateIOBuildingSite("haus", 1, Entities.B_Bakery)
-- -- Baustelle mit Kosten und Aktivierungsdistanz
-- API.CreateIOBuildingSite("haus", 1, Entities.B_Bakery, {Goods.G_Wood, 4}, 1000)
--
function API.CreateIOBuildingSite(_Position, _PlayerID, _Type, _Costs, _Distance, _Icon, _Title, _Text, _Callback)
    if GUI then
        API.Fatal("API.CreateIOBuildingSite: Can not be used from local script!");
        return;
    end
    AddOnInteractiveObjectTemplates.Global:CreateIOBuildingSite(_Position, _PlayerID, _Type, _Costs, _Distance, _Icon, _Title, _Text, _Callback);
end
CreateIOBuildingSite = API.CreateIOBuildingSite;

---
-- Erstellt eine Schatztruhe mit einer zufälligen Menge an Waren
-- des angegebenen Typs.
--
-- Die Menge der Ware ist dabei zufällig und liegt zwischen dem Minimalwert
-- und dem Maximalwert. Optional kann eine Funktion angegeben werden, die
-- ausgeführt wird, wenn die Truhe geöffnet wird. Diese Funktion verhält sich
-- wie das Callback eines interaktiven Objektes.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: CreateRandomChest&#x3C;/p&#x3E;
--
-- @param[type=string]   _Name Name der zu ersetzenden Script Entity
-- @param[type=number]   _Good Warentyp
-- @param[type=number]   _Min Mindestmenge
-- @param[type=number]   _Max Maximalmenge
-- @param[type=function] _Callback Callback-Funktion
-- @within Anwenderfunktionen
--
-- @usage
-- API.CreateRandomChest("chest", Goods.G_Gems, 100, 300, OnChestOpened)
--
function API.CreateRandomChest(_Name, _Good, _Min, _Max, _Callback)
    if GUI then
        API.Fatal("API.CreateRandomChest: Can not be used from local script!");
        return;
    end
    AddOnInteractiveObjectTemplates.Global:CreateRandomChest(_Name, _Good, _Min, _Max, _Callback);
end
CreateRandomChest = API.CreateRandomChest;

---
-- Erstellt eine Schatztruhe mit einer zufälligen Menge Gold.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: CreateRandomGoldChest&#x3C;/p&#x3E;
--
-- @param[type=string] _Name Name der zu ersetzenden Script Entity
-- @within Anwenderfunktionen
--
function API.CreateRandomGoldChest(_Name)
    if GUI then
        API.Fatal("API.CreateRandomGoldChest('" .._Name.. "')");
        return;
    end
    AddOnInteractiveObjectTemplates.Global:CreateRandomChest(_Name, Goods.G_Gold, 300, 600);
end
CreateRandomGoldChest = API.CreateRandomGoldChest;

---
-- Erstellt eine Schatztruhe mit einer zufälligen Art und Menge
-- an Gütern.
--
-- Güter können seien: Eisen, Fisch, Fleisch, Getreide, Holz,
-- Honig, Kräuter, Milch, Stein, Wolle.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: CreateRandomResourceChest&#x3C;/p&#x3E;
--
-- @param[type=string] _Name Name der zu ersetzenden Script Entity
-- @within Anwenderfunktionen
--
function API.CreateRandomResourceChest(_Name)
    if GUI then
        API.Bridge("API.CreateRandomResourceChest('" .._Name.. "')");
        return;
    end
    AddOnInteractiveObjectTemplates.Global:CreateRandomResourceChest(_Name);
end
CreateRandomResourceChest = API.CreateRandomResourceChest;

---
-- Erstellt eine Schatztruhe mit einer zufälligen Art und Menge
-- an Luxusgütern.
--
-- Luxusgüter können seien: Edelsteine, Farben, Musikinstrumente
-- Salz oder Weihrauch.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: CreateRandomLuxuryChest&#x3C;/p&#x3E;
--
-- @param[type=string] _Name Name der zu ersetzenden Script Entity
-- @within Anwenderfunktionen
--
function API.CreateRandomLuxuryChest(_Name)
    if GUI then
        API.Bridge("API.CreateRandomLuxuryChest('" .._Name.. "')");
        return;
    end
    AddOnInteractiveObjectTemplates.Global:CreateRandomLuxuryChest(_Name);
end
CreateRandomLuxuryChest = API.CreateRandomLuxuryChest;

---
-- Erstellt eine Trebuchet-Baustelle an der Position mit den
-- angegebenen Baukosten.
--
-- Das Trebuchet kann von einem Helden aufgebaut werden. Es wird ein Karren
-- aus dem Lagerhaus zur Baustelle fahren. Erreicht der Karren die Baustelle,
-- wird er durch ein Trebuchet ersetzt.
--
-- Das Trebuchet hat dann 10 Schuss. Sind diese aufgebraucht wird das Trebuchet
-- abgebaut und fährt in das Lagerhaus zurück. Sobald der Karren angekommen
-- ist, kann die Baustelle erneut aktiviert werden.
--
-- &#x3C;b&#x3E;Achtung:&#x3C;/b&#x3E;Das Auffüllen von Trebuchets wird deaktiviert, sobald eine
-- Baustelle erzeugt wird. Es wird NICHT empfohlen dem Spieler beides, normale
-- Trebuchets und Trebuchetbaustellen, zur gleichen Zeit zu geben!
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: CreateTrebuchetConstructionSite&#x3C;/p&#x3E;
--
-- @param[type=string] _Name Skriptname Position
-- @param[type=number] _GoldCost Goldkosten
-- @param[type=number] _WoodCost Holzkosten
-- @within Anwenderfunktionen
--
function API.CreateTrebuchetConstructionSite(_Name, _GoldCost, _WoodCost)
    if GUI then
        API.Bridge("API.CreateTrebuchetConstructionSite('" .._Name.. "', " .._GoldCost.. ", " .._WoodCost.. ")");
        return;
    end
    AddOnInteractiveObjectTemplates.Global:CreateTrebuchetConstructionSite(_Name, _GoldCost, _WoodCost);
end
CreateTrebuchetConstructionSite = API.CreateTrebuchetConstructionSite;

---
-- Zerstört eine Trebuchet-Baustelle, aber nicht die Skript Entity.
--
-- Die Baustelle wird in jedem möglichen Status zerstört. Es ist egal, ob das
-- Trebuchet aufgebaut ist, gerade ein Karren unterwegs ist, oder die Baustelle
-- noch nie berührt wurde.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: DestroyTrebuchetConstructionSite&#x3C;/p&#x3E;
--
-- @param[type=string] _Name Skriptname Position
-- @within Anwenderfunktionen
--
function API.DestroyTrebuchetConstructionSite(_Name)
    if GUI then
        API.Bridge("API.DestroyTrebuchetConstructionSite('" .._Name.. "')");
        return;
    end
    AddOnInteractiveObjectTemplates.Global:DestroyTrebuchetConstructionSite(_Name);
end
DestroyTrebuchetConstructionSite = API.DestroyTrebuchetConstructionSite;

---
-- Gibt die EntityID aufgebaute Trebuchet der Trebuchet-Baustelle zurück.
-- Sollte kein Trebuchet aufgebaut sein, wird 0 zurückgegeben.
--
-- @param[type=string] _Name Skriptname der Trebuchet-Baustelle
-- @return[type=number] EntityID des Trebuchet
-- @within Anwenderfunktionen
--
function API.GetTrebuchetByTrebuchetConstructionSite(_Name)
    if GUI then
        API.Fatal("API.GetTrebuchetByTrebuchetConstructionSite: Can only be used in global script!");
        return;
    end
    if not self.Data.Trebuchet.Sites[_Name] then
        API.Warn("API.GetTrebuchetByTrebuchetConstructionSite: Site '" ..tostring(_Name).. "' does not exist!");
        return 0;
    end
    return self.Data.Trebuchet.Sites[_Name].ConstructedTrebuchet;
end
GetTrebuchet = API.GetTrebuchetByTrebuchetConstructionSite;

---
-- Gibt die EntityID des Anforderungswagens der Trebuchet-Baustelle zurück.
-- Sollte kein Anforderungswagen unterwegs sein, wird 0 zurückgegeben.
--
-- @param[type=string] _Name Skriptname der Trebuchet-Baustelle
-- @return[type=number] EntityID des angeforderten Wagens
-- @within Anwenderfunktionen
--
function API.GetReturningCartByTrebuchetConstructionSite(_Name)
    if GUI then
        API.Fatal("API.GetReturningCartByTrebuchetConstructionSite: Can only be used in global script!");
        return;
    end
    if not self.Data.Trebuchet.Sites[_Name] then
        API.Warn("API.GetReturningCartByTrebuchetConstructionSite: Site '" ..tostring(_Name).. "' does not exist!");
        return 0;
    end
    return self.Data.Trebuchet.Sites[_Name].ReturningCart;
end
GetReturningCart = API.GetReturningCartByTrebuchetConstructionSite;

---
-- Gibt die EntityID des Abreisewagens der Trebuchet-Baustelle zurück. Sollte
-- kein Abreisewagens unterwegs sein, wird 0 zurückgegeben.
--
-- @param[type=string] _Name Skriptname der Trebuchet-Baustelle
-- @return[type=number] EntityID des angeforderten Wagens
-- @within Anwenderfunktionen
--
function API.GetConstructionCartByTrebuchetConstructionSite(_Name)
    if GUI then
        API.Fatal("API.GetConstructionCartByTrebuchetConstructionSite: Can only be used in global script!");
        return;
    end
    if not self.Data.Trebuchet.Sites[_Name] then
        API.Warn("API.GetConstructionCartByTrebuchetConstructionSite: Site '" ..tostring(_Name).. "' does not exist!");
        return 0;
    end
    return self.Data.Trebuchet.Sites[_Name].ConstructionCart;
end
GetConstructionCart = API.GetConstructionCartByTrebuchetConstructionSite;

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

AddOnInteractiveObjectTemplates = {
    Global = {
        Data = {
            ConstructionSite = {
                Sites = {},

                Description = {
                    Title = {
                        de = "Gebäude bauen",
                        en = "Create building",
                    },
                    Text = {
                        de = "Beauftragt den Bau eines Gebäudes. Ein Siedler wird aus"..
                             " dem Lagerhaus kommen und mit dem Bau beginnen.",
                        en = "Order a building. A worker will come out of the"..
                             " storehouse and erect it.",
                    },
                    Unfulfilled = {
                        de = "Das Gebäude kann derzeit nicht gebaut werden.",
                        en = "The building can not be built at the moment.",
                    },
                }
            },

            Mines = {
                Description = {
                    Title = {
                        de = "Mine errichten",
                        en = "Build pit",
                    },
                    Text = {
                        de = "An diesem Ort könnt Ihr eine Mine errichten!",
                        en = "You're able to create a pit at this location!",
                    },
                    Unfulfilled = {
                        de = "Die Mine kann nicht umgewandelt werden!",
                        en = "The mine can not be transformed!",
                    },
                },
            },

            Chests = {
                Description = {
                    Title = {
                        de = "Schatztruhe",
                        en = "Treasure Chest",
                    },
                    Text = {
                        de = "Diese Truhe enthält einen geheimen Schatz. Öffnet sie um den Schatz zu bergen.",
                        en = "This chest contains a secred treasure. Open it to salvage the treasure.",
                    },
                },
            },

            Trebuchet = {
                Error = {
                    de = "Euer Ritter benötigt einen höheren Titel!",
                    en = "Your knight need a higher title to use this site!",
                },
                Description = {
                    Title = {
                        de = "Trebuchet anfordern",
                        en = "Order trebuchet",
                    },
                    Text = {
                        de = "- Fordert ein Trebuchet aus der Stadt an {cr}- Trebuchet wird gebaut, wenn Wagen Baustelle erreicht {cr}- Fährt zurück, wenn Munition aufgebraucht {cr}- Trebuchet kann manuell zurückgeschickt werden",
                        en = "- Order a trebuchet from your city {cr}- The trebuchet is build after the cart has arrived {cr}- Returns after ammunition is depleted {cr}- The trebuchet can be manually send back to the city",
                    },
                },

                Sites = {},
                NeededKnightTitle = 0,
                IsActive = false,
            },
        }
    },
    Local = {
        Data = {},
    },
}

-- Global ----------------------------------------------------------------------

---
-- Initalisiert das AddOn.
-- @within Internal
-- @local
--
function AddOnInteractiveObjectTemplates.Global:Install()
end

---
-- Initialisiert die interaktiven Trebuchet-Baustellen.
-- @within Internal
-- @local
--
function AddOnInteractiveObjectTemplates.Global:TrebuchetActivate()
    if not self.Data.Trebuchet.IsActive then
        GameCallback_QSB_OnDisambleTrebuchet = AddOnInteractiveObjectTemplates.Global.OnTrebuchetDisambled;
        GameCallback_QSB_OnErectTrebuchet = function() end;
        StartSimpleJobEx(self.WatchTrebuchetsAndCarts);
        API.DisableRefillTrebuchet(true);
        self.Data.Trebuchet.IsActive = true;
    end
end

---
-- Prüft, ob der menschliche Spieler einen ausreichenden Titel
-- hat um Trebuchets zu bauen.
--
-- @return boolean: Titel hoch genug
-- @within Internal
-- @local
--
function AddOnInteractiveObjectTemplates.Global.TrebuchetHasSufficentTitle()
    local pID = 1;
    for i=1,8 do
        if Logic.PlayerGetIsHumanFlag(i) == 1 then
            pID = i;
            break;
        end
    end
    return Logic.GetKnightTitle(pID) &#x3E;= AddOnInteractiveObjectTemplates.Global.Data.Trebuchet.NeededKnightTitle;
end

---
-- Setzt den mindestens benötigten Titel um Trebuchets zu bauen.
--
-- @param _KnightTitle Titel
-- @within Internal
-- @local
--
function AddOnInteractiveObjectTemplates.Global:TrebuchetSetNeededKnightTitle(_KnightTitle)
    self.Data.Trebuchet.NeededKnightTitle = _KnightTitle;
end

---
-- Erstellt eine Trebuchet-Baustelle an der Position mit den
-- angegebenen Baukosten.
--
-- @param _Name [string] Skriptname Position
-- @param _GoldCost Goldkosten
-- @param _WoodCost Holzkosten
-- @within Internal
-- @local
--
function AddOnInteractiveObjectTemplates.Global:CreateTrebuchetConstructionSite(_Name, _GoldCost, _WoodCost)
    self:TrebuchetActivate();

    _GoldCost = _GoldCost or 4500;
    _WoodCost = _WoodCost or 35;
    local eID = GetID(_Name);
    Logic.SetModel(eID, Models.Buildings_B_BuildingPlot_8x8);
    Logic.SetVisible(eID, true);

    self.Data.Trebuchet.Sites[_Name] = {
        ConstructedTrebuchet = 0,
        ConstructionCart = 0,
        ReturningCart = 0,
    }

    CreateObject {
        Name                    = _Name,
        Title                   = self.Data.Trebuchet.Description.Title,
        Text                    = self.Data.Trebuchet.Description.Text,
        Costs                   = {Goods.G_Gold, _GoldCost, Goods.G_Wood, _WoodCost},
        Distance                = 1000,
        State                   = 0,
        Condition               = self.TrebuchetHasSufficentTitle,
        ConditionUnfulfilled    = self.Data.Trebuchet.Error,
        Callback                = function(t, PlayerID)
            AddOnInteractiveObjectTemplates.Global:SpawnTrebuchetCart(PlayerID, t.Name);
        end,
    }
end

---
-- Zerstört eine Trebuchet-Baustelle.
--
-- @param _Name [string] Skriptname Position
-- @within Internal
-- @local
--
function AddOnInteractiveObjectTemplates.Global:DestroyTrebuchetConstructionSite(_Name)
    local ConstructionCart = self.Data.Trebuchet.Sites[_Name].ConstructionCart;
    DestroyEntity(ConstructionCart);
    local ConstructedTrebuchet = self.Data.Trebuchet.Sites[_Name].ConstructedTrebuchet;
    DestroyEntity(ConstructedTrebuchet);
    local ReturningCart = self.Data.Trebuchet.Sites[_Name].ReturningCart;
    DestroyEntity(ReturningCart);

    self.Data.Trebuchet.Sites[_Name] = nil;
    Logic.SetVisible(GetID(_Name), false);
    RemoveInteractiveObject(_Name);
end

---
-- Erzeugt einen Trebuchetwagen für die Baustelle.
--
-- @param _PlayerID Besitzer
-- @param _Site     Baustelle
-- @within Internal
-- @local
--
function AddOnInteractiveObjectTemplates.Global:SpawnTrebuchetCart(_PlayerID, _Site)
    local StoreID = Logic.GetStoreHouse(_PlayerID);
    local x,y = Logic.GetBuildingApproachPosition(StoreID);
    local CartID = Logic.CreateEntity(Entities.U_SiegeEngineCart, x, y, 0, _PlayerID);
    Logic.SetEntitySelectableFlag(CartID, 0);
    self.Data.Trebuchet.Sites[_Site].ConstructionCart = CartID;
end

---
-- Erzeugt das Trebuchet an der Baustelle.
--
-- @param _PlayerID Besitzer
-- @param _Site     Baustelle
-- @within Internal
-- @local
--
function AddOnInteractiveObjectTemplates.Global:SpawnTrebuchet(_PlayerID, _Site)
    local pos = GetPosition(_Site);
    local TrebuchetID = Logic.CreateEntity(Entities.U_Trebuchet, pos.X, pos.Y, 0, _PlayerID);
    self.Data.Trebuchet.Sites[_Site].ConstructedTrebuchet = TrebuchetID;
end

---
-- Baut das Trebuchet zum Wagen zurück und lässt es wieder ins
-- Lagerhaus des Besitzers fahren.
--
-- @param _PlayerID  Besitzer
-- @param _Trebuchet Baustelle
-- @within Internal
-- @local
--
function AddOnInteractiveObjectTemplates.Global:ReturnTrebuchetToStorehouse(_PlayerID, _Trebuchet)
    local x,y,z = Logic.EntityGetPos(_Trebuchet);
    local CartID = Logic.CreateEntity(Entities.U_SiegeEngineCart, x, y, 0, _PlayerID);
    Logic.SetEntitySelectableFlag(CartID, 0);

    local SiteName;
    for k,v in pairs(self.Data.Trebuchet.Sites) do
        if v.ConstructedTrebuchet == _Trebuchet then
            SiteName = k;
        end
    end
    if SiteName then
        self.Data.Trebuchet.Sites[SiteName].ReturningCart = CartID;
        self.Data.Trebuchet.Sites[SiteName].ConstructedTrebuchet = 0;
        Logic.SetVisible(GetID(SiteName), true);
        DestroyEntity(_Trebuchet);
    else
        DestroyEntity(CartID);
    end
end

---
-- Callback: Ein Trebuchet wird manuell zurückgebaut.
--
-- @param _EntityID Entity-ID des Trebuchet
-- @param _PlayerID Besitzer
-- @param _x        X-Position
-- @param _y        Y-Position
-- @param _z        Z-Position
-- @within Internal
-- @local
--
function AddOnInteractiveObjectTemplates.Global.OnTrebuchetDisambled(_EntityID, _PlayerID, _x, _y, _z)
    AddOnInteractiveObjectTemplates.Global:ReturnTrebuchetToStorehouse(_PlayerID, _EntityID);
end

---
-- Steuert die Trebuchet-Mechanik.
-- @within Internal
-- @local
--
function AddOnInteractiveObjectTemplates.Global.WatchTrebuchetsAndCarts()
    for k,v in pairs(AddOnInteractiveObjectTemplates.Global.Data.Trebuchet.Sites) do
        local SiteID = GetID(k);

        -- Stufe 1: Karren kommt
        if v.ConstructionCart ~= 0 then
            -- Bauwagen wurde zerstört
            if not IsExisting(v.ConstructionCart) then
                AddOnInteractiveObjectTemplates.Global.Data.Trebuchet.Sites[k].ConstructionCart = 0;
                API.InteractiveObjectActivate(k);
            end
            -- Bauwagen bewegt sich nicht zum Ziel
            if not Logic.IsEntityMoving(v.ConstructionCart) then
                local SiteID = GetID(k);
                local x,y,z = Logic.EntityGetPos(SiteID);
                Logic.MoveSettler(v.ConstructionCart, x, y);
            end
            -- Bauwagen ist angekommen
            if IsNear(v.ConstructionCart, k, 500) then
                local x,y,z = Logic.EntityGetPos(SiteID);
                local PlayerID = Logic.EntityGetPlayer(v.ConstructionCart);
                AddOnInteractiveObjectTemplates.Global:SpawnTrebuchet(PlayerID, k);
                DestroyEntity(v.ConstructionCart);
                AddOnInteractiveObjectTemplates.Global.Data.Trebuchet.Sites[k].ConstructionCart = 0;
                Logic.SetVisible(SiteID, false);
                Logic.CreateEffect(EGL_Effects.E_Shockwave01, x, y, 0);
            end
        end

        -- Stufe 2: Trebuchet steht
        if v.ConstructedTrebuchet ~= 0 then
            -- Trebuchet wurde zerstört
            if not IsExisting(v.ConstructedTrebuchet) then
                AddOnInteractiveObjectTemplates.Global.Data.Trebuchet.Sites[k].ConstructedTrebuchet = 0;
                Logic.SetVisible(SiteID, true);
                API.InteractiveObjectActivate(k);
            end
            -- Trebuchet hat keine Munition
            if Logic.GetAmmunitionAmount(v.ConstructedTrebuchet) == 0 and BundleEntitySelection.Local.Data.RefillTrebuchet == false then
                local PlayerID = Logic.EntityGetPlayer(v.ConstructedTrebuchet);
                AddOnInteractiveObjectTemplates.Global:ReturnTrebuchetToStorehouse(PlayerID, v.ConstructedTrebuchet);
            end
        end

        -- Stufe 3: Rückweg
        if v.ReturningCart ~= 0 then
            -- Rückkehrwagen wurde zerstört
            if not IsExisting(v.ReturningCart) then
                AddOnInteractiveObjectTemplates.Global.Data.Trebuchet.Sites[k].ReturningCart = 0;
                API.InteractiveObjectActivate(k);
            end

            local PlayerID = Logic.EntityGetPlayer(v.ReturningCart);
            local StoreID = Logic.GetStoreHouse(PlayerID);

            -- Rückkehrwagen muss sich zum Ziel bewegen
            if not Logic.IsEntityMoving(v.ReturningCart) then
                local x,y = Logic.GetBuildingApproachPosition(StoreID);
                Logic.MoveSettler(v.ReturningCart, x, y);
            end
            -- Rückkehrwagen kommt an
            if IsNear(v.ReturningCart, StoreID, 1100) then
                local PlayerID = Logic.EntityGetPlayer(v.ConstructionCart);
                DestroyEntity(v.ReturningCart);
            end
        end
    end
end

---
-- Erstellt eine Schatztruhe mit einer zufälligen Menge an Waren
-- des angegebenen Typs.
-- @param _Name [string] Name der zu ersetzenden Script Entity
-- @param _Good [number] Warentyp
-- @param _Min [number] Mindestmenge
-- @param _Max [number] Maximalmenge
-- @param _Callback [function] Callback-Funktion
-- @within Internal
-- @local
--
function AddOnInteractiveObjectTemplates.Global:CreateRandomChest(_Name, _Good, _Min, _Max, _Callback)
    _Min = (_Min ~= nil and _Min &#x3E; 0 and _Min) or 1;
    _Max = (_Max ~= nil and _Max &#x3E; 1 and _Max) or 2;
    if not _Callback then
        _Callback = function(t) end
    end
    assert(_Good ~= nil, "CreateRandomChest: Good does not exist!");
    assert(_Min &#x3C; _Max, "CreateRandomChest: min amount must be smaller than max amount!");

    local eID = ReplaceEntity(_Name, Entities.XD_ScriptEntity, 0);
    Logic.SetModel(eID, Models.Doodads_D_X_ChestClose);
    Logic.SetVisible(eID, true);

    CreateObject {
        Name                    = _Name,
        Title                   = self.Data.Chests.Description.Title,
        Text                    = self.Data.Chests.Description.Text,
        Reward                  = {_Good, math.random(_Min, _Max)},
        Texture                 = {1, 6},
        Distance                = 650,
        State                   = 0,
        CallbackOpened          = _Callback,
        Callback                = function(_Data)
            ReplaceEntity(_Data.Name, Entities.D_X_ChestOpenEmpty);
            _Data.CallbackOpened(_Data);
        end,
    }
end

---
-- Erstellt eine Schatztruhe mit einer zufälligen Menge an Gold
-- des angegebenen Typs.
--
-- @param _Name [string] Name der zu ersetzenden Script Entity
-- @within Internal
-- @local
--
function AddOnInteractiveObjectTemplates.Global:CreateRandomGoldChest(_Name)
    AddOnInteractiveObjectTemplates.Global:CreateRandomChest(_Name, Goods.G_Gold, 300, 600);
end

---
-- Erstellt eine Schatztruhe mit einer zufälligen Art und Menge
-- an Gütern.
-- Güter können seien: Eisen, Fisch, Fleisch, Getreide, Holz,
-- Honig, Kräuter, Milch, Stein, Wolle.
--
-- @param _Name [string] Name der zu ersetzenden Script Entity
-- @within Internal
-- @local
--
function AddOnInteractiveObjectTemplates.Global:CreateRandomResourceChest(_Name)
    local PossibleGoods = {
        Goods.G_Iron, Goods.G_Stone, Goods.G_Wood, Goods.G_Wool,
        Goods.G_Carcass, Goods.G_Herb, Goods.G_Honeycomb,
        Goods.G_Milk, Goods.G_RawFish, Goods.G_Grain
    };
    local Good = PossibleGoods[math.random(1, #PossibleGoods)];
    AddOnInteractiveObjectTemplates.Global:CreateRandomChest(_Name, Good, 30, 60);
end

---
-- Erstellt eine Schatztruhe mit einer zufälligen Art und Menge
-- an Luxusgütern.
-- Luxusgüter können seien: Edelsteine, Farben, Musikinstrumente
-- Salz oder Weihrauch.
--
-- @param _Name [string] Name der zu ersetzenden Script Entity
-- @within Internal
-- @local
--
function AddOnInteractiveObjectTemplates.Global:CreateRandomLuxuryChest(_Name)
    local Luxury = {Goods.G_Salt, Goods.G_Dye};
    if g_GameExtraNo &#x3E;= 1 then
        table.insert(Luxury, Goods.G_Gems);
        table.insert(Luxury, Goods.G_MusicalInstrument);
        table.insert(Luxury, Goods.G_Olibanum);
    end
    local Good = Luxury[math.random(1, #Luxury)];
    AddOnInteractiveObjectTemplates.Global:CreateRandomChest(_Name, Good, 50, 100);
end

---
-- Erstelle eine Mine eines bestimmten Typs. Es können zudem eine Bedingung
-- und zwei verschiedene Callbacks vereinbart werden.
--
-- @param _Position [string] Script Entity, die mit Mine ersetzt wird
-- @param _Type [number] Typ der Mine
-- @param _Costs [table] (optional) Kostentabelle
-- @param _NotRefillable [boolean] (optional) Die Mine wird weiterhin überwacht
-- @param _Condition [function] (optional) Bedingungsfunktion
-- @param _CreationCallback (optional) Funktion nach Kauf ausführen
-- @param _CallbackDepleted (optional) Funktion nach Ausbeutung ausführen
-- @within Internal
-- @local
--
function AddOnInteractiveObjectTemplates.Global:CreateIOMine(_Position, _Type, _Costs, _NotRefillable, _Condition, _CreationCallback, _CallbackDepleted)
    -- Objekt austauschen und Model anpassen
    local eID = ReplaceEntity(_Position, Entities.XD_ScriptEntity);
    local Model = Models.Doodads_D_SE_ResourceIron_Wrecked;
    if _Type == Entities.R_StoneMine then
        Model = Models.R_SE_ResorceStone_10;
    end
    Logic.SetVisible(eID, true);
    Logic.SetModel(eID, Model);
    local x, y, z = Logic.EntityGetPos(eID);
    local BlockerID = Logic.CreateEntity(Entities.D_ME_Rock_Set01_B_07, x, y, 0, 0);
    Logic.SetVisible(BlockerID, false);

    CreateObject {
        Name                 = _Position,
        Title                = self.Data.Mines.Description.Title,
        Text                 = self.Data.Mines.Description.Text,
        Type                 = _Type,
        Special              = _NotRefillable,
        Costs                = _Costs,
        InvisibleBlocker     = BlockerID,
        Distance             = 1500,
        Condition            = self.ConditionBuildIOMine,
        CustomCondition      = _Condition,
        ConditionUnfulfilled = self.Data.Mines.Description.Unfulfilled,
        CallbackCreate       = _CreationCallback,
        CallbackDepleted     = _CallbackDepleted,
        Callback             = self.ActionBuildIOMine,
    };
end

---
-- Erstelle eine verschüttete Eisenmine.
--
-- @param _Position [string] Script Entity, die mit Mine ersetzt wird
-- @param _Cost1Type [number] (optional) Kostenware 1
-- @param _Cost1Amount [number] (optional) Kostenmenge 1
-- @param _Cost2Type [number] (optional) Kostenware 2
-- @param _Cost2Amount [number] (optional) Kostenmenge 2
-- @param _NotRefillable [boolean] (optional) Mine wird nach Ausbeutung zerstört
-- @within Internal
-- @local
--
function AddOnInteractiveObjectTemplates.Global:CreateIOIronMine(_Position, _Cost1Type, _Cost1Amount, _Cost2Type, _Cost2Amount, _NotRefillable)
    assert(IsExisting(_Position));
    if _Cost1Type then
        assert(API.TraverseTable(_Cost1Type, Goods));
        assert(type(_Cost1Amount) == "number");
    end
    if _Cost2Type then
        assert(API.TraverseTable(_Cost2Type, Goods));
        assert(type(_Cost2Amount) == "number");
    end

    self:CreateIOMine(
        _Position, Entities.R_IronMine,
        {_Cost1Type, _Cost1Amount, _Cost2Type, _Cost2Amount},
        _NotRefillable
    );
end

---
-- Erstelle eine verschüttete Steinmine.
--
-- @param _Position [string] Script Entity, die mit Mine ersetzt wird
-- @param _Cost1Type [number] (optional) Kostenware 1
-- @param _Cost1Amount [number] (optional) Kostenmenge 1
-- @param _Cost2Type [number] (optional) Kostenware 2
-- @param _Cost2Amount [number] (optional) Kostenmenge 2
-- @param _NotRefillable [boolean] (optional) Mine wird nach Ausbeutung zerstört
-- @within Internal
-- @local
--
function AddOnInteractiveObjectTemplates.Global:CreateIOStoneMine(_Position, _Cost1Type, _Cost1Amount, _Cost2Type, _Cost2Amount, _NotRefillable)
    assert(IsExisting(_Position));
    if _Cost1Type then
        assert(API.TraverseTable(_Cost1Type, Goods));
        assert(type(_Cost1Amount) == "number");
    end
    if _Cost2Type then
        assert(API.TraverseTable(_Cost2Type, Goods));
        assert(type(_Cost2Amount) == "number");
    end

    self:CreateIOMine(
        _Position, Entities.R_StoneMine,
        {_Cost1Type, _Cost1Amount, _Cost2Type, _Cost2Amount},
        _NotRefillable
    );
end

---
-- Testet die Bedingung, unter der die Mine errichtet werden kann.
-- @param _Data Daten des Objektes
-- @return boolean: Bedingung erfüllt
-- @within Internal
-- @local
--
function AddOnInteractiveObjectTemplates.Global.ConditionBuildIOMine(_Data)
    if _Data.CustomCondition then
        return _Data.CustomCondition(_Data) == true;
    end
    return true;
end


function AddOnInteractiveObjectTemplates.Global.ActionBuildIOMine(_Data)
    ReplaceEntity(_Data.Name, _Data.Type);
    DestroyEntity(_Data.InvisibleBlocker);
    if type(_Data.CallbackCreate) == "function" then
        _Data.CallbackCreate(_Data);
    end
    Trigger.RequestTrigger( Events.LOGIC_EVENT_EVERY_SECOND, "", "AddOnInteractiveObjectTemplates_JobControlIOMine", 1, {}, {_Data.Name});
end

---
-- Prüft gebaute Minen ob diese ausgebeutet sind. Ist das der Fall
-- werden sie "zerstört" und ggf. das Callback ausgelöst.
-- @param _Mine Zu überwachende Mine
-- @return boolean: Job beendet
-- @within Internal
-- @local
--
function AddOnInteractiveObjectTemplates.Global.ControlIOMine(_Mine)
    if not IO[_Mine] then
        return true;
    end
    if not IsExisting(_Mine) then
        return true;
    end
    local eID = GetID(_Mine);

    if Logic.GetResourceDoodadGoodAmount(eID) == 0 then
        API.Note(IO[_Mine].Special)
        if IO[_Mine].Special == true then
            local Model = Models.Doodads_D_SE_ResourceIron_Wrecked;
            if IO[_Mine].Type == Entities.R_StoneMine then
                Model = Models.R_ResorceStone_Scaffold_Destroyed;
            end
            eID = ReplaceEntity(eID, Entities.XD_ScriptEntity);
            Logic.SetVisible(eID, true);
            Logic.SetModel(eID, Model);
        end

        if type(IO[_Mine].CallbackDepleted) == "function" then
            IO[_Mine].CallbackDepleted(IO[_Mine]);
        end
        return true;
    end
end
AddOnInteractiveObjectTemplates_JobControlIOMine = AddOnInteractiveObjectTemplates.Global.ControlIOMine;

---
-- Initialisiert die interaktiven Baustellen.
-- @within Internal
-- @local
--
function AddOnInteractiveObjectTemplates.Global:ConstructionSiteActivate()
    if self.Data.ConstructionSiteActivated then
        return;
    end
    self.Data.ConstructionSiteActivated = true;

    Core:AppendFunction(
        "GameCallback_OnBuildingConstructionComplete",
        self.OnConstructionComplete
    );
end

---
-- Ruft das Callback einer Baustelle auf, sofern eins definiert wurde.
-- @param _PlayerID Besitzer des Gebäudes
-- @param _EntityID Entity-ID des Gebäudes
-- @within Internal
-- @local
--
function AddOnInteractiveObjectTemplates.Global.OnConstructionComplete(_PlayerID, _EntityID)
    local IO = AddOnInteractiveObjectTemplates.Global.Data.ConstructionSite.Sites[_EntityID];
    if IO ~= nil and IO.CompletedCallback then
        IO.CompletedCallback(IO, _EntityID);
    end
end

---
-- Erzeugt eine echte Baustelle an der Position. Ein Siedler wird das Gebäude
-- aufbauen.
--
-- @param _Position [string] Zielpunkt
-- @param _PlayerID Besitzer des Gebäudes
-- @param _Type [number] Typ des Gebäudes
-- @param _Costs [table] (optional) Eigene Gebäudekosten
-- @param _Distance [number] (optional) Aktivierungsentfernung
-- @param _Icon [table] (optional) Icon des Schalters
-- @param _Title [string] (optional) Titel der Beschreibung
-- @param _Text [string] (optional) Text der Beschreibung
-- @param _Callback [function] (optional) Funktion nach fertigstellung
-- @within Internal
-- @local
--
function AddOnInteractiveObjectTemplates.Global:CreateIOBuildingSite(_Position, _PlayerID, _Type, _Costs, _Distance, _Icon, _Title, _Text, _Callback)
    AddOnInteractiveObjectTemplates.Global:ConstructionSiteActivate();
    local Costs = _Costs or {Logic.GetEntityTypeFullCost(_Type)};
    local Title = _Title or self.Data.ConstructionSite.Description.Title;
    local Text  = Text or self.Data.ConstructionSite.Description.Text;
    local eID = GetID(_Position);
    Logic.SetModel(eID, Models.Buildings_B_BuildingPlot_10x10);
    Logic.SetVisible(eID, true);

    CreateObject {
        Name                 = _Position,
        Title                = Title,
        Text                 = Text,
        Texture              = _Icon or {14, 10},
        Distance             = _Distance or 1500,
        Type                 = _Type,
        Costs                = Costs,
        Condition            = AddOnInteractiveObjectTemplates.Global.ConditionConstructionSite,
        ConditionUnfulfilled = AddOnInteractiveObjectTemplates.Global.Data.ConstructionSite.Description.Unfulfilled,
        PlayerID             = _PlayerID,
        CompletedCallback    = _Callback,
        Callback             = AddOnInteractiveObjectTemplates.Global.CallbackIOConstructionSite;
    };
end

---
-- Lässt einen Siedler die Baustelle zum Gebäude aufbauen.
-- @param _Data Daten des Objekt
-- @within Internal
-- @local
--
function AddOnInteractiveObjectTemplates.Global.CallbackIOConstructionSite(_Data)
    local pos  = GetPosition(_Data.Name);
    local eID  = GetID(_Data.Name);
    local ori  = Logic.GetEntityOrientation(eID);
    local site = Logic.CreateConstructionSite(pos.X, pos.Y, ori, _Data.Type, _Data.PlayerID);
    Logic.SetVisible(eID, false);
    if (site == nil) then
        API.Fatal('AddOnInteractiveObjectTemplates.Global:CreateIOBuildingSite: Failed to place construction site!');
        return;
    end
    AddOnInteractiveObjectTemplates.Global.Data.ConstructionSite.Sites[site] = _Data;
    StartSimpleJobEx(AddOnInteractiveObjectTemplates.Global.ControlConstructionSite, site);
end

---
-- Prüft ob das Gebäude theoretisch gebaut werden kann.
-- @param _Data Daten des Objekt
-- @return boolean: Kann aktiviert werden
-- @within Internal
-- @local
--
function AddOnInteractiveObjectTemplates.Global.ConditionConstructionSite(_Data)
    local eID = GetID(_Data.Name);
    local tID = GetTerritoryUnderEntity(eID);
    local pID = Logic.GetTerritoryPlayerID(tID);

    if Logic.GetStoreHouse(_Data.PlayerID) == 0 then
        return false;
    end
    if _Data.PlayerID ~= pID then
        return false;
    end
    return true;
end

---
-- Überwacht eine Gebäudebaustelle und reaktiviert sie falls nötig.
-- @param _eID EntityID des Gebäudes
-- @return boolean: Job beenden
-- @within Internal
-- @local
--
function AddOnInteractiveObjectTemplates.Global.ControlConstructionSite(_eID)
    if AddOnInteractiveObjectTemplates.Global.Data.ConstructionSite.Sites[_eID] == nil then
        return true;
    end
    if not IsExisting(_eID) then
        local Name = AddOnInteractiveObjectTemplates.Global.Data.ConstructionSite.Sites[_eID].Name;
        Logic.SetVisible(GetID(Name), true);
        API.InteractiveObjectActivate(Name);
        return true;
    end
end

-- Local -----------------------------------------------------------------------

---
-- Initalisiert das AddOn.
-- @within Internal
-- @local
--
function AddOnInteractiveObjectTemplates.Local:Install()
end

Core:RegisterAddOn("AddOnInteractiveObjectTemplates");

</code></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/addonquestdebug.lua.html">
            <div class='doclink'>
                <div>AddOnQuestDebug</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><code>-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia AddOnQuestDebug                                              # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Erweitert den mitgelieferten Debug des Spiels um eine Vielzahl nützlicher
-- neuer Möglichkeiten.
--
-- Die wichtigste Neuerung ist die Konsole, die es erlaubt Quests direkt über
-- die Eingabe von Befehlen zu steuern, einzelne Lua-Funktionen im Spiel
-- auszuführen und sogar komplette Skripte zu laden.
--
-- &#x3C;p&#x3E;&#x3C;a href="#API.ActivateDebugMode"&#x3E;Debug starten&#x3C;/a&#x3E;&#x3C;/p&#x3E;
--
-- @within Modulbeschreibung
-- @set sort=true
--
AddOnQuestDebug = {};

API = API or {};
QSB = QSB or {};

AddOnQuestDebug = {
    Global =  {
        Data = {},
    },
    Local = {
        Data = {},
    },
}

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Aktiviert den Debug.
--
-- Der Developing Mode bietet viele Hotkeys und eine Konsole. Die Konsole ist
-- ein mächtiges Werkzeug. Es ist möglich tief in das Spiel einzugreifen und
-- sogar Funktionen während des Spiels zu überschreiben.
--
-- Die Konsole kann über &#x3C;b&#x3E;SHIFT + ^&#x3C;/b&#x3E; geöffnet werden.
--
-- &#x3C;p&#x3E;&#x3C;b&#x3E;Alias:&#x3C;/b&#x3E; ActivateDebugMode&#x3C;/p&#x3E;
--
-- &#x3C;h3&#x3E;Cheats&#x3C;/h3&#x3E;
-- &#x3C;table border="1"&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;&#x3C;b&#x3E;Cheat&#x3C;/b&#x3E;&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;&#x3C;b&#x3E;Beschreibung&#x3C;/b&#x3E;&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;SHIFT + ^&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Konsole öffnen&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;CTRL + C&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Zeitanzeige an/aus&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;CTRL + SHIFT + F&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Nebel des Krieges abschalten&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;STRG + G&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;GUI ausschalten&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;ALT + F10&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Selektiertes Gebäude anzünden&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;ALT + F11&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Selektierte Einheit verwunden&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;ALT + F12&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Alle Rechte freigeben / wieder sperren&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;CTRL + SHIFT + 1&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;FPS-Anzeige&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;CTRL + (Num) 4&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Bogenschützen unter der Maus spawnen&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;CTRL + (Num) 5&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Schwertkämpfer unter der Maus spawnen&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;CTRL + (Num) 6&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Katapultkarren unter der Maus spawnen&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;CTRL + (Num) 7&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Ramme unter der Maus spawnen&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;CTRL + (Num) 8&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Belagerungsturm unter der Maus spawnen&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;CTRL + (Num) 9&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Katapult unter der Maus spawnen&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;(Num) +&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Spiel beschleunigen&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;(Num) -&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Spiel verlangsamen&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;(Num) *&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Geschwindigkeit zurücksetzen&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;CTRL + F1&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;+ 50 Gold&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;CTRL + F2&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;+ 10 Holz&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;CTRL + F3&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;+ 10 Stein&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;CTRL + F4&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;+ 10 Getreide&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;CTRL + F5&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;+ 10 Milch&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;CTRL + F6&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;+ 10 Kräuter&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;CTRL + F7&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;+ 10 Wolle&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;CTRL + F8&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;+ 10 auf alle Waren&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;SHIFT + F1&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;+ 10 Honig&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;SHIFT + F2&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;+ 10 Eisen&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;SHIFT + F3&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;+ 10 Fisch&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;SHIFT + F4&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;+ 10 Wild&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;CTRL + F9&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Nahrung für selektiertes Gebäude erhöhen&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;SHIFT + F9&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Nahrung für selektiertes Gebäude verringern&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;CTRL + F10&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Kleidung für selektiertes Gebäude erhöhen&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;SHIFT + F10&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Kleidung für selektiertes Gebäude verringern&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;CTRL + F11&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Hygiene für selektiertes Gebäude erhöhen&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;SHIFT + F11&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Hygiene für selektiertes Gebäude verringern&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;CTRL + F12&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Unterhaltung für selektiertes Gebäude erhöhen&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;SHIFT + F12&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Unterhaltung für selektiertes Gebäude verringern&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;ALT + CTRL + F10&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Einnahmen des selektierten Gebäudes erhöhen&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;ALT + (Num) 1&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Burg selektiert → Gold verringern, Werkstatt selektiert → Ware verringern&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;ALT + (Num) 2&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Burg selektiert → Gold erhöhen, Werkstatt selektiert → Ware erhöhen&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;CTRL + ALT + 1&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Kontrolle über Spieler 1&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;CTRL + ALT + 2&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Kontrolle über Spieler 2&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;CTRL + ALT + 3&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Kontrolle über Spieler 3&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;CTRL + ALT + 4&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Kontrolle über Spieler 4&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;CTRL + ALT + 5&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Kontrolle über Spieler 5&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;CTRL + ALT + 6&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Kontrolle über Spieler 6&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;CTRL + ALT + 7&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Kontrolle über Spieler 7&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;CTRL + ALT + 8&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Kontrolle über Spieler 8&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;CTRL + (Num) 0&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Kamera durchschalten&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;CTRL + (Num) 1&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Kamerasprünge im RTS-Mode&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;CTRL + SHIFT + V&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Territorien anzeigen&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;CTRL + SHIFT + B&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Blocking anzeigen&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;CTRL + SHIFT + N&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Gitter verstecken&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;CTRL + SHIFT + F9&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;DEBUG-Ausgabe einschalten&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;ALT + F9&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Zufälligen Arbeiter verheiraten&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;/table&#x3E;
--
-- &#x3C;h3&#x3E;Konsolenbefehle&#x3C;/h3&#x3E;
-- &#x3C;table border=1&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;th&#x3E;&#x3C;b&#x3E;Befehl&#x3C;/b&#x3E;&#x3C;/th&#x3E;
-- &#x3C;th&#x3E;&#x3C;b&#x3E;Parameter&#x3C;/b&#x3E;&#x3C;/th&#x3E;
-- &#x3C;th&#x3E;&#x3C;b&#x3E;Beschreibung&#x3C;/b&#x3E;&#x3C;/th&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;clear&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Entfernt alle Textnachrichten im Debug-Window.&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;diplomacy&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;PlayerID1, PlayerID2, Diplomacy&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Ändert die Doplomatischen Beziehungen zwischen zwei Parteien&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;restartmap&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Startet die Map sofort neu.&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;reveal&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;PlayerID1, PlayerID2&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Teilt die Sicht zweier Spieler.&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;conceal&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;PlayerID1, PlayerID2&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Hebt die geteilte Sicht wieder auf.&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;setposition&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Entity, Target&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Versetzt ein Entity zu einer neuen Position.&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;version&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Zeigt die Version der QSB an.&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;stop&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;QuestName&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Unterbricht den angegebenen Quest.&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;start&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;QuestName&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Startet den angegebenen Quest.&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;win&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;QuestName&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Schließt den angegebenen Quest erfolgreich ab.&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;fail&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;QuestName&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Lässt den angegebenen Quest fehlschlagen&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;restart&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;QuestName&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Startet den angegebenen Quest neu.&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;stopped&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Pattern&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Gibt die Namen abgebrochener Quests zurück.&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;active&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Pattern&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Gibt die Namen aktiver Quests zurück.&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;won&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Pattern&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Gibt die Namen gewonnener Quests zurück.&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;failed&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Pattern&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Gibt die Namen fehlgeschlagener Quests zurück.&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;waiting&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Pattern&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Gibt die Namen nicht ausgelöster Quests zurück.&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;find&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Pattern&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Gibt die Namen von Quests mit ähnlichen Namen zurück.&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;&#x3C;&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Path&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Läd ein Skript zur Laufzeit ins globale Skript.&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;&#x3C;&#x3C;&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Path&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Läd ein Skript zur Laufzeit ins lokale Skript.&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;&#x3E;&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Command&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Führt die Eingabe als Lua-Befahl im globalen Skript aus.&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;tr&#x3E;
-- &#x3C;td&#x3E;&#x3E;&#x3E;&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Command&#x3C;/td&#x3E;
-- &#x3C;td&#x3E;Führt die Eingabe als Lua-Befahl im lokalen Skript aus.&#x3C;/td&#x3E;
-- &#x3C;/tr&#x3E;
-- &#x3C;/table&#x3E;
--
-- @param[type=boolean] _CheckAtRun Prüfe Quests zur Laufzeit
-- @param[type=boolean] _TraceQuests Aktiviert Questverfolgung
-- @param[type=boolean] _DevelopingCheats Aktiviert Cheats
-- @param[type=boolean] _DevelopingShell Aktiviert Eingabe
-- @see Reward_DEBUG
-- @within Anwenderfunktionen
--
function API.ActivateDebugMode(_CheckAtRun, _TraceQuests, _DevelopingCheats, _DevelopingShell)
    if GUI then
        API.Bridge("API.ActivateDebugMode(" ..tostring(_CheckAtRun).. ", " ..tostring(_TraceQuests).. ", " ..tostring(_DevelopingCheats).. ", " ..tostring(_DevelopingShell).. ")");
        return;
    end
    AddOnQuestDebug.Global:ActivateDebug(_CheckAtRun, _TraceQuests, _DevelopingCheats, _DevelopingShell);
end
ActivateDebugMode = API.ActivateDebugMode;

-- -------------------------------------------------------------------------- --
-- Rewards                                                                    --
-- -------------------------------------------------------------------------- --

---
-- Aktiviert den Debug.
--
-- @param[type=boolean] _CheckAtRun Prüfe Quests zur Laufzeit
-- @param[type=boolean] _TraceQuests Aktiviert Questverfolgung
-- @param[type=boolean] _DevelopingCheats Aktiviert Cheats
-- @param[type=boolean] _DevelopingShell Aktiviert Eingabe
-- @see API.ActivateDebugMode
--
-- @within Reward
--
function Reward_DEBUG(...)
    return b_Reward_DEBUG:new(...);
end

b_Reward_DEBUG = {
    Name = "Reward_DEBUG",
    Description = {
        en = "Reward: Start the debug mode. See documentation for more information.",
        de = "Lohn: Startet den Debug-Modus. Für mehr Informationen siehe Dokumentation.",
    },
    Parameter = {
        { ParameterType.Custom,     en = "Check quest while runtime", de = "Quests zur Laufzeit prüfen" },
        { ParameterType.Custom,     en = "Use quest trace", de = "Questverfolgung" },
        { ParameterType.Custom,     en = "Activate developing cheats", de = "Cheats aktivieren" },
        { ParameterType.Custom,     en = "Activate developing shell", de = "Eingabe aktivieren" },
    },
}

function b_Reward_DEBUG:GetRewardTable(__quest_)
    return { Reward.Custom, {self, self.CustomFunction} }
end

function b_Reward_DEBUG:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.CheckWhileRuntime = AcceptAlternativeBoolean(_Parameter)
    elseif (_Index == 1) then
        self.UseQuestTrace = AcceptAlternativeBoolean(_Parameter)
    elseif (_Index == 2) then
        self.DevelopingCheats = AcceptAlternativeBoolean(_Parameter)
    elseif (_Index == 3) then
        self.DevelopingShell = AcceptAlternativeBoolean(_Parameter)
    end
end

function b_Reward_DEBUG:CustomFunction(__quest_)
    API.ActivateDebugMode(self.CheckWhileRuntime, self.UseQuestTrace, self.DevelopingCheats, self.DevelopingShell);
end

function b_Reward_DEBUG:GetCustomData(_Index)
    return {"true","false"};
end

Core:RegisterBehavior(b_Reward_DEBUG);

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

-- Global Script ---------------------------------------------------------------

---
-- Initalisiert das Bundle im globalen Skript.
--
-- @within Internal
-- @local
--
function AddOnQuestDebug.Global:Install()

    AddOnQuestDebug.Global.Data.DebugCommands = {
        -- groupless commands
        {"clear",       AddOnQuestDebug.Global.Clear,},
        {"diplomacy",   AddOnQuestDebug.Global.Diplomacy,},
        {"restartmap",  AddOnQuestDebug.Global.RestartMap,},
        {"reveal",      AddOnQuestDebug.Global.ShareView,                1},
        {"conceal",     AddOnQuestDebug.Global.ShareView,                0},
        {"setposition", AddOnQuestDebug.Global.SetPosition,},
        {"version",     AddOnQuestDebug.Global.ShowVersion,},
        -- quest control
        {"win",         AddOnQuestDebug.Global.SetQuestState,            1},
        {"fail",        AddOnQuestDebug.Global.SetQuestState,            2},
        {"stop",        AddOnQuestDebug.Global.SetQuestState,            3},
        {"start",       AddOnQuestDebug.Global.SetQuestState,            4},
        {"restart",     AddOnQuestDebug.Global.SetQuestState,            5},
        {"won",         AddOnQuestDebug.Global.FindQuestsByState,        1},
        {"failed",      AddOnQuestDebug.Global.FindQuestsByState,        2},
        {"stoped",      AddOnQuestDebug.Global.FindQuestsByState,        3},
        {"active",      AddOnQuestDebug.Global.FindQuestsByState,        4},
        {"waiting",     AddOnQuestDebug.Global.FindQuestsByState,        5},
        {"find",        AddOnQuestDebug.Global.FindQuestsByState,        6},
        -- loading scripts into running game and execute them
        {"&#x3C;&#x3C;",          AddOnQuestDebug.Global.LoadScript,               true},
        {"&#x3C;",           AddOnQuestDebug.Global.LoadScript,               false},
        -- execute short lua commands
        {"&#x3E;&#x3E;",          AddOnQuestDebug.Global.ExecuteCommand,           true},
        {"&#x3E;",           AddOnQuestDebug.Global.ExecuteCommand,           false},
        -- old shit -&#x3E; "inoffical commands"
        {"shareview",   AddOnQuestDebug.Global.ShareView,                -1},
        {"printequal",  AddOnQuestDebug.Global.FindQuestsByState,        6},
        {"printactive", AddOnQuestDebug.Global.FindQuestsByState,        4},
        {"lexec",       AddOnQuestDebug.Global.ExecuteLuaCommand,        true},
        {"gexec",       AddOnQuestDebug.Global.ExecuteLuaCommand,        false},
        {"lload",       AddOnQuestDebug.Global.LoadScript,               true},
        {"gload",       AddOnQuestDebug.Global.LoadScript,               false},
    }

    for k,v in pairs(_G) do
        if type(v) == "table" and v.Name and k == "b_"..v.Name and v.CustomFunction and not v.CustomFunction2 then
            v.CustomFunction2 = v.CustomFunction;
            v.CustomFunction = function(self, __quest_)
                if AddOnQuestDebug.Global.Data.CheckAtRun then
                    if self.DEBUG and not self.FOUND_ERROR and self:Debug(__quest_) then
                        self.FOUND_ERROR = true;
                    end
                end
                if not self.FOUND_ERROR then
                    return self:CustomFunction2(__quest_);
                end
            end
        end
    end

    self:OverwriteCreateQuests();

    API.AddSaveGameAction(self.OnSaveGameLoad);
end

---
-- Aktiviert den Debug.
--
-- Der Developing Mode bietet viele Hotkeys und eine Konsole. Die Konsole ist
-- ein mächtiges Werkzeug. Es ist möglich tief in das Spiel einzugreifen und
-- sogar Funktionen während des Spiels zu überschreiben.
--
-- @param _CheckAtRun [boolean] Prüfe Quests zur Laufzeit
-- @param _TraceQuests [boolean] Aktiviert Questverfolgung
-- @param _Cheats [boolean] Aktiviert Cheats
-- @param _Shell [boolean] Aktiviert Konsole
-- @within Internal
-- @local
--
function AddOnQuestDebug.Global:ActivateDebug(_CheckAtRun, _TraceQuests, _Cheats, _Shell)
    if self.Data.DebugModeIsActive then
        return;
    end
    self.Data.DebugModeIsActive = true;

    self.Data.CheckAtRun       = _CheckAtRun == true;
    self.Data.TraceQuests      = _TraceQuests == true;
    self.Data.DevelopingCheats = _Cheats == true;
    self.Data.DevelopingShell  = _Shell == true;

    self:ActivateQuestTrace();
    self:ActivateDevelopingCheats();
    self:ActivateDevelopingShell();
end

---
-- Aktiviert die Questverfolgung. Jede Statusänderung wird am Bildschirm
-- angezeigt.
--
-- @within Internal
-- @local
--
function AddOnQuestDebug.Global:ActivateQuestTrace()
    if self.Data.TraceQuests then
        DEBUG_EnableQuestDebugKeys();
        DEBUG_QuestTrace(true);
    end
end

---
-- &#x3C;p&#x3E;Aktiviert die Cheats.&#x3C;/p&#x3E;
-- &#x3C;p&#x3E;Es werden die Development-Cheats benutzt und um einige neue erweitert.&#x3C;/p&#x3E;
--
-- @within Internal
-- @local
--
function AddOnQuestDebug.Global:ActivateDevelopingCheats()
    if self.Data.DevelopingCheats then
        Logic.ExecuteInLuaLocalState("AddOnQuestDebug.Local:ActivateDevelopingCheats()");
    end
end

---
-- &#x3C;p&#x3E;Aktiviert die Shell.&#x3C;/p&#x3E;
-- &#x3C;p&#x3E;Der Debug stellt einige zusätzliche Tastenkombinationen bereit:&#x3C;/p&#x3E;
-- &#x3C;p&#x3E;Die Konsole des Debug wird mit SHIFT + ^ geöffnet.&#x3C;/p&#x3E;
-- &#x3C;p&#x3E;Die Konsole bietet folgende Kommandos:&#x3C;/p&#x3E;
--
-- @within Internal
-- @local
--
function AddOnQuestDebug.Global:ActivateDevelopingShell()
    if self.Data.DevelopingShell then
        Logic.ExecuteInLuaLocalState("AddOnQuestDebug.Local:ActivateDevelopingShell()");
    end
end

---
-- Ließt eingegebene Kommandos und führt entsprechende Funktionen aus.
--
-- Für die Zerlegung der Kommandizeile wird der Tokenizer benutzt.
--
-- Für die Nutzung im LuaDebugger des Spiels, müssen Kommandos mit
-- eval() aufgerufen werden.
--
-- @within Internal
-- @local
-- @see AddOnQuestDebug.Global:Tokenize
--
function AddOnQuestDebug.Global:Parser(_Input)
    local Results = {};
    local Commands = self:Tokenize(_Input);
    for k, v in pairs(Commands) do
        local Action = string.lower(v[1]);
        for i= 1, #AddOnQuestDebug.Global.Data.DebugCommands, 1 do
            if v[1] == AddOnQuestDebug.Global.Data.DebugCommands[i][1] then
                local SelectedCommand = AddOnQuestDebug.Global.Data.DebugCommands[i];
                for j=2, #v, 1 do
                    local Number = tonumber(v[j]);
                    if Number then
                        v[j] = Number;
                    end
                end

                local CommandResult = SelectedCommand[2](v, SelectedCommand[3]);
                if CommandResult then
                    table.insert(Results, CommandResult);
                end
            end
        end
    end
    return Results;
end
function eval(_Input)
    return AddOnQuestDebug.Global:Parser(_Input);
end

---
-- Zerlegt den Eingabestring in einzelne Kommandos und gibt diese als Table
-- zurück. Unterschiedliche Kommandos werden mit && abgetrennt und entsprechend
-- als mehrere Einträge im Table angelegt. Mit dem Wiederholungszeichen &
-- wird das Komanndo für alle angegebenen Eingaben wiederholt.
--
-- Beispiel:
--
-- &#x3C;pre&#x3E;
-- Eingabe:
-- "win QuestA & QuestB && fail QuestC && stop QuestD & Quest E"
--
-- Ausgabe:
-- {
-- {"win", "QuestA"}
-- {"win", "QuestB"}
-- {"fail", "QuestC"}
-- {"stop", "QuestD"}
-- {"stop", "QuestE"}
-- }&#x3C;/pre&#x3E;
--
-- @return Table mit Tokens
-- @within Internal
-- @local
--
function AddOnQuestDebug.Global:Tokenize(_Input)
    local Commands = {};
    local DAmberCommands = {_Input};
    local AmberCommands = {};

    -- parse & delimiter
    local s, e = string.find(_Input, "s+&&s+");
    if s then
        DAmberCommands = {};
        while (s) do
            local tmp = string.sub(_Input, 1, s-1);
            table.insert(DAmberCommands, tmp);
            _Input = string.sub(_Input, e+1);
            s, e = string.find(_Input, "s+&&s+");
        end
        if string.len(_Input) &#x3E; 0 then 
            table.insert(DAmberCommands, _Input);
        end
    end

    -- parse & delimiter
    for i= 1, #DAmberCommands, 1 do
        local s, e = string.find(DAmberCommands[i], "s+&s+");
        if s then
            local LastCommand = "";
            while (s) do
                local tmp = string.sub(DAmberCommands[i], 1, s-1);
                table.insert(AmberCommands, LastCommand .. tmp);
                if string.find(tmp, " ") then
                    LastCommand = string.sub(tmp, 1, string.find(tmp, " ")-1) .. " ";
                end
                DAmberCommands[i] = string.sub(DAmberCommands[i], e+1);
                s, e = string.find(DAmberCommands[i], "s+&s+");
            end
            if string.len(DAmberCommands[i]) &#x3E; 0 then 
                table.insert(AmberCommands, LastCommand .. DAmberCommands[i]);
            end
        else
            table.insert(AmberCommands, DAmberCommands[i]);
        end
    end

    -- parse spaces
    for i= 1, #AmberCommands, 1 do
        local CommandLine = {};
        local s, e = string.find(AmberCommands[i], "s+");
        if s then
            while (s) do
                local tmp = string.sub(AmberCommands[i], 1, s-1);
                table.insert(CommandLine, tmp);
                AmberCommands[i] = string.sub(AmberCommands[i], e+1);
                s, e = string.find(AmberCommands[i], "s+");
            end
            table.insert(CommandLine, AmberCommands[i]);
        else
            table.insert(CommandLine, AmberCommands[i]);
        end
        table.insert(Commands, CommandLine);
    end

    return Commands;
end

---
-- Läd ein Lua-Skript in das Enviorment.
--
-- @within Internal
-- @local
--
function AddOnQuestDebug.Global.LoadScript(_Arguments, _Flags)
    if _Arguments[2] then
        if _Flags == true then
            Logic.ExecuteInLuaLocalState([[Script.Load("]].._Arguments[2]..[[")]]);
        elseif _Flags == false then
            Script.Load(_Arguments[2]);
        end
        API.Note("load script ".._Arguments[2]);
    end
end

---
-- Ruft eine Funktion (optional mit Parametern) im Enviorment auf.
--
-- @within Internal
-- @local
--
function AddOnQuestDebug.Global.ExecuteCommand(_Arguments, _Flags)
    if _Arguments[2] then
        local args = "";
        for i=3,#_Arguments do
            args = args .. ((i&#x3E;3 and ",") or "");
            args = args .. " " .. _Arguments[i];
        end

        if _Flags == true then
            Logic.ExecuteInLuaLocalState([[]].. _Arguments[2] .. [[(]] ..args..[[)]]);
        elseif _Flags == false then
            Logic.ExecuteInLuaLocalState([[GUI.SendScriptCommand("]].. _Arguments[2] .. [[(]]..args..[[)")]]);
        end
    end
end

---
-- Führt ein Lua-Command innerhalb des Strings aus.
--
-- @within Internal
-- @local
--
function AddOnQuestDebug.Global.ExecuteLuaCommand(_Arguments, _Flags)
    if _Arguments[2] then
        local args = "";
        for i=2,#_Arguments do
            args = args .. " " .. _Arguments[i];
        end

        if _Flags == true then
            Logic.ExecuteInLuaLocalState([[]]..args..[[]]);
        elseif _Flags == false then
            Logic.ExecuteInLuaLocalState([[GUI.SendScriptCommand("]]..args..[[")]]);
        end
    end
end

---
-- Konsolenbefehl: Leert das Debug Window.
--
-- @within Internal
-- @local
--
function AddOnQuestDebug.Global.Clear()
    Logic.ExecuteInLuaLocalState("GUI.ClearNotes()");
end

---
-- Konsolenbefehl: Ändert die Diplomatie zwischen zwei Spielern.
--
-- @within Internal
-- @local
--
function AddOnQuestDebug.Global.Diplomacy(_Arguments)
    SetDiplomacyState(_Arguments[2], _Arguments[3], _Arguments[4]);
end

---
--  Konsolenbefehl: Startet die Map umgehend neu.
--
-- @within Internal
-- @local
--
function AddOnQuestDebug.Global.RestartMap()
    Logic.ExecuteInLuaLocalState("Framework.RestartMap()");
end

---
-- Konsolenbefehl: Aktiviert/deaktiviert die geteilte Sicht zweier Spieler.
--
-- @within Internal
-- @local
--
function AddOnQuestDebug.Global.ShareView(_Arguments, _Flag)
    if _Flag == -1 then
        Logic.SetShareExplorationWithPlayerFlag(_Arguments[2], _Arguments[3], _Arguments[4]);
    end
    Logic.SetShareExplorationWithPlayerFlag(_Arguments[2], _Arguments[3], _Flag);
end

---
-- Konsolenbefehl: Setzt die Position eines Entity.
--
-- @within Internal
-- @local
--
function AddOnQuestDebug.Global.SetPosition(_Arguments)
    local entity = GetID(_Arguments[2]);
    local target = GetID(_Arguments[3]);
    local x,y,z  = Logic.EntityGetPos(target);
    if Logic.IsBuilding(target) == 1 then
        x,y = Logic.GetBuildingApproachPosition(target);
    end
    Logic.DEBUG_SetSettlerPosition(entity, x, y);
    if Logic.IsLeader(entity) == 1 then
        local Soldiers = {Logic.GetSoldiersAttachedToLeader(entity)};
        for i= 1, #Soldiers, 1 do
            if isExisting(Soldiers[i]) then
                Logic.DEBUG_SetSettlerPosition(Soldiers[i], x, y);
            end
        end
    end
end

---
-- Konsolenbefehl: Zeigt die Version der QSB an.
--
-- @within Internal
-- @local
--
function AddOnQuestDebug.Global.ShowVersion()
    API.Bridge("GUI.ClearNotes(); GUI.AddStaticNote(QSB.Version)");
    return QSB.Version;
end

---
-- Konsolenbefehl: Sucht nach allen Quests, auf die den angegebenen Namen
-- enthalten und gibt die Namen der gefundenen Quests zurück.
--
-- @within Internal
-- @local
--
function AddOnQuestDebug.Global.FindQuestNames(_Pattern, _ExactName)
    local FoundQuests = FindQuestsByName(_Pattern, _ExactName);
    if #FoundQuests == 0 then
        return {};
    end
    local NamesOfFoundQuests = {};
    for i= 1, #FoundQuests, 1 do
        table.insert(NamesOfFoundQuests, FoundQuests[i].Identifier);
    end
    return NamesOfFoundQuests;
end

---
-- Konsolenbefehl: Gibt die Namen aller Quests mit dem Status zurück. Die
-- Suche kann mit einem Pattern eingeschränkt werden. Es werden maximal 12
-- Quests angezeigt.
--
-- @within Internal
-- @local
--
function AddOnQuestDebug.Global.FindQuestsByState(_Data, _Flag)
    local QuestsOfState = {};
    for i= 1, Quests[0], 1 do
        if _Flag == 1 and Quests[i].Result == QuestResult.Success then
            table.insert(QuestsOfState, Quests[i]);
        end
        if _Flag == 2 and Quests[i].Result == QuestResult.Failure then
            table.insert(QuestsOfState, Quests[i]);
        end
        if _Flag == 3 and Quests[i].Result == QuestResult.Interrupted then
            table.insert(QuestsOfState, Quests[i]);
        end
        if _Flag == 4 and Quests[i].State == QuestState.Active then
            table.insert(QuestsOfState, Quests[i]);
        end
        if _Flag == 5 and Quests[i].State == QuestState.NotTriggered then
            table.insert(QuestsOfState, Quests[i]);
        end
        if _Flag == 6 and ((_Data[2] and string.find(Quests[i].Identifier, _Data[2])) or not _Data[2]) then
            table.insert(QuestsOfState, Quests[i]);
        end
    end

    local QuestNames = "";
    local Matching = 0;
    for i= 1, #QuestsOfState, 1 do
        if Matching &#x3C; 15 then
            if _Data[2] then
                if string.find(QuestsOfState[i].Identifier, _Data[2]) then
                    QuestNames = QuestNames .. "- " .. QuestsOfState[i].Identifier .. "{cr}";
                    Matching = Matching +1;
                end
            else
                QuestNames = QuestNames .. "- " .. QuestsOfState[i].Identifier .. "{cr}";
                Matching = Matching +1;
            end
        else
            QuestNames = QuestNames .. "... (" .. (#QuestsOfState-Matching) .. " more)";
            break;
        end
    end

    Logic.ExecuteInLuaLocalState([[
        GUI.ClearNotes()
        GUI.AddStaticNote("Found quests:{cr}]]..QuestNames..[[")
    ]]);
    return "Found quests:{cr}"..QuestNames;
end

---
-- Konsolenbefehl: Setzt den Status eines Quests. Mit der Statusänderung wird
-- ggf. Fortschrit zurückgesetzt.
--
-- @within Internal
-- @local
--
function AddOnQuestDebug.Global.SetQuestState(_Data, _Flag)
    local FoundQuests = AddOnQuestDebug.Global.FindQuestNames(_Data[2], true);
    if #FoundQuests ~= 1 then
        API.Note("Unable to find quest containing '" .._Data[2].. "'");
        return "Unable to find quest containing '" .._Data[2].. "'";
    end
    if _Flag == 1 then
        API.WinQuest(FoundQuests[1], true);
        API.Note("win quest '" ..FoundQuests[1].. "'");
        return "win quest '" ..FoundQuests[1].. "'"
    elseif _Flag == 2 then
        API.FailQuest(FoundQuests[1], true);
        API.Note("fail quest '" ..FoundQuests[1].. "'");
        return "fail quest '" ..FoundQuests[1].. "'"
    elseif _Flag == 3 then
        API.StopQuest(FoundQuests[1], true);
        API.Note("interrupt quest '" ..FoundQuests[1].. "'");
        return "interrupt quest '" ..FoundQuests[1].. "'";
    elseif _Flag == 4 then
        API.StartQuest(FoundQuests[1], true);
        API.Note("trigger quest '" ..FoundQuests[1].. "'");
        return "trigger quest '" ..FoundQuests[1].. "'";
    else
        API.RestartQuest(FoundQuests[1], true);
        API.Note("restart quest '" ..FoundQuests[1].. "'");
        return "restart quest '" ..FoundQuests[1].. "'";
    end
end

---
-- Überschreibt CreateQuests, sodass Assistentenquests über das Skript erzeugt
-- werden um diese sinnvoll überprüfen zu können.
--
-- @within Internal
-- @local
--
function AddOnQuestDebug.Global.OverwriteCreateQuests()
    AddOnQuestDebug.Global.Data.CreateQuestsOriginal = CreateQuests;
    CreateQuests = function()
        local QuestNames = Logic.Quest_GetQuestNames()
        for i=1, #QuestNames, 1 do
            local QuestName = QuestNames[i]
            local QuestData = {Logic.Quest_GetQuestParamter(QuestName)};

            -- Behavior ermitteln
            local Behaviors = {};
            local Amount = Logic.Quest_GetQuestNumberOfBehaviors(QuestName);
            if Amount &#x3E; 0 then
                for j=0, Amount-1, 1 do
                    local Name = Logic.Quest_GetQuestBehaviorName(QuestName, j);
                    local Template = GetBehaviorTemplateByName(Name);
                    assert(Template ~= nil);

                    local Parameters = Logic.Quest_GetQuestBehaviorParameter(QuestName, j);
                    table.insert(Behaviors, Template:new(unpack(Parameters)));
                end

                local SuggestionText;
                if (QuestData[6] and QuestData[6] ~= "" and QuestData[6] ~= "KEY(NO_MESSAGE)") then
                    SuggestionText = QuestData[6];
                end
                local SuccessText;
                if (QuestData[8] and QuestData[8] ~= "" and QuestData[8] ~= "KEY(NO_MESSAGE)") then
                    SuccessText = QuestData[8];
                end
                local FailureText;
                if (QuestData[7] and QuestData[7] ~= "" and QuestData[7] ~= "KEY(NO_MESSAGE)") then
                    FailureText = QuestData[7];
                end

                API.CreateQuest {
                    Name        = QuestName,
                    Sender      = QuestData[1],
                    Receiver    = QuestData[2],
                    Time        = QuestData[4],
                    Description = QuestData[5],
                    Suggestion  = SuggestionText,
                    Failure     = FailureText,
                    Success     = SuccessText,

                    unpack(Behaviors),
                };
            end
        end
    end
end

---
-- Stellt den Debug nach dem Laden eines Spielstandes wieder her.
--
-- @param _Arguments Argumente der überschriebenen Funktion
-- @param _Original  Referenz auf Save-Funktion
-- @within Internal
-- @local
--
function AddOnQuestDebug.Global.OnSaveGameLoad(_Arguments, _Original)
    AddOnQuestDebug.Global:ActivateDevelopingCheats();
    AddOnQuestDebug.Global:ActivateDevelopingShell();
    AddOnQuestDebug.Global:ActivateQuestTrace();
end

-- Local Script ----------------------------------------------------------------

---
-- Initalisiert das Bundle im lokalen Skript.
--
-- @within Internal
-- @local
--
function AddOnQuestDebug.Local:Install()
end

---
-- Aktiviert die Development Cheats des Spiels.
--
-- @see AddOnQuestDebug.Global:ActivateDevelopingCheats
-- @within Internal
-- @local
--
function AddOnQuestDebug.Local:ActivateDevelopingCheats()
    KeyBindings_EnableDebugMode(1);
    KeyBindings_EnableDebugMode(2);
    KeyBindings_EnableDebugMode(3);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft/GameClock",1);
end

---
-- Aktiviert die Kommandokonsole.
--
-- @see AddOnQuestDebug.Global:ActivateDevelopingShell
-- @within Internal
-- @local
--
function AddOnQuestDebug.Local:ActivateDevelopingShell()
    GUI_Chat.Abort = function() end

    GUI_Chat.Confirm = function()
        Input.GameMode();
        XGUIEng.ShowWidget("/InGame/Root/Normal/ChatInput",0);
        AddOnQuestDebug.Local.Data.ChatBoxInput = XGUIEng.GetText("/InGame/Root/Normal/ChatInput/ChatInput");
        g_Chat.JustClosed = 1;
        Game.GameTimeSetFactor( GUI.GetPlayerID(), 1 );
    end

    QSB_DEBUG_InputBoxJob = function()
        if not AddOnQuestDebug.Local.Data.BoxShown then
            Input.ChatMode();
            Game.GameTimeSetFactor( GUI.GetPlayerID(), 0 );
            XGUIEng.ShowWidget("/InGame/Root/Normal/ChatInput", 1);
            XGUIEng.SetText("/InGame/Root/Normal/ChatInput/ChatInput", "");
            XGUIEng.SetFocus("/InGame/Root/Normal/ChatInput/ChatInput");
            AddOnQuestDebug.Local.Data.BoxShown = true
        elseif AddOnQuestDebug.Local.Data.ChatBoxInput then
            AddOnQuestDebug.Local.Data.ChatBoxInput = string.gsub(AddOnQuestDebug.Local.Data.ChatBoxInput,"'","\'");
            GUI.SendScriptCommand("AddOnQuestDebug.Global:Parser('"..AddOnQuestDebug.Local.Data.ChatBoxInput.."')");
            AddOnQuestDebug.Local.Data.BoxShown = nil;
            return true;
        end
    end

    Input.KeyBindDown(Keys.ModifierShift + Keys.OemPipe, "StartSimpleJob('QSB_DEBUG_InputBoxJob')", 2);
end

Core:RegisterBundle("AddOnQuestDebug");

</code></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/addonrandomrequests.lua.html">
            <div class='doclink'>
                <div>AddOnRandomRequests</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><code>-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia AddOnRandomRequests                                          # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Dieses Bundle stellt zufällige Aufgaben durch NPC-Spieler bereit.
--
-- Es gibt verschiedene Typen von zufälligen Aufträgen. Es wird versucht, immer
-- einen einzigartigen Auftrag für den jeweiligen Auftraggeber zu erzeugen.
-- Wenn kein Auftrag erzeugt werden kann, wird der Spieler aufgefordert 2000
-- Gold zu bezahlen.
--
-- @within Modulbeschreibung
-- @set sort=true
--
AddOnRandomRequests = {};

API = API or {};
QSB = QSB or {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --


-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

AddOnRandomRequests = {
    Global = {
        Data = {
            RandomQuestNameCounter = 0;
            Claim = {},
            Deliver = {},
            Reputation = {},
            KnightTitle = {},

            Text = {
                Suggestion = {
                    {de = "Ihr müsst Euer Können unter Beweis stellen!",
                     en = "Please show us what you are capable of!"},
                    {de = "Bei diesem Problem benötigen wir Eure Unterstützung!",
                     en = "This problem is driving us nuts! Please help us!"},
                    {de = "Euer Volk braucht Eure Hilfe! Werdet Ihr uns helfen?",
                     en = "Your pepole demand your attantion. Will you help them?"},
                },
                Success = {
                    {de = "Wir möchten Euch von Herzen für Eure Hilfe danken!",
                     en = "Let us thank you from the bottem of out hearts!"},
                    {de = "Ihr habt bewiesen, dass man Euch vertrauen kann!",
                     en = "You have proven the trust we have in your, Milord!"},
                    {de = "Gott segne Euch! Wir sind gerettet!",
                     en = "God be praised! You saved us all!"},
                },
                Failure = {
                    {de = "Wir haben Euch vertraut! Mich deucht Euer Wort ist nichts wert!",
                     en = "We trusted you! So that is what your words are worth! Nothing!"},
                    {de = "Anführer! Es sind viele an der Zahl doch taugen alle wenig!",
                     en = "Leaders! They are many but they can't even tie their shoes!"},
                    {de = "Ein Herrscher wollt Ihr sein? Lernt das Volk zu schätzen!",
                     en = "You call yourself a ruler? Go and remember the needs of the pepole!"},
                },
            }
        },
    },
    Local = {},
}

-- Global ----------------------------------------------------------------------

---
-- Initalisiert das AddOn.
-- @within Internal
-- @local
--
function AddOnRandomRequests.Global:Install()
end

---
-- Erzeugt einen zufälligen Slave Quest anhand der Einstellungen im Quest.
-- @param[type=table] _Behavior Behavior Data
-- @param[type=table] _Quest    Quest Data
-- @within Internal
-- @local
--
function AddOnRandomRequests.Global:CreateSlaveQuest(_Behavior, _Quest)
    if not _Behavior.SlaveQuest then
        local QuestGoals = self:GetPossibleBehaviors(_Behavior, _Quest);
        -- Fallback
        if #QuestGoals == 0 then
            QuestGoals[#QuestGoals+1] = {"Goal_Deliver", "G_Gold", 2000};
        end
        local SelectedGoal = QuestGoals[math.random(1, #QuestGoals)];
        local FunctionName = table.remove(SelectedGoal, 1);

        self.Data.RandomQuestNameCounter = self.Data.RandomQuestNameCounter +1;
        local QuestName = API.CreateQuest {
            Name        = "RandomRequest_Player" .._Quest.SendingPlayer.. "_" ..self.Data.RandomQuestNameCounter;
            Suggestion  = _Behavior.OptionalSuggestion or self.Data.Text.Suggestion[math.random(1, 3)],
            Success     = _Behavior.OptionalSuccess or self.Data.Text.Success[math.random(1, 3)],
            Failure     = _Behavior.OptionalFailure or self.Data.Text.Failure[math.random(1, 3)],
            Receiver    = _Quest.ReceivingPlayer,
            Sender      = _Quest.SendingPlayer,
            Time        = _Behavior.TimeLimit,

            _G[FunctionName](unpack(SelectedGoal)),
            Trigger_Time(0),
        };
        _Behavior.SlaveQuest = Quests[GetQuestID(QuestName)];
    end
end

---
-- Gibt eine Liste mit Behavior zurück, die für den Random Quest verfügbar
-- sind. Es wird eines der Behavior ausgewählt.
-- @param[type=table] _Behavior Behavior Data
-- @param[type=table] _Quest    Quest Data
-- @within Internal
-- @local
--
function AddOnRandomRequests.Global:GetPossibleBehaviors(_Behavior, _Quest)
    local QuestGoals = {};
    if _Behavior.TypeDeliverGoods then
        QuestGoals[#QuestGoals+1] = self:GetDeliverGoodsBehavior(_Behavior, _Quest);
    end
    if _Behavior.TypeDeliverGold then
        local Amount = math.random(150, 225) * (Logic.GetKnightTitle(_Quest.ReceivingPlayer) +1);
        QuestGoals[#QuestGoals+1] = {"Goal_Deliver", "G_Gold", Amount};
    end
    if _Behavior.TypeClaim then
        QuestGoals[#QuestGoals+1] = self:GetClaimTerritoryBehavior(_Behavior, _Quest);
    end
    if _Behavior.TypeKnightTitle then
        QuestGoals[#QuestGoals+1] = self:GetKnightTitleBehavior(_Behavior, _Quest);
    end
    if _Behavior.TypeReputation then
        self.Data.KnightTitle[_Quest.ReceivingPlayer] = self.Data.KnightTitle[_Quest.ReceivingPlayer] or {};
        local Reputation = 25 + (10 * Logic.GetKnightTitle(_Quest.ReceivingPlayer));
        if self.Data.KnightTitle[_Quest.ReceivingPlayer][Reputation] then
            return QuestGoals;
        end
        self.Data.KnightTitle[_Quest.ReceivingPlayer][Reputation] = true;
        QuestGoals[#QuestGoals+1] = {"Goal_CityReputation", Reputation};
    end
    if _Behavior.TypeBuildWall then
        QuestGoals[#QuestGoals+1] = self:GetBuildWallBehavior(_Behavior, _Quest);
    end
    return QuestGoals;
end

---
-- Erstellt Goal_KnightTitle für den Random Quest.
-- @param[type=table] _Behavior Behavior Data
-- @param[type=table] _Quest    Quest Data
-- @within Internal
-- @local
--
function AddOnRandomRequests.Global:GetKnightTitleBehavior(_Behavior, _Quest)
    if Logic.GetKnightTitle(_Quest.ReceivingPlayer) &#x3C; KnightTitles.Archduke then
        local PossibleTitles = {"Mayor", "Baron", "Earl", "Marquees", "Duke", "Archduke"};
        local NextTitle = PossibleTitles[Logic.GetKnightTitle(_Quest.ReceivingPlayer)+1];
        self.Data.KnightTitle[_Quest.ReceivingPlayer] = self.Data.KnightTitle[_Quest.ReceivingPlayer] or {};
        if self.Data.KnightTitle[_Quest.ReceivingPlayer][NextTitle] then
            return;
        end
        self.Data.KnightTitle[_Quest.ReceivingPlayer][NextTitle] = true;
        return {"Goal_KnightTitle", NextTitle};
    end 
end

---
-- Erstellt Goal_BuildWall für den Random Quest.
-- @param[type=table] _Behavior Behavior Data
-- @param[type=table] _Quest    Quest Data
-- @within Internal
-- @local
--
function AddOnRandomRequests.Global:GetBuildWallBehavior(_Behavior, _Quest)
    local FirstEnemy;
    for i= 1, 8, 1 do
        if i ~= _Quest.SendingPlayer and i ~= _Quest.ReceivingPlayer and DiplomaticEntity.GetRelationBetween(i, _Quest.ReceivingPlayer) == DiplomacyStates.Enemy then
            FirstEnemy = i;
            break;
        end
    end
    if FirstEnemy then
        local SPStorehouse = Logic.GetStoreHouse(_Quest.SendingPlayer);
        local RPStorehouse = Logic.GetStoreHouse(_Quest.ReceivingPlayer);
        return {"Goal_BuildWall", FirstEnemy, RPStorehouse, SPStorehouse};
    end
end

---
-- Erstellt Goal_Claim für den Random Quest.
-- @param[type=table] _Behavior Behavior Data
-- @param[type=table] _Quest    Quest Data
-- @within Internal
-- @local
--
function AddOnRandomRequests.Global:GetClaimTerritoryBehavior(_Behavior, _Quest)
    local AllTerritories = {Logic.GetTerritories()};
    self.Data.Claim[_Quest.ReceivingPlayer] = self.Data.Claim[_Quest.ReceivingPlayer] or {};
    for i= #AllTerritories, 1, -1 do
        if self.Data.Claim[_Quest.ReceivingPlayer][NextTitle] then
            return;
        end
        if AllTerritories[i] == 0 or Logic.GetTerritoryPlayerID(AllTerritories[i]) ~= 0 
        or self.Data.Claim[_Quest.ReceivingPlayer][AllTerritories[i]] then
            table.remove(AllTerritories, i);
        end
    end
    if #AllTerritories &#x3E; 0 then
        local Territory = AllTerritories[math.random(1, #AllTerritories)];
        self.Data.Claim[_Quest.ReceivingPlayer][Territory] = true;
        return {"Goal_Claim", AllTerritories[math.random(1, #AllTerritories)]};
    end
end

---
-- Erstellt Goal_Deliver (Rohstoffe) für den Random Quest.
-- @param[type=table] _Behavior Behavior Data
-- @param[type=table] _Quest    Quest Data
-- @within Internal
-- @local
--
function AddOnRandomRequests.Global:GetDeliverGoodsBehavior(_Behavior, _Quest)
    local GoodTypes = {
        "G_Wood", "G_Iron", "G_Stone", "G_Carcass", "G_Herb", "G_Wool",
        "G_Honeycomb", "G_Grain", "G_Milk", "G_RawFish"
    };

    local Receiver = _Quest.ReceivingPlayer;
    local Sender   = _Quest.SendingPlayer;
    self.Data.Deliver[Receiver] = self.Data.Deliver[Receiver] or {};
    self.Data.Deliver[Receiver][Sender] = self.Data.Deliver[Receiver][Sender] or {};

    local SelectedGood;
    repeat
        SelectedGood = GoodTypes[math.random(1, #GoodTypes)];
    until (self:CanGoodBeSetAsGoal(Sender, Receiver, Goods[SelectedGood]));
    local Amount = math.random(15, 25) * (Logic.GetKnightTitle(Receiver) +1);
    self.Data.Deliver[Receiver][Sender][Goods[SelectedGood]] = true;
    return {"Goal_Deliver", SelectedGood, Amount};
end 

---
-- Prüft, ob eine Ware für ein Goal_Deliver verwendet werden kann.
-- @param[type=number] _SenderID   Sendender Spieler
-- @param[type=number] _ReceiverID Empfangender Spieler
-- @param[type=number] _Good       Warentyp
-- @return[type=boolean] Ware kann benutzt werden.
-- @within Internal
-- @local
--
function AddOnRandomRequests.Global:CanGoodBeSetAsGoal(_SenderID, _ReceiverID, _Good)
    if self.Data.Deliver[_ReceiverID][_SenderID][_Good] then
        return false;
    end
    if MerchantSystem.TradeBlackList[_SenderID] then
        for k, v in pairs(MerchantSystem.TradeBlackList[_SenderID]) do
            if v == _Good then
                return false;
            end
        end
    end
    return true;
end

-- -------------------------------------------------------------------------- --

---
-- Wählt einen zufälligen Auftrag für den Spieler aus. Über die Parameter kann
-- bestimmt werden, welche Typen von Aufträgen erscheinen können. Dieses
-- Behavior sollte in versteckten Quests benutzt werden.
--
-- Tribute und Warenanforderungen steigen in der Menge mit höherem Titel
-- des Auftragnehmers.
--
-- &#x3C;b&#x3E;Hinweis&#x3C;/b&#x3E;: Das Behavior erzeugt einen weiteren Quest mit dem zufällig
-- gewählten Ziel. Somit ist es mit den Tribut-Quests vergleichbar.
--
-- @param[type=boolean] _DeliverGoods   Ziel: Waren liefern
-- @param[type=boolean] _DeliverGold    Ziel: Tribut bezahlen
-- @param[type=boolean] _ClaimTerritory Ziel: Territorium erobern
-- @param[type=boolean] _KnightTitle    Ziel: Nächst höherer Titel
-- @param[type=boolean] _CityReputation Ziel: Ruf der Stadt
-- @param[type=number]  _Time           Zeit bis zur Niederlage (0 = aus)
-- @param[type=string]  _Suggestion     (optional) Startnachricht
-- @param[type=string]  _Success        (optional) Erfolgsnachricht
-- @param[type=string]  _Failure        (optional) Fehlschlagnachricht
--
-- @within Goal
--
function Goal_RandomRequest(...)
    return b_Goal_RandomRequest:new(...);
end

b_Goal_RandomRequest = {
    Name = "Goal_RandomRequest",
    Description = {
        en = "Goal: Der Spieler erhält einen zufällig generierten Auftrag, der erfüllt werden muss. Über die Parameter wird bestimmt, welche Typen von Aufträgen möglich sind. Tipp: Für versteckten Quest nutzen!",
        de = "Ziel: The player receives an randomly generated quest that he needs to complete. Define which types of quest possibly appear by setting the parameters. Tip: Use this quest as invisible quest!",
    },
    Parameter = {
        { ParameterType.Custom,  en = "Deliver goods",           de = "Waren liefern" },
        { ParameterType.Custom,  en = "Pay tribute",             de = "Tribut entrichten" },
        { ParameterType.Custom,  en = "Claim territory",         de = "Territorium beanspruchen" },
        { ParameterType.Custom,  en = "Knight title",            de = "Titel erreichen" },
        { ParameterType.Custom,  en = "City reputation",         de = "Ruf der Stadt" },
        { ParameterType.Custom,  en = "Build rampart",           de = "Festung bauen" },
        { ParameterType.Number,  en = "Time limit (0 = off)",    de = "Leitlimit (0 = aus)" },
        { ParameterType.Default, en = "(optional) Mission text", de = "(optional) Auftragsnachricht" },
        { ParameterType.Default, en = "(optional) Success text", de = "(optional) Erfolgsnachricht" },
        { ParameterType.Default, en = "(optional) Failure text", de = "(optional) Fehlschlagsnachricht" },
    },
}

function b_Goal_RandomRequest:GetGoalTable()
    return {Objective.Custom2, {self, self.CustomFunction}};
end

function b_Goal_RandomRequest:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.TypeDeliverGoods = API.ToBoolean(_Parameter);
    elseif (_Index == 1) then
        self.TypeDeliverGold = API.ToBoolean(_Parameter);
    elseif (_Index == 2) then
        self.TypeClaim = API.ToBoolean(_Parameter);
    elseif (_Index == 3) then
        self.TypeKnightTitle = API.ToBoolean(_Parameter);
    elseif (_Index == 4) then
        self.TypeReputation = API.ToBoolean(_Parameter);
    elseif (_Index == 5) then
        self.TypeBuildWall = API.ToBoolean(_Parameter);
    elseif (_Index == 6) then
        self.TimeLimit = _Parameter * 1;
    elseif (_Index == 7) then
        if _Parameter and _Parameter ~= "" then
            self.OptionalSuggestion = _Parameter;
        end
    elseif (_Index == 8) then
        if _Parameter and _Parameter ~= "" then
            self.OptionalSuccess = _Parameter;
        end
    elseif (_Index == 9) then
        if _Parameter and _Parameter ~= "" then
            self.OptionalFailure = _Parameter;
        end
    end
end

function b_Goal_RandomRequest:GetCustomData(_Index)
    return {"true", "false"};
end

function b_Goal_RandomRequest:CustomFunction(_Quest)
    AddOnRandomRequests.Global:CreateSlaveQuest(self, _Quest);
    if self.SlaveQuest and self.SlaveQuest.Result == QuestResult.Success then
        return true;
    end
    if self.SlaveQuest and self.SlaveQuest.Result == QuestResult.Failure then
        return false;
    end
end

function b_Goal_RandomRequest:Reset(_Quest)
    self:Interrupt(_Quest);
    if self.SlaveQuest then
        API.RestartQuest(self.SlaveQuest.Identifier, false);
    end
end

function b_Goal_RandomRequest:Interrupt(_Quest)
    if self.SlaveQuest and self.SlaveQuest.State == QuestState.Active then
        API.StopQuest(self.SlaveQuest.Identifier, false);
    end
end

function b_Goal_RandomRequest:Debug(_Quest)
    if (type(self.TimeLimit) ~= "number" or self.TimeLimit &#x3C; 0) then 
        API.Fatal(_Quest.Identifier.. ": " ..self.Name.. ": Time limit must be a number and at least 0!");
        return true;
    end
    return false;
end

Core:RegisterBehavior(b_Goal_RandomRequest);

-- -------------------------------------------------------------------------- --

Core:RegisterAddOn("AddOnRandomRequests");

</code></div>
    </div>
</div><div class='docContainer'>
    <div class='docLinkContainer'>
        <div>
            <a class='docLinkExpander' href="html/addoncutscenesystem.lua.html">
            <div class='doclink'>
                <div>AddonCutsceneSystem</div>
            </div>
            </a>
        </div>
        <div class='docInvisibleContent'><code>-- -------------------------------------------------------------------------- --
-- ########################################################################## --
-- #  Symfonia AddOnCutsceneSystem                                          # --
-- ########################################################################## --
-- -------------------------------------------------------------------------- --

---
-- Mit diesem Modul können Cutscenes abgespielt werden.
-- 
-- &#x3C;a href="#API.StartCutscene"&#x3E;Cutscene starten&#x3C;/a&#x3E;
--
-- Cutscenes sind als CS-Datei vordefinierte Kameraflüge. Mit diesem Modul
-- können diese Kameraflüge gruppiert werden. Diese Gruppierung ist das, was
-- die Cutscene ausmacht.
--
-- Pro Flug können Titel und Text eingeblendet werden und eine Lua-Funktion
-- aufgerufen werden.
--
-- Flights können entweder im Internal-Mode des Mapeditors oder über externe
-- Tools erzeugt werden. Sie müssen jedoch immer in das Hauptverzeichnis der
-- Map kopiert werden.
-- &#x3C;pre&#x3E;maps/externalmap/.../myCutscene.cs&#x3C;/pre&#x3E;
-- Gibt Deinen Flights passende Namen, um die Zuordnung zu erleichtern.
-- &#x3C;pre&#x3E;cs01_flight1.cs
--cs01_flight2.cs
--...&#x3C;/pre&#x3E;
--
-- Während der Mapentwicklung können die CS-Dateien nicht in der Map liegen,
-- da sie bei jedem Speichern gelöscht werden. Wenn die Datei nicht vorhanden
-- ist, wird der Flight übersprungen. Sind also keine Flights da, gilt die
-- Cutscene trotzdem als abgespielt, sobald sie beendet ist. Das erleichtert
-- das Testen. Du siehst nur nix.
--
-- @within Modulbeschreibung
-- @set sort=true
--
AddOnCutsceneSystem = {};

API = API or {};

-- -------------------------------------------------------------------------- --
-- User-Space                                                                 --
-- -------------------------------------------------------------------------- --

---
-- Startet eine Cutscene.
--
-- Die einzelnen Flights einer Cutscene werden als CS-Dateien definiert.
--
-- Eine Cutscene besteht aus den einzelnen Flights und speziellen Feldern, mit
-- denen weitere Einstellungen gemacht werden können. Siehe dazu auch das
-- Briefing System für einen Vergleich.
--
-- Das Gerüst für eine Cutscene sieht wie folgt aus:
-- &#x3C;pre&#x3E;local Cutscene = {
--    CameraLookAt = {X, Y},   -- Kameraposition am Ende setzen
--    RestoreGameSpeed = true, -- Spielgeschwindigkeit wiederherstellen
--    TransperentBars = false, -- Durchsichtige Bars verwenden (Opacity = 39)
--    HideBorderPins = true,   -- Grenzsteine ausblenden
--    FastForward = false,     -- Beschleunigt abspielen erlauben
--
--    ... -- Hier nacheinander die Flights auflisten
--
--    Starting = function(_Data)
--        -- Hier werden Aktionen vor dem Start ausgeführt.
--    end,
--    Finished = function(_Data)
--        -- Hier kann eine abschließende Aktion ausgeführt werden.
--    end
--};
--return API.StartCutscene(Cutscene);&#x3C;/pre&#x3E;
--
-- Die einzelnen Flights werden nacheinander als Tables angegeben:
-- &#x3C;pre&#x3E;{
--    Flight = "some_file", -- .cs wird nicht mit angegeben!
--    Title  = "Angezeigter Titel",
--    Text   = "Angezeigter Text",
--    Action = function(_Data)
--        -- Aktion für den Flight ausführen
--    end,
--},&#x3C;/pre&#x3E;
-- Ersetze ... mit den Flights, die zur Cutscene gehören sollen.
--
-- Die Funktion gibt die ID der Cutscene zurück, mit der geprüft werden kann,
-- ob die Cutscene beendet ist.
-- 
-- &#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: StartCutscene
--
-- @param[type=table]   _Cutscene Cutscene table
-- @return[type=number] ID der Cutscene
-- @within Anwenderfunktionen
--
function API.CutsceneStart(_Cutscene)
    if GUI then
        fatal("API.CutsceneStart: Cannot start cutscene from local script!");
        return;
    end

    -- Lokalisierung Texte
    local Language = (Network.GetDesiredLanguage() == "de" and "de") or "en";
    for i= 1, #_Cutscene, 1 do
        if _Cutscene[i].Title and type(_Cutscene[i].Title) == "table" then
            _Cutscene[i].Title = _Cutscene[i].Title[Language];
        end
        if _Cutscene[i].Text and type(_Cutscene[i].Text) == "table" then
            _Cutscene[i].Text = _Cutscene[i].Text[Language];
        end
    end

    return AddOnCutsceneSystem.Global:StartCutscene(_Cutscene);
end
StartCutscene = API.CutsceneStart;

---
-- Prüft, ob zur Zeit eine Cutscene aktiv ist.
-- 
-- &#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: IsCutsceneActive
-- 
-- @return[type=boolean] Cutscene aktiv
-- @within Anwenderfunktionen
--
function API.CutsceneIsActive()
    if GUI then
        return AddOnCutsceneSystem.Local:IsCutsceneActive();
    end
    return AddOnCutsceneSystem.Global:IsCutsceneActive();
end
IsCutsceneActive = API.CutsceneIsActive;

---
-- Setzt die Geschwindigkeit für den schnellen Vorlauf für alle Cutscenes.
--
-- Beim schnellen Vorlauf wird eine Cutscene beschleunigt abgespielt.
--
-- &#x3C;b&#x3E;Alias&#x3C;/b&#x3E;: SetCutsceneFastForwardSpeed
-- 
-- @param[type=number] _Speed Geschwindigkeit
-- @within Anwenderfunktionen
-- @usage API.CutsceneSetFastForwardSpeed(6);
--
function API.CutsceneSetFastForwardSpeed(_Speed)
    if not GUI then
        API.Bridge("API.CutsceneSetFastForwardSpeed(" .._Speed.. ")");
        return;
    end
    AddOnCutsceneSystem.LoadScreenVisible.Data.FastForward.Speed = _Speed;
end
SetCutsceneFastForwardSpeed = API.CutsceneSetFastForwardSpeed;

-- -------------------------------------------------------------------------- --
-- Application-Space                                                          --
-- -------------------------------------------------------------------------- --

AddOnCutsceneSystem = {
    Global = {
        Data = {
            CurrentCutscene = {},
            CutsceneQueue = {},
            CutsceneActive = false,
        },
    },
    Local = {
        Data = {
            CurrentCutscene = {},
            CurrentFlight = 1,
            CutsceneActive = false,
            CinematicActive = false,
            FastForward = {
                Active = false,
                Indent = 1,
                Speed = 15,
            },
            Fader = {
                From = 1.0,
                To = 0.0,
                TimeStamp = 0,
                Duration = 0,
                Callback = nil,
                Widget = "/InGame/Fader/Element",      
                Page = "/InGame/Fader" 
            }
        },
    },

    Text = {
        FastForwardActivate   = {de = "Beschleunigen", en = "Fast Forward"},
        FastForwardDeactivate = {de = "Zurücksetzen",  en = "Normal Speed"},
        FastFormardMessage    = {de = "SCHNELLER VORLAUF",  en = "FAST FORWARD"},
    }
}

-- Global Script ---------------------------------------------------------------

---
-- Initalisiert das Bundle im globalen Skript.
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Global:Install()
end

---
-- Startet die Cutscene im globalen Skript. Es wird eine neue ID für die
-- Cutscene erzeugt und zurückgegeben. Die Cutscehe wird als CurrentCutscene
-- gespeichert und in das lokale Skript kopiert.
--
-- Damit keine Briefings starten, wird die entsprechende Variable im
-- Briefingsystem true gesetzt.
--
-- @param[type=table]   _Cutscene Cutscene table
-- @return[type=number] ID der Cutscene
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Global:StartCutscene(_Cutscene)
    if not self.Data.LoadScreenHidden or self:IsCutsceneActive() then
        table.insert(self.Data.CutsceneQueue, _Cutscene);
        if not self.Data.CutsceneQueueJobID then
            self.Data.CutsceneQueueJobID = StartSimpleHiResJobEx(AddOnCutsceneSystem.Global.CutsceneQueueController);
        end
        return;
    end
    if _Cutscene.Starting then
        _Cutscene:Starting();
    end

    BundleBriefingSystem.Global.Data.BriefingID = BundleBriefingSystem.Global.Data.BriefingID +1;
    self.Data.CurrentCutscene = _Cutscene;
    self.Data.CurrentCutscene.ID = BundleBriefingSystem.Global.Data.BriefingID;
    local Cutscene = API.ConvertTableToString(self.Data.CurrentCutscene);
    API.Bridge("AddOnCutsceneSystem.Local:StartCutscene(" ..Cutscene.. ")");
    self.Data.CutsceneActive = true;
    BundleBriefingSystem.Global.Data.BriefingActive = true;
    BundleBriefingSystem.Global.Data.DisplayIngameCutscene = true;

    return BundleBriefingSystem.Global.Data.BriefingID;
end

---
-- Stoppt die Cutscene im globalen Skript. Falls eine Finished-Funktion für
-- die Cutscene definiert ist, wird diese ausgeführt. Wenn weitere Cutscenes
-- in der Warteschlange stehen, wird die nächste Cutscene gestartet. Die
-- aktuelle Cutscene wird als beendet vermerkt.
--
-- Das Starten von Briefings wird wieder erlaubt.
--
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Global:StopCutscene()
    BundleBriefingSystem.Global.Data.BriefingActive = false;
    BundleBriefingSystem.Global.Data.DisplayIngameCutscene = false;

    local CutsceneID = self.Data.CurrentCutscene.ID;
    BundleBriefingSystem.Global.Data.FinishedBriefings[CutsceneID] = true;
    API.Bridge("AddOnCutsceneSystem.Local:StopCutscene()");

    if self.Data.CurrentCutscene.Finished then
        self.Data.CurrentCutscene:Finished();
    end
    self.Data.CutsceneActive = false;
end

---
-- Prüft, ob eine Cutscene aktiv ist.
-- @param[type=boolean] Cutscene ist aktiv
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Global:IsCutsceneActive()
    return IsBriefingActive() == true or self.Data.CutsceneActive == true;
end

---
-- Steuert die Cutscene-Warteschlange.
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Global.CutsceneQueueController()
    if #AddOnCutsceneSystem.Global.Data.CutsceneQueue == 0 then
        AddOnCutsceneSystem.Global.Data.CutsceneQueueJobID = nil;
        return true;
    end
    
    if AddOnCutsceneSystem.Global.Data.LoadScreenHidden and not AddOnCutsceneSystem.Global:IsCutsceneActive() then
        local Next = table.remove(AddOnCutsceneSystem.Global.Data.CutsceneQueue, 1);
        AddOnCutsceneSystem.Global:StartCutscene(Next);
    end
end

-- Local Script ----------------------------------------------------------------

---
-- Initalisiert das Bundle im lokalen Skript.
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Local:Install()
    StartSimpleHiResJobEx(AddOnCutsceneSystem.Local.WaitForLoadScreenHidden);
    StartSimpleHiResJobEx(AddOnCutsceneSystem.Local.DisplayFastForwardMessage);

    self:OverrideUpdateFader();
end

---
-- Startet die Cutscene im lokalen Skript. Die Spielansicht wird versteckt
-- und der Cinematic Mode aktiviert.
-- @param[type=table] _Cutscene Cutscene table
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Local:StartCutscene(_Cutscene)
    BundleBriefingSystem.Local.Data.DisplayIngameCutscene = true;

    self.Data.CurrentFlight = 1;
    self.Data.CurrentCutscene = _Cutscene;
    self.Data.CutsceneActive = true;
    
    Display.SetRenderSky(1);
    if self.Data.CurrentCutscene.HideBorderPins then
        Display.SetRenderBorderPins(0);
    end
    if Game.GameTimeGetFactor() ~= 0 then
        if self.Data.CurrentCutscene.RestoreGameSpeed and not self.Data.GaneSpeedBackup then
            self.Data.GaneSpeedBackup = Game.GameTimeGetFactor();
            if self.Data.GaneSpeedBackup &#x3C; 1 then
                self.Data.GaneSpeedBackup = 1;
            end
        end
        Game.GameTimeSetFactor(GUI.GetPlayerID(), 1);
    end
    self.Data.SelectedEntities = {GUI.GetSelectedEntities()};
    
    if not self.Data.CinematicActive then
        self:ActivateCinematicMode();
    end

    self:NextFlight();
end

---
-- Stoppt die Cutscene im lokalen Skript. Hier wird der Cinematic Mode
-- deaktiviert und die Spielansicht wiederhergestellt.
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Local:StopCutscene()
    if self.Data.CurrentCutscene.CameraLookAt then 
        Camera.RTS_SetLookAtPosition(unpack(self.Data.CurrentCutscene.CameraLookAt));
    end
    for k, v in pairs(self.Data.SelectedEntities) do
        GUI.SelectEntity(v);
    end
    Display.SetRenderBorderPins(1);
    Display.SetRenderSky(0);

    local GameSpeed = (self.Data.GaneSpeedBackup or 1);
    Game.GameTimeSetFactor(GUI.GetPlayerID(), GameSpeed);
    self.Data.GaneSpeedBackup = nil;

    BundleBriefingSystem.Local.Data.DisplayIngameCutscene = false;
    self:DeactivateCinematicMode();
    self.Data.CutsceneActive = false;
    self.Data.FastForward.Active = false;
end

---
-- Prüft, ob eine Cutscene aktiv ist.
-- @param[type=boolean] Cutscene ist aktiv
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Local:IsCutsceneActive()
    return IsBriefingActive() == true or self.Data.CutsceneActive == true;
end

---
-- Startet den nächsten Flight.
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Local:NextFlight()
    local FlightIndex = self.Data.CurrentFlight;
    local CurrentFlight = self.Data.CurrentCutscene[FlightIndex];
    if not CurrentFlight then
        return;
    end
    if Camera.IsValidCutscene(CurrentFlight.Flight) then
        Camera.StartCutscene(CurrentFlight.Flight);
    else
        self:FlightFinished();
    end
end

---
-- Script Event: Flight wurde gestartet.
-- @param[type=number] _Duration Dauer in Turns
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Local:FlightStarted(_Duration)
    if self:IsCutsceneActive() then
        local FlightIndex = self.Data.CurrentFlight;
        local CurrentFlight = self.Data.CurrentCutscene[FlightIndex];
        if not CurrentFlight then
            return;
        end

        local Flight  = CurrentFlight.Flight;
        local Title   = CurrentFlight.Title or "";
        local Text    = CurrentFlight.Text or "";
        local Action  = CurrentFlight.Action;

        -- Setze Title
        if string.sub(Title, 1, 1) ~= "{" then
            Title = "{@color:255,250,0,255}{center}{darkshadow}" .. Title;
        end
        XGUIEng.SetText("/InGame/ThroneRoom/Main/DialogTopChooseKnight/ChooseYourKnight", Title);
        -- Setze Text
        if string.sub(Text, 1, 1) ~= "{" then
            Text = "{center}" .. Text;
        end
        XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Text", "{cr}{cr}{cr}" .. Text);
        -- Führe Action aus
        if Action then
            API.Bridge("AddOnCutsceneSystem.Global.Data.CurrentCutscene[" ..FlightIndex.. "]:Action()");
        end

        XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/Skip", (self.Data.CurrentCutscene.FastForward and 1) or 0);

        -- Handle fader
        self.Data.Fader.To = 0;
        self:SetFaderAlpha(0);
        if CurrentFlight.FadeIn then
            self:FadeIn(CurrentFlight.FadeIn);
        end
        if CurrentFlight.FadeOut then
            StartSimpleHiResJobEx(function(_Time, _FadeOut)
                if Logic.GetTimeMs() &#x3E; _Time - (_FadeOut * 1000) then
                    self:FadeOut(_FadeOut);
                    return true;
                end
            end, Logic.GetTimeMs() + (_Duration*100), CurrentFlight.FadeOut);
        end
    end
end
CutsceneFlightStarted = function(_Duration)
    AddOnCutsceneSystem.Local:FlightStarted(_Duration);
end

---
-- Script Event: Flight ist beendet.
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Local:FlightFinished()
    if self:IsCutsceneActive() then
        local FlightIndex = self.Data.CurrentFlight;
        if FlightIndex == #self.Data.CurrentCutscene then
            API.Bridge("AddOnCutsceneSystem.Global:StopCutscene()");
            return true;
        end
        self.Data.CurrentFlight = self.Data.CurrentFlight +1;
        self:SetFaderAlpha(1);
        self:NextFlight();
    end
end
CutsceneFlightFinished = function()
    AddOnCutsceneSystem.Local:FlightFinished();
end

---
-- Steuert die Wiedergabe der Cutscenes.
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Local:ThroneRoomCameraControl()
    if self:IsCutsceneActive() then
        local Language = (Network.GetDesiredLanguage() == "de" and "de") or "en";
        if self.Data.FastForward.Active == false then
            XGUIEng.SetText("/InGame/ThroneRoom/Main/Skip", "{center}" ..AddOnCutsceneSystem.Text.FastForwardActivate[Language]);
        else 
            XGUIEng.SetText("/InGame/ThroneRoom/Main/Skip", "{center}" ..AddOnCutsceneSystem.Text.FastForwardDeactivate[Language]);
        end
    end
end

---
-- Steuert Reaktionen auf Klicks des Spielers.
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Local:ThroneRoomLeftClick()
    if self:IsCutsceneActive() then
        if self.Data.CurrentCutscene.LeftClick then
            self.Data.CurrentCutscene:LeftClick();
        end
    end
end

---
-- Startet oder beendet den schnellen Vorlauf, wenn der Spieler den Skip-Button
-- klickt. Außerdem wird der Text des Skip-Button gesetzt und ein Flag gesetzt.
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Local:NextButtonPressed()
    if self:IsCutsceneActive() then
        if Game.GameTimeGetFactor() &#x3E; 1 then
            Game.GameTimeSetFactor(GUI.GetPlayerID(), 1);
            self.Data.FastForward.Active = false;
        else
            Game.GameTimeSetFactor(GUI.GetPlayerID(), self.Data.FastForward.Speed);
            self.Data.FastForward.Active = true;
        end
    end
end

---
-- Initialisiert den Fader. Bei diesem Fader handelt es sich um eine leicht
-- abgewandelte Version des normalen Fader. Dieser Fader verhält sich relativ
-- zur Spielgeschwindigkeit.
-- @return[type=boolean] Fading läuft gerade
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Local:InitializeFader()
    self.Data.Fader.Duration = 0;
    self.Data.Fader.To = 0;
    self:SetFaderAlpha(1.0);
    XGUIEng.PushPage(self.Data.Fader.Page, false);
end

---
-- Prüft, ob gerade ein Fading-Prozess läuft.
-- @return[type=boolean] Fading läuft gerade
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Local:IsFading()
	return self.Data.Fader.Duration ~= 0;
end

---
-- Blendet zur Fader-Maske aus. Callback wird am Ende ausgeführt.
-- @param[type=number] _Duration Dauer in Sekunden
-- @param[type=number] _Callback (optional) Callback-Funktion
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Local:FadeOut(_Duration, _Callback)
	if self:IsFading() then
        local time = Logic.GetTimeMs();
        local progress = (time - self.Data.Fader.TimeStamp) / (self.Data.Fader.Duration * 1000);
        local alpha = self:LERP(self.Data.Fader.From, self.Data.Fader.To, progress);
		self.Data.Fader.From = alpha;
		self.Data.Fader.To = 1;
		self.Data.Fader.Duration = _Duration * (self.Data.Fader.To - self.Data.Fader.From);
		
	else
        self.Data.Fader.From = 0;
        self.Data.Fader.To = 1;
        self.Data.Fader.Duration = _Duration;
	end
    self.Data.Fader.Callback = _Callback;
    self.Data.Fader.TimeStamp = Logic.GetTimeMs();
end

---
-- Blendet von der Fader-Maske ein. Callback wird am Ende ausgeführt.
-- @param[type=number] _Duration Dauer in Sekunden
-- @param[type=number] _Callback (optional) Callback-Funktion
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Local:FadeIn(_Duration, _Callback)
	if self:IsFading() then
		return;
	end
    self.Data.Fader.Callback = _Callback;
    self.Data.Fader.Duration = _Duration;
    self.Data.Fader.From = 1;
    self.Data.Fader.To = 0;
    self.Data.Fader.TimeStamp = Logic.GetTimeMs();
end

---
-- Setzt den Alpha-Wert der Fader-Maske auf den angegebenen Wert.
-- @param[type=number] _Alpha Alpha-Wert
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Local:SetFaderAlpha(_Alpha)
	if XGUIEng.IsWidgetExisting(self.Data.Fader.Widget) == 0 then
		return;
	end
	XGUIEng.SetMaterialColor(self.Data.Fader.Widget,0,0,0,0,255 * _Alpha);
	XGUIEng.SetMaterialColor(self.Data.Fader.Widget,1,0,0,0,255 * _Alpha);
end

---
-- Berechnet die lineare Interpolation des Alpha der Fader-Maske.
-- @param[type=number] _A Startwert
-- @param[type=number] _B Endwert
-- @param[type=number] _T Zeitfaktor
-- @return[number] Interpolationsfaktor
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Local:LERP(_A, _B, _T)
    return _A + ((_B - _A) * _T);
end

---
-- Überschreibt die Update-Funktion des normalen Fader, sodass während einer
-- Cutscene Spielzeit statt Realzeit verwendet wird.
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Local:OverrideUpdateFader()
    UpdateFader_Orig_CutsceneSystem = UpdateFader;
    UpdateFader = function()
        if AddOnCutsceneSystem.Local.Data.CutsceneActive then
            AddOnCutsceneSystem.Local:UpdateFader();
        else
            UpdateFader_Orig_CutsceneSystem();
        end
    end
end

---
-- Aktualisiert den Alpha-Wert der Fader-Maske, wenn eine Cutscene aktiv ist.
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Local:UpdateFader()
    if self.Data.CutsceneActive == true then
        if self.Data.Fader.Duration &#x3E; 0 then
            local time = Logic.GetTimeMs();
            local progress = (time - self.Data.Fader.TimeStamp) / (self.Data.Fader.Duration * 1000);
            local alpha = self:LERP(self.Data.Fader.From, self.Data.Fader.To, progress);
            self:SetFaderAlpha(alpha);
            if time &#x3E; self.Data.Fader.TimeStamp + (self.Data.Fader.Duration * 1000)  then
                self.Data.Fader.Duration = 0;
                if self.Data.Fader.Callback ~= nil then
                    self.Data.Fader:Callback();
                    return false;
                end
            end
        else
            self:SetFaderAlpha(self.Data.Fader.To);
        end
    end
end

---
-- Setzt den Bar-Style für die aktuelle Cutscene.
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Local:SetBarStyle(_Transparend)
    local Alpha = (_Transparend and 100) or 255;

    XGUIEng.ShowWidget("/InGame/ThroneRoomBars", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2", 1);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_Dodge", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2_Dodge", 1);

    XGUIEng.SetMaterialAlpha("/InGame/ThroneRoomBars/BarBottom", 1, Alpha);
    XGUIEng.SetMaterialAlpha("/InGame/ThroneRoomBars/BarTop", 1, Alpha);
    XGUIEng.SetMaterialAlpha("/InGame/ThroneRoomBars_2/BarBottom", 1, Alpha);
    XGUIEng.SetMaterialAlpha("/InGame/ThroneRoomBars_2/BarTop", 1, Alpha);
end

---
-- Aktiviert den Cinematic Mode. Alle selektierten Entities werden gespeichert
-- und anschließend deselektiert. Optional wird die Kameraposition und die
-- Spielgeschwindigkeit ebenfalls gespeichert.
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Local:ActivateCinematicMode()
    self.Data.CinematicActive = true;
    
    local LoadScreenVisible = XGUIEng.IsWidgetShownEx("/LoadScreen/LoadScreen") == 1;
    if LoadScreenVisible then
        XGUIEng.PopPage();
    end

    XGUIEng.ShowWidget("/InGame/Root/3dOnScreenDisplay", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom", 1);
    XGUIEng.PushPage("/InGame/ThroneRoomBars", false);
    XGUIEng.PushPage("/InGame/ThroneRoomBars_2", false);
    XGUIEng.PushPage("/InGame/ThroneRoom/Main", false);
    XGUIEng.PushPage("/InGame/ThroneRoomBars_Dodge", false);
    XGUIEng.PushPage("/InGame/ThroneRoomBars_2_Dodge", false);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/Skip", 1);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogTopChooseKnight", 1);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogTopChooseKnight/Frame", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogTopChooseKnight/DialogBG", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogTopChooseKnight/FrameEdges", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogBottomRight3pcs", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/KnightInfoButton", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/Briefing", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/BackButton", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/TitleContainer", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/StartButton", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/MissionBriefing/Text", 1);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/MissionBriefing/Title", 1);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/MissionBriefing/Objectives", 1);

    XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Text", " ");
    XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Title", " ");
    XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Objectives", " ");

    local x,y = XGUIEng.GetWidgetScreenPosition("/InGame/ThroneRoom/Main/DialogTopChooseKnight/ChooseYourKnight");
    XGUIEng.SetWidgetScreenPosition("/InGame/ThroneRoom/Main/DialogTopChooseKnight/ChooseYourKnight", x, 65);

    XGUIEng.SetWidgetPositionAndSize("/InGame/ThroneRoom/KnightInfo/Objectives", 2, 0, 2000, 20);
    XGUIEng.PushPage("/InGame/ThroneRoom/KnightInfo", false);
    XGUIEng.ShowAllSubWidgets("/InGame/ThroneRoom/KnightInfo", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/KnightInfo/Text", 1);
    XGUIEng.SetText("/InGame/ThroneRoom/KnightInfo/Text", " ");
    XGUIEng.SetWidgetPositionAndSize("/InGame/ThroneRoom/KnightInfo/Text", 200, 300, 1000, 10);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/KnightInfo/LeftFrame", 1);
    XGUIEng.ShowAllSubWidgets("/InGame/ThroneRoom/KnightInfo/LeftFrame", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/KnightInfo/KnightBG", 1);
    XGUIEng.SetWidgetPositionAndSize("/InGame/ThroneRoom/KnightInfo/KnightBG", 0, 6000, 400, 600);
    XGUIEng.SetMaterialAlpha("/InGame/ThroneRoom/KnightInfo/KnightBG", 0, 0);

    AddOnCutsceneSystem.Local:SetBarStyle(self.Data.CurrentCutscene.TransperentBars == true);

    if not self.Data.SkipButtonTextBackup then
        self.Data.SkipButtonTextBackup = XGUIEng.GetText("/InGame/ThroneRoom/Main/Skip");
    end

    GUI.ClearSelection();
    GUI.ForbidContextSensitiveCommandsInSelectionState();
    GUI.ActivateCutSceneState();
    GUI.SetFeedbackSoundOutputState(0);
    GUI.EnableBattleSignals(false);
    Input.CutsceneMode();
    Display.SetRenderFogOfWar(0);
    Display.SetUserOptionOcclusionEffect(0);
    Camera.SwitchCameraBehaviour(0);

    self:InitializeFader();
    self:SetFaderAlpha(0);

    if LoadScreenVisible then
        XGUIEng.PushPage("/LoadScreen/LoadScreen", false);
    end
end

---
-- Stoppt den Cinematic Mode. Die Selektion wird wiederhergestellt. Falls
-- aktiviert, werden auch Kameraposition und Spielgeschwindigkeit auf ihre
-- alten Werte zurückgesetzt.
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Local:DeactivateCinematicMode()
    self.Data.CinematicActive = false;

    if not self.Data.SkipButtonTextBackup then
        XGUIEng.SetText("/InGame/ThroneRoom/Main/Skip", self.Data.SkipButtonTextBackup);
        self.Data.SkipButtonTextBackup =  nil;
    end

    self.Data.Fader.To = 0;
    self:SetFaderAlpha(0);

    XGUIEng.PopPage();
    Camera.SwitchCameraBehaviour(0);
    Display.UseStandardSettings();
    Input.GameMode();
    GUI.EnableBattleSignals(true);
    GUI.SetFeedbackSoundOutputState(1);
    GUI.ActivateSelectionState();
    GUI.PermitContextSensitiveCommandsInSelectionState();
    Display.SetRenderFogOfWar(1);
    if Options.GetIntValue("Display", "Occlusion", 0) &#x3E; 0 then
        Display.SetUserOptionOcclusionEffect(1);
    end

    XGUIEng.PopPage();
    XGUIEng.PopPage();
    XGUIEng.PopPage();
    XGUIEng.PopPage();
    XGUIEng.PopPage();
    XGUIEng.PopPage();
    XGUIEng.ShowWidget("/InGame/ThroneRoom", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_Dodge", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2_Dodge", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal", 1);
    XGUIEng.ShowWidget("/InGame/Root/3dOnScreenDisplay", 1);
    XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Objectives", " ");
end

---
-- Steuert die Nachricht bei aktiven schnellen Vorlauf von Cutscenes.
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Local.DisplayFastForwardMessage()
    if AddOnCutsceneSystem.Local.Data.CutsceneActive == true then
        if AddOnCutsceneSystem.Local.Data.FastForward.Active then
            -- Realzeit ermitteln
            local RealTime = API.RealTimeGetSecondsPassedSinceGameStart();
            if not AddOnCutsceneSystem.Local.Data.FastForward.RealTime then
                AddOnCutsceneSystem.Local.Data.FastForward.RealTime = RealTime;
            end
            -- Einrückung anpassen
            if AddOnCutsceneSystem.Local.Data.FastForward.RealTime &#x3C; RealTime then
                AddOnCutsceneSystem.Local.Data.FastForward.Indent = AddOnCutsceneSystem.Local.Data.FastForward.Indent +1;
                if AddOnCutsceneSystem.Local.Data.FastForward.Indent &#x3E; 4 then
                    AddOnCutsceneSystem.Local.Data.FastForward.Indent = 1;
                end
                AddOnCutsceneSystem.Local.Data.FastForward.RealTime = RealTime;
            end
            -- Message anzeigen
            local Language = (Network.GetDesiredLanguage() == "de" and "de") or "en";
            local Text = "{cr}{cr}" ..AddOnCutsceneSystem.Text.FastFormardMessage[Language];
            local Indent = string.rep("  ", AddOnCutsceneSystem.Local.Data.FastForward.Indent);
            XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Objectives", Text..Indent.. ". . .");
        else
            XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Objectives", " ");
        end
    end
end

---
-- Wartet bis der Ladebildschirm inaktiv ist und setzt dann ein Flag, dass
-- das Starten von Cutscenes erlaubt.
-- @within Internal
-- @local
--
function AddOnCutsceneSystem.Local.WaitForLoadScreenHidden()
    if XGUIEng.IsWidgetShownEx("/LoadScreen/LoadScreen") == 0 then
        GUI.SendScriptCommand("AddOnCutsceneSystem.Global.Data.LoadScreenHidden = true;");
        return true;
    end
end

-- -------------------------------------------------------------------------- --

Core:RegisterBundle("AddOnCutsceneSystem");
 
</code></div>
    </div>
</div>
                </div>
                <p id="notFound">Leider wurden keine Ergebnisse gefunden!</p>
            </div>
        </div>
    </bod>
</html>